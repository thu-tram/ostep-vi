<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OS Bí truyền thư - OSTEP in Vietnamese</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Trang chủ</a></li><li class="chapter-item expanded affix "><li class="part-title">Phần 1: Virtualization</li><li class="chapter-item expanded "><a href="02/index.html"><strong aria-hidden="true">2.</strong> Introduction to Operating Systems</a></li><li class="chapter-item expanded "><a href="03/index.html"><strong aria-hidden="true">3.</strong> A Dialogue on Virtualization</a></li><li class="chapter-item expanded "><a href="04/index.html"><strong aria-hidden="true">4.</strong> The Abstraction: The Process</a></li><li class="chapter-item expanded "><a href="05/index.html"><strong aria-hidden="true">5.</strong> Interlude: Process API</a></li><li class="chapter-item expanded "><a href="06/index.html"><strong aria-hidden="true">6.</strong> Mechanism: Limited Direct Execution</a></li><li class="chapter-item expanded "><a href="07/index.html"><strong aria-hidden="true">7.</strong> Scheduling: Introduction</a></li><li class="chapter-item expanded "><a href="08/index.html"><strong aria-hidden="true">8.</strong> Scheduling:The Multi-Level Feedback Queue</a></li><li class="chapter-item expanded "><a href="09/index.html"><strong aria-hidden="true">9.</strong> Scheduling: Proportional Share</a></li><li class="chapter-item expanded "><a href="10/index.html"><strong aria-hidden="true">10.</strong> Multiprocessor Scheduling (Advanced)</a></li><li class="chapter-item expanded "><a href="13/index.html"><strong aria-hidden="true">11.</strong> The Abstraction: Address Spaces</a></li><li class="chapter-item expanded "><a href="14/index.html"><strong aria-hidden="true">12.</strong> Interlude: Memory API</a></li><li class="chapter-item expanded "><a href="15/index.html"><strong aria-hidden="true">13.</strong> Mechanism: Address Translation</a></li><li class="chapter-item expanded "><a href="16/index.html"><strong aria-hidden="true">14.</strong> Segmentation</a></li><li class="chapter-item expanded "><a href="17/index.html"><strong aria-hidden="true">15.</strong> Free-Space Management</a></li><li class="chapter-item expanded "><a href="18/index.html"><strong aria-hidden="true">16.</strong> Paging: Introduction</a></li><li class="chapter-item expanded "><a href="19/index.html"><strong aria-hidden="true">17.</strong> Paging: Faster Translations (TLBs)</a></li><li class="chapter-item expanded "><a href="20/index.html"><strong aria-hidden="true">18.</strong> Paging: Smaller Tables</a></li><li class="chapter-item expanded "><a href="21/index.html"><strong aria-hidden="true">19.</strong> Beyond Physical Memory: Mechanisms</a></li><li class="chapter-item expanded "><a href="22/index.html"><strong aria-hidden="true">20.</strong> Beyond Physical Memory: Policies</a></li><li class="chapter-item expanded "><a href="23/index.html"><strong aria-hidden="true">21.</strong> The VAX/VMS Virtual Memory System</a></li><li class="chapter-item expanded affix "><li class="part-title">Phần 2: Concurrency</li><li class="chapter-item expanded "><a href="26/index.html"><strong aria-hidden="true">22.</strong> Concurrency: An Introduction</a></li><li class="chapter-item expanded "><a href="27/index.html"><strong aria-hidden="true">23.</strong> Interlude: Thread API</a></li><li class="chapter-item expanded "><a href="28/index.html"><strong aria-hidden="true">24.</strong> Locks</a></li><li class="chapter-item expanded "><a href="29/index.html"><strong aria-hidden="true">25.</strong> Lock-based Concurrent Data Structures</a></li><li class="chapter-item expanded "><a href="30/index.html"><strong aria-hidden="true">26.</strong> Condition Variables</a></li><li class="chapter-item expanded "><a href="31/index.html"><strong aria-hidden="true">27.</strong> Semaphores</a></li><li class="chapter-item expanded "><a href="32/index.html"><strong aria-hidden="true">28.</strong> Common Concurrency Problems</a></li><li class="chapter-item expanded "><a href="33/index.html"><strong aria-hidden="true">29.</strong> Event-based Concurrency (Advanced)</a></li><li class="chapter-item expanded affix "><li class="part-title">Phần 3 Persistence</li><li class="chapter-item expanded "><a href="36/index.html"><strong aria-hidden="true">30.</strong> I/O Devices</a></li><li class="chapter-item expanded "><a href="37/index.html"><strong aria-hidden="true">31.</strong> Hard Disk Drives</a></li><li class="chapter-item expanded "><a href="38/index.html"><strong aria-hidden="true">32.</strong> Redundant Arrays of Inexpensive Disks (RAIDs)</a></li><li class="chapter-item expanded "><a href="39/index.html"><strong aria-hidden="true">33.</strong> Interlude: Files and Directories</a></li><li class="chapter-item expanded "><a href="40/index.html"><strong aria-hidden="true">34.</strong> File System Implementation</a></li><li class="chapter-item expanded "><a href="41/index.html"><strong aria-hidden="true">35.</strong> Locality and The Fast File System</a></li><li class="chapter-item expanded "><a href="42/index.html"><strong aria-hidden="true">36.</strong> Crash Consistency: FSCK and Journaling</a></li><li class="chapter-item expanded "><a href="43/index.html"><strong aria-hidden="true">37.</strong> Log-structured File Systems</a></li><li class="chapter-item expanded "><a href="44/index.html"><strong aria-hidden="true">38.</strong> Flash-based SSDs</a></li><li class="chapter-item expanded "><a href="45/index.html"><strong aria-hidden="true">39.</strong> Data Integrity and Protection</a></li><li class="chapter-item expanded "><a href="48/index.html"><strong aria-hidden="true">40.</strong> Distributed Systems</a></li><li class="chapter-item expanded "><a href="49/index.html"><strong aria-hidden="true">41.</strong> Sun’s Network File System (NFS)</a></li><li class="chapter-item expanded "><a href="50/index.html"><strong aria-hidden="true">42.</strong> The Andrew File System (AFS)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OS Bí truyền thư - OSTEP in Vietnamese</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="trang-chủ"><a class="header" href="#trang-chủ">Trang chủ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="giới-thiệu-về-hệ-điều-hành"><a class="header" href="#giới-thiệu-về-hệ-điều-hành">Giới thiệu về Hệ điều hành</a></h1>
<p>Nếu bạn đang học một môn Hệ điều hành ở bậc đại học, hẳn bạn đã có một ý niệm về việc một <strong>chương trình máy tính (computer program)</strong> làm gì khi nó chạy.
Nếu không, cuốn sách này (và cả khóa học tương ứng) sẽ khá khó — vậy nên bạn có lẽ nên tạm ngưng đọc, hoặc chạy ngay ra hiệu sách gần nhất để nhanh chóng đọc qua tài liệu nền tảng cần thiết trước khi tiếp tục (cả cuốn <em>Introduction to Computing Systems</em> của Patt &amp; Patel [PP03] và <em>Computer Systems: A Programmer’s Perspective</em> của Bryant &amp; O’Hallaron [BOH10] đều là những cuốn sách rất hay).</p>
<p>Vậy điều gì xảy ra khi một chương trình chạy?</p>
<p>Thực ra, một chương trình đang chạy làm một việc rất đơn giản: nó <strong>excecute các lệnh (instructions)</strong>. Mỗi giây, bộ xử lý (<strong>processor</strong>) thực hiện hàng triệu (ngày nay thậm chí là hàng tỷ) lần các thao tác: lấy một lệnh từ bộ nhớ, <strong>giải mã (decode)</strong> nó (nghĩa là xác định đó là lệnh nào), và <strong>excecute (excecute)</strong> nó (nghĩa là làm công việc mà lệnh yêu cầu, như cộng hai số, truy cập bộ nhớ, kiểm tra điều kiện, nhảy đến một hàm, v.v.). Khi hoàn tất một lệnh, bộ xử lý chuyển sang lệnh tiếp theo, và cứ thế, cho đến khi chương trình kết thúc <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Như vậy, chúng ta vừa mô tả cơ bản của <strong>mô hình Von Neumann (Von Neumann model)</strong> trong tính toán <sup class="footnote-reference"><a href="#2">2</a></sup>. Nghe có vẻ đơn giản, đúng không? Nhưng trong khóa học này, chúng ta sẽ thấy rằng trong khi một chương trình chạy, có rất nhiều thứ phức tạp khác cũng đang diễn ra, với mục tiêu chính là làm cho hệ thống trở nên dễ sử dụng.</p>
<p>Có một tập hợp phần mềm chịu trách nhiệm cho việc này: giúp chạy chương trình một cách thuận tiện (thậm chí cho phép bạn <em>có vẻ như</em> chạy nhiều chương trình cùng lúc), cho phép các chương trình chia sẻ bộ nhớ, hỗ trợ chúng tương tác với thiết bị, và nhiều thứ thú vị khác. Tập hợp phần mềm đó được gọi là <strong>hệ điều hành (Operating System, OS)</strong> <sup class="footnote-reference"><a href="#3">3</a></sup>, vì nó chịu trách nhiệm đảm bảo hệ thống hoạt động đúng, hiệu quả, và dễ sử dụng.</p>
<p>Cách chủ yếu mà hệ điều hành làm điều đó là thông qua một kỹ thuật chung gọi là <strong>ảo hóa (virtualization)</strong>. Nói cách khác, OS lấy một tài nguyên vật lý (chẳng hạn như bộ xử lý, bộ nhớ, hay đĩa) và biến nó thành một dạng “ảo” tổng quát hơn, mạnh mẽ hơn và dễ dùng hơn. Chính vì thế, đôi khi chúng ta gọi hệ điều hành là một <strong>máy ảo (virtual machine)</strong>.</p>
<p>Tất nhiên, để cho phép người dùng ra lệnh cho hệ điều hành (và nhờ đó sử dụng các tính năng của máy ảo — như chạy một chương trình, cấp phát bộ nhớ, hay truy cập tệp), OS cung cấp một số <strong>interface (API)</strong> mà bạn có thể gọi. Một hệ điều hành điển hình thực sự cung cấp vài trăm <strong>system call (lời gọi hệ thống)</strong> sẵn sàng cho ứng dụng sử dụng. Vì OS cung cấp các call này để chạy chương trình, truy cập bộ nhớ và thiết bị, và các thao tác liên quan khác, nên đôi khi ta cũng nói rằng OS cung cấp một <strong>thư viện chuẩn (standard library)</strong> cho ứng dụng.</p>
<p>Cuối cùng, vì ảo hóa cho phép nhiều chương trình chạy (chia sẻ CPU), nhiều chương trình đồng thời truy cập lệnh và dữ liệu riêng (chia sẻ bộ nhớ), và nhiều chương trình truy cập thiết bị (chia sẻ đĩa, v.v.), nên OS đôi khi còn được gọi là một <strong>bộ quản lý tài nguyên (resource manager)</strong>. CPU, bộ nhớ, và đĩa đều là tài nguyên của hệ thống; do đó vai trò của OS là quản lý những tài nguyên đó — một cách hiệu quả, công bằng, hay theo nhiều mục tiêu khác nhau. Để hiểu rõ hơn về vai trò của OS, hãy cùng xem qua một vài ví dụ.</p>
<blockquote>
<blockquote>
<p><strong>Trọng tâm của vấn đề: Làm thế nào để ảo hóa tài nguyên?</strong></p>
<p>Một câu hỏi trung tâm mà chúng ta sẽ trả lời trong cuốn sách này khá đơn giản: <strong>Hệ điều hành ảo hóa tài nguyên như thế nào?</strong> Đây chính là cốt lõi của vấn đề.</p>
<p>Tại sao OS làm điều này không phải là câu hỏi chính, vì câu trả lời khá hiển nhiên: nó khiến hệ thống dễ sử dụng hơn. Do đó, chúng ta tập trung vào câu hỏi <strong>làm thế nào</strong>: những cơ chế (<strong>mechanisms</strong>) và chính sách (<strong>policies</strong>) nào được OS triển khai để đạt được ảo hóa? OS làm việc này hiệu quả ra sao? Cần hỗ trợ phần cứng gì?</p>
<p>Chúng ta sẽ sử dụng các ô đánh dấu như thế này để chỉ ra những vấn đề cụ thể mà chúng ta cần giải quyết khi xây dựng một hệ điều hành. Vì vậy, trong một ghi chú về một chủ đề nhất định, bạn có thể thấy một hoặc nhiều <strong>cruces</strong> (dạng số nhiều đúng của “crux”) làm nổi bật vấn đề. Phần nội dung trong chương dĩ nhiên sẽ trình bày lời giải, hoặc ít nhất là các yếu tố cơ bản của một lời giải.</p>
</blockquote>
</blockquote>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/time.h&gt;

#include &quot;common.h&quot;

int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, &quot;usage: cpu &lt;string&gt;\n&quot;);
    exit(1);
  }
  char *str = argv[1];
  while (1) {
    Spin(1);
    printf(&quot;%s\n&quot;, str);
  }
  return 0;
}
</code></pre>
<p><em>Figure 2.1: Simple Example: Code That Loops And Prints (cpu.c)</em></p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Tất nhiên, các bộ xử lý hiện đại thực hiện nhiều kỹ thuật kỳ lạ và phức tạp để chương trình chạy nhanh hơn, ví dụ: excecute nhiều lệnh cùng lúc, thậm chí phát hành và hoàn thành chúng <strong>không theo thứ tự</strong>! Nhưng đó không phải điều chúng ta quan tâm ở đây; chúng ta chỉ xét mô hình đơn giản mà hầu hết chương trình giả định: các lệnh được excecute tuần tự, từng cái một, một cách trật tự.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><strong>John von Neumann</strong> là một trong những người tiên phong của các hệ thống máy tính. Ông cũng có những đóng góp nền tảng cho lý thuyết trò chơi và bom nguyên tử, và từng chơi bóng rổ NBA trong sáu năm. (À, chỉ một trong những điều đó không đúng thôi.)</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Một cách gọi khác trong những ngày đầu của OS là <strong>supervisor</strong> hay thậm chí là <strong>master control program</strong>. Tuy nhiên, cái tên sau nghe có vẻ hơi “quá tay” (xem phim <em>Tron</em> để biết thêm), và may mắn thay, thuật ngữ “operating system” đã trở thành phổ biến.</p>
</div>
<h2 id="21-Ảo-hóa-cpu-virtualizing-the-cpu"><a class="header" href="#21-Ảo-hóa-cpu-virtualizing-the-cpu">2.1 Ảo hóa CPU (Virtualizing the CPU)</a></h2>
<p>Hình 2.1 mô tả chương trình đầu tiên của chúng ta. Nó không làm được gì nhiều. Thực tế, tất cả những gì nó làm là gọi hàm <code>Spin()</code>, một hàm liên tục kiểm tra thời gian và chỉ trả về sau khi đã chạy đủ một giây. Sau đó, nó in ra chuỗi ký tự mà người dùng truyền vào từ dòng lệnh, rồi lặp lại, mãi mãi.</p>
<p>Giả sử ta lưu tệp này dưới tên <code>cpu.c</code> và quyết định biên dịch rồi chạy nó trên một hệ thống chỉ có một bộ xử lý (processor hay CPU). Khi chạy, chúng ta sẽ thấy như sau:</p>
<pre><code class="language-shell">prompt&gt; gcc -o cpu cpu.c -Wall
prompt&gt; ./cpu &quot;A&quot;
A
A
A
A
ˆC
prompt&gt;
</code></pre>
<p>Kết quả chạy không có gì quá thú vị — hệ thống bắt đầu excecute chương trình, chương trình liên tục kiểm tra thời gian cho đến khi một giây trôi qua. Khi một giây đã hết, mã sẽ in ra chuỗi ký tự đầu vào mà người dùng cung cấp (trong ví dụ này là ký tự “A”), rồi tiếp tục. Lưu ý rằng chương trình sẽ chạy mãi mãi; bằng cách nhấn “Control-C” (trên các hệ thống dựa trên UNIX, thao tác này sẽ chấm dứt chương trình đang chạy ở nền trước), ta có thể dừng chương trình.</p>
<pre><code class="language-shell">prompt&gt; ./cpu A &amp; ./cpu B &amp; ./cpu C &amp; ./cpu D &amp;
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
...
</code></pre>
<p><em>Hình 2.2: Chạy nhiều chương trình cùng lúc</em></p>
<p>Bây giờ, hãy làm điều tương tự, nhưng lần này ta sẽ chạy nhiều phiên bản khác nhau của cùng một chương trình. Hình 2.2 cho thấy kết quả của ví dụ phức tạp hơn một chút này.</p>
<p>Lúc này thì thú vị hơn rồi. Dù chỉ có một bộ xử lý, nhưng bằng cách nào đó, cả bốn chương trình này dường như đang chạy cùng lúc! Vậy “phép màu” này diễn ra thế nào?</p>
<p>Hóa ra, hệ điều hành (operating system), với sự hỗ trợ từ phần cứng, chính là bên tạo ra ảo giác này — tức ảo giác rằng hệ thống có một số lượng rất lớn CPU ảo (virtual CPUs). Việc biến một CPU đơn lẻ (hoặc một tập nhỏ CPU) thành một số lượng CPU “vô hạn” để cho phép nhiều chương trình chạy song song chính là cái mà ta gọi là <strong>ảo hóa CPU (virtualizing the CPU)</strong>. Đây là trọng tâm của phần đầu tiên trong cuốn sách này.</p>
<p>Tất nhiên, để chạy chương trình, dừng chương trình, và nói cho hệ điều hành biết chương trình nào cần chạy, ta cần có các interface (APIs) để giao tiếp với hệ điều hành. Chúng ta sẽ bàn về những API này xuyên suốt cuốn sách; thực ra, chúng chính là cách chính yếu mà hầu hết người dùng tương tác với hệ điều hành.</p>
<p>Ngoài ra, khả năng chạy đồng thời nhiều chương trình đặt ra hàng loạt câu hỏi mới. Ví dụ: nếu hai chương trình muốn chạy tại cùng một thời điểm, chương trình nào nên được ưu tiên? Câu hỏi này được trả lời bằng <strong>policy (chính sách)</strong> của hệ điều hành. Các policy được sử dụng ở nhiều nơi trong hệ điều hành để giải quyết các loại câu hỏi như vậy. Vì thế, ta sẽ nghiên cứu chúng cùng với các cơ chế cơ bản mà hệ điều hành triển khai (như khả năng chạy nhiều chương trình đồng thời). Đây chính là vai trò của hệ điều hành với tư cách là <strong>resource manager</strong>.</p>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Lưu ý rằng chúng ta đã chạy bốn <strong>process</strong> cùng lúc bằng cách sử dụng ký hiệu <code>&amp;</code>. Thao tác này sẽ chạy một job ở chế độ nền trong shell <code>zsh</code>, cho phép người dùng ngay lập tức nhập lệnh kế tiếp, mà trong ví dụ này là chạy một chương trình khác. Nếu bạn sử dụng shell khác (ví dụ <code>tcsh</code>), cách hoạt động sẽ hơi khác; hãy đọc thêm tài liệu trực tuyến để biết chi tiết.</p>
</div>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &quot;common.h&quot;

int main(int argc, char* argv[]) {
  int* p = malloc(sizeof(int));
  // a1
  assert(p != NULL);
  printf(&quot;(%d) address pointed to by p: %p\n&quot;, getpid(), p);
  // a2
  // a3
  *p = 0;
  while (1) {
    Spin(1);
    *p = *p + 1;
    printf(&quot;(%d) p: %d\n&quot;, getpid(), *p);
    // a4
  }
  return 0;
}
</code></pre>
<p>Hình 2.3: <strong>Một chương trình sử dụng bộ nhớ (mem.c)</strong></p>
<h2 id="22-Ảo-hóa-bộ-nhớ-virtualizing-memory"><a class="header" href="#22-Ảo-hóa-bộ-nhớ-virtualizing-memory">2.2 Ảo hóa bộ nhớ (Virtualizing Memory)</a></h2>
<p>Bây giờ, hãy xét đến bộ nhớ. Mô hình bộ nhớ vật lý (physical memory) mà các máy tính hiện đại cung cấp khá đơn giản. Bộ nhớ chỉ là một mảng các byte; để đọc dữ liệu trong bộ nhớ, ta phải chỉ định một <strong>địa chỉ (address)</strong> để truy cập dữ liệu đã lưu ở đó; để ghi (hay cập nhật) dữ liệu, ta cũng phải chỉ định dữ liệu cần ghi cùng địa chỉ đích.</p>
<p>Bộ nhớ được truy cập liên tục khi một chương trình đang chạy. Một chương trình lưu giữ tất cả các cấu trúc dữ liệu của nó trong bộ nhớ, và truy cập chúng thông qua nhiều lệnh khác nhau, như <strong>load</strong>, <strong>store</strong>, hoặc các lệnh khác có liên quan đến truy cập bộ nhớ. Đừng quên rằng chính các lệnh của chương trình cũng nằm trong bộ nhớ; do đó, bộ nhớ được truy cập ở mỗi lần load lệnh (instruction fetch).</p>
<p>Hãy cùng xem một chương trình (Hình 2.3) cấp phát một vùng bộ nhớ bằng cách gọi <code>malloc()</code>. Kết quả chạy chương trình có thể được thấy như sau:</p>
<pre><code class="language-shell">prompt&gt; ./mem
(2134) address pointed to by p: 0x200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
ˆC
prompt&gt; ./mem &amp; ./mem &amp;
[1] 24113
[2] 24114
(24113) address pointed to by p: 0x200000
(24114) address pointed to by p: 0x200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
...

</code></pre>
<p><em>Figure 2.4: Running The Memory Program Multiple Times</em></p>
<p>Chương trình thực hiện vài việc. Đầu tiên, nó cấp phát một vùng bộ nhớ (dòng a1). Sau đó, nó in ra địa chỉ của vùng nhớ vừa cấp phát (a2), rồi gán số 0 vào ô nhớ đầu tiên của vùng nhớ đó (a3). Cuối cùng, nó lặp lại: trì hoãn một giây và tăng giá trị được lưu ở địa chỉ con trỏ <code>p</code>. Với mỗi lần in, chương trình cũng in ra <strong>process identifier (PID – mã định danh process)</strong> của process đang chạy. Mỗi process đang chạy sẽ có một PID duy nhất.</p>
<p>Kết quả đầu tiên này không có gì đặc biệt. Vùng bộ nhớ mới cấp phát có địa chỉ <code>0x200000</code>. Khi chương trình chạy, nó chậm rãi cập nhật giá trị và in ra kết quả.</p>
<p>Bây giờ, ta lại chạy nhiều phiên bản của cùng một chương trình để xem chuyện gì xảy ra (Hình 2.4). Ta thấy rằng mỗi chương trình chạy đều cấp phát bộ nhớ tại cùng một địa chỉ (<code>0x200000</code>), nhưng mỗi chương trình lại dường như cập nhật giá trị ở <code>0x200000</code> một cách độc lập! Như thể mỗi chương trình có một vùng bộ nhớ riêng, thay vì phải chia sẻ cùng bộ nhớ vật lý với các chương trình khác.</p>
<p>Thực tế, đó chính xác là điều đang xảy ra: hệ điều hành đang <strong>ảo hóa bộ nhớ (virtualizing memory)</strong>. Mỗi process truy cập <strong>không gian địa chỉ ảo riêng (virtual address space)</strong> của nó (còn gọi tắt là <strong>address space</strong>), và hệ điều hành bằng cách nào đó ánh xạ (map) nó vào bộ nhớ vật lý của máy. Một tham chiếu bộ nhớ trong một chương trình sẽ không ảnh hưởng đến không gian địa chỉ của process khác (hay của chính hệ điều hành). Từ góc nhìn của chương trình đang chạy, nó như thể sở hữu toàn bộ bộ nhớ vật lý. Nhưng thực tế, bộ nhớ vật lý là một tài nguyên dùng chung, được hệ điều hành quản lý.</p>
<p>Chính xác hệ điều hành làm thế nào để thực hiện điều này sẽ là chủ đề của phần đầu cuốn sách, trong phạm trù <strong>ảo hóa (virtualization)</strong>.</p>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>Để ví dụ này chạy đúng, bạn cần đảm bảo <strong>address-space randomization</strong> (ngẫu nhiên hóa không gian địa chỉ) đã được tắt; bởi lẽ tính năng ngẫu nhiên hóa này thực ra là một cơ chế phòng thủ hữu ích chống lại một số loại lỗ hổng bảo mật. Hãy đọc thêm nếu bạn quan tâm, đặc biệt khi muốn tìm hiểu cách tấn công hệ thống máy tính thông qua <strong>stack-smashing attacks</strong>. (Tất nhiên, chúng tôi không khuyến khích làm điều đó...)</p>
</div>
<h2 id="23-concurrency-tính-đồng-thời"><a class="header" href="#23-concurrency-tính-đồng-thời">2.3 Concurrency (Tính đồng thời)</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;common.h&quot;
#include &quot;common_threads.h&quot;

volatile int counter = 0;
int loops;

void *worker(void *arg) {
  int i;
  for (i = 0; i &lt; loops; i++) {
    counter++;
  }
  return NULL;
}

int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, &quot;usage: threads &lt;value&gt;\n&quot;);
    exit(1);
  }
  loops = atoi(argv[1]);
  pthread_t p1, p2;
  printf(&quot;Initial value : %d\n&quot;, counter);

  Pthread_create(&amp;p1, NULL, worker, NULL);
  Pthread_create(&amp;p2, NULL, worker, NULL);
  Pthread_join(p1, NULL);
  Pthread_join(p2, NULL);
printf(&quot;Final value
: %d\n&quot;, counter);
return 0;
}
</code></pre>
<p><em>Figure 2.5: A Multi-threaded Program (threads.c)</em></p>
<p>Một chủ đề chính khác của cuốn sách này là <strong>concurrency (tính đồng thời)</strong>. Chúng tôi dùng thuật ngữ khái niệm này để chỉ một tập hợp các vấn đề phát sinh (và cần phải được giải quyết) khi thực hiện nhiều việc cùng lúc (concurrently) trong cùng một chương trình.</p>
<p>Các vấn đề về concurrency xuất hiện đầu tiên ngay trong bản thân hệ điều hành. Như bạn thấy ở các ví dụ về ảo hóa ở phần trên, hệ điều hành phải “xoay sở” nhiều việc cùng một lúc: chạy một process (process), rồi chuyển sang process khác, và cứ thế tiếp tục. Hóa ra, việc này dẫn đến nhiều vấn đề sâu sắc và thú vị.</p>
<p>Tuy nhiên, các vấn đề về concurrency không còn giới hạn trong hệ điều hành. Thực tế, các chương trình đa luồng (multi-threaded programs) hiện đại cũng gặp chính các vấn đề tương tự. Hãy minh họa bằng một ví dụ về chương trình đa luồng (Hình 2.5).</p>
<p>Mặc dù lúc này bạn có thể chưa hiểu hết ví dụ (chúng ta sẽ học chi tiết hơn trong các chương sau, thuộc phần concurrency của cuốn sách), nhưng ý tưởng cơ bản khá đơn giản. Chương trình chính tạo ra hai <strong>thread (luồng)</strong> bằng cách gọi <code>Pthread_create()</code> <sup class="footnote-reference"><a href="#6">6</a></sup>. Bạn có thể hình dung thread giống như một hàm chạy trong cùng không gian bộ nhớ với các hàm khác, và có thể có nhiều thread hoạt động đồng thời. Trong ví dụ này, mỗi thread bắt đầu excecute trong một thủ tục tên là <code>worker()</code>, trong đó nó chỉ đơn giản tăng giá trị của một biến đếm (counter) trong vòng lặp, lặp đi lặp lại một số lần bằng với giá trị của biến <code>loops</code>.</p>
<p>Dưới đây là bản ghi kết quả khi chạy chương trình với giá trị <code>loops = 1000</code>. Biến <code>loops</code> xác định mỗi thread sẽ tăng biến đếm chung (shared counter) bao nhiêu lần trong vòng lặp. Khi chương trình chạy với <code>loops = 1000</code>, bạn kỳ vọng giá trị cuối cùng của <code>counter</code> sẽ là bao nhiêu?</p>
<pre><code>prompt&gt; gcc -o threads threads.c -Wall -pthread
prompt&gt; ./threads 1000
Initial value : 0
Final value: 2000
</code></pre>
<p>Như bạn có thể đoán, khi cả hai thread kết thúc, giá trị cuối cùng của counter là 2000, vì mỗi thread đã tăng counter 1000 lần. Thật vậy, khi giá trị <code>loops = N</code>, ta kỳ vọng kết quả cuối cùng là <code>2N</code>.</p>
<p>Nhưng thực tế lại không đơn giản như vậy. Hãy thử chạy lại chương trình với giá trị <code>loops</code> lớn hơn để xem chuyện gì xảy ra:</p>
<pre><code>prompt&gt; ./threads 100000
Initial value : 0
Final value  : 143012
prompt&gt; ./threads 100000
Initial value : 0
Final value  : 137298

// huh??
// what the??
</code></pre>
<p>Trong lần chạy này, khi ta truyền vào <code>loops = 100000</code>, thay vì nhận được kết quả đúng là <code>200000</code>, ta lại nhận giá trị <code>143012</code>. Khi chạy lại, không chỉ giá trị lại sai, mà còn khác với lần trước. Thực tế, nếu chạy chương trình nhiều lần với giá trị <code>loops</code> lớn, đôi khi bạn có thể nhận được kết quả đúng, nhưng hầu hết là sai. Vậy tại sao lại xảy ra hiện tượng này?</p>
<p>Nguyên nhân nằm ở cách lệnh được excecute: từng lệnh một. Đoạn code quan trọng trong chương trình trên — chỗ tăng biến counter chia sẻ — thực ra cần đến <strong>ba lệnh</strong>:</p>
<ol>
<li>Nạp giá trị counter từ bộ nhớ vào một thanh ghi.</li>
<li>Tăng giá trị đó.</li>
<li>Ghi kết quả trở lại bộ nhớ.</li>
</ol>
<p>Vì ba lệnh này <strong>không được excecute một cách nguyên tử (atomically, tức tất cả cùng một lúc)</strong>, nên có thể xảy ra xung đột, dẫn đến kết quả kỳ lạ. Chính vấn đề concurrency này sẽ được chúng ta nghiên cứu chi tiết trong phần thứ hai của cuốn sách.</p>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>Lời gọi thực tế là <code>pthread_create()</code> viết thường; phiên bản viết hoa trong sách là một hàm bao (wrapper) của tác giả, gọi <code>pthread_create()</code> và kiểm tra mã trả về để chắc chắn rằng call đã thành công. Xem mã nguồn để biết chi tiết.</p>
</div>
<blockquote>
<p><strong>THE CRUX OF THE PROBLEM: HOW TO BUILD CORRECT CONCURRENT PROGRAMS</strong>
Khi có nhiều thread excecute đồng thời trong cùng một không gian bộ nhớ, làm thế nào để xây dựng một chương trình hoạt động đúng? Hệ điều hành cần cung cấp những nguyên thủy (primitives) nào? Phần cứng nên hỗ trợ những cơ chế nào? Và chúng ta có thể dùng chúng để giải quyết vấn đề concurrency ra sao?</p>
</blockquote>
<h2 id="24-persistence-tính-bền-vững-của-dữ-liệu"><a class="header" href="#24-persistence-tính-bền-vững-của-dữ-liệu">2.4 Persistence (Tính bền vững của dữ liệu)</a></h2>
<p>Chủ đề lớn thứ ba của môn học này là <strong>persistence (tính bền vững của dữ liệu)</strong>. Trong bộ nhớ hệ thống, dữ liệu có thể dễ dàng bị mất, vì các thiết bị như DRAM lưu trữ dữ liệu theo cách <strong>volatile (không bền vững)</strong>; khi mất điện hoặc hệ thống sập, mọi dữ liệu trong bộ nhớ đều mất. Vì vậy, ta cần cả phần cứng và phần mềm để lưu dữ liệu một cách <strong>bền vững</strong>; việc lưu trữ này là cực kỳ quan trọng, bởi người dùng luôn quan tâm sâu sắc đến dữ liệu của họ.</p>
<p>Về phần cứng, ta có các thiết bị <strong>I/O (input/output)</strong>; trong các hệ thống hiện đại, ổ cứng (hard drive) là nơi phổ biến để lưu trữ dữ liệu lâu dài, mặc dù ổ đĩa thể rắn (SSD) ngày càng được sử dụng nhiều.</p>
<p>Về phần mềm, bộ phận trong hệ điều hành chịu trách nhiệm quản lý ổ đĩa được gọi là <strong>file system (hệ thống tập tin)</strong>; nó có trách nhiệm lưu trữ tất cả các file mà người dùng tạo ra một cách tin cậy và hiệu quả trên ổ đĩa.</p>
<p>Khác với trừu tượng hóa mà hệ điều hành cung cấp cho CPU và bộ nhớ, hệ điều hành <strong>không tạo ra một đĩa riêng ảo (virtualized disk) cho mỗi ứng dụng</strong>. Thay vào đó, giả định rằng người dùng thường muốn chia sẻ thông tin trong các file. Ví dụ: khi viết một chương trình C, bạn có thể dùng một trình soạn thảo (như Emacs <sup class="footnote-reference"><a href="#7">7</a></sup>) để tạo và chỉnh sửa file C (<code>emacs -nw main.c</code>). Sau đó, bạn dùng trình biên dịch để dịch mã nguồn thành file excecute (<code>gcc -o main main.c</code>). Cuối cùng, bạn chạy file excecute (<code>./main</code>). Như vậy, bạn thấy file được chia sẻ giữa các process khác nhau: trước tiên Emacs tạo file, sau đó compiler dùng nó để tạo file excecute, và cuối cùng chương trình mới được chạy.</p>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p>Bạn nên dùng Emacs. Nếu bạn dùng vi thì có lẽ có vấn đề gì đó. Còn nếu bạn dùng một thứ không phải là editor thực thụ thì còn tệ hơn nữa.</p>
</div>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;

int main(int argc, char *argv[]) {
    int fd = open(&quot;/tmp/file&quot;,
                  O_WRONLY|O_CREAT|O_TRUNC,
                  S_IRWXU);
    assert(fd &gt; -1);
    int rc = write(fd, &quot;hello world\n&quot;, 13);
    assert(rc == 13);
    close(fd);
    return 0;
}
</code></pre>
<p><strong>Hình 2.6: Một chương trình thực hiện I/O (io.c)</strong></p>
<p>Để hiểu rõ hơn, hãy xem đoạn code trên. Chương trình này tạo một file (<code>/tmp/file</code>) và ghi vào đó chuỗi <code>&quot;hello world&quot;</code>. Để thực hiện, chương trình gọi ba <strong>system call (lời gọi hệ thống)</strong>:</p>
<ul>
<li><code>open()</code> để mở và tạo file.</li>
<li><code>write()</code> để ghi dữ liệu vào file.</li>
<li><code>close()</code> để đóng file, báo rằng chương trình sẽ không ghi thêm nữa.</li>
</ul>
<p>Các system call này được chuyển đến <strong>file system</strong> trong hệ điều hành, nơi tiếp nhận yêu cầu, xử lý, và trả về mã lỗi (nếu có).</p>
<p>Bạn có thể thắc mắc: hệ điều hành thật sự làm gì để ghi dữ liệu xuống đĩa? Câu trả lời khá phức tạp: <strong>file system</strong> phải xác định dữ liệu mới sẽ nằm ở đâu trên đĩa, và duy trì thông tin này trong các cấu trúc dữ liệu nội bộ. Điều đó đòi hỏi hệ điều hành phải gửi các yêu cầu I/O đến thiết bị lưu trữ bên dưới, để đọc hoặc cập nhật các cấu trúc này. Bất kỳ ai từng viết <strong>device driver (trình điều khiển thiết bị)</strong> đều biết rằng việc điều khiển một thiết bị là quá trình phức tạp, đòi hỏi hiểu biết sâu sắc về interface cấp thấp và ngữ nghĩa chính xác của nó. May mắn thay, hệ điều hành cung cấp một interface chuẩn và đơn giản thông qua system call. Vì vậy, đôi khi hệ điều hành có thể được xem như một “thư viện chuẩn” để truy cập phần cứng.</p>
<p>Tất nhiên, còn rất nhiều chi tiết khác trong việc truy cập thiết bị và cách <strong>file system</strong> quản lý dữ liệu bền vững. Vì lý do hiệu năng, hầu hết file system đều <strong>trì hoãn việc ghi (delayed writes)</strong>, nhằm gom nhiều ghi nhỏ thành các ghi lớn. Để xử lý vấn đề hệ thống sập trong lúc ghi, nhiều file system sử dụng các giao thức ghi tinh vi, như <strong>journaling</strong> hoặc <strong>copy-on-write</strong>, nhằm đảm bảo nếu có sự cố trong chuỗi ghi, hệ thống vẫn có thể phục hồi về trạng thái hợp lý. Ngoài ra, để tối ưu các thao tác phổ biến, file system áp dụng nhiều cấu trúc dữ liệu khác nhau, từ danh sách đơn giản cho đến <strong>B-trees</strong> phức tạp.</p>
<p>Nếu lúc này bạn chưa hiểu hết, điều đó hoàn toàn bình thường! Chúng ta sẽ bàn kỹ hơn về tất cả những điều này trong phần ba của cuốn sách về persistence, nơi ta sẽ học về thiết bị, I/O nói chung, rồi đến đĩa, RAID, và file system chi tiết hơn.</p>
<blockquote>
<p><strong>THE CRUX OF THE PROBLEM: HOW TO STORE DATA PERSISTENTLY</strong>
File system là bộ phận trong hệ điều hành chịu trách nhiệm quản lý dữ liệu bền vững. Những kỹ thuật nào cần có để thực hiện đúng? Cơ chế và policy nào cần để đạt hiệu năng cao? Làm sao để đảm bảo độ tin cậy khi phần cứng hoặc phần mềm gặp sự cố?</p>
</blockquote>
<h2 id="25-mục-tiêu-thiết-kế"><a class="header" href="#25-mục-tiêu-thiết-kế">2.5 Mục tiêu thiết kế</a></h2>
<p>Giờ thì bạn đã có một ý niệm về việc một hệ điều hành thực sự làm gì: nó lấy các tài nguyên vật lý như CPU, bộ nhớ (memory), hoặc đĩa (disk), và “ảo hóa” chúng. Nó xử lý những vấn đề phức tạp và khó khăn liên quan đến đồng thời (concurrency). Và nó lưu trữ tệp (file) một cách bền vững, giúp dữ liệu an toàn lâu dài.</p>
<p>Khi xây dựng một hệ thống như vậy, chúng ta cần có những mục tiêu để định hướng thiết kế và triển khai, đồng thời biết cách cân nhắc giữa các sự đánh đổi (trade-offs); việc tìm ra tập hợp đánh đổi hợp lý chính là chìa khóa để xây dựng hệ thống.</p>
<p>Một trong những mục tiêu cơ bản nhất là xây dựng các <strong>trừu tượng (abstraction)</strong> nhằm giúp hệ thống thuận tiện và dễ sử dụng. Trừu tượng là nền tảng cho mọi thứ trong khoa học máy tính. Nhờ trừu tượng, ta có thể viết một chương trình lớn bằng cách chia nó thành các phần nhỏ và dễ hiểu; viết chương trình bằng ngôn ngữ bậc cao như C <sup class="footnote-reference"><a href="#9">8</a></sup> mà không cần quan tâm đến assembly; viết code assembly mà không cần nghĩ về cổng logic; và xây dựng một bộ xử lý từ các cổng logic mà không cần bận tâm nhiều đến transistor.</p>
<p>Trừu tượng quan trọng đến mức đôi khi ta quên mất giá trị của nó, nhưng ở đây thì không; trong từng phần, chúng ta sẽ thảo luận về các trừu tượng lớn đã hình thành theo thời gian, từ đó giúp bạn có cách nhìn rõ hơn về từng thành phần của hệ điều hành.</p>
<p>Một mục tiêu khác trong thiết kế và triển khai hệ điều hành là cung cấp <strong>hiệu năng cao (high performance)</strong>; nói cách khác, mục tiêu là giảm thiểu chi phí phụ trội (overheads) do OS gây ra. Việc ảo hóa và làm cho hệ thống dễ sử dụng là xứng đáng, nhưng không thể bằng mọi giá; do đó, ta phải cố gắng cung cấp ảo hóa và các tính năng khác của OS mà không tạo ra chi phí phụ trội quá lớn. Các chi phí này có thể xuất hiện dưới nhiều dạng: thời gian bổ sung (thêm lệnh) hoặc không gian bổ sung (trong bộ nhớ hoặc trên đĩa). Ta sẽ tìm cách tối thiểu hóa một trong hai hoặc cả hai, nếu có thể. Tuy nhiên, sự hoàn hảo không phải lúc nào cũng đạt được – điều này ta sẽ dần học cách nhận ra và (khi phù hợp) chấp nhận.</p>
<p>Một mục tiêu khác nữa là cung cấp <strong>cơ chế bảo vệ (protection)</strong> giữa các ứng dụng (application), cũng như giữa ứng dụng và hệ điều hành. Bởi vì ta muốn nhiều chương trình chạy cùng lúc, cần đảm bảo rằng hành vi sai trái (dù cố ý hay vô tình) của một chương trình không gây hại cho chương trình khác; đặc biệt là một ứng dụng không được phép làm hỏng hệ điều hành, vì điều đó sẽ ảnh hưởng đến tất cả chương trình đang chạy.</p>
<p>Bảo vệ chính là trung tâm của một nguyên lý cốt lõi trong hệ điều hành: <strong>cách ly (isolation)</strong>. Cách ly các process (process) với nhau là chìa khóa cho bảo vệ, và là nền tảng cho phần lớn những gì OS phải thực hiện.</p>
<p>Hệ điều hành cũng phải hoạt động liên tục; khi nó hỏng, mọi ứng dụng đang chạy cũng ngừng theo. Do sự phụ thuộc này, hệ điều hành thường hướng tới việc cung cấp <strong>độ tin cậy cao (high reliability)</strong>.</p>
<div class="footnote-definition" id="9"><sup class="footnote-definition-label">8</sup>
<p>Một số bạn có thể phản đối việc gọi C là ngôn ngữ bậc cao. Nhưng hãy nhớ đây là một khóa học về hệ điều hành, nơi chúng ta đơn giản cảm thấy vui vì không phải viết code bằng assembly mọi lúc!</p>
</div>
<p>Khi hệ điều hành ngày càng phức tạp (đôi khi chứa hàng triệu dòng code), việc xây dựng một OS đáng tin cậy trở thành một thách thức lớn – và thực tế, nhiều nghiên cứu hiện nay (bao gồm cả công trình của chúng tôi [BS+09, SS+10]) tập trung chính vào vấn đề này.</p>
<p>Ngoài ra còn có các mục tiêu khác: hiệu quả năng lượng (energy-efficiency) quan trọng trong một thế giới ngày càng chú trọng “xanh”; bảo mật (security – mở rộng từ bảo vệ) chống lại các ứng dụng độc hại đặc biệt quan trọng trong thời đại kết nối mạng cao; tính di động (mobility) ngày càng cần thiết khi OS được triển khai trên các thiết bị nhỏ hơn và nhỏ hơn nữa. Tùy thuộc vào cách hệ thống được sử dụng, OS sẽ có mục tiêu khác nhau, và do đó thường được triển khai theo những cách khác nhau (dù chỉ khác một chút). Tuy nhiên, như ta sẽ thấy, nhiều nguyên lý xây dựng OS sẽ hữu ích cho nhiều loại thiết bị khác nhau.</p>
<h2 id="26-một-chút-lịch-sử"><a class="header" href="#26-một-chút-lịch-sử">2.6 Một chút lịch sử</a></h2>
<p>Trước khi kết thúc phần giới thiệu này, chúng ta hãy điểm qua một chút lịch sử về sự phát triển của hệ điều hành. Giống như bất kỳ hệ thống nào do con người tạo ra, các ý tưởng hay dần dần được tích lũy trong OS theo thời gian, khi kỹ sư học được điều gì quan trọng trong thiết kế. Ở đây, ta sẽ thảo luận một vài bước phát triển lớn. Nếu muốn tìm hiểu sâu hơn, hãy xem cuốn lịch sử xuất sắc của Brinch Hansen về hệ điều hành [BH00].</p>
<h3 id="hệ-điều-hành-thời-kỳ-đầu-chỉ-là-thư-viện"><a class="header" href="#hệ-điều-hành-thời-kỳ-đầu-chỉ-là-thư-viện">Hệ điều hành thời kỳ đầu: Chỉ là thư viện</a></h3>
<p>Ban đầu, hệ điều hành không làm được nhiều. Về cơ bản, nó chỉ là một tập thư viện các hàm thường dùng; ví dụ, thay vì để mỗi lập trình viên tự viết mã xử lý I/O cấp thấp, “OS” sẽ cung cấp API này, giúp cuộc sống của lập trình viên dễ dàng hơn.</p>
<p>Thông thường, trên các hệ thống mainframe cũ, chỉ có một chương trình chạy tại một thời điểm, được điều khiển bởi một <strong>toán tử (operator)</strong> là con người. Nhiều việc mà bạn nghĩ một OS hiện đại phải làm (ví dụ: quyết định thứ tự chạy job) khi đó do người vận hành quyết định. Nếu bạn là lập trình viên khôn khéo, bạn sẽ đối xử tốt với operator để được ưu tiên đưa job của mình lên đầu hàng đợi.</p>
<p>Mô hình tính toán này được gọi là <strong>xử lý theo lô (batch processing)</strong>, khi một loạt job được thiết lập sẵn và chạy theo “lô” bởi operator. Máy tính thời đó chưa dùng theo kiểu tương tác, do chi phí: quá đắt đỏ để cho phép một người ngồi trước máy tính và sử dụng nó, vì phần lớn thời gian máy sẽ rỗi, gây tổn thất hàng trăm nghìn đô la mỗi giờ [BH00].</p>
<h3 id="vượt-khỏi-thư-viện-bảo-vệ"><a class="header" href="#vượt-khỏi-thư-viện-bảo-vệ">Vượt khỏi thư viện: Bảo vệ</a></h3>
<p>Khi thoát khỏi vai trò chỉ là thư viện dịch vụ thường dùng, hệ điều hành bắt đầu đảm nhận vai trò trung tâm trong quản lý máy tính. Một khía cạnh quan trọng là nhận thức rằng code chạy thay mặt cho OS là đặc biệt: nó có quyền kiểm soát thiết bị, và vì thế phải được xử lý khác với code ứng dụng thông thường.</p>
<p>Tại sao vậy? Hãy tưởng tượng nếu bất kỳ ứng dụng nào cũng có thể đọc toàn bộ đĩa; khái niệm riêng tư sẽ không còn, vì bất kỳ chương trình nào cũng đọc được mọi file. Do đó, việc triển khai hệ thống file như một thư viện là không hợp lý. Thay vào đó, cần một cơ chế khác.</p>
<p>Vậy nên, khái niệm <strong>lời gọi hệ thống (system call)</strong> được phát minh, khởi đầu từ hệ thống Atlas [K+61, L78]. Thay vì cung cấp routine của OS như một thư viện (chỉ cần gọi hàm thủ tục), ý tưởng ở đây là thêm một cặp lệnh phần cứng đặc biệt và trạng thái phần cứng để biến việc chuyển vào OS thành một quá trình chính thức và được kiểm soát.</p>
<p>Điểm khác biệt chính giữa system call và procedure call là: system call chuyển quyền điều khiển (jump) vào OS đồng thời nâng mức đặc quyền phần cứng. Ứng dụng người dùng chạy trong cái gọi là <strong>chế độ người dùng (user mode)</strong>, nơi phần cứng hạn chế những gì ứng dụng có thể làm; ví dụ, một ứng dụng trong user mode thường không thể trực tiếp gửi yêu cầu I/O tới đĩa, truy cập bất kỳ trang bộ nhớ vật lý nào, hoặc gửi gói tin mạng.</p>
<p>Khi một system call được khởi tạo (thường qua một lệnh phần cứng đặc biệt gọi là <strong>trap</strong>), phần cứng sẽ chuyển quyền điều khiển tới một <strong>trình xử lý trap (trap handler)</strong> đã được OS cài đặt từ trước, đồng thời nâng mức đặc quyền lên <strong>chế độ nhân (kernel mode)</strong>. Trong kernel mode, OS có toàn quyền truy cập phần cứng hệ thống, do đó có thể thực hiện các việc như khởi tạo I/O hoặc cấp thêm bộ nhớ cho chương trình. Khi OS hoàn tất xử lý yêu cầu, nó trả quyền điều khiển về ứng dụng qua một lệnh đặc biệt gọi là <strong>return-from-trap</strong>, vừa khôi phục về user mode, vừa tiếp tục chương trình tại vị trí nó đã dừng.</p>
<h3 id="kỷ-nguyên-đa-chương-trình-multiprogramming"><a class="header" href="#kỷ-nguyên-đa-chương-trình-multiprogramming">Kỷ nguyên đa chương trình (Multiprogramming)</a></h3>
<p>Hệ điều hành thực sự cất cánh trong kỷ nguyên máy tính mini, vượt khỏi mainframe. Những máy kinh điển như dòng PDP của Digital Equipment giúp máy tính trở nên rẻ hơn nhiều; thay vì mỗi tổ chức lớn chỉ có một mainframe, thì một nhóm nhỏ trong tổ chức cũng có thể sở hữu máy tính riêng. Không ngạc nhiên khi chi phí giảm đã dẫn tới sự bùng nổ hoạt động lập trình; nhiều người tài năng được tiếp cận máy tính và tạo ra những hệ thống thú vị và đẹp đẽ hơn.</p>
<p>Đặc biệt, <strong>đa chương trình (multiprogramming)</strong> trở nên phổ biến nhờ nhu cầu tận dụng tốt hơn tài nguyên máy. Thay vì chỉ chạy một job tại một thời điểm, OS sẽ load nhiều job vào bộ nhớ và chuyển đổi nhanh giữa chúng, giúp tăng hiệu quả sử dụng CPU. Điều này đặc biệt quan trọng vì thiết bị I/O rất chậm; để chương trình ngồi chờ CPU trong lúc I/O xử lý là một lãng phí. Tốt hơn hết là chuyển sang job khác và chạy nó trong khi chờ I/O.</p>
<p>Nhu cầu hỗ trợ multiprogramming và xử lý chồng chéo trong sự hiện diện của I/O và ngắt (interrupt) đã thúc đẩy đổi mới trong thiết kế khái niệm OS theo nhiều hướng. Các vấn đề như <strong>bảo vệ bộ nhớ (memory protection)</strong> trở nên quan trọng; ta không muốn một chương trình truy cập bộ nhớ của chương trình khác. Hiểu cách xử lý các vấn đề đồng thời (concurrency) do multiprogramming tạo ra cũng rất quan trọng; đảm bảo OS hoạt động đúng bất chấp sự có mặt của ngắt là một thách thức lớn. Những vấn đề này và các chủ đề liên quan sẽ được nghiên cứu kỹ hơn trong các chương sau.</p>
<p>Một trong những tiến bộ thực tiễn lớn của thời kỳ này là sự ra đời của hệ điều hành <strong>UNIX</strong>, chủ yếu nhờ công của Ken Thompson (và Dennis Ritchie) tại Bell Labs. UNIX đã kế thừa nhiều ý tưởng hay từ các OS khác (đặc biệt là Multics [O72], và một số từ hệ thống như TENEX [B+72] và Berkeley Time-Sharing System [S68]), nhưng làm cho chúng đơn giản và dễ dùng hơn. Chẳng bao lâu, nhóm này đã gửi băng chứa mã nguồn UNIX tới mọi nơi trên thế giới; nhiều người khác tham gia và bổ sung thêm cho hệ thống <sup class="footnote-reference"><a href="#10">9</a></sup>.</p>
<h2 id="thời-đại-hiện-đại"><a class="header" href="#thời-đại-hiện-đại">Thời đại hiện đại</a></h2>
<p>Sau thời kỳ minicomputer (máy tính cỡ trung), một loại máy mới xuất hiện: rẻ hơn, nhanh hơn và dành cho số đông — đó là <strong>personal computer (PC, máy tính cá nhân)</strong> như chúng ta gọi ngày nay. Dẫn đầu bởi những dòng máy đầu tiên của Apple (ví dụ: Apple II) và IBM PC, thế hệ máy này nhanh chóng trở thành lực lượng thống trị trong ngành tính toán, vì chi phí thấp cho phép mỗi người có một máy tính trên bàn làm việc, thay vì phải chia sẻ một minicomputer cho cả nhóm.</p>
<p>Tuy nhiên, đối với <strong>operating system (hệ điều hành)</strong>, PC lúc đầu lại là một bước lùi lớn, bởi các hệ thống ban đầu đã quên (hoặc chưa từng biết) những bài học trong kỷ nguyên minicomputer. Ví dụ, các hệ điều hành như <strong>DOS (Disk Operating System, Hệ điều hành đĩa, của Microsoft)</strong> không coi trọng việc bảo vệ bộ nhớ; do đó, một ứng dụng độc hại (hoặc chỉ là lập trình kém) có thể ghi lung tung vào toàn bộ vùng nhớ.</p>
<div class="footnote-definition" id="10"><sup class="footnote-definition-label">9</sup>
<p>Chúng tôi sẽ sử dụng chú thích bên lề và các hộp văn bản liên quan để nhấn mạnh những điểm không hoàn toàn nằm trong mạch chính của nội dung. Thỉnh thoảng, chúng tôi còn thêm chút hài hước cho vui. Đúng vậy, nhiều trò đùa khá dở.</p>
</div>
<h3 id="aside-tẦm-quan-trỌng-cỦa-unix"><a class="header" href="#aside-tẦm-quan-trỌng-cỦa-unix">ASIDE: TẦM QUAN TRỌNG CỦA UNIX</a></h3>
<p>Thật khó có thể nói hết tầm quan trọng của <strong>UNIX</strong> trong lịch sử hệ điều hành. Bị ảnh hưởng từ các hệ thống trước đó (đặc biệt là hệ thống <strong>Multics</strong> nổi tiếng của MIT), UNIX đã tập hợp nhiều ý tưởng xuất sắc và xây dựng nên một hệ thống vừa đơn giản vừa mạnh mẽ.</p>
<p>Nền tảng của UNIX do “Bell Labs” phát triển dựa trên nguyên tắc thống nhất: xây dựng các chương trình nhỏ nhưng mạnh, có thể kết hợp với nhau thành các luồng công việc (workflow) lớn hơn. <strong>Shell</strong> — nơi bạn nhập lệnh — cung cấp các công cụ cơ bản như <strong>pipes (ống dẫn)</strong> để hỗ trợ lập trình ở cấp độ meta. Nhờ vậy, ta có thể dễ dàng ghép các chương trình lại để giải quyết một nhiệm vụ lớn hơn. Ví dụ: để tìm các dòng trong tệp văn bản có chứa từ “foo”, sau đó đếm số dòng đó, bạn chỉ cần gõ:</p>
<pre><code>grep foo file.txt | wc -l
</code></pre>
<p>Ở đây, <code>grep</code> dùng để lọc, còn <code>wc</code> (word count) dùng để đếm số dòng.</p>
<p>Môi trường UNIX thân thiện với lập trình viên, đồng thời cung cấp <strong>compiler (trình biên dịch)</strong> cho ngôn ngữ C mới. Điều này giúp các lập trình viên dễ dàng viết chương trình riêng và chia sẻ, làm cho UNIX trở nên cực kỳ phổ biến. Thêm vào đó, các tác giả còn phát miễn phí bản sao cho bất kỳ ai yêu cầu — một dạng <strong>open-source software (phần mềm nguồn mở)</strong> sơ khai.</p>
<p>Một điểm then chốt khác là mã nguồn của hệ thống có tính <strong>readability (dễ đọc)</strong> cao. <strong>Kernel (nhân hệ điều hành)</strong> nhỏ gọn, đẹp mắt, viết bằng C, khuyến khích cộng đồng tham gia bổ sung tính năng. Ví dụ, một nhóm ở Berkeley do Bill Joy dẫn đầu đã phát triển bản phân phối <strong>BSD (Berkeley Systems Distribution)</strong> với các hệ thống con tiên tiến về <strong>virtual memory (bộ nhớ ảo)</strong>, <strong>file system (hệ thống tệp)</strong>, và <strong>networking (mạng máy tính)</strong>. Sau này, Bill Joy đồng sáng lập Sun Microsystems.</p>
<p>Đáng tiếc, sự phổ biến của UNIX bị chậm lại do các công ty tìm cách giành quyền sở hữu và lợi nhuận, kết quả thường thấy khi luật sư nhúng tay. Nhiều công ty tung ra biến thể riêng: <strong>SunOS</strong> (Sun Microsystems), <strong>AIX</strong> (IBM), <strong>HP-UX</strong> (HP), <strong>IRIX</strong> (SGI). Các tranh chấp pháp lý giữa AT&amp;T/Bell Labs và những bên này đã khiến tương lai của UNIX mờ mịt, đặc biệt khi <strong>Windows</strong> xuất hiện và chiếm lĩnh phần lớn thị trường PC.</p>
<h3 id="aside-rỒi-ĐẾn-linux"><a class="header" href="#aside-rỒi-ĐẾn-linux">ASIDE: RỒI ĐẾN LINUX</a></h3>
<p>May mắn cho UNIX, một hacker trẻ người Phần Lan tên <strong>Linus Torvalds</strong> quyết định viết phiên bản UNIX riêng, dựa trên các nguyên tắc và ý tưởng ban đầu nhưng không sao chép mã nguồn, từ đó tránh rắc rối pháp lý. Anh kêu gọi sự giúp đỡ từ khắp nơi, tận dụng bộ công cụ GNU sẵn có [G85], và không lâu sau <strong>Linux</strong> ra đời, kéo theo cả phong trào phần mềm nguồn mở hiện đại.</p>
<p>Khi kỷ nguyên internet bùng nổ, hầu hết các công ty (như Google, Amazon, Facebook,...) đều chọn Linux vì miễn phí và có thể tùy chỉnh. Khó mà tưởng tượng được sự thành công của họ nếu thiếu hệ thống này. Khi <strong>smartphone</strong> trở thành nền tảng phổ biến, Linux cũng chiếm chỗ đứng (qua Android), vì những lý do tương tự. Steve Jobs cũng mang môi trường <strong>NeXTStep</strong> dựa trên UNIX đến Apple, khiến UNIX phổ biến cả trên desktop (dù nhiều người dùng Apple không hề hay biết).</p>
<p>Nhờ vậy, UNIX vẫn sống, và ngày nay còn quan trọng hơn bao giờ hết. Nếu tin vào các vị “thần máy tính”, hãy cảm ơn họ vì kết quả tuyệt vời này.</p>
<p>Thế hệ đầu của <strong>Mac OS</strong> (phiên bản 9 trở về trước) sử dụng cơ chế <strong>cooperative scheduling (lập lịch hợp tác)</strong>; do đó, một <strong>thread (luồng)</strong> vô tình mắc kẹt trong vòng lặp vô hạn có thể chiếm toàn bộ hệ thống, buộc phải khởi động lại. Danh sách dài những tính năng còn thiếu trong hệ này rất đau đớn, quá dài để bàn hết ở đây.</p>
<p>May mắn thay, sau nhiều năm chịu đựng, các đặc tính từ hệ điều hành minicomputer dần xuất hiện trên desktop. Ví dụ, <strong>Mac OS X/macOS</strong> có nhân UNIX, bao gồm toàn bộ tính năng của một hệ thống trưởng thành. <strong>Windows</strong> cũng dần tiếp thu nhiều ý tưởng lớn, bắt đầu từ <strong>Windows NT</strong> — một bước tiến vượt bậc của Microsoft.</p>
<p>Ngay cả điện thoại ngày nay cũng chạy hệ điều hành (như Linux) gần giống với những gì minicomputer chạy vào thập niên 1970, hơn là PC thập niên 1980 (một điều đáng mừng). Thật tuyệt khi thấy các ý tưởng hay của giai đoạn vàng son trong phát triển hệ điều hành đã được đưa vào thế giới hiện đại. Tốt hơn nữa, các ý tưởng này vẫn tiếp tục phát triển, bổ sung nhiều tính năng và làm cho hệ thống hiện đại ngày càng tốt hơn cho người dùng lẫn ứng dụng.</p>
<h2 id="27-tóm-tắt"><a class="header" href="#27-tóm-tắt">2.7 Tóm tắt</a></h2>
<p>Chúng ta vừa có cái nhìn tổng quan về hệ điều hành. Ngày nay, hệ điều hành giúp việc sử dụng máy tính trở nên dễ dàng hơn rất nhiều, và hầu hết chúng đều chịu ảnh hưởng từ những phát triển sẽ được bàn trong cuốn sách này.</p>
<p>Tuy nhiên, do hạn chế về thời gian, một số phần sẽ không được đề cập. Ví dụ: hệ điều hành chứa rất nhiều mã mạng (<strong>networking code</strong>), bạn sẽ học trong môn Mạng máy tính. Tương tự, đồ họa (<strong>graphics devices</strong>) rất quan trọng, nhưng hãy để dành cho môn Đồ họa máy tính. Một số giáo trình hệ điều hành khác bàn nhiều về bảo mật (<strong>security</strong>); ở đây, chúng tôi chỉ nói đến khía cạnh hệ điều hành phải bảo vệ giữa các chương trình và cung cấp khả năng bảo vệ tệp cho người dùng, chứ không đi sâu vào an ninh hệ thống như trong môn An toàn thông tin.</p>
<p>Dẫu vậy, có nhiều chủ đề quan trọng sẽ được đề cập, bao gồm cơ bản về <strong>virtualization (ảo hóa CPU và bộ nhớ)</strong>, <strong>concurrency (tính đồng thời)</strong>, và <strong>persistence (tính bền vững của dữ liệu)</strong> thông qua thiết bị và hệ thống tệp. Đừng lo! Mặc dù còn rất nhiều điều cần học, hầu hết đều rất thú vị, và cuối chặng đường, bạn sẽ có một cách nhìn mới mẻ về cách hệ thống máy tính thật sự vận hành.</p>
<p>Bây giờ thì bắt đầu học thôi!</p>
<h2 id="tham-khảo"><a class="header" href="#tham-khảo">Tham khảo</a></h2>
<p>[BS+09] “Tolerating File-System Mistakes with EnvyFS”<br />
Lakshmi N. Bairavasundaram, Swaminathan Sundararaman, Andrea C. Arpaci-Dusseau, RemziH. Arpaci-Dusseau<br />
USENIX ’09, San Diego, CA, June 2009<br />
A fun paper about using multiple file systems at once to tolerate a mistake in any one of them.</p>
<p>[BH00] “The Evolution of Operating Systems”<br />
P. Brinch Hansen<br />
In Classic Operating Systems: From Batch Processing to Distributed Systems Springer-Verlag, New York, 2000<br />
This essay provides an intro to a wonderful collection of papers about historically significant systems.</p>
<p>[B+72] “TENEX, A Paged Time Sharing System for the PDP-10”<br />
Daniel G. Bobrow, Jerry D. Burchfiel, Daniel L. Murphy, Raymond S. Tomlinson<br />
CACM, Volume 15, Number 3, March 1972<br />
TENEX has much of the machinery found in modern operating systems; read more about it to see how much innovation was already in place in the early 1970’s.</p>
<p>[B75] “The Mythical Man-Month”<br />
Fred Brooks<br />
Addison-Wesley, 1975<br />
A classic text on software engineering; well worth the read.</p>
<p>[BOH10] “Computer Systems: A Programmer’s Perspective”<br />
Randal E. Bryant and David R. O’Hallaron<br />
Addison-Wesley, 2010<br />
Another great intro to how computer systems work. Has a little bit of overlap with this book — so if you’d like, you can skip the last few chapters of that book, or simply read them to get a different perspective on some of the same material. After all, one good way to build up your own knowledge is to hear as many other perspectives as possible, and then develop your own opinion and thoughts on the matter. You know, by thinking!</p>
<p>[G85] “The GNU Manifesto”<br />
Richard Stallman, 1985<br />
Available: https://www.gnu.org/gnu/manifesto.html<br />
A huge part of Linux’s success was no doubt the presence of an excellent compiler, gcc, and other relevant pieces of open software, all thanks to the GNU effort headed by Richard Stallman. Stallman is quite a visionary when it comes to open source, and this manifesto lays out his thoughts as to why; well worth the read.</p>
<p>[K+61] “One-Level Storage System”<br />
T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner<br />
IRE Transactions on Electronic Computers, April 1962<br />
The Atlas pioneered much of what you see in modern systems. However, this paper is not the best read. If you were to only read one, you might try the historical perspective below [L78].</p>
<p>[L78] “The Manchester Mark I and Atlas: A Historical Perspective”<br />
S. H. Lavington<br />
Communications of the ACM archive<br />
Volume 21, Issue 1 (January 1978), pages 4-12<br />
A nice piece of history on the early development of computer systems and the pioneering efforts of the Atlas. Of course, one could go back and read the Atlas papers themselves, but this paper provides a great overview and adds some historical perspective.</p>
<p>[O72] “The Multics System: An Examination of its Structure”<br />
Elliott Organick, 1972<br />
A great overview of Multics. So many good ideas, and yet it was an over-designed system, shooting for too much, and thus never really worked as expected. A classic example of what Fred Brooks would call the “second-system effect” [B75].</p>
<p>[PP03] “Introduction to Computing Systems:<br />
From Bits and Gates to C and Beyond”<br />
Yale N. Patt and Sanjay J. Patel<br />
McGraw-Hill, 2003<br />
One of our favorite intro to computing systems books. Starts at transistors and gets you all the way up to C; the early material is particularly great.</p>
<p>[RT74] “The UNIX Time-Sharing System”<br />
Dennis M. Ritchie and Ken Thompson<br />
CACM, Volume 17, Number 7, July 1974, pages 365-375<br />
A great summary of UNIX written as it was taking over the world of computing, by the people who wrote it.</p>
<p>[S68] “SDS 940 Time-Sharing System”<br />
Scientific Data Systems Inc.<br />
TECHNICAL MANUAL, SDS 90 11168 August 1968<br />
Available: http://goo.gl/EN0Zrn<br />
Yes, a technical manual was the best we could find. But it is fascinating to read these old system documents, and see how much was already in place in the late 1960’s. One of the minds behind the Berkeley Time-Sharing System (which eventually became the SDS system) was Butler Lampson, who later won a Turing award for his contributions in systems.</p>
<p>[SS+10] “Membrane: Operating System Support for Restartable File Systems”<br />
Swaminathan Sundararaman, Sriram Subramanian, Abhishek Rajimwale, Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, Michael M. Swift<br />
FAST ’10, San Jose, CA, February 2010<br />
The great thing about writing your own class notes: you can advertise your own research. But this paper is actually pretty neat — when a file system hits a bug and crashes, Membrane auto-magically restarts it, all without applications or the rest of the system being affected.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-dialogue-on-virtualization"><a class="header" href="#a-dialogue-on-virtualization">A Dialogue on Virtualization</a></h1>
<p>Không dịch</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-sự-trừu-tượng-process-tiến-trình"><a class="header" href="#4-sự-trừu-tượng-process-tiến-trình">4. Sự trừu tượng: Process (tiến trình)</a></h1>
<p>Trong chương này, chúng ta sẽ thảo luận về một trong những <strong>sự trừu tượng (abstraction)</strong> cơ bản nhất mà hệ điều hành cung cấp cho người dùng: <strong>process (tiến trình)</strong>.</p>
<p>Một định nghĩa không chính thức về process khá đơn giản: đó là một <strong>chương trình đang chạy</strong> [V+65, BH70]. Bản thân chương trình khi nằm trên đĩa chỉ là một thực thể “vô hồn”: một tập hợp các lệnh (và có thể là static data (dữ liệu tĩnh)), chờ được kích hoạt. Chính hệ điều hành là thành phần lấy những byte đó, cho chúng chạy, và biến chương trình thành một thực thể hữu ích.</p>
<p>Thực tế, người dùng thường muốn chạy nhiều chương trình cùng lúc; ví dụ, trên máy tính để bàn hoặc laptop, bạn có thể chạy trình duyệt web, chương trình email, một trò chơi, một trình phát nhạc,... Thậm chí, một hệ thống điển hình có thể chạy hàng chục hoặc hàng trăm process đồng thời. Điều này làm hệ thống trở nên dễ sử dụng, vì người dùng không cần bận tâm xem CPU có đang rảnh hay không; đơn giản chỉ là “chạy chương trình”. Từ đây, nảy sinh một thách thức:</p>
<blockquote>
<p><strong>VẤN ĐỀ CỐT LÕI: LÀM THẾ NÀO ĐỂ TẠO RA ẢO GIÁC VỀ NHIỀU CPU?</strong></p>
<p>Trong khi thực tế chỉ có vài CPU vật lý, làm thế nào hệ điều hành có thể tạo ra ảo giác rằng có một nguồn CPU gần như vô hạn?</p>
</blockquote>
<p>Hệ điều hành giải quyết bằng cách <strong>ảo hóa CPU (virtualizing the CPU)</strong>. Bằng cách chạy một process, rồi dừng nó để chạy process khác, và lặp lại, hệ điều hành tạo ra ảo giác rằng có nhiều CPU ảo tồn tại, trong khi thực tế chỉ có một (hoặc một vài) CPU vật lý. Kỹ thuật cơ bản này gọi là <strong>time sharing (chia sẻ theo thời gian)</strong> CPU. Nhờ đó, người dùng có thể chạy nhiều process đồng thời; chi phí phải trả là hiệu năng, vì mỗi process sẽ chạy chậm hơn khi CPU phải được chia sẻ.</p>
<p>Để hiện thực hóa ảo hóa CPU một cách hiệu quả, hệ điều hành cần cả <strong>cơ chế (mechanism)</strong> ở mức thấp lẫn <strong>policy</strong> (chính sách) ở mức cao.</p>
<p><strong>Mechanism (cơ chế)</strong>: các phương pháp hoặc giao thức mức thấp để hiện thực một chức năng cần thiết. Ví dụ: ta sẽ học về <strong>context switch (chuyển ngữ cảnh)</strong> — cơ chế cho phép OS dừng một chương trình và bắt đầu chạy chương trình khác trên CPU. Đây là cơ chế time sharing mà mọi hệ điều hành hiện đại đều sử dụng.</p>
<blockquote>
<p>💡 <strong>TIP: Sử dụng Time Sharing và Space Sharing</strong></p>
<p>Time sharing là kỹ thuật cơ bản giúp hệ điều hành chia sẻ một tài nguyên. Tài nguyên (ví dụ CPU hoặc đường truyền mạng) được cho một đối tượng sử dụng một thời gian ngắn, sau đó đến đối tượng khác, luân phiên như vậy.</p>
<p>Ngược lại, <strong>space sharing (chia sẻ theo không gian)</strong> chia tài nguyên theo “không gian”. Ví dụ, dung lượng đĩa là một tài nguyên space-shared: khi một block đã được gán cho một file, nó sẽ không được gán cho file khác cho đến khi người dùng xóa file ban đầu.</p>
</blockquote>
<p><strong>Policy</strong>: là các thuật toán đưa ra quyết định trong hệ điều hành. Ví dụ: khi có nhiều chương trình sẵn sàng chạy trên CPU, OS cần quyết định chạy chương trình nào. <strong>Scheduling policy (chính sách lập lịch)</strong> sẽ đưa ra quyết định này, thường dựa trên thông tin lịch sử (ví dụ: chương trình nào đã chạy nhiều hơn trong phút vừa qua?), đặc điểm workload (loại chương trình đang chạy), và tiêu chí hiệu năng (tối ưu cho tính tương tác hay cho thông lượng?).</p>
<h2 id="41-sự-trừu-tượng-process"><a class="header" href="#41-sự-trừu-tượng-process">4.1 Sự trừu tượng: Process</a></h2>
<p>Sự trừu tượng mà hệ điều hành cung cấp cho một chương trình đang chạy chính là <strong>process</strong>. Như đã nói ở trên, process đơn giản là một chương trình đang excecute. Tại một thời điểm bất kỳ, ta có thể mô tả process bằng cách liệt kê những thành phần hệ thống mà nó truy cập hoặc ảnh hưởng trong suốt quá trình chạy.</p>
<p>Để hiểu process gồm những gì, ta cần hiểu <strong>machine state (trạng thái máy)</strong>: tức là tập hợp các giá trị mà chương trình có thể đọc hoặc ghi trong khi excecute. Vậy, tại một thời điểm bất kỳ, những phần nào của máy tính quan trọng đối với việc chạy chương trình?</p>
<p><strong>Memory (bộ nhớ)</strong>: thành phần rõ ràng nhất. Các lệnh của chương trình nằm trong bộ nhớ; dữ liệu mà chương trình đọc và ghi cũng nằm trong bộ nhớ. Vì vậy, vùng bộ nhớ mà process có thể truy cập (gọi là <strong>address space – không gian địa chỉ</strong>) là một phần của process.</p>
<p><strong>Registers (thanh ghi)</strong>: nhiều lệnh của CPU trực tiếp đọc/ghi các thanh ghi, nên chúng cũng là thành phần cốt lõi của machine state. Đặc biệt có một số thanh ghi quan trọng bao gồm <strong>Program Counter (PC)</strong>, còn gọi là <strong>Instruction Pointer (IP)</strong>, cho biết lệnh tiếp theo cần excecute. Đồng thời, còn có <strong>Stack Pointer</strong> và <strong>Frame Pointer</strong> đi kèm được dùng để quản lý <strong>stack</strong> (ngăn xếp), nơi lưu tham số hàm (function parameters), biến cục bộ (local variables) và địa chỉ trả về (return addresses).</p>
<p><strong>I/O state (trạng thái nhập/xuất)</strong>: chương trình thường truy cập cả các thiết bị lưu trữ lâu dài. Ví dụ: process có thể duy trì danh sách các file đang mở.</p>
<blockquote>
<p><strong>TIP: Tách biệt Policy và Mechanism</strong></p>
<p>Trong nhiều hệ điều hành, nguyên lý thiết kế phổ biến là <strong>tách biệt policy và mechanism</strong> [L+75].</p>
<ul>
<li>
<p><strong>Mechanism</strong> trả lời câu hỏi “làm thế nào” (<em>how</em>). Ví dụ: làm thế nào để OS thực hiện context switch?</p>
</li>
<li>
<p><strong>Policy</strong> trả lời câu hỏi “chọn cái nào” (<em>which</em>). Ví dụ: OS nên chạy process nào ngay lúc này?</p>
<p>Việc tách rời này cho phép thay đổi policy dễ dàng mà không ảnh hưởng đến cơ chế, và đây cũng là một dạng <strong>modularity (tính mô-đun)</strong> — nguyên tắc chung trong thiết kế phần mềm.</p>
</li>
</ul>
</blockquote>
<h2 id="42-api-của-process-tiến-trình"><a class="header" href="#42-api-của-process-tiến-trình">4.2 API của Process (Tiến trình)</a></h2>
<p>Mặc dù chúng ta sẽ hoãn việc bàn chi tiết về một API process thực sự cho đến các chương sau, nhưng trước hết, ở đây ta sẽ phác thảo những thành phần cơ bản cần có trong bất kỳ interface (giao diện) nào của hệ điều hành. Các API này, dưới một dạng nào đó, đều có mặt trong mọi hệ điều hành hiện đại.</p>
<ul>
<li><strong>Create (Tạo):</strong> Hệ điều hành phải cung cấp phương thức để tạo process mới. Khi bạn gõ một lệnh trong shell, hoặc nhấp đúp vào biểu tượng ứng dụng, hệ điều hành sẽ được gọi để tạo ra một process mới nhằm chạy chương trình bạn yêu cầu.</li>
<li><strong>Destroy (Hủy):</strong> Cũng như việc tạo process, hệ điều hành phải cung cấp interface để hủy process một cách cưỡng bức. Tất nhiên, nhiều process sẽ tự chạy và thoát khi hoàn tất; tuy nhiên, khi chúng không làm vậy, người dùng có thể muốn “kill” (dừng) chúng, và do đó, interface để kết thúc một process “chạy mất kiểm soát” là rất hữu ích.</li>
<li><strong>Wait (Chờ):</strong> Đôi khi, người dùng cần chờ cho đến khi một process kết thúc; do đó, hầu hết hệ điều hành đều cung cấp một interface chờ process.</li>
<li><strong>Miscellaneous Control (Các điều khiển khác):</strong> Ngoài việc hủy hoặc chờ process, hệ điều hành còn cung cấp thêm các điều khiển khác. Ví dụ, hầu hết hệ điều hành cho phép tạm dừng (suspend) một process và sau đó khôi phục (resume) nó để tiếp tục chạy.</li>
<li><strong>Status (Trạng thái):</strong> Thường có các interface để lấy thông tin trạng thái của process, chẳng hạn như process đã chạy bao lâu hoặc hiện tại đang ở trạng thái nào.</li>
</ul>
<p><img src="04/./img/fig4_1.PNG" alt="" /></p>
<p><strong>Hình 4.1: Quá trình load – Từ Chương trình thành Process</strong></p>
<h2 id="43-tạo-process-chi-tiết-hơn-một-chút"><a class="header" href="#43-tạo-process-chi-tiết-hơn-một-chút">4.3 Tạo Process: Chi tiết hơn một chút</a></h2>
<p>Một điều bí ẩn mà ta cần làm rõ là: làm thế nào chương trình (program) được biến thành process? Cụ thể hơn, hệ điều hành làm thế nào để khởi chạy một chương trình? Quá trình tạo process thực sự diễn ra như thế nào?</p>
<p>Bước đầu tiên mà hệ điều hành phải thực hiện là <strong>load mã lệnh (code)</strong> và static data (ví dụ: các biến đã khởi tạo) của chương trình vào bộ nhớ, trong <em>không gian địa chỉ</em> (address space) của process. Ban đầu, chương trình nằm trên đĩa (hoặc, trong nhiều hệ thống hiện đại, ổ SSD dạng flash) dưới một định dạng excecute. Do đó, việc load chương trình và static data vào bộ nhớ đòi hỏi hệ điều hành phải đọc các byte từ đĩa và đặt chúng vào một vị trí nào đó trong bộ nhớ (như minh họa trong Hình 4.1).</p>
<p>Trong các hệ điều hành đơn giản (hoặc đời đầu), quá trình load thường được thực hiện <strong>eagerly</strong> (tức là load toàn bộ trước khi chạy). Ngược lại, các hệ điều hành hiện đại áp dụng cách <strong>lazy loading</strong> (load từng phần mã hoặc dữ liệu chỉ khi cần trong quá trình excecute). Để hiểu rõ lazy loading hoạt động thế nào, chúng ta cần nắm vững các cơ chế như <em>paging</em> (trang bộ nhớ) và <em>swapping</em> (hoán đổi), sẽ được bàn kỹ hơn trong phần ảo hóa bộ nhớ. Tạm thời, bạn chỉ cần nhớ rằng trước khi chạy bất cứ thứ gì, hệ điều hành phải làm công việc chuẩn bị: đưa các phần quan trọng của chương trình từ đĩa vào bộ nhớ.</p>
<p>Khi mã lệnh và static data đã được load vào bộ nhớ, hệ điều hành còn phải làm thêm một số việc trước khi process có thể chạy:</p>
<ul>
<li><strong>Cấp phát bộ nhớ cho ngăn xếp (stack):</strong> Các chương trình C sử dụng stack để lưu biến cục bộ, tham số hàm và địa chỉ trả về. Hệ điều hành sẽ cấp phát vùng nhớ này và gán nó cho process. Ngoài ra, nó còn khởi tạo stack với tham số đầu vào, cụ thể là các giá trị truyền cho hàm <code>main()</code>, tức là <code>argc</code> và mảng <code>argv</code>.</li>
<li><strong>Cấp phát bộ nhớ cho heap:</strong> Trong C, heap được dùng để lưu trữ dữ liệu được cấp phát động (dynamic memory). Chương trình yêu cầu vùng nhớ này thông qua call <code>malloc()</code>, và giải phóng nó bằng <code>free()</code>. Heap thường nhỏ ban đầu, nhưng có thể mở rộng khi chương trình chạy và yêu cầu thêm bộ nhớ; lúc đó hệ điều hành có thể cấp thêm. Heap thường dùng cho các cấu trúc dữ liệu phức tạp như danh sách liên kết, bảng băm, cây, v.v.</li>
<li><strong>Khởi tạo I/O:</strong> Ví dụ, trong các hệ thống UNIX, mỗi process mặc định có 3 <em>file descriptor</em> (bộ mô tả tệp) mở sẵn: chuẩn nhập (stdin), chuẩn xuất (stdout), và chuẩn lỗi (stderr). Nhờ đó, chương trình có thể dễ dàng đọc dữ liệu từ terminal và in kết quả ra màn hình.</li>
</ul>
<p>Sau khi load mã lệnh và static data, tạo stack, chuẩn bị heap, và thiết lập I/O, hệ điều hành đã sẵn sàng để process bắt đầu excecute. Bước cuối cùng là chuyển quyền điều khiển CPU sang chương trình tại điểm vào (entry point), thường là hàm <code>main()</code>. Bằng cách “nhảy” đến <code>main()</code> (thông qua một cơ chế đặc biệt sẽ được bàn trong chương tiếp theo), hệ điều hành đã chính thức khởi động process.</p>
<h2 id="44-các-trạng-thái-của-process"><a class="header" href="#44-các-trạng-thái-của-process">4.4 Các Trạng Thái của Process</a></h2>
<p>Giờ đây, khi đã nắm được process là gì và sơ bộ cách nó được tạo ra, chúng ta sẽ bàn về các trạng thái mà một process có thể ở tại một thời điểm. Khái niệm process có thể tồn tại trong nhiều trạng thái khác nhau bắt nguồn từ các hệ thống máy tính đời đầu [DV66, V+65].</p>
<p>Trong một mô hình đơn giản, process có thể ở một trong ba trạng thái:</p>
<ul>
<li><strong>Running (Đang chạy):</strong> Process đang thực sự chạy trên CPU, nghĩa là nó đang excecute các chỉ thị.</li>
<li><strong>Ready (Sẵn sàng):</strong> Process đã sẵn sàng chạy, nhưng vì lý do nào đó hệ điều hành chưa cho nó chiếm CPU ở thời điểm hiện tại.</li>
<li><strong>Blocked (Bị chặn):</strong> Process đang chờ một sự kiện khác để có thể tiếp tục chạy. Ví dụ: khi process gửi yêu cầu I/O đến đĩa, nó sẽ bị chặn cho đến khi thao tác đó hoàn tất, trong khi đó CPU có thể phục vụ process khác.</li>
</ul>
<p><img src="04/./img/fig4_2.PNG" alt="" /></p>
<p><strong>Hình 4.2: Các trạng thái của Process và sự chuyển đổi</strong></p>
<p>Trong sơ đồ trạng thái (Hình 4.2), bạn có thể thấy process được chuyển qua lại giữa trạng thái <em>ready</em> và <em>running</em> dưới sự điều phối của hệ điều hành.</p>
<ul>
<li>Từ <em>ready → running</em>: process được <strong>schedule</strong> (lập lịch để chạy).</li>
<li>Từ <em>running → ready</em>: process bị <strong>deschedule</strong> (dừng chạy).</li>
<li>Khi process chuyển sang <em>blocked</em>, hệ điều hành sẽ giữ nó trong trạng thái này cho đến khi sự kiện cần thiết xảy ra (ví dụ: I/O hoàn tất), sau đó chuyển nó về trạng thái <em>ready</em> (và có thể lập lịch chạy ngay).</li>
</ul>
<p>Ví dụ: giả sử có hai process chạy, cả hai chỉ dùng CPU (không I/O). Dấu vết trạng thái (trace) của chúng sẽ giống như Hình 4.3.</p>
<p><img src="04/./img/fig4_3.PNG" alt="" /></p>
<p><strong>Hình 4.3: Dấu vết trạng thái process – chỉ dùng CPU</strong></p>
<p>Trong ví dụ tiếp theo, một process thực hiện I/O sau một thời gian chạy. Khi đó nó chuyển sang trạng thái <em>blocked</em>, nhường CPU cho process còn lại. Dấu vết tình huống này được thể hiện ở Hình 4.4.</p>
<p><img src="04/./img/fig4_4.PNG" alt="" /></p>
<p><strong>Hình 4.4: Dấu vết trạng thái process – CPU và I/O</strong></p>
<p>Cụ thể, Process0 thực hiện một yêu cầu I/O và bị chặn để chờ kết quả; điều này thường xảy ra khi đọc từ đĩa hoặc chờ gói tin mạng. Hệ điều hành nhận thấy Process0 không dùng CPU, nên lập lịch chạy Process1. Trong khi Process1 chạy, I/O hoàn tất, Process0 chuyển về trạng thái <em>ready</em>. Khi Process1 kết thúc, Process0 được chạy tiếp cho đến khi hoàn thành.</p>
<p><strong>Lưu ý</strong>: ngay cả trong ví dụ đơn giản này, hệ điều hành vẫn phải đưa ra nhiều quyết định. Thứ nhất, hệ thống chọn chạy Process1 trong khi Process0 bị chặn I/O – điều này giúp tận dụng CPU tốt hơn. Thứ hai, khi I/O của Process0 hoàn tất, hệ điều hành <strong>không lập tức chuyển lại cho Process0</strong> mà để Process1 tiếp tục. Đây có phải là quyết định đúng hay không? Những quyết định như vậy được đưa ra bởi <strong>OS scheduler (bộ lập lịch của hệ điều hành)</strong> – chủ đề chúng ta sẽ bàn kỹ hơn trong các chương tới.</p>
<h2 id="45-cấu-trúc-dữ-liệu"><a class="header" href="#45-cấu-trúc-dữ-liệu">4.5 Cấu Trúc Dữ Liệu</a></h2>
<p>Hệ điều hành cũng chỉ là một chương trình, và giống như mọi chương trình khác, nó sử dụng các <strong>cấu trúc dữ liệu</strong> để quản lý thông tin.</p>
<p>Ví dụ: để theo dõi trạng thái của các process, hệ điều hành thường duy trì một <strong>danh sách process</strong> (process list) chứa tất cả process đang ở trạng thái <em>ready</em>, kèm thêm thông tin về process hiện tại đang chạy. Hệ điều hành cũng cần quản lý danh sách các process <em>blocked</em>; khi một sự kiện I/O hoàn tất, OS phải đánh thức đúng process liên quan và chuyển nó sang trạng thái <em>ready</em>.</p>
<p>Hình 4.5 thể hiện Thông tin OS theo dõi cho mỗi process trong nhân xv6 [CK+08]. Trong các hệ điều hành thực tế như Linux, Mac OS X, hay Windows, cấu trúc quản lý process còn phức tạp hơn nhiều. Bạn có thể tự tìm hiểu để so sánh mức độ chi tiết.</p>
<p>Trong hình, ta thấy một số thông tin quan trọng mà hệ điều hành lưu cho mỗi process. <strong>Register context (Ngữ cảnh thanh ghi):</strong> Đối với process bị dừng, hệ điều hành lưu lại toàn bộ giá trị các thanh ghi vào vùng nhớ này. Khi cần chạy lại process, OS chỉ việc khôi phục các giá trị vào thanh ghi vật lý để tiếp tục excecute. Kỹ thuật này gọi là <strong>context switch (chuyển ngữ cảnh)</strong> – sẽ được bàn kỹ trong các chương tiếp theo.</p>
<pre><code class="language-c">// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
  int eip;
  int esp;
  int ebx;
  int ecx;
  int edx;
  int esi;
  int edi;
  int ebp;
};
// the different states a process can be in
enum proc_state {
  UNUSED,
  EMBRYO,
  SLEEPING,
  RUNNABLE,
  RUNNING,
  ZOMBIE
};
// the information xv6 tracks about each process
// including its register context and state
struct proc {
  char * mem;
  // Start of process memory
  uint sz;
  // Size of process memory
  char * kstack;
  // Bottom of kernel stack
  // for this process
  enum proc_state state; // Process state
  int pid;
  // Process ID
  struct proc * parent;
  // Parent process
  void * chan;
  // If !zero, sleeping on chan
  int killed;
  // If !zero, has been killed
  struct file * ofile[NOFILE]; // Open files
  struct inode * cwd;
  // Current directory
  struct context context; // Switch here to run process
  struct trapframe * tf;
  // Trap frame for the
  // current interrupt
};
</code></pre>
<p>Bạn cũng có thể thấy từ hình minh họa rằng một process (process) có thể ở một số trạng thái khác ngoài đang chạy (running), sẵn sàng (ready), và bị chặn (blocked). Đôi khi một hệ thống sẽ có một trạng thái ban đầu (initial state) mà process ở trong đó khi nó đang được tạo ra. Ngoài ra, một process có thể được đặt vào một trạng thái cuối (final state), nơi nó đã thoát ra nhưng chưa được dọn dẹp (trong các hệ thống dựa trên UNIX, trạng thái này được gọi là <strong>trạng thái zombie</strong> (thây ma)¹).</p>
<p><em>(Giải thích: Trạng thái này được gọi là &quot;zombie&quot; vì process đã &quot;chết&quot; - tức là đã kết thúc excecute - nhưng thông tin về nó vẫn còn tồn tại trong bảng process, chưa được &quot;chôn cất&quot; hay dọn dẹp hoàn toàn.)</em></p>
<p>Trạng thái cuối này có thể hữu ích vì nó cho phép các process khác (thường là process cha đã tạo ra process này) kiểm tra mã trả về (return code) của process và xem liệu process vừa hoàn thành có excecute thành công hay không (thường thì các chương trình trong hệ thống dựa trên UNIX trả về giá trị 0 khi chúng đã hoàn thành tác vụ thành công, và khác 0 trong trường hợp ngược lại). Khi xong việc, process cha sẽ thực hiện một call cuối cùng (ví dụ, <code>wait()</code>) để chờ đợi sự hoàn thành của process con, và cũng để báo cho OS rằng nó có thể dọn dẹp bất kỳ cấu trúc dữ liệu nào liên quan đến process đã không còn tồn tại này.</p>
<blockquote>
<p><strong>TẢN MẠN: CẤU TRÚC DỮ LIỆU — DANH SÁCH TIẾN TRÌNH</strong></p>
<p>Các hệ điều hành chứa đầy đủ các cấu trúc dữ liệu quan trọng khác nhau mà chúng ta sẽ thảo luận trong tài liệu này. <strong>Danh sách process</strong> (Process List), còn được gọi là danh sách tác vụ (task list), là cấu trúc đầu tiên như vậy. Nó là một trong những cấu trúc đơn giản hơn, nhưng chắc chắn bất kỳ hệ điều hành nào có khả năng chạy nhiều chương trình cùng một lúc sẽ có một thứ gì đó tương tự như cấu trúc này để theo dõi tất cả các chương trình đang chạy trong hệ thống. Đôi khi người ta gọi cấu trúc riêng lẻ lưu trữ thông tin về một process là <strong>Khối Quản lý Process</strong> (Process Control Block - PCB), một cách nói hoa mỹ để chỉ một cấu trúc trong ngôn ngữ C chứa thông tin về mỗi process (đôi khi còn được gọi là bộ mô tả process - process descriptor).</p>
</blockquote>
<h2 id="46-tóm-tắt"><a class="header" href="#46-tóm-tắt">4.6 Tóm tắt</a></h2>
<p>Chúng ta đã giới thiệu khái niệm trừu tượng hóa cơ bản nhất của OS: process. Nó được xem một cách khá đơn giản là một chương trình đang chạy. Với quan điểm khái niệm này, bây giờ chúng ta sẽ chuyển sang các chi tiết cốt lõi: các cơ chế cấp thấp cần thiết để triển khai process, và các policy cấp cao cần thiết để lập lịch (schedule) cho chúng một cách thông minh. Bằng cách kết hợp các cơ chế và policy, chúng ta sẽ xây dựng sự hiểu biết của mình về cách một hệ điều hành ảo hóa CPU.</p>
<blockquote>
<p><strong>TẢN MẠN: CÁC THUẬT NGỮ CHÍNH VỀ TIẾN TRÌNH</strong></p>
<ul>
<li><strong>Tiến trình (process)</strong> là khái niệm trừu tượng hóa chính của hệ điều hành về một chương trình đang chạy. Tại bất kỳ thời điểm nào, process có thể được mô tả bởi trạng thái của nó: nội dung bộ nhớ trong không gian địa chỉ (address space) của nó, nội dung của các thanh ghi CPU (bao gồm bộ đếm chương trình - program counter và con trỏ ngăn xếp - stack pointer, cùng nhiều thanh ghi khác), và thông tin về I/O (chẳng hạn như các tập tin đang mở có thể được đọc hoặc ghi).</li>
<li><strong>API process</strong> bao gồm các call mà chương trình có thể thực hiện liên quan đến process. Thông thường, điều này bao gồm việc tạo (creation), hủy (destruction), và các call hữu ích khác.</li>
<li>Các process tồn tại ở một trong nhiều <strong>trạng thái process</strong> khác nhau, bao gồm <strong>đang chạy (running)</strong>, <strong>sẵn sàng chạy (ready to run)</strong>, và <strong>bị chặn (blocked)</strong>. Các sự kiện khác nhau (ví dụ: được lập lịch để chạy hoặc bị rút khỏi CPU, hoặc chờ một thao tác I/O hoàn tất) sẽ chuyển một process từ trạng thái này sang trạng thái khác.</li>
<li>Một <strong>danh sách process (process list)</strong> chứa thông tin về tất cả các process trong hệ thống. Mỗi mục nhập được tìm thấy trong một cấu trúc đôi khi được gọi là <strong>khối quản lý process (process control block - PCB)</strong>, thực chất chỉ là một cấu trúc chứa thông tin về một process cụ thể.</li>
</ul>
</blockquote>
<h2 id="tham-khảo-1"><a class="header" href="#tham-khảo-1">Tham khảo</a></h2>
<p>[BH70] “The Nucleus of a Multiprogramming System”<br />
Per Brinch Hansen<br />
Communications of the ACM, Volume 13, Number 4, April 1970<br />
This paper introduces one of the first microkernels in operating systems history, called Nucleus. The idea of smaller, more minimal systems is a theme that rears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.</p>
<p>[CK+08] “The xv6 Operating System”<br />
Russ Cox, Frans Kaashoek, Robert Morris, Nickolai Zeldovich<br />
From: https://github.com/mit-pdos/xv6-public<br />
The coolest real and little OS in the world. Download and play with it to learn more about the details of how operating systems actually work. We have been using an older version (2012-01-30-1-g1c41342) and hence some examples in the book may not match the latest in the source.</p>
<p>[DV66] “Programming Semantics for Multiprogrammed Computations”<br />
Jack B. Dennis and Earl C. Van Horn<br />
Communications of the ACM, Volume 9, Number 3, March 1966<br />
This paper defined many of the early terms and concepts around building multiprogrammed systems.</p>
<p>[L+75] “Policy/mechanism separation in Hydra”<br />
R. Levin, E. Cohen, W. Corwin, F. Pollack, W. Wulf<br />
SOSP 1975<br />
An early paper about how to structure operating systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of its ideas influenced OS designers.</p>
<p>[V+65] “Structure of the Multics Supervisor”<br />
V.A. Vyssotsky, F. J. Corbato, R. M. Graham<br />
Fall Joint Computer Conference, 1965<br />
An early paper on Multics, which described many of the basic ideas and terms that we find in modern systems. Some of the vision behind computing as a utility are finally being realized in modern cloud systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-phần-xen-kẽ-process-api"><a class="header" href="#5-phần-xen-kẽ-process-api">5. Phần xen kẽ: Process API</a></h1>
<p><strong>GHI CHÚ: VỀ CÁC PHẦN XEN KẼ</strong><br />
Các phần xen kẽ (interlude) sẽ đề cập đến những khía cạnh thực tiễn hơn của hệ thống, đặc biệt tập trung vào các API (Application Programming Interface – interface lập trình ứng dụng) của hệ điều hành và cách sử dụng chúng. Nếu bạn không thích các vấn đề mang tính thực hành, bạn có thể bỏ qua các phần này. Tuy nhiên, bạn <strong>nên</strong> quan tâm đến chúng, vì chúng thường rất hữu ích trong thực tế; ví dụ, các công ty thường không tuyển dụng bạn chỉ vì những kỹ năng “phi thực tế”.</p>
<p>Trong phần xen kẽ này, chúng ta sẽ thảo luận về việc tạo process (process) trong các hệ thống UNIX. UNIX cung cấp một trong những cách thú vị nhất để tạo process mới thông qua một cặp system call (call hệ thống): <code>fork()</code> và <code>exec()</code>. Một thủ tục thứ ba, <code>wait()</code>, có thể được một process sử dụng khi muốn chờ process mà nó đã tạo hoàn thành. Chúng ta sẽ trình bày chi tiết các interface này, kèm theo một số ví dụ đơn giản để minh họa. Và đây là vấn đề đặt ra:</p>
<blockquote>
<p><strong>Cốt lõi: Làm thế nào để tạo và điều khiển process</strong><br />
Hệ điều hành nên cung cấp những interface nào để tạo và điều khiển process? Các interface này nên được thiết kế ra sao để vừa mạnh mẽ, dễ sử dụng, vừa đạt hiệu năng cao?</p>
</blockquote>
<h2 id="51-lời-gọi-hệ-thống-fork"><a class="header" href="#51-lời-gọi-hệ-thống-fork">5.1 Lời gọi hệ thống fork()</a></h2>
<p>Lời gọi hệ thống <code>fork()</code> được sử dụng để tạo một process mới [C63]. Tuy nhiên, hãy lưu ý: đây chắc chắn là một trong những thủ tục kỳ lạ nhất mà bạn từng gọi<sup class="footnote-reference"><a href="#1">1</a></sup>. Cụ thể hơn, giả sử bạn có một chương trình đang chạy với đoạn code như trong Hình 5.1; hãy xem xét đoạn code đó, hoặc tốt hơn, hãy gõ và chạy nó để tự mình trải nghiệm.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Thực ra, chúng tôi không thể khẳng định chắc chắn điều này; ai biết được bạn gọi những thủ tục gì khi không ai để ý? Nhưng <code>fork()</code> thực sự rất khác thường, bất kể thói quen gọi hàm của bạn ra sao.</p>
</div>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char * argv[]) {
  printf(&quot;hello (pid:%d)\n&quot;, (int) getpid());
  int rc = fork();
  if (rc &lt; 0) {
    // fork failed
    fprintf(stderr, &quot;fork failed\n&quot;);
    exit(1);
  } else if (rc == 0) {
    // child (new process)
    printf(&quot;child (pid:%d)\n&quot;, (int) getpid());
  } else {
    // parent goes down this path (main)
    printf(&quot;parent of %d (pid:%d)\n&quot;,
      rc, (int) getpid());
  }
  return 0;
}

</code></pre>
<p>Figure 5.1: Calling fork() (p1.c)</p>
<p>Khi bạn chạy chương trình này (gọi là <code>p1.c</code>), bạn sẽ thấy kết quả như sau:</p>
<pre><code>prompt&gt; ./p1
hello (pid:29146)
parent of 29147 (pid:29146)
child (pid:29147)
prompt&gt;
</code></pre>
<p>Hãy phân tích chi tiết hơn điều gì đã xảy ra trong <code>p1.c</code>. Khi bắt đầu chạy, process in ra một thông điệp “hello”; kèm theo đó là <strong>process identifier</strong> (PID – định danh process). Trong ví dụ, process có PID là 29146; trong hệ thống UNIX, PID được dùng để định danh process khi muốn thực hiện một thao tác nào đó với nó, chẳng hạn như dừng process. Đến đây thì mọi thứ vẫn bình thường.</p>
<p>Phần thú vị bắt đầu khi process gọi call hệ thống <code>fork()</code>, mà OS cung cấp như một cách để tạo process mới. Điều kỳ lạ là: process được tạo ra gần như là <strong>bản sao</strong> của process gọi <code>fork()</code>. Điều này có nghĩa là, từ góc nhìn của OS, giờ đây có hai bản sao của chương trình <code>p1</code> đang chạy, và cả hai đều sắp <strong>trả về</strong> từ call <code>fork()</code>. Process mới được tạo (gọi là <strong>child process</strong> – process con, đối lập với <strong>parent process</strong> – process cha) <strong>không</strong> bắt đầu chạy từ <code>main()</code> như bạn có thể nghĩ (lưu ý, thông điệp “hello” chỉ được in ra một lần); thay vào đó, nó xuất hiện như thể chính nó vừa gọi <code>fork()</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;


int main(int argc, char * argv[]) {
  printf(&quot;hello (pid:%d)\n&quot;, (int) getpid());
  int rc = fork();
  if (rc &lt; 0) {
    // fork failed; exit
    fprintf(stderr, &quot;fork failed\n&quot;);
    exit(1);
  } else if (rc == 0) { // child (new process)
    printf(&quot;child (pid:%d)\n&quot;, (int) getpid());
  } else {
    // parent goes down this path
    int rc_wait = wait(NULL);
    printf(&quot;parent of %d (rc_wait:%d) (pid:%d)\n&quot;,
      rc, rc_wait, (int) getpid());
  }
  return 0;
}

</code></pre>
<p>Figure 5.2: Calling fork() And wait() (p2.c)</p>
<p>Bạn có thể nhận thấy: process con <strong>không</strong> phải là bản sao hoàn toàn. Cụ thể, mặc dù nó có bản sao riêng của <strong>address space</strong> (không gian địa chỉ – tức vùng bộ nhớ riêng), các thanh ghi (registers) riêng, bộ đếm chương trình (PC – Program Counter) riêng, v.v., nhưng giá trị trả về từ <code>fork()</code> lại khác nhau. Cụ thể, process cha nhận về PID của process con mới tạo, còn process con nhận giá trị trả về là 0. Sự khác biệt này rất hữu ích, vì nó giúp lập trình viên dễ dàng viết mã xử lý cho hai trường hợp khác nhau.</p>
<p>Bạn cũng có thể nhận thấy: kết quả in ra từ <code>p1.c</code> <strong>không</strong> mang tính xác định (non-deterministic). Khi process con được tạo, lúc này có hai process đang hoạt động: cha và con. Giả sử hệ thống chỉ có một CPU (để đơn giản), thì tại thời điểm đó, hoặc process cha, hoặc process con có thể được chạy trước. Trong ví dụ trên, process cha chạy trước và in thông điệp của nó trước. Trong các trường hợp khác, điều ngược lại có thể xảy ra, như trong kết quả sau:</p>
<pre><code>prompt&gt; ./p1
hello (pid:29146)
child (pid:29147)
parent of 29147 (pid:29146)
prompt&gt;
</code></pre>
<p><strong>CPU scheduler</strong> (bộ lập lịch CPU – thành phần quyết định process nào chạy tại một thời điểm) sẽ quyết định process nào được chạy. Vì bộ lập lịch khá phức tạp, chúng ta thường không thể dự đoán chắc chắn nó sẽ chọn process nào, và do đó không thể biết process nào sẽ chạy trước. Tính <strong>bất định</strong> (nondeterminism) này sẽ dẫn đến nhiều vấn đề thú vị, đặc biệt trong các chương trình đa luồng (multi-threaded). Chúng ta sẽ gặp lại khái niệm này nhiều hơn khi nghiên cứu <strong>lập trình đồng thời</strong> (concurrency) ở phần sau của sách.</p>
<h2 id="52-lời-gọi-hệ-thống-wait"><a class="header" href="#52-lời-gọi-hệ-thống-wait">5.2 Lời gọi hệ thống wait()</a></h2>
<p>Cho đến giờ, chúng ta mới chỉ tạo một process con in ra thông điệp rồi thoát. Trong nhiều trường hợp, process cha cần <strong>chờ</strong> process con hoàn thành công việc. Nhiệm vụ này được thực hiện bằng call hệ thống <code>wait()</code> (hoặc phiên bản đầy đủ hơn là <code>waitpid()</code>); xem Hình 5.2 để biết chi tiết.</p>
<p>Trong ví dụ (<code>p2.c</code>), process cha gọi <code>wait()</code> để tạm dừng excecute cho đến khi process con kết thúc. Khi process con hoàn tất, <code>wait()</code> trả quyền điều khiển lại cho process cha.</p>
<p>Việc thêm call <code>wait()</code> vào đoạn code trên khiến kết quả trở nên <strong>xác định</strong> (deterministic). Bạn có biết tại sao không? Hãy thử suy nghĩ một chút.<br />
(… chờ bạn suy nghĩ … xong)<br />
Và đây là kết quả:</p>
<pre><code>prompt&gt; ./p2
hello (pid:29266)
child (pid:29267)
parent of 29267 (rc_wait:29267) (pid:29266)
prompt&gt;
</code></pre>
<p>Với đoạn code này, chúng ta <strong>luôn</strong> biết rằng process con sẽ in ra trước. Tại sao? Bởi vì:</p>
<ul>
<li>Nếu process con chạy trước, nó sẽ in thông điệp trước process cha.</li>
<li>Nếu process cha chạy trước, nó sẽ lập tức gọi <code>wait()</code>; call này sẽ <strong>không trả về</strong> cho đến khi process con chạy và thoát<sup class="footnote-reference"><a href="#2">2</a></sup>. Do đó, ngay cả khi cha chạy trước, nó vẫn “lịch sự” chờ con hoàn thành, rồi mới in thông điệp của mình.</li>
</ul>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Có một số trường hợp <code>wait()</code> trả về trước khi process con thoát; hãy đọc trang hướng dẫn <code>man</code> để biết thêm chi tiết. Và hãy cảnh giác với những phát biểu tuyệt đối như “process con luôn in trước” hoặc “UNIX là thứ tuyệt vời nhất trên đời, còn hơn cả kem”.</p>
</div>
<h2 id="53-cuối-cùng-call-hệ-thống-exec"><a class="header" href="#53-cuối-cùng-call-hệ-thống-exec">5.3 Cuối cùng, call hệ thống exec()</a></h2>
<p>Một thành phần cuối cùng và quan trọng của <strong>process creation API</strong> (API tạo process) là call hệ thống <code>exec()</code><sup class="footnote-reference"><a href="#3">3</a></sup>. Lời gọi này hữu ích khi bạn muốn chạy một chương trình <strong>khác</strong> với chương trình đang gọi nó. Ví dụ, gọi <code>fork()</code>…</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Trên Linux, có sáu biến thể của <code>exec()</code>: <code>execl()</code>, <code>execlp()</code>, <code>execle()</code>, <code>execv()</code>, <code>execvp()</code>, và <code>execvpe()</code>. Hãy đọc trang hướng dẫn <code>man</code> để tìm hiểu thêm.</p>
</div>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/wait.h&gt;

int main(int argc, char * argv[]) {
  printf(&quot;hello (pid:%d)\n&quot;, (int) getpid());
  int rc = fork();
  if (rc &lt; 0) {
    // fork failed; exit
    fprintf(stderr, &quot;fork failed\n&quot;);
    exit(1);
  } else if (rc == 0) { // child (new process)
    printf(&quot;child (pid:%d)\n&quot;, (int) getpid());
    char * myargs[3];
    myargs[0] = strdup(&quot;wc&quot;);
    // program: &quot;wc&quot;
    myargs[1] = strdup(&quot;p3.c&quot;); // arg: input file
    myargs[2] = NULL;
    // mark end of array
    execvp(myargs[0], myargs); // runs word count
    printf(&quot;this shouldn’t print out&quot;);
  } else {
    // parent goes down this path
    int rc_wait = wait(NULL);
    printf(&quot;parent of %d (rc_wait:%d) (pid:%d)\n&quot;,
      rc, rc_wait, (int) getpid());
  }
  return 0;
}
</code></pre>
<p><strong>Hình 5.3: Gọi fork(), wait() và exec() (p3.c)</strong></p>
<p>Trong <code>p2.c</code>, việc sử dụng chỉ hữu ích nếu bạn muốn tiếp tục chạy các bản sao của <strong>cùng một chương trình</strong>. Tuy nhiên, trong nhiều trường hợp, bạn muốn chạy <strong>một chương trình khác</strong>; <code>exec()</code> chính là công cụ để làm điều đó (Hình 5.3).</p>
<p>Trong ví dụ này, <strong>process con</strong> (child process) gọi <code>execvp()</code> để chạy chương trình <code>wc</code> – đây là chương trình đếm từ (word counting program). Cụ thể, nó chạy <code>wc</code> trên tệp mã nguồn <code>p3.c</code>, cho chúng ta biết số dòng, số từ và số byte trong tệp:</p>
<pre><code>prompt&gt; ./p3
hello (pid:29383)
child (pid:29384)
29
107
1030 p3.c
parent of 29384 (rc_wait:29384) (pid:29383)
prompt&gt;
</code></pre>
<p>Lời gọi hệ thống (system call) <code>fork()</code> vốn đã kỳ lạ; “đồng phạm” của nó, <code>exec()</code>, cũng không hề bình thường. Cách hoạt động của <code>exec()</code> như sau: khi được cung cấp tên của một <strong>tệp excecute</strong> (executable) – ví dụ <code>wc</code> – và một số đối số (arguments) – ví dụ <code>p3.c</code> – nó sẽ nạp (load) mã lệnh (code) và static data (static data) từ tệp excecute đó, <strong>ghi đè</strong> lên phân đoạn code (code segment) và static data hiện tại của process; vùng heap, stack và các phần khác của không gian bộ nhớ (memory space) của chương trình sẽ được khởi tạo lại. Sau đó, hệ điều hành chỉ đơn giản chạy chương trình mới này, truyền các đối số vào dưới dạng <code>argv</code> của process.</p>
<p>Điểm quan trọng: <code>exec()</code> <strong>không tạo ra process mới</strong>; thay vào đó, nó <strong>biến đổi</strong> process hiện tại (trước đó là <code>p3</code>) thành một chương trình khác đang chạy (<code>wc</code>). Sau khi <code>exec()</code> được gọi trong process con, gần như <code>p3.c</code> chưa từng chạy; một call <code>exec()</code> thành công sẽ <strong>không bao giờ trả về</strong>.</p>
<blockquote>
<p><strong>Mẹo: Làm đúng ngay từ đầu (Lampson’s Law)</strong><br />
Như Lampson đã nói trong bài viết nổi tiếng <em>Hints for Computer Systems Design</em> [L83]:<br />
“Hãy làm đúng. Cả tính trừu tượng lẫn sự đơn giản đều không thể thay thế cho việc làm đúng.”<br />
Đôi khi, bạn chỉ cần làm đúng, và khi làm đúng, kết quả sẽ vượt xa mọi lựa chọn thay thế. Có rất nhiều cách để thiết kế API cho việc tạo process; tuy nhiên, sự kết hợp giữa <code>fork()</code> và <code>exec()</code> vừa đơn giản vừa cực kỳ mạnh mẽ. Ở đây, các nhà thiết kế UNIX đã “làm đúng”. Và vì Lampson thường xuyên “làm đúng”, nên nguyên tắc này được đặt tên để vinh danh ông.</p>
</blockquote>
<h2 id="54-tại-sao-Động-cơ-thiết-kế-api"><a class="header" href="#54-tại-sao-Động-cơ-thiết-kế-api">5.4 Tại sao? Động cơ thiết kế API</a></h2>
<p>Một câu hỏi lớn có thể xuất hiện: <strong>Tại sao</strong> chúng ta lại xây dựng một interface kỳ lạ như vậy cho một hành động tưởng chừng đơn giản là tạo process mới?</p>
<p>Câu trả lời: việc tách biệt <code>fork()</code> và <code>exec()</code> là <strong>thiết yếu</strong> trong việc xây dựng một <strong>UNIX shell</strong>, vì nó cho phép shell chạy một đoạn code <strong>sau</strong> khi gọi <code>fork()</code> nhưng <strong>trước</strong> khi gọi <code>exec()</code>. Đoạn code này có thể thay đổi môi trường (environment) của chương trình sắp chạy, từ đó cho phép xây dựng nhiều tính năng thú vị một cách dễ dàng.</p>
<p><strong>Shell</strong> thực chất chỉ là một chương trình người dùng (user program)<sup class="footnote-reference"><a href="#4">4</a></sup>. Nó hiển thị một dấu nhắc lệnh (prompt) và chờ bạn nhập vào. Bạn gõ một lệnh (tức tên của một chương trình excecute kèm các đối số) vào; trong hầu hết các trường hợp, shell sẽ:</p>
<ol>
<li>Xác định vị trí của tệp excecute trong hệ thống tệp (file system).</li>
<li>Gọi <code>fork()</code> để tạo một process con chạy lệnh đó.</li>
<li>Gọi một biến thể của <code>exec()</code> để excecute lệnh.</li>
<li>Gọi <code>wait()</code> để chờ lệnh hoàn tất.</li>
</ol>
<p>Khi process con kết thúc, shell thoát khỏi <code>wait()</code> và in ra dấu nhắc lệnh mới, sẵn sàng cho lệnh tiếp theo.</p>
<p>Việc tách <code>fork()</code> và <code>exec()</code> cho phép shell thực hiện nhiều việc hữu ích một cách đơn giản. Ví dụ:</p>
<pre><code>prompt&gt; wc p3.c &gt; newfile.txt
</code></pre>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Có rất nhiều loại shell: <code>tcsh</code>, <code>bash</code>, <code>zsh</code>… Bạn nên chọn một loại, đọc trang hướng dẫn (<code>man page</code>) và tìm hiểu thêm; tất cả chuyên gia UNIX đều làm vậy.</p>
</div>
<p>Trong ví dụ trên, đầu ra của chương trình <code>wc</code> được <strong>chuyển hướng</strong> (redirect) vào tệp <code>newfile.txt</code> (dấu <code>&gt;</code> thể hiện việc chuyển hướng). Cách shell thực hiện rất đơn giản: khi process con được tạo, <strong>trước</strong> khi gọi <code>exec()</code>, shell (cụ thể là đoạn code chạy trong process con) đóng luồng xuất chuẩn (standard output) và mở tệp <code>newfile.txt</code>.</p>
<p>Bằng cách này, mọi dữ liệu xuất ra từ chương trình <code>wc</code> sắp chạy sẽ được ghi vào tệp thay vì hiển thị trên màn hình. (Các <strong>file descriptor</strong> đang mở sẽ vẫn được giữ nguyên qua call <code>exec()</code>, cho phép hành vi này [SR05]).</p>
<p>Hình 5.4 (trang 8) minh họa một chương trình thực hiện chính xác điều này. Nguyên nhân việc chuyển hướng hoạt động được là nhờ giả định về cách hệ điều hành quản lý file descriptor: trong UNIX, hệ thống bắt đầu tìm file descriptor trống từ số 0. Trong trường hợp này, <code>STDOUT_FILENO</code> sẽ là file descriptor trống đầu tiên và được gán khi <code>open()</code> được gọi. Các lệnh ghi (write) tiếp theo của process con tới file descriptor xuất chuẩn – ví dụ qua <code>printf()</code> – sẽ được ghi vào tệp mới mở thay vì màn hình.</p>
<p>Kết quả chạy chương trình <code>p4.c</code> như sau:</p>
<pre><code>prompt&gt; ./p4
prompt&gt; cat p4.output
32
109
846 p4.c
prompt&gt;
</code></pre>
<p>Có ít nhất <strong>hai điểm thú vị</strong> trong kết quả này:</p>
<ol>
<li>Khi chạy <code>p4</code>, có vẻ như không có gì xảy ra; shell chỉ in dấu nhắc lệnh và sẵn sàng cho lệnh tiếp theo. Nhưng thực tế, <code>p4</code> đã gọi <code>fork()</code> để tạo process con, sau đó chạy chương trình <code>wc</code> qua <code>execvp()</code>. Bạn không thấy kết quả trên màn hình vì nó đã được chuyển hướng vào tệp <code>p4.output</code>.</li>
<li>Khi dùng <code>cat</code> để xem nội dung tệp <code>p4.output</code>, toàn bộ kết quả mong đợi từ <code>wc</code> đều có ở đó.</li>
</ol>
<p><strong>UNIX pipes</strong> (đường ống) được triển khai tương tự, nhưng sử dụng call hệ thống <code>pipe()</code>. Trong trường hợp này, đầu ra của một process được kết nối tới một <strong>in-kernel pipe</strong> (hàng đợi trong nhân hệ điều hành), và đầu vào của process khác được kết nối tới cùng pipe đó. Nhờ vậy, đầu ra của process này trở thành đầu vào của process kia một cách liền mạch, cho phép ghép chuỗi nhiều lệnh hữu ích.</p>
<p>Ví dụ đơn giản: tìm một từ trong tệp và đếm số lần từ đó xuất hiện. Với pipe và các tiện ích <code>grep</code> và <code>wc</code>, việc này rất dễ:</p>
<pre><code>grep -o foo file | wc -l
</code></pre>
<p>Nhập lệnh trên vào shell và bạn sẽ thấy kết quả ngay.</p>
<p>Cuối cùng, mặc dù chúng ta mới chỉ phác thảo API tạo process ở mức cao, nhưng vẫn còn rất nhiều chi tiết cần tìm hiểu thêm; ví dụ, chúng ta sẽ học kỹ hơn về <strong>file descriptor</strong> khi bàn về hệ thống tệp ở phần ba của sách. Tạm thời, có thể kết luận rằng sự kết hợp <code>fork()</code>/<code>exec()</code> là một cách <strong>mạnh mẽ</strong> để tạo và điều khiển process.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;

int main(int argc, char * argv[]) {
  int rc = fork();
  if (rc &lt; 0) {
    // fork failed
    fprintf(stderr, &quot;fork failed\n&quot;);
    exit(1);
  } else if (rc == 0) {
    // child: redirect standard output to a file
    close(STDOUT_FILENO);
    open(&quot;./p4.output&quot;, O_CREAT | O_WRONLY | O_TRUNC,
      S_IRWXU);
    // now exec &quot;wc&quot;...
    char * myargs[3];
    myargs[0] = strdup(&quot;wc&quot;);
    // program: wc
    myargs[1] = strdup(&quot;p4.c&quot;); // arg: file to count
    myargs[2] = NULL;
    // mark end of array
    execvp(myargs[0], myargs); // runs word count
  } else {
    // parent goes down this path (main)
    int rc_wait = wait(NULL);
  }
  return 0;
}
</code></pre>
<p>Figure 5.4: All Of The Above With Redirection (p4.c)</p>
<h2 id="55-Điều-khiển-process-process-control-và-người-dùng-users"><a class="header" href="#55-Điều-khiển-process-process-control-và-người-dùng-users">5.5 Điều khiển process (Process Control) và Người dùng (Users)</a></h2>
<p>Ngoài <code>fork()</code>, <code>exec()</code> và <code>wait()</code>, trong các hệ thống UNIX còn có nhiều interface khác để tương tác với <strong>process</strong> (process). Ví dụ, call hệ thống (system call) <code>kill()</code> được dùng để gửi <strong>signal</strong> (tín hiệu) tới một process, bao gồm các chỉ thị như tạm dừng (pause), kết thúc (die/terminate) và nhiều lệnh hữu ích khác.</p>
<p>Để thuận tiện, trong hầu hết các <strong>UNIX shell</strong>, một số tổ hợp phím được cấu hình để gửi một tín hiệu cụ thể tới process đang chạy. Ví dụ:</p>
<ul>
<li><code>Ctrl-C</code> gửi tín hiệu <strong>SIGINT</strong> (interrupt – ngắt) tới process (thường sẽ kết thúc process đó).</li>
<li><code>Ctrl-Z</code> gửi tín hiệu <strong>SIGTSTP</strong> (stop – dừng) để tạm dừng process khi đang excecute (bạn có thể tiếp tục process này sau bằng một lệnh, ví dụ lệnh tích hợp <code>fg</code> có trong nhiều shell).</li>
</ul>
<p>Toàn bộ <strong>hệ thống con signals</strong> (signals subsystem) cung cấp một hạ tầng phong phú để gửi các sự kiện bên ngoài tới process, bao gồm:</p>
<ul>
<li>Cách để process nhận và xử lý các tín hiệu này.</li>
<li>Cách gửi tín hiệu tới từng process hoặc cả nhóm process (process group).</li>
</ul>
<p>Để sử dụng hình thức giao tiếp này, một process có thể dùng call hệ thống <code>signal()</code> để “bắt” (catch) các tín hiệu khác nhau. Khi một tín hiệu cụ thể được gửi tới process, process sẽ tạm ngừng excecute bình thường và chạy một đoạn code được chỉ định để xử lý tín hiệu đó. (Xem [SR05] để tìm hiểu sâu hơn về signals và các chi tiết phức tạp của chúng).</p>
<p><strong>GHI CHÚ: RTFM — Read The Man Pages</strong></p>
<p>Nhiều lần trong cuốn sách này, khi đề cập đến một system call hoặc library call cụ thể, chúng tôi sẽ khuyên bạn đọc <strong>man pages</strong> (manual pages – trang hướng dẫn). Đây là dạng tài liệu gốc tồn tại trên các hệ thống UNIX, được tạo ra <strong>trước khi</strong> có thứ gọi là “web”.</p>
<p>Dành thời gian đọc man pages là một bước quan trọng trong quá trình trưởng thành của một lập trình viên hệ thống; có rất nhiều thông tin hữu ích ẩn trong đó. Một số man pages đặc biệt hữu ích gồm:</p>
<ul>
<li>Man pages của shell bạn đang dùng (ví dụ: <code>tcsh</code>, <code>bash</code>).</li>
<li>Man pages của bất kỳ system call nào mà chương trình của bạn sử dụng (để biết giá trị trả về và các điều kiện lỗi).</li>
</ul>
<p>Cuối cùng, đọc man pages còn giúp bạn tránh bối rối. Khi bạn hỏi đồng nghiệp về một chi tiết phức tạp của <code>fork()</code>, họ có thể chỉ trả lời: <strong>“RTFM”</strong>. Đây là cách họ nhẹ nhàng nhắc bạn <strong>Read The Man pages</strong>. Chữ “F” trong RTFM chỉ để thêm chút “màu sắc” cho câu nói…</p>
<p>Điều này dẫn đến câu hỏi: <strong>Ai có thể gửi tín hiệu tới một process, và ai thì không?</strong></p>
<p>Thông thường, hệ thống có thể được nhiều người dùng cùng lúc. Nếu một người có thể tùy ý gửi tín hiệu như <strong>SIGINT</strong> (để ngắt process, thường sẽ kết thúc nó) tới process của người khác, tính khả dụng (usability) và bảo mật (security) của hệ thống sẽ bị ảnh hưởng nghiêm trọng.</p>
<p>Vì vậy, các hệ thống hiện đại có khái niệm chặt chẽ về <strong>user</strong> (người dùng). Sau khi nhập mật khẩu để xác thực, người dùng đăng nhập để truy cập tài nguyên hệ thống. Người dùng có thể khởi chạy một hoặc nhiều process và toàn quyền điều khiển chúng (tạm dừng, kết thúc, v.v.).</p>
<p>Người dùng thường chỉ có thể điều khiển <strong>process của chính mình</strong>; hệ điều hành chịu trách nhiệm phân bổ tài nguyên (CPU, bộ nhớ, đĩa…) cho từng người dùng (và các process của họ) để đạt được mục tiêu tổng thể của hệ thống.</p>
<h2 id="56-các-công-cụ-hữu-ích"><a class="header" href="#56-các-công-cụ-hữu-ích">5.6 Các công cụ hữu ích</a></h2>
<p>Có nhiều công cụ dòng lệnh (command-line tools) rất hữu ích. Ví dụ:</p>
<ul>
<li>Lệnh <code>ps</code> cho phép bạn xem các process đang chạy; hãy đọc man pages để biết các tùy chọn (flags) hữu ích khi dùng <code>ps</code>.</li>
<li>Công cụ <code>top</code> cũng rất hữu ích, hiển thị các process của hệ thống và mức độ sử dụng CPU cùng các tài nguyên khác. Thú vị là, nhiều khi bạn chạy <code>top</code>, nó tự nhận mình là process “ngốn” tài nguyên nhất – có lẽ hơi… tự mãn.</li>
<li>Lệnh <code>kill</code> có thể được dùng để gửi tín hiệu tùy ý tới process; <code>killall</code> thân thiện hơn một chút với người dùng.</li>
</ul>
<p>Hãy cẩn thận khi dùng các lệnh này; nếu bạn vô tình “kill” <strong>window manager</strong> (trình quản lý cửa sổ), máy tính trước mặt bạn có thể trở nên rất khó sử dụng.</p>
<p>Ngoài ra, có nhiều loại <strong>CPU meter</strong> (đồng hồ đo CPU) giúp bạn nhanh chóng nắm được tải (load) của hệ thống. Ví dụ, chúng tôi luôn bật <strong>MenuMeters</strong> (từ Raging Menace software) trên thanh công cụ của máy Mac để xem mức sử dụng CPU tại mọi thời điểm. Nói chung, càng có nhiều thông tin về những gì đang diễn ra, bạn càng dễ quản lý hệ thống.</p>
<p><strong>GHI CHÚ: Superuser (Root)</strong></p>
<p>Một hệ thống thường cần một người dùng có quyền quản trị (admin) và <strong>không bị giới hạn</strong> như người dùng thông thường. Người này có thể:</p>
<ul>
<li>Kết thúc (kill) bất kỳ process nào (ví dụ: nếu process đó đang gây hại cho hệ thống), ngay cả khi process đó không do họ khởi chạy.</li>
<li>Chạy các lệnh mạnh như <code>shutdown</code> (tắt hệ thống).</li>
</ul>
<p>Trong các hệ thống dựa trên UNIX, các quyền đặc biệt này được trao cho <strong>superuser</strong> (còn gọi là <strong>root</strong>). Trong khi hầu hết người dùng không thể kết thúc process của người khác, superuser có thể.</p>
<p>Làm <strong>root</strong> giống như làm Spider-Man: <em>“Quyền lực lớn đi kèm trách nhiệm lớn”</em> [QI15]. Vì vậy, để tăng cường bảo mật (và tránh sai lầm tốn kém), tốt nhất là bạn nên hoạt động như một người dùng bình thường; nếu cần trở thành root, hãy thật cẩn trọng, vì mọi “quyền năng hủy diệt” của thế giới máy tính đều nằm trong tay bạn.</p>
<h2 id="57-tóm-tắt"><a class="header" href="#57-tóm-tắt">5.7 Tóm tắt</a></h2>
<p>Chúng ta đã giới thiệu một số API liên quan đến việc tạo process trong UNIX: <code>fork()</code>, <code>exec()</code> và <code>wait()</code>. Tuy nhiên, đây mới chỉ là phần bề mặt. Để tìm hiểu chi tiết hơn, hãy đọc Stevens và Rago [SR05], đặc biệt các chương về <strong>Process Control</strong>, <strong>Process Relationships</strong> và <strong>Signals</strong>.</p>
<p>Mặc dù chúng tôi đánh giá cao API process của UNIX, nhưng không phải ai cũng đồng tình. Ví dụ, một bài báo gần đây của các nhà nghiên cứu hệ thống từ Microsoft, Đại học Boston và ETH Zurich đã chỉ ra một số vấn đề với <code>fork()</code> và đề xuất các API tạo process khác, đơn giản hơn, như <code>spawn()</code> [B+19]. Hãy đọc bài báo và các tài liệu liên quan để hiểu góc nhìn khác này.</p>
<p>Nhớ rằng, dù bạn có thể tin tưởng cuốn sách này, tác giả vẫn có quan điểm riêng; và những quan điểm đó không phải lúc nào cũng được chia sẻ rộng rãi như bạn nghĩ.</p>
<p><strong>GHI CHÚ: Các thuật ngữ chính trong Process API</strong></p>
<ul>
<li>Mỗi <strong>process</strong> (process) có một tên; trong hầu hết các hệ thống, tên này là một số gọi là <strong>process ID</strong> (PID – định danh process).</li>
<li>Lời gọi hệ thống <code>fork()</code> trong UNIX được dùng để tạo process mới. Process tạo ra gọi là <strong>parent</strong> (cha), process mới gọi là <strong>child</strong> (con). Giống như ngoài đời [J16], process con gần như là bản sao của process cha.</li>
<li>Lời gọi hệ thống <code>wait()</code> cho phép process cha chờ process con hoàn tất excecute.</li>
<li>Nhóm call hệ thống <code>exec()</code> cho phép process con thoát khỏi sự giống nhau với process cha và excecute một chương trình hoàn toàn mới.</li>
<li>Một UNIX shell thường dùng <code>fork()</code>, <code>wait()</code> và <code>exec()</code> để chạy lệnh của người dùng; việc tách <code>fork</code> và <code>exec</code> cho phép thực hiện các tính năng như chuyển hướng I/O (input/output redirection), <strong>pipes</strong> và nhiều tính năng khác mà không cần</li>
</ul>
<h2 id="tham-khảo-2"><a class="header" href="#tham-khảo-2">Tham khảo</a></h2>
<p>[C63] “A Multiprocessor System Design”<br />
Melvin E. Conway<br />
AFIPS ’63 Fall Joint Computer Conference<br />
New York, USA 1963<br />
An early paper on how to design multiprocessing systems; may be the first place the term fork() was used in the discussion of spawning new processes.</p>
<p>[DV66] “Programming Semantics for Multiprogrammed Computations”<br />
Jack B. Dennis and Earl C. Van Horn<br />
Communications of the ACM, Volume 9, Number 3, March 1966<br />
A classic paper that outlines the basics of multiprogrammed computer systems. Undoubtedly had great influence on Project MAC, Multics, and eventually UNIX.</p>
<p>[L83] “Hints for Computer Systems Design”<br />
Butler Lampson<br />
ACM Operating Systems Review, 15:5, October 1983<br />
Lampson’s famous hints on how to design computer systems. You should read it at some point in your life, and probably at many points in your life.</p>
<p>[SR05] “Advanced Programming in the UNIX Environment”<br />
W. Richard Stevens and Stephen A. Rago<br />
Addison-Wesley, 2005<br />
All nuances and subtleties of using UNIX APIs are found herein. Buy this book! Read it! And most importantly, live it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-cơ-chế-limited-direct-execution-thực-thi-trực-tiếp-có-giới-hạn"><a class="header" href="#6-cơ-chế-limited-direct-execution-thực-thi-trực-tiếp-có-giới-hạn">6. Cơ chế: Limited Direct Execution (Thực thi trực tiếp có giới hạn)</a></h1>
<p>Để <strong>virtualize</strong> (ảo hóa) CPU, hệ điều hành (Operating System – OS) cần phải tìm cách chia sẻ CPU vật lý cho nhiều công việc (job) chạy dường như đồng thời. Ý tưởng cơ bản rất đơn giản: chạy một <strong>process</strong> (tiến trình) trong một khoảng thời gian ngắn, sau đó chuyển sang chạy một process khác, và cứ thế tiếp tục. Bằng cách chia sẻ thời gian (<strong>time sharing</strong>) của CPU theo cách này, việc ảo hóa được thực hiện.</p>
<p>Tuy nhiên, việc xây dựng cơ chế ảo hóa như vậy gặp một số thách thức. Thứ nhất là <strong>hiệu năng</strong>: làm thế nào để triển khai ảo hóa mà không tạo ra quá nhiều <strong>overhead</strong> (chi phí xử lý bổ sung) cho hệ thống? Thứ hai là <strong>kiểm soát</strong>: làm thế nào để chạy các process một cách hiệu quả mà vẫn giữ quyền kiểm soát CPU? Kiểm soát đặc biệt quan trọng đối với OS, vì OS chịu trách nhiệm quản lý tài nguyên; nếu không có kiểm soát, một process có thể chạy mãi mãi và chiếm toàn bộ máy, hoặc truy cập thông tin mà nó không được phép. Do đó, đạt được hiệu năng cao đồng thời duy trì khả năng kiểm soát là một trong những thách thức trung tâm khi xây dựng hệ điều hành.</p>
<blockquote>
<blockquote>
<p><strong>Cốt lõi: Làm thế nào để ảo hóa CPU một cách hiệu quả mà vẫn giữ quyền kiểm soát</strong></p>
<p>OS phải ảo hóa CPU theo cách hiệu quả đồng thời duy trì quyền kiểm soát hệ thống. Để làm được điều này, cần có sự hỗ trợ từ cả phần cứng và hệ điều hành. OS thường tận dụng một số hỗ trợ phần cứng hợp lý để thực hiện công việc hiệu quả.</p>
</blockquote>
</blockquote>
<h2 id="61-kỹ-thuật-cơ-bản-limited-direct-execution"><a class="header" href="#61-kỹ-thuật-cơ-bản-limited-direct-execution">6.1 Kỹ thuật cơ bản: Limited Direct Execution</a></h2>
<p>Để một chương trình chạy nhanh như mong đợi, các nhà phát triển OS đã đưa ra một kỹ thuật gọi là <strong>limited direct execution</strong> (thực thi trực tiếp có giới hạn). Phần “direct execution” (thực thi trực tiếp) của ý tưởng này rất đơn giản: chỉ cần chạy chương trình trực tiếp trên CPU.</p>
<p>Khi OS muốn bắt đầu chạy một chương trình, nó sẽ:</p>
<ol>
<li>Tạo một mục <strong>process entry</strong> trong <strong>process list</strong> (danh sách tiến trình).</li>
<li>Cấp phát một vùng bộ nhớ cho process.</li>
<li>Nạp mã chương trình vào bộ nhớ (từ đĩa).</li>
<li>Xác định <strong>entry point</strong> (điểm bắt đầu, ví dụ hàm <code>main()</code>).</li>
<li>Nhảy tới entry point và bắt đầu chạy mã của người dùng.</li>
</ol>
<p><img src="06/./img/fig6_1.PNG" alt="" /></p>
<p>Hình 6.1 minh họa giao thức thực thi trực tiếp cơ bản này (chưa có giới hạn), sử dụng lời gọi hàm (call) và trả về (return) thông thường để nhảy vào <code>main()</code> của chương trình và sau đó quay lại <strong>kernel</strong>.</p>
<p>Nghe có vẻ đơn giản, đúng không? Nhưng cách tiếp cận này nảy sinh một số vấn đề trong mục tiêu ảo hóa CPU:</p>
<ol>
<li>Nếu chỉ chạy chương trình, làm thế nào OS đảm bảo chương trình không làm những việc trái phép, mà vẫn chạy hiệu quả?</li>
<li>Khi đang chạy một process, làm thế nào OS dừng nó và chuyển sang process khác, để thực hiện <strong>time sharing</strong> cần thiết cho việc ảo hóa CPU?</li>
</ol>
<p>Khi trả lời những câu hỏi này, chúng ta sẽ hiểu rõ hơn những gì cần thiết để ảo hóa CPU. Đồng thời, ta sẽ thấy vì sao có chữ “limited” (giới hạn) trong tên kỹ thuật này; nếu không giới hạn chương trình, OS sẽ không kiểm soát được gì và sẽ chỉ là “một thư viện” — một tình trạng đáng buồn cho một hệ điều hành đang hình thành.</p>
<h2 id="62-vấn-đề-1-restricted-operations-các-thao-tác-bị-hạn-chế"><a class="header" href="#62-vấn-đề-1-restricted-operations-các-thao-tác-bị-hạn-chế">6.2 Vấn đề #1: Restricted Operations (Các thao tác bị hạn chế)</a></h2>
<p><strong>Direct execution</strong> có ưu điểm rõ ràng là nhanh; chương trình chạy trực tiếp trên CPU phần cứng nên tốc độ đạt như mong đợi. Nhưng chạy trực tiếp trên CPU lại dẫn đến vấn đề: nếu process muốn thực hiện một thao tác bị hạn chế, ví dụ:</p>
<ul>
<li>Gửi yêu cầu I/O tới đĩa.</li>
<li>Truy cập thêm tài nguyên hệ thống như CPU hoặc bộ nhớ.</li>
</ul>
<blockquote>
<p><strong>Cốt lõi: Làm thế nào để thực hiện các thao tác bị hạn chế</strong><br />
Một process cần có khả năng thực hiện I/O và một số thao tác bị hạn chế khác, nhưng không được trao toàn quyền kiểm soát hệ thống. Làm thế nào để OS và phần cứng phối hợp để đạt được điều này?</p>
</blockquote>
<blockquote>
<blockquote>
<p><strong>Ghi chú:</strong> <em>Vì sao system call trông giống như procedure call?</em></p>
<p>Bạn có thể thắc mắc tại sao call tới một <strong>system call</strong> (call hệ thống), như <code>open()</code> hoặc <code>read()</code>, lại trông giống hệt một lời gọi hàm thông thường trong C. Nếu giống hệt procedure call, làm sao hệ thống biết đó là system call và xử lý đúng?</p>
<p>Lý do đơn giản: nó thực sự là một procedure call, nhưng bên trong có chứa <strong>trap instruction</strong> (lệnh bẫy). Cụ thể:</p>
<ul>
<li>Khi bạn gọi <code>open()</code>, bạn đang gọi một hàm trong thư viện C.</li>
<li>Thư viện này (dù là <code>open()</code> hay system call khác) tuân theo <strong>calling convention</strong> (quy ước gọi hàm) đã thống nhất với kernel: đặt các tham số vào vị trí đã biết (ví dụ: trên stack hoặc trong thanh ghi), đặt số hiệu system call vào vị trí đã biết, rồi thực thi lệnh trap.</li>
<li>Mã trong thư viện sau lệnh trap sẽ giải nén giá trị trả về và trả quyền điều khiển lại cho chương trình gọi.</li>
</ul>
<p>Phần mã của thư viện C thực hiện system call thường được viết bằng assembly, vì cần tuân thủ chặt chẽ quy ước để xử lý tham số và giá trị trả về chính xác, cũng như thực thi lệnh trap đặc thù của phần cứng. Nhờ vậy, lập trình viên ứng dụng không cần tự viết assembly để trap vào OS — đã có người viết sẵn cho bạn.</p>
</blockquote>
</blockquote>
<p>Một cách tiếp cận đơn giản là cho phép bất kỳ process nào thực hiện mọi thao tác I/O hoặc liên quan. Tuy nhiên, điều này sẽ phá vỡ nhiều loại hệ thống mong muốn. Ví dụ: nếu muốn xây dựng một <strong>file system</strong> (hệ thống tệp) kiểm tra quyền truy cập trước khi cho phép mở tệp, ta không thể để process người dùng gửi trực tiếp I/O tới đĩa; nếu làm vậy, process có thể đọc/ghi toàn bộ đĩa và mọi cơ chế bảo vệ sẽ mất tác dụng.</p>
<p>Vì vậy, ta giới thiệu một chế độ xử lý mới của CPU gọi là <strong>user mode</strong> (chế độ người dùng). Mã chạy trong user mode bị hạn chế khả năng:</p>
<ul>
<li>Không thể gửi yêu cầu I/O trực tiếp; nếu làm, CPU sẽ phát sinh <strong>exception</strong> (ngoại lệ) và OS có thể sẽ hủy process.</li>
</ul>
<p>Ngược lại, <strong>kernel mode</strong> (chế độ nhân) là chế độ mà OS (kernel) chạy. Trong kernel mode, mã có thể thực hiện mọi thao tác, bao gồm các lệnh đặc quyền như I/O và các lệnh bị hạn chế khác.</p>
<p>Vấn đề còn lại: khi một process ở user mode muốn thực hiện thao tác đặc quyền (ví dụ đọc từ đĩa), nó phải làm thế nào?<br />
Hầu hết phần cứng hiện đại cho phép chương trình ở user mode thực hiện <strong>system call</strong>. Cơ chế này xuất hiện từ các máy tính cổ như Atlas, cho phép kernel cung cấp một số chức năng quan trọng cho chương trình người dùng, như:</p>
<ul>
<li>Truy cập file system.</li>
<li>Tạo/hủy process.</li>
<li>Giao tiếp giữa các process.</li>
<li>Cấp phát thêm bộ nhớ.</li>
</ul>
<p>Hầu hết OS hiện đại cung cấp vài trăm system call (xem chuẩn POSIX để biết chi tiết); các hệ Unix ban đầu chỉ có khoảng 20 system call.</p>
<blockquote>
<p><strong>Mẹo: Sử dụng Protected Control Transfer (chuyển điều khiển được bảo vệ)</strong> </p>
<p>Phần cứng hỗ trợ OS bằng cách cung cấp các chế độ thực thi khác nhau:</p>
<ul>
<li>Trong user mode, ứng dụng không có toàn quyền truy cập tài nguyên phần cứng.</li>
<li>Trong kernel mode, OS có toàn quyền truy cập.</li>
</ul>
<p>Phần cứng cũng cung cấp:</p>
<ul>
<li>Lệnh đặc biệt để trap vào kernel và lệnh return-from-trap để quay lại user mode.</li>
<li>Lệnh cho phép OS chỉ định vị trí <strong>trap table</strong> (bảng bẫy) trong bộ nhớ.</li>
</ul>
</blockquote>
<p>Để thực hiện một system call, chương trình phải thực thi lệnh trap đặc biệt. Lệnh này đồng thời:</p>
<ol>
<li>Nhảy vào kernel.</li>
<li>Nâng mức đặc quyền lên kernel mode.</li>
</ol>
<p>Khi ở kernel, hệ thống có thể thực hiện các thao tác đặc quyền cần thiết (nếu được phép) để phục vụ process gọi. Khi hoàn tất, OS thực thi lệnh <strong>return-from-trap</strong>, vừa trả quyền điều khiển cho chương trình người dùng, vừa hạ mức đặc quyền trở lại user mode.</p>
<p>Phần cứng cần cẩn trọng khi thực thi một <strong>trap</strong> (cơ chế bẫy), vì nó phải đảm bảo lưu đủ các thanh ghi (<strong>register</strong>) của tiến trình gọi để có thể khôi phục chính xác khi OS thực hiện lệnh <strong>return-from-trap</strong> (trả về từ trap).</p>
<p>Ví dụ, trên kiến trúc <strong>x86</strong>, bộ xử lý sẽ <strong>push</strong> (đẩy) <strong>program counter</strong> (bộ đếm lệnh), <strong>flags</strong> (các cờ trạng thái) và một số thanh ghi khác vào <strong>kernel stack</strong> (ngăn xếp nhân) riêng cho từng <strong>process</strong> (tiến trình). Khi thực hiện <strong>return-from-trap</strong>, các giá trị này sẽ được <strong>pop</strong> (lấy ra) khỏi stack và tiếp tục thực thi chương trình ở <strong>user mode</strong> (chế độ người dùng). (Xem chi tiết trong tài liệu hệ thống của Intel [I11]). Các hệ thống phần cứng khác có thể dùng quy ước khác, nhưng khái niệm cơ bản là tương tự trên nhiều nền tảng.</p>
<p>Có một chi tiết quan trọng: làm sao trap biết được đoạn code nào trong OS cần được thực thi? Rõ ràng, process gọi trap không thể chỉ định trực tiếp địa chỉ để nhảy tới (như khi gọi một hàm thông thường). Nếu cho phép, chương trình có thể nhảy tới bất kỳ đâu trong kernel — đây rõ ràng là một <strong>Very Bad Idea</strong> (ý tưởng cực kỳ tồi tệ) <sup class="footnote-reference"><a href="#1">1</a></sup>. Vì vậy, kernel phải kiểm soát chặt chẽ đoạn code nào sẽ chạy khi xảy ra trap.</p>
<p>Kernel thực hiện điều này bằng cách thiết lập một <strong>trap table</strong> (bảng bẫy) khi khởi động máy (<strong>boot time</strong>). Khi máy khởi động, nó ở <strong>kernel mode</strong> (chế độ nhân, đặc quyền cao nhất), do đó có thể cấu hình phần cứng tùy ý. Một trong những việc đầu tiên OS thực hiện là thông báo cho phần cứng biết đoạn code nào cần chạy khi xảy ra các sự kiện đặc biệt (<strong>exceptional events</strong>), ví dụ:</p>
<ul>
<li>Khi có <strong>hard disk interrupt</strong> (ngắt từ ổ cứng).</li>
<li>Khi có <strong>keyboard interrupt</strong> (ngắt từ bàn phím).</li>
<li>Khi một chương trình thực hiện <strong>system call</strong> (call hệ thống).</li>
</ul>
<p><img src="06/./img/fig6_2.PNG" alt="" /></p>
<p>OS thông báo vị trí của các <strong>trap handler</strong> (trình xử lý trap) này cho phần cứng, thường thông qua một lệnh đặc biệt (<strong>privileged instruction</strong> – lệnh đặc quyền). Sau khi được cấu hình, phần cứng sẽ ghi nhớ vị trí các handler này cho đến khi máy được khởi động lại, và sẽ biết phải làm gì (tức là nhảy tới đoạn code nào) khi xảy ra system call hoặc các sự kiện đặc biệt khác.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Ví dụ: tưởng tượng việc nhảy vào đoạn code truy cập tệp nhưng ngay sau bước kiểm tra quyền truy cập; khả năng này có thể cho phép lập trình viên tinh ranh khiến kernel chạy các chuỗi lệnh tùy ý [S07]. Nói chung, hãy tránh những <strong>Very Bad Ideas</strong> như vậy.</p>
<blockquote>
<p><strong>TIP</strong>: Cẩn trọng với dữ liệu đầu vào của người dùng trong hệ thống bảo mật</p>
<p>Mặc dù chúng ta đã rất nỗ lực bảo vệ OS trong quá trình thực hiện system call (bằng cách thêm cơ chế trap phần cứng và đảm bảo mọi call vào OS đều đi qua cơ chế này), vẫn còn nhiều khía cạnh khác để xây dựng một hệ điều hành an toàn.</p>
<p>Một trong số đó là xử lý <strong>arguments</strong> (tham số) tại ranh giới system call; OS phải kiểm tra dữ liệu mà người dùng truyền vào và đảm bảo chúng hợp lệ, nếu không thì từ chối call.</p>
<p>Ví dụ: với system call <code>write()</code>, người dùng chỉ định một địa chỉ bộ đệm (<strong>buffer</strong>) làm nguồn dữ liệu để ghi. Nếu người dùng (vô tình hoặc cố ý) truyền vào một địa chỉ “xấu” (ví dụ: nằm trong vùng địa chỉ của kernel), OS phải phát hiện và từ chối call. Nếu không, người dùng có thể đọc toàn bộ bộ nhớ của kernel; mà bộ nhớ kernel (virtual memory – bộ nhớ ảo) thường ánh xạ toàn bộ bộ nhớ vật lý của hệ thống, nên lỗi này sẽ cho phép đọc bộ nhớ của bất kỳ process nào khác.</p>
<p>Nói chung, một hệ thống an toàn phải luôn <strong>nghi ngờ</strong> dữ liệu đầu vào từ người dùng. Nếu không, phần mềm sẽ dễ bị tấn công, lập trình viên OS sẽ mất việc, và thế giới sẽ trở nên nguy hiểm hơn.</p>
</blockquote>
<p>Để xác định chính xác system call, mỗi system call thường được gán một <strong>system-call number</strong> (số hiệu). Mã người dùng sẽ đặt số hiệu này vào một thanh ghi hoặc một vị trí xác định trên stack. Khi xử lý system call trong trap handler, OS sẽ:</p>
<ol>
<li>Kiểm tra số hiệu.</li>
<li>Đảm bảo nó hợp lệ.</li>
<li>Nếu hợp lệ, thực thi đoạn code tương ứng.</li>
</ol>
<p>Cách gián tiếp này giúp bảo vệ hệ thống: mã người dùng không thể chỉ định địa chỉ nhảy trực tiếp, mà chỉ có thể yêu cầu dịch vụ thông qua số hiệu.</p>
<p>One last aside: Khả năng thực thi lệnh thông báo cho phần cứng vị trí trap table là một quyền năng rất lớn. Do đó, đây cũng là một <strong>privileged operation</strong> (thao tác đặc quyền). Nếu cố gắng thực hiện lệnh này ở user mode, phần cứng sẽ không cho phép và chương trình vi phạm sẽ bị chấm dứt ngay.</p>
<p>Hãy suy nghĩ: nếu bạn có thể cài trap table của riêng mình, bạn có thể làm gì với hệ thống? Liệu bạn có thể chiếm quyền điều khiển toàn bộ máy?</p>
<p>Hình 6.2 (với thời gian tăng dần từ trên xuống) tóm tắt giao thức. Giả sử mỗi process có một kernel stack, nơi các thanh ghi (bao gồm cả thanh ghi đa dụng và program counter) được phần cứng lưu và khôi phục khi chuyển vào/ra kernel.</p>
<p>Giao thức LDE có hai giai đoạn:</p>
<ol>
<li>
<p><strong>Giai đoạn khởi động (boot time)</strong>:</p>
<ul>
<li>Kernel khởi tạo trap table.</li>
<li>CPU ghi nhớ vị trí trap table để sử dụng sau này.</li>
<li>Kernel thực hiện điều này bằng <strong>privileged instruction</strong>.</li>
</ul>
</li>
<li>
<p><strong>Giai đoạn chạy process</strong>:</p>
<ul>
<li>Kernel chuẩn bị một số thứ (ví dụ: cấp phát node trong process list, cấp phát bộ nhớ).</li>
<li>Sử dụng lệnh <strong>return-from-trap</strong> để bắt đầu thực thi process (chuyển CPU sang user mode).</li>
<li>Khi process muốn thực hiện system call, nó trap vào OS, OS xử lý và trả quyền điều khiển lại bằng return-from-trap.</li>
<li>Khi process kết thúc (return từ <code>main()</code>), nó thường quay về một đoạn code stub để thoát chương trình đúng cách (ví dụ: gọi system call <code>exit()</code> để trap vào OS).</li>
<li>OS dọn dẹp và kết thúc.</li>
</ul>
</li>
</ol>
<h2 id="63-vấn-đề-2-chuyển-đổi-giữa-các-process"><a class="header" href="#63-vấn-đề-2-chuyển-đổi-giữa-các-process">6.3 Vấn đề #2: Chuyển đổi giữa các process</a></h2>
<p>Vấn đề tiếp theo của <strong>direct execution</strong> là làm sao chuyển đổi giữa các process. Nghe có vẻ đơn giản: OS chỉ cần dừng một process và chạy process khác. Nhưng thực tế phức tạp hơn: nếu một process đang chạy trên CPU, điều đó có nghĩa là OS <strong>không</strong> đang chạy. Nếu OS không chạy, nó không thể làm gì cả. Đây là vấn đề thực tế, không chỉ triết lý.</p>
<blockquote>
<blockquote>
<p><strong>Cốt lõi: Làm sao OS giành lại quyền điều khiển CPU để chuyển đổi process?</strong></p>
</blockquote>
</blockquote>
<h2 id="một-phương-pháp-hợp-tác-chờ-system-call-call-hệ-thống"><a class="header" href="#một-phương-pháp-hợp-tác-chờ-system-call-call-hệ-thống">Một phương pháp hợp tác: Chờ <strong>system call</strong> (call hệ thống)</a></h2>
<p>Một phương pháp mà một số hệ thống trong quá khứ đã áp dụng (ví dụ: các phiên bản đầu tiên của hệ điều hành Macintosh [M11], hoặc hệ thống Xerox Alto cũ [A79]) được gọi là <strong>phương pháp hợp tác</strong> (<em>cooperative approach</em>). Trong mô hình này, <strong>OS</strong> (hệ điều hành) tin tưởng các <strong>process</strong> (tiến trình) trong hệ thống sẽ hoạt động một cách hợp lý. Các process chạy quá lâu được giả định là sẽ định kỳ nhường lại <strong>CPU</strong> để OS có thể quyết định chạy một tác vụ khác.</p>
<p>Vậy, bạn có thể hỏi: trong “thế giới lý tưởng” này, một process “thân thiện” sẽ nhường CPU như thế nào? Thực tế, hầu hết các process thường xuyên chuyển quyền điều khiển CPU cho OS bằng cách thực hiện <strong>system call</strong> — ví dụ: mở một tệp và sau đó đọc nó, gửi một thông điệp tới một máy khác, hoặc tạo một process mới.</p>
<p>Các hệ thống kiểu này thường bao gồm một <strong>yield system call</strong> (call hệ thống <code>yield</code>) — vốn không làm gì ngoài việc chuyển quyền điều khiển sang OS để nó có thể chạy các process khác.</p>
<p>Ứng dụng cũng sẽ chuyển quyền điều khiển cho OS khi chúng thực hiện một hành vi bất hợp pháp. Ví dụ: nếu một ứng dụng thực hiện phép chia cho 0, hoặc cố gắng truy cập vào vùng bộ nhớ mà nó không được phép, nó sẽ tạo ra một <strong>trap</strong> (ngắt bẫy) tới OS. Khi đó, OS sẽ giành lại quyền điều khiển CPU (và nhiều khả năng sẽ chấm dứt process vi phạm).</p>
<p>Như vậy, trong một hệ thống <strong>cooperative scheduling</strong> (lập lịch hợp tác), OS giành lại quyền điều khiển CPU bằng cách chờ một system call hoặc một thao tác bất hợp pháp nào đó xảy ra.</p>
<p>Tuy nhiên, bạn có thể nghĩ: cách tiếp cận thụ động này có phải là không tối ưu? Điều gì sẽ xảy ra nếu một process (dù là độc hại hay chỉ đơn giản là chứa nhiều lỗi) rơi vào vòng lặp vô hạn và không bao giờ thực hiện system call? Khi đó OS có thể làm gì?</p>
<h2 id="một-phương-pháp-không-hợp-tác-os-tự-giành-quyền-điều-khiển"><a class="header" href="#một-phương-pháp-không-hợp-tác-os-tự-giành-quyền-điều-khiển">Một phương pháp không hợp tác: OS tự giành quyền điều khiển</a></h2>
<p>Nếu không có sự hỗ trợ bổ sung từ phần cứng, hóa ra OS hầu như không thể làm gì khi một process từ chối thực hiện system call (hoặc mắc lỗi) và vì thế không trả quyền điều khiển về cho OS. Thực tế, trong phương pháp hợp tác, cách duy nhất khi một process bị kẹt trong vòng lặp vô hạn là dùng đến “giải pháp cổ điển” cho mọi vấn đề trong hệ thống máy tính: <strong>khởi động lại máy</strong>. Như vậy, chúng ta lại quay về một tiểu vấn đề (subproblem) trong mục tiêu tổng quát: <strong>làm thế nào để giành quyền điều khiển CPU</strong>.</p>
<blockquote>
<p><strong>THE CRUX: HOW TO GAIN CONTROL WITHOUT COOPERATION</strong><br />
Làm thế nào để OS có thể giành quyền điều khiển CPU ngay cả khi các process không hợp tác? OS có thể làm gì để đảm bảo một process “nổi loạn” không chiếm quyền điều khiển toàn bộ máy?</p>
</blockquote>
<p>Câu trả lời hóa ra lại đơn giản và đã được nhiều người xây dựng hệ thống máy tính phát hiện từ nhiều năm trước: <strong>timer interrupt</strong> (ngắt định thời) [M+63].   Một thiết bị <strong>timer</strong> có thể được lập trình để phát sinh một <strong>interrupt</strong> (ngắt) sau mỗi một khoảng thời gian tính bằng mili-giây; khi ngắt xảy ra, <strong>process</strong> (tiến trình) đang chạy sẽ bị tạm dừng, và một <strong>interrupt handler</strong> (trình xử lý ngắt) đã được cấu hình sẵn trong <strong>OS</strong> (Operating System – hệ điều hành) sẽ được thực thi.   Tại thời điểm này, OS đã giành lại quyền điều khiển <strong>CPU</strong>, và do đó có thể làm bất cứ điều gì cần thiết: dừng process hiện tại và khởi chạy một process khác.</p>
<p>Như đã thảo luận trước đây với <strong>system call</strong> (call hệ thống), OS phải thông báo cho phần cứng biết đoạn code nào cần chạy khi xảy ra timer interrupt; vì vậy, trong quá trình <strong>boot</strong> (khởi động), OS sẽ thực hiện việc này.</p>
<p>Tiếp theo, cũng trong quá trình khởi động, OS phải khởi chạy timer — đây tất nhiên là một <strong>privileged operation</strong> (thao tác đặc quyền). Khi timer đã bắt đầu, OS có thể yên tâm rằng quyền điều khiển sẽ sớm quay trở lại, và do đó OS có thể tự do chạy các chương trình người dùng. Timer cũng có thể bị tắt (cũng là thao tác đặc quyền), điều này sẽ được bàn đến sau khi chúng ta tìm hiểu chi tiết hơn về <strong>concurrency</strong> (tính đồng thời).</p>
<blockquote>
<blockquote>
<p><strong>TIP: Xử lý ứng dụng hoạt động sai (Application Misbehavior)</strong></p>
<p>Hệ điều hành thường phải xử lý các process hoạt động sai — có thể do thiết kế (mục đích xấu) hoặc do vô tình (lỗi phần mềm) — cố gắng thực hiện những hành động không được phép.</p>
<p>Trong các hệ thống hiện đại, cách OS xử lý hành vi sai trái này thường là <strong>chấm dứt ngay lập tức</strong> process vi phạm. <em>One strike and you’re out!</em> (Phạm lỗi một lần là bị loại ngay!) Nghe có vẻ khắc nghiệt, nhưng OS còn có thể làm gì khác khi bạn cố truy cập bộ nhớ trái phép hoặc thực thi một lệnh bất hợp pháp?</p>
</blockquote>
</blockquote>
<p>Cần lưu ý rằng phần cứng cũng có trách nhiệm khi một interrupt xảy ra, đặc biệt là phải lưu đủ trạng thái (<strong>state</strong>) của chương trình đang chạy tại thời điểm ngắt, để khi thực hiện lệnh <strong>return-from-trap</strong> (trả về từ trap) sau đó, chương trình có thể tiếp tục chạy chính xác. Tập hợp các hành động này khá giống với hành vi của phần cứng khi thực hiện một system-call trap vào <strong>kernel</strong>, với việc lưu các thanh ghi (ví dụ: vào <strong>kernel stack</strong>) và dễ dàng khôi phục chúng khi thực hiện return-from-trap.</p>
<h2 id="lưu-và-khôi-phục-ngữ-cảnh-saving-and-restoring-context"><a class="header" href="#lưu-và-khôi-phục-ngữ-cảnh-saving-and-restoring-context">Lưu và khôi phục ngữ cảnh (Saving and Restoring Context)</a></h2>
<p>Khi OS đã giành lại quyền điều khiển — dù là hợp tác thông qua system call, hay cưỡng chế thông qua timer interrupt — OS phải đưa ra quyết định: <strong>tiếp tục chạy process hiện tại hay chuyển sang process khác</strong>.</p>
<p>Quyết định này được thực hiện bởi một thành phần của OS gọi là <strong>scheduler</strong> (bộ lập lịch). Chúng ta sẽ bàn chi tiết về các chính sách <strong>scheduling</strong> trong những chương tiếp theo.</p>
<p>Nếu quyết định chuyển đổi, OS sẽ thực thi một đoạn code mức thấp gọi là <strong>context switch</strong> (chuyển đổi ngữ cảnh).</p>
<p>Về mặt khái niệm, context switch khá đơn giản:</p>
<ul>
<li>OS lưu một số giá trị thanh ghi của process đang chạy (ví dụ: vào kernel stack của nó).</li>
<li>OS khôi phục các giá trị thanh ghi của process sắp chạy (từ kernel stack của process đó).</li>
</ul>
<p>Bằng cách này, OS đảm bảo rằng khi lệnh return-from-trap được thực thi, thay vì quay lại process cũ, hệ thống sẽ tiếp tục thực thi process mới.</p>
<p>Cụ thể, để lưu ngữ cảnh của process đang chạy, OS sẽ thực thi một số lệnh <strong>assembly</strong> mức thấp để lưu:</p>
<ul>
<li>Các <strong>general purpose registers</strong> (thanh ghi đa dụng).</li>
<li><strong>PC</strong> (Program Counter – bộ đếm lệnh).</li>
<li><strong>Kernel stack pointer</strong> (con trỏ ngăn xếp nhân).</li>
</ul>
<p>Sau đó, OS khôi phục các giá trị này cho process sắp chạy và chuyển sang kernel stack của process đó.</p>
<p>Việc chuyển stack cho phép kernel bắt đầu call tới mã chuyển đổi trong ngữ cảnh của process bị ngắt, và kết thúc trong ngữ cảnh của process sắp chạy. Khi OS thực hiện return-from-trap, process sắp chạy trở thành process đang chạy. <strong>Context switch hoàn tất.</strong></p>
<blockquote>
<blockquote>
<p><strong>TIP: Sử dụng Timer Interrupt để giành lại quyền điều khiển</strong></p>
<p>Việc bổ sung timer interrupt cho phép OS có thể chạy lại trên CPU ngay cả khi các process hoạt động không hợp tác. Vì vậy, đây là một tính năng phần cứng <strong>thiết yếu</strong> giúp OS duy trì quyền kiểm soát hệ thống.</p>
</blockquote>
</blockquote>
<p>Thêm một mẹo khác</p>
<blockquote>
<blockquote>
<p><strong>TIP: Reboot là một công cụ hữu ích</strong></p>
<p>Trước đây, chúng ta đã lưu ý rằng giải pháp duy nhất cho vòng lặp vô hạn (và các hành vi tương tự) trong cơ chế <strong>cooperative preemption</strong> (tiền xử lý hợp tác) là <strong>reboot</strong> (khởi động lại) máy.</p>
<p>Mặc dù bạn có thể coi đây là một “mẹo vặt” xấu xí, nhưng các nhà nghiên cứu đã chỉ ra rằng reboot (hoặc nói chung là khởi động lại một phần mềm) có thể là một công cụ cực kỳ hữu ích trong việc xây dựng hệ thống <strong>robust</strong> (mạnh mẽ) [C+04].</p>
<p>Cụ thể:</p>
<ul>
<li>Reboot đưa phần mềm trở lại trạng thái đã biết và thường được kiểm thử kỹ hơn.</li>
<li>Reboot thu hồi các tài nguyên bị rò rỉ hoặc không còn sử dụng (ví dụ: bộ nhớ) mà nếu không sẽ khó xử lý.</li>
<li>Reboot dễ dàng tự động hóa.</li>
</ul>
<p>Vì những lý do này, trong các dịch vụ Internet quy mô lớn dạng <strong>cluster</strong> (cụm máy chủ), phần mềm quản lý hệ thống thường định kỳ reboot một nhóm máy để đặt lại trạng thái và tận dụng các lợi ích trên.</p>
</blockquote>
</blockquote>
<p>Vì vậy, lần tới khi bạn reboot, bạn không chỉ đang áp dụng một “mẹo vặt” tạm thời, mà thực ra đang sử dụng một phương pháp đã được kiểm chứng qua thời gian để cải thiện hành vi của hệ thống máy tính. <strong>Rất đáng khen!</strong></p>
<p>Dòng thời gian của toàn bộ quá trình được minh họa trong <strong>Hình 6.3</strong>. Trong ví dụ này, <strong>Process A</strong> (tiến trình A) đang chạy thì bị <strong>timer interrupt</strong> (ngắt định thời) làm gián đoạn. Phần cứng sẽ lưu các <strong>register</strong> (thanh ghi) của nó (vào <strong>kernel stack</strong> – ngăn xếp nhân) và chuyển vào <strong>kernel</strong> (chuyển sang <strong>kernel mode</strong> – chế độ nhân).</p>
<p>Trong <strong>timer interrupt handler</strong> (trình xử lý ngắt định thời), <strong>OS</strong> (Operating System – hệ điều hành) quyết định chuyển từ chạy Process A sang Process B. Tại thời điểm đó, OS gọi hàm <code>switch()</code>, hàm này sẽ:</p>
<ul>
<li>Cẩn thận lưu các giá trị thanh ghi hiện tại (vào <strong>process structure</strong> – cấu trúc tiến trình của A).</li>
<li>Khôi phục các thanh ghi của Process B (từ mục cấu trúc tiến trình của B).</li>
<li>Thực hiện <strong>context switch</strong> (chuyển đổi ngữ cảnh), cụ thể là thay đổi <strong>stack pointer</strong> để sử dụng kernel stack của B (thay vì của A).</li>
</ul>
<p>Cuối cùng, OS thực hiện <strong>return-from-trap</strong>, khôi phục các thanh ghi của B và bắt đầu chạy nó.</p>
<p>Cần lưu ý rằng có <strong>hai loại</strong> thao tác lưu/khôi phục thanh ghi xảy ra trong giao thức này:</p>
<ol>
<li>
<p><strong>Khi timer interrupt xảy ra</strong>:</p>
<ul>
<li>Các <strong>user registers</strong> (thanh ghi của tiến trình người dùng) của process đang chạy được phần cứng <strong>ngầm định</strong> lưu lại, sử dụng kernel stack của process đó.</li>
</ul>
</li>
<li>
<p><strong>Khi OS quyết định chuyển từ A sang B</strong>:</p>
<ul>
<li>Các <strong>kernel registers</strong> (thanh ghi của nhân) được phần mềm (OS) <strong>tường minh</strong> lưu lại, lần này vào bộ nhớ trong process structure của tiến trình.</li>
</ul>
</li>
</ol>
<p>Hành động thứ hai này khiến hệ thống chuyển từ trạng thái “như thể vừa trap vào kernel từ A” sang trạng thái “như thể vừa trap vào kernel từ B”.</p>
<p>Để bạn hình dung rõ hơn cách thực hiện chuyển đổi này, <strong>Hình 6.4</strong> hiển thị mã <strong>context switch</strong> của <strong>xv6</strong>. Bạn cần biết một chút về kiến trúc <strong>x86</strong> và hệ điều hành xv6 để hiểu rõ. Các cấu trúc ngữ cảnh (<strong>context structures</strong>) <code>old</code> và <code>new</code> lần lượt nằm trong process structure của tiến trình cũ và tiến trình mới.</p>
<p><img src="06/./img/fig6_3.PNG" alt="" /></p>
<p><em>Figure 6.3: Limited Direct Execution Protocol (Timer Interrupt)</em></p>
<h2 id="64-lo-ngại-về-concurrency-tính-đồng-thời"><a class="header" href="#64-lo-ngại-về-concurrency-tính-đồng-thời">6.4 Lo ngại về Concurrency (Tính đồng thời)</a></h2>
<p>Một số bạn đọc kỹ lưỡng có thể đang nghĩ:</p>
<ul>
<li>“Điều gì xảy ra nếu trong khi đang thực hiện một <strong>system call</strong>, lại có một <strong>timer interrupt</strong> xảy ra?”</li>
<li>“Điều gì xảy ra nếu đang xử lý một interrupt mà một interrupt khác lại đến? Kernel có xử lý được không?”</li>
</ul>
<p>Câu trả lời là: <strong>Có</strong>, OS thực sự cần quan tâm đến việc nếu trong quá trình xử lý interrupt hoặc trap, một interrupt khác xảy ra thì điều gì sẽ diễn ra. Đây chính là chủ đề của <strong>phần thứ hai</strong> của cuốn sách này, về <strong>concurrency</strong>; chúng ta sẽ để phần thảo luận chi tiết cho sau.</p>
<p>Để gợi mở, ta điểm qua một số nguyên tắc cơ bản:</p>
<ul>
<li>Một cách đơn giản mà OS có thể làm là <strong>disable interrupts</strong> (vô hiệu hóa ngắt) trong khi đang xử lý một interrupt; điều này đảm bảo rằng khi một interrupt đang được xử lý, sẽ không có interrupt khác được gửi tới CPU.</li>
<li>Tuy nhiên, OS phải cẩn thận: vô hiệu hóa ngắt quá lâu có thể dẫn đến <strong>lost interrupts</strong> (mất ngắt), điều này (theo thuật ngữ kỹ thuật) là <strong>rất tệ</strong>.</li>
</ul>
<pre><code class="language-assembly"># void swtch(struct context *old, struct context *new);
#
# Save current register context in old
# and then load register context from new.
.globl swtch
swtch:
# Save old registers
movl 4(%esp), %eax # put old ptr into eax
popl 0(%eax)
# save the old IP
movl %esp, 4(%eax) # and stack
movl %ebx, 8(%eax) # and other registers
movl %ecx, 12(%eax)
movl %edx, 16(%eax)
movl %esi, 20(%eax)
movl %edi, 24(%eax)
movl %ebp, 28(%eax)

# Load new registers
movl 4(%esp), %eax # put new ptr into eax
movl 28(%eax), %ebp # restore other registers
movl 24(%eax), %edi
movl 20(%eax), %esi
movl 16(%eax), %edx
movl 12(%eax), %ecx
movl 8(%eax), %ebx
movl 4(%eax), %esp # stack is switched here
pushl 0(%eax)
# return addr put in place
ret
# finally return into new ctxt
</code></pre>
<p><em>Figure 6.4: The xv6 Context Switch Code</em></p>
<p>Ngoài ra, các hệ điều hành hiện đại còn phát triển nhiều cơ chế <strong>locking</strong> (khóa) tinh vi để bảo vệ việc truy cập đồng thời vào các cấu trúc dữ liệu nội bộ. Điều này cho phép nhiều hoạt động diễn ra song song trong kernel, đặc biệt hữu ích trên hệ thống <strong>multiprocessor</strong> (đa bộ xử lý). Tuy nhiên, như chúng ta sẽ thấy ở phần sau, việc sử dụng khóa có thể phức tạp và dẫn đến nhiều lỗi khó phát hiện.</p>
<h2 id="65-tóm-tắt"><a class="header" href="#65-tóm-tắt">6.5 Tóm tắt</a></h2>
<p>Chúng ta đã mô tả một số cơ chế mức thấp quan trọng để triển khai <strong>CPU virtualization</strong> (ảo hóa CPU) – tập hợp các kỹ thuật mà chúng ta gọi chung là <strong>limited direct execution</strong> (thực thi trực tiếp có giới hạn).</p>
<p>Ý tưởng cơ bản rất đơn giản: chạy trực tiếp chương trình trên CPU, nhưng trước đó phải cấu hình phần cứng để giới hạn những gì process có thể làm mà không cần sự can thiệp của OS.</p>
<p>Cách tiếp cận này cũng tương tự trong đời sống. Ví dụ: nếu bạn có con nhỏ, bạn sẽ <strong>baby proof</strong> (làm an toàn cho trẻ) căn phòng: khóa tủ chứa đồ nguy hiểm, che ổ điện. Khi căn phòng đã được chuẩn bị như vậy, bạn có thể để trẻ tự do đi lại, yên tâm rằng các yếu tố nguy hiểm đã được hạn chế.</p>
<p>Tương tự như vậy, OS “baby proof” CPU bằng cách:</p>
<ol>
<li>Trong <strong>boot time</strong> (thời gian khởi động), thiết lập <strong>trap handler</strong> và khởi động <strong>interrupt timer</strong>.</li>
<li>Chỉ chạy process ở <strong>restricted mode</strong> (chế độ hạn chế – user mode).</li>
</ol>
<p>Bằng cách này, OS đảm bảo process chạy hiệu quả, chỉ cần OS can thiệp khi:</p>
<ul>
<li>Thực hiện thao tác đặc quyền.</li>
<li>Hoặc chiếm CPU quá lâu và cần bị chuyển ra.</li>
</ul>
<p>Như vậy, chúng ta đã có các cơ chế cơ bản để ảo hóa CPU. Nhưng vẫn còn một câu hỏi lớn: <strong>Chạy process nào tại một thời điểm nhất định?</strong> Đây chính là câu hỏi mà <strong>scheduler</strong> (bộ lập lịch) phải trả lời – và sẽ là chủ đề tiếp theo.</p>
<blockquote>
<blockquote>
<p>ASIDE: Thời gian thực hiện context switch</p>
<p>Một câu hỏi tự nhiên: <strong>context switch</strong> mất bao lâu? Hoặc một system call mất bao lâu?</p>
<p>Có một công cụ tên <strong>lmbench</strong> [MS96] đo chính xác những điều này, cùng một số chỉ số hiệu năng khác. Kết quả đã cải thiện đáng kể theo thời gian, gần như song hành với hiệu năng CPU.</p>
<p>Ví dụ:</p>
<ul>
<li>Năm 1996, chạy Linux 1.3.37 trên CPU P6 200 MHz:
<ul>
<li>System call mất khoảng <strong>4 microsecond</strong>.</li>
<li>Context switch mất khoảng <strong>6 microsecond</strong> [MS96].</li>
</ul>
</li>
<li>Hệ thống hiện đại nhanh hơn gần một bậc độ lớn, với kết quả dưới 1 microsecond trên CPU 2–3 GHz.</li>
</ul>
<p>Tuy nhiên, không phải mọi thao tác của OS đều tỷ lệ thuận với tốc độ CPU. Như Ousterhout đã chỉ ra, nhiều thao tác của OS phụ thuộc nhiều vào bộ nhớ, và <strong>memory bandwidth</strong> (băng thông bộ nhớ) không tăng nhanh như tốc độ CPU [O90]. Do đó, tùy vào <strong>workload</strong> (khối lượng công việc), việc mua CPU mới nhất có thể không cải thiện OS nhiều như bạn kỳ vọng.</p>
</blockquote>
</blockquote>
<h3 id="aside-các-thuật-ngữ-chính-trong-cpu-virtualization-cơ-chế"><a class="header" href="#aside-các-thuật-ngữ-chính-trong-cpu-virtualization-cơ-chế">ASIDE: Các thuật ngữ chính trong CPU virtualization (cơ chế)</a></h3>
<ul>
<li>CPU phải hỗ trợ ít nhất <strong>hai chế độ thực thi</strong>:
<ul>
<li><strong>User mode</strong> (chế độ người dùng – bị hạn chế).</li>
<li><strong>Kernel mode</strong> (chế độ nhân – đặc quyền, không bị hạn chế).</li>
</ul>
</li>
<li>Ứng dụng người dùng chạy ở user mode và sử dụng <strong>system call</strong> để trap vào kernel, yêu cầu dịch vụ từ OS.</li>
<li><strong>Trap instruction</strong> lưu trạng thái thanh ghi, chuyển phần cứng sang kernel mode, và nhảy vào OS tới vị trí xác định trước trong <strong>trap table</strong>.</li>
<li>Khi OS hoàn tất xử lý system call, nó quay lại chương trình người dùng qua lệnh <strong>return-from-trap</strong>, hạ mức đặc quyền và tiếp tục thực thi sau lệnh trap.</li>
<li><strong>Trap table</strong> phải được OS thiết lập khi boot và không thể bị chương trình người dùng sửa đổi. Đây là một phần của giao thức <strong>limited direct execution</strong>, cho phép chạy chương trình hiệu quả mà vẫn giữ quyền kiểm soát của OS.</li>
<li>Khi chương trình đang chạy, OS phải dùng cơ chế phần cứng để đảm bảo nó không chạy mãi mãi, cụ thể là <strong>timer interrupt</strong>. Đây là cách tiếp cận <strong>non-cooperative</strong> (không hợp tác) trong CPU scheduling.</li>
<li>Đôi khi, trong timer interrupt hoặc system call, OS có thể muốn chuyển từ process hiện tại sang process khác – kỹ thuật mức thấp này gọi là <strong>context switch</strong>.</li>
</ul>
<h2 id="tham-khảo-3"><a class="header" href="#tham-khảo-3">Tham khảo</a></h2>
<p>[A79] “Alto User’s Handbook”<br />
Xerox Palo Alto Research Center, September 1979<br />
Available: http://history-computer.com/Library/AltoUsersHandbook.pdf<br />
An amazing system, way ahead of its time. Became famous because Steve Jobs visited, took notes, and built Lisa and eventually Mac.</p>
<p>[C+04] “Microreboot — A Technique for Cheap Recovery”<br />
George Candea, Shinichi Kawamoto, Yuichi Fujiki, Greg Friedman, Armando Fox<br />
OSDI ’04, San Francisco, CA, December 2004<br />
An excellent paper pointing out how far one can go with reboot in building more robust systems.</p>
<p>[I11] “Intel 64 and IA-32 Architectures Software Developer’s Manual”<br />
Volume 3A and 3B: System Programming Guide<br />
Intel Corporation, January 2011</p>
<p>[K+61] “One-Level Storage System”<br />
T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner<br />
IRE Transactions on Electronic Computers, April 1962<br />
The Atlas pioneered much of what you see in modern systems. However, this paper is not the best one to read. If you were to only read one, you might try the historical perspective below [L78].</p>
<p>[L78] “The Manchester Mark I and Atlas: A Historical Perspective”<br />
S. H. Lavington<br />
Communications of the ACM, 21:1, January 1978<br />
A history of the early development of computers and the pioneering efforts of Atlas.</p>
<p>[M+63] “A Time-Sharing Debugging System for a Small Computer”<br />
J. McCarthy, S. Boilen, E. Fredkin, J. C. R. Licklider<br />
AFIPS ’63 (Spring), May, 1963, New York, USA<br />
An early paper about time-sharing that refers to using a timer interrupt; the quote that discusses it: “The basic task of the channel 17 clock routine is to decide whether to remove the current user from core and if so to decide which user program to swap in as he goes out.”</p>
<p>[MS96] “lmbench: Portable tools for performance analysis”<br />
Larry McVoy and Carl Staelin<br />
USENIX Annual Technical Conference, January 1996<br />
A fun paper about how to measure a number of different things about your OS and its performance. Download lmbench and give it a try.</p>
<p>[M11] “Mac OS 9”<br />
January 2011<br />
Available: http://en.wikipedia.org/wiki/Mac OS 9</p>
<p>[O90] “Why Aren’t Operating Systems Getting Faster as Fast as Hardware?”<br />
J. Ousterhout<br />
USENIX Summer Conference, June 1990<br />
A classic paper on the nature of operating system performance.</p>
<p>[P10] “The Single UNIX Specification, Version 3”<br />
The Open Group, May 2010<br />
Available: http://www.unix.org/version3/<br />
This is hard and painful to read, so probably avoid it if you can.</p>
<p>[S07] “The Geometry of Innocent Flesh on the Bone:<br />
Return-into-libc without Function Calls (on the x86)”<br />
Hovav Shacham<br />
CCS ’07, October 2007<br />
One of those awesome, mind-blowing ideas that you’ll see in research from time to time. The author shows that if you can jump into code arbitrarily, you can essentially stitch together any code sequence you like (given a large code base); read the paper for the details. The technique makes it even harder to defend against malicious attacks, alas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-scheduling-giới-thiệu"><a class="header" href="#7-scheduling-giới-thiệu">7. Scheduling: Giới thiệu</a></h1>
<p>Đến thời điểm này, các cơ chế mức thấp để chạy process (tiến trình) như context switching (chuyển ngữ cảnh) hẳn đã rõ ràng; nếu chưa, hãy quay lại một hoặc hai chương trước để đọc lại phần mô tả cách hoạt động của chúng. Tuy nhiên, chúng ta vẫn chưa hiểu rõ các chính sách mức cao mà một OS scheduler (bộ lập lịch của hệ điều hành) sử dụng. Chúng ta sẽ làm điều đó ngay sau đây, bằng cách trình bày một loạt scheduling policy (chính sách lập lịch, đôi khi gọi là <em>discipline</em>) mà nhiều người thông minh và cần mẫn đã phát triển qua nhiều năm.</p>
<p>Thực tế, nguồn gốc của scheduling còn xuất hiện trước cả các hệ thống máy tính; những cách tiếp cận ban đầu được lấy từ lĩnh vực quản lý vận hành (operations management) và áp dụng cho máy tính. Điều này không có gì bất ngờ: dây chuyền lắp ráp và nhiều hoạt động khác của con người cũng đòi hỏi lập lịch, với cùng một mối quan tâm mạnh mẽ đến hiệu suất. Và như vậy, vấn đề của chúng ta là:</p>
<blockquote>
<p><strong>THE CRUX: CÁCH PHÁT TRIỂN CHÍNH SÁCH LẬP LỊCH</strong>
Làm thế nào để xây dựng một khung cơ bản cho tư duy về scheduling policy? Giả định nào là then chốt? Các chỉ số nào quan trọng? Các cách tiếp cận cơ bản nào đã được dùng trong những hệ thống máy tính đầu tiên?</p>
</blockquote>
<h2 id="71-workload-assumptions-các-giả-định-về-khối-lượng-công-việc"><a class="header" href="#71-workload-assumptions-các-giả-định-về-khối-lượng-công-việc">7.1 Workload Assumptions (Các giả định về khối lượng công việc)</a></h2>
<p>Trước khi đi sâu vào các chính sách có thể có, hãy đưa ra một số giả định đơn giản hóa về các process đang chạy trong hệ thống, đôi khi được gọi chung là <em>workload</em> (khối lượng công việc). Xác định workload là một phần quan trọng của việc xây dựng chính sách; bạn càng biết nhiều về workload thì chính sách lập lịch của bạn càng có thể tinh chỉnh tốt hơn.</p>
<p>Các giả định mà chúng ta đưa ra ở đây phần lớn là phi thực tế, nhưng điều đó không sao (ít nhất là lúc này), vì chúng ta sẽ dần nới lỏng chúng và cuối cùng phát triển thứ mà chúng ta sẽ gọi là... (nghỉ một chút cho kịch tính)... một <em>fully-operational scheduling discipline</em>^[1].</p>
<p>^[1]: Được nói theo cùng cách bạn sẽ nói “A fully-operational Death Star.”</p>
<p>Chúng ta sẽ đưa ra các giả định sau về process (còn gọi là <em>job</em>) đang chạy trong hệ thống:</p>
<ol>
<li>Mỗi job chạy trong cùng một khoảng thời gian.</li>
<li>Tất cả job đến vào cùng một thời điểm.</li>
<li>Một khi đã bắt đầu, mỗi job sẽ chạy đến khi hoàn tất.</li>
<li>Tất cả job chỉ sử dụng CPU (không thực hiện I/O).</li>
<li>Thời gian chạy của mỗi job là đã biết trước.</li>
</ol>
<p>Chúng ta đã nói rằng nhiều giả định này là phi thực tế, nhưng giống như trong <em>Trại súc vật</em> (<em>Animal Farm</em>) của Orwell [O45] rằng “một số con vật bình đẳng hơn những con khác”, ở đây cũng vậy: một số giả định phi thực tế hơn những giả định khác. Đặc biệt, việc biết trước thời gian chạy của mỗi job có thể khiến bạn khó chịu, vì điều này khiến scheduler trở thành <em>toàn tri</em> (omniscient) — điều mà mặc dù sẽ tuyệt vời (có lẽ thế), nhưng khó có khả năng xảy ra trong tương lai gần.</p>
<h2 id="72-scheduling-metrics-các-thước-đo-lập-lịch"><a class="header" href="#72-scheduling-metrics-các-thước-đo-lập-lịch">7.2 Scheduling Metrics (Các thước đo lập lịch)</a></h2>
<p>Ngoài việc đưa ra giả định về workload, chúng ta cũng cần thêm một yếu tố nữa để có thể so sánh các scheduling policy khác nhau: một <em>scheduling metric</em> (thước đo lập lịch). Metric đơn giản là một đại lượng để đo lường điều gì đó, và trong lập lịch có nhiều metric hợp lý.</p>
<p>Tạm thời, chúng ta sẽ đơn giản hóa bằng cách chỉ xét một metric duy nhất: <em>turnaround time</em> (thời gian quay vòng). Turnaround time của một job được định nghĩa là thời điểm job hoàn tất trừ đi thời điểm job đến hệ thống. Một cách chính thức hơn, turnaround time $T_{turnaround}$ được xác định như sau:</p>
<p>$$
T_{turnaround} = T_{completion} - T_{arrival} \quad (7.1)
$$</p>
<p>Vì chúng ta giả định rằng tất cả job đến cùng lúc, nên hiện tại $T_{arrival} = 0$, do đó $T_{turnaround} = T_{completion}$. Thực tế này sẽ thay đổi khi ta nới lỏng các giả định ở trên.</p>
<p>Bạn cần lưu ý rằng turnaround time là một <em>performance metric</em> (chỉ số hiệu năng), vốn là trọng tâm chính trong chương này. Một metric khác cũng quan trọng là <em>fairness</em> (công bằng), được đo lường (ví dụ) bằng Jain’s Fairness Index [J91]. Trong lập lịch, performance và fairness thường mâu thuẫn với nhau; ví dụ, một scheduler có thể tối ưu hiệu năng nhưng lại khiến một số job không được chạy, từ đó làm giảm fairness. Thế mới thấy, cuộc đời vốn không hoàn hảo.</p>
<h2 id="73-first-in-first-out-fifo"><a class="header" href="#73-first-in-first-out-fifo">7.3 First In, First Out (FIFO)</a></h2>
<p>Thuật toán cơ bản nhất mà chúng ta có thể cài đặt được gọi là <em>First In, First Out (FIFO)</em> hay đôi khi là <em>First Come, First Served (FCFS)</em>.</p>
<p>FIFO có một số ưu điểm: rõ ràng nó đơn giản và dễ triển khai. Và với các giả định hiện tại, nó hoạt động khá tốt.</p>
<p>Hãy làm một ví dụ nhanh. Giả sử có ba job A, B và C đến hệ thống gần như cùng lúc ($T_{arrival} = 0$). Vì FIFO phải chọn một job chạy trước, hãy giả sử A đến sớm hơn một chút so với B, và B đến sớm hơn một chút so với C. Giả sử thêm rằng mỗi job chạy trong 10 giây. Vậy turnaround time trung bình sẽ là bao nhiêu?</p>
<p><img src="07/./img/fig7_1.PNG" alt="" /></p>
<p>Từ Hình 7.1, ta thấy A hoàn tất ở thời điểm 10, B ở thời điểm 20, và C ở thời điểm 30. Như vậy, turnaround time trung bình của ba job đơn giản là:</p>
<p>$(10 + 20 + 30) / 3 = 20$</p>
<p>Tính turnaround time đơn giản chỉ vậy thôi.</p>
<p>Giờ hãy nới lỏng một giả định: cụ thể là giả định số 1, tức không còn giả định rằng mỗi job có cùng thời gian chạy. Vậy FIFO hoạt động thế nào trong trường hợp này? Bạn có thể tạo ra workload nào để khiến FIFO hoạt động tệ hại?</p>
<p><em>(hãy nghĩ kỹ trước khi đọc tiếp... nghĩ tiếp... rồi, hiểu chưa?)</em></p>
<p>Chắc hẳn bạn đã thấy rồi, nhưng để chắc chắn, hãy làm một ví dụ. Giả sử có ba job (A, B và C), lần này A chạy trong 100 giây, còn B và C chỉ chạy trong 10 giây.</p>
<p><img src="07/./img/fig7_2.PNG" alt="" /></p>
<p><em>Figure 7.2: Why FIFO Is Not That Great</em></p>
<p>Như thấy ở Hình 7.2, job A chạy trước suốt 100 giây, khiến B và C không được chạy cho đến khi A hoàn tất. Do đó, turnaround time trung bình của hệ thống rất cao: tận 110 giây $((100 + 110 + 120)/3 = 110)$.</p>
<p>Vấn đề này thường được gọi là <em>convoy effect</em> [B+79], trong đó một số job ngắn phải xếp hàng chờ sau một job rất dài tiêu thụ tài nguyên. Trường hợp này giống như bạn xếp hàng ở siêu thị và thấy người phía trước có ba xe đẩy chất đầy hàng hóa và đang lục ví lấy sổ séc — bạn sẽ phải chờ khá lâu^[2].</p>
<p>Vậy chúng ta nên làm gì? Làm thế nào để phát triển một thuật toán tốt hơn để xử lý thực tế rằng các job có thời gian chạy khác nhau? Hãy suy nghĩ trước, rồi đọc tiếp.</p>
<blockquote>
<p><strong>TIP: NGUYÊN LÝ CỦA SJF</strong>
<em>Shortest Job First</em> (SJF) thể hiện một nguyên lý lập lịch tổng quát có thể áp dụng cho bất kỳ hệ thống nào mà turnaround time (thời gian quay vòng) cho mỗi khách hàng (hay ở đây là job) đều quan trọng. Hãy nghĩ đến bất kỳ hàng chờ nào bạn từng xếp: nếu cơ sở đó quan tâm đến sự hài lòng của khách hàng, rất có thể họ đã áp dụng SJF. Ví dụ, siêu thị thường có quầy thanh toán “dưới 10 món hàng” để đảm bảo người mua ít hàng không bị kẹt sau gia đình đang chuẩn bị dự trữ cho “mùa đông hạt nhân”.</p>
</blockquote>
<h2 id="74-shortest-job-first-sjf"><a class="header" href="#74-shortest-job-first-sjf">7.4 Shortest Job First (SJF)</a></h2>
<p>Hóa ra có một cách tiếp cận rất đơn giản để giải quyết vấn đề này; thực tế đây là một ý tưởng lấy từ <em>operations research</em> [C54,PV56] và áp dụng vào lập lịch job trong hệ thống máy tính. Chính sách lập lịch mới này gọi là <em>Shortest Job First (SJF)</em>, và cái tên đủ rõ ràng: luôn chạy job ngắn nhất trước, sau đó đến job ngắn tiếp theo, và cứ thế.</p>
<p><img src="07/./img/fig7_3.PNG" alt="" /></p>
<p><em>Figure 7.3: SJF Simple Example</em></p>
<p>Hãy áp dụng ví dụ trước nhưng dùng SJF làm chính sách lập lịch. Hình 7.3 cho thấy kết quả khi chạy A, B và C. Hy vọng sơ đồ đã làm rõ vì sao SJF cải thiện đáng kể turnaround time trung bình. Chỉ đơn giản bằng việc chạy B và C trước A, SJF đã giảm turnaround time trung bình từ 110 giây xuống còn 50 giây $((10 + 20 + 120)/3 = 50)$, tức cải thiện hơn hai lần.</p>
<p>^[2]: Hành động khuyến nghị trong trường hợp này: hoặc nhanh chóng chuyển sang hàng khác, hoặc hít một hơi thật sâu rồi thở ra thật chậm. Đúng vậy, hít vào, thở ra. Mọi thứ sẽ ổn thôi, đừng lo lắng.</p>
<blockquote>
<p><strong>ASIDE: PREEMPTIVE SCHEDULERS</strong>
Trong thời kỳ máy tính xử lý theo lô (<em>batch computing</em>), nhiều scheduler không hỗ trợ <em>preemption</em> (không thể ngắt job giữa chừng) đã được phát triển; hệ thống như vậy sẽ chạy từng job đến khi hoàn tất mới xem xét chạy job khác. Gần như tất cả scheduler hiện đại đều là <em>preemptive</em> (có thể ngắt), sẵn sàng dừng một process đang chạy để chuyển sang chạy process khác. Điều này ngụ ý rằng scheduler sử dụng các cơ chế mà chúng ta đã học trước đây; đặc biệt, scheduler có thể thực hiện <em>context switch</em>, tạm thời dừng một process đang chạy và tiếp tục (hoặc bắt đầu) một process khác.</p>
</blockquote>
<p>Thực tế, với các giả định rằng tất cả job đến cùng lúc, chúng ta có thể chứng minh rằng <em>SJF</em> thực sự là một thuật toán lập lịch tối ưu. Tuy nhiên, bạn đang học môn <em>systems</em>, không phải lý thuyết hay <em>operations research</em>; nên sẽ không có chứng minh nào ở đây.</p>
<p>Như vậy, ta đã tìm được một cách tiếp cận khá tốt với SJF, nhưng các giả định vẫn còn quá phi thực tế. Hãy nới lỏng thêm một giả định nữa. Cụ thể, ta xét đến giả định số 2: thay vì giả định tất cả job đến cùng lúc, ta cho rằng các job có thể đến vào bất kỳ thời điểm nào. Vấn đề nào sẽ nảy sinh?
<em>(nghỉ một chút để suy nghĩ... bạn đang nghĩ chứ?... nào, bạn làm được mà)</em></p>
<p>Ta có thể minh họa vấn đề bằng một ví dụ. Lần này, giả sử A đến lúc $t = 0$ và cần chạy trong 100 giây, trong khi B và C đến ở $t = 10$ và mỗi job cần 10 giây. Với SJF thuần túy, ta sẽ có lịch chạy như trong Hình 7.4.</p>
<p><img src="07/./img/fig7_4.PNG" alt="" /></p>
<p><em>Figure 7.4: SJF With Late Arrivals From B and C</em></p>
<p>Như bạn thấy ở hình, mặc dù B và C đến ngay sau A, nhưng chúng vẫn buộc phải chờ cho đến khi A hoàn tất, do đó lại chịu cảnh <em>convoy problem</em>. Turnaround time trung bình của ba job là 103.33 giây $((100 + (110 - 10) + (120 - 10)) / 3)$. Vậy scheduler có thể làm gì?</p>
<h2 id="75-shortest-time-to-completion-first-stcf"><a class="header" href="#75-shortest-time-to-completion-first-stcf">7.5 Shortest Time-to-Completion First (STCF)</a></h2>
<p>Để giải quyết vấn đề này, chúng ta cần nới lỏng giả định số 3 (rằng job phải chạy đến khi hoàn tất). Đồng thời, scheduler cũng cần có thêm cơ chế hỗ trợ. Như bạn có thể đoán, dựa trên thảo luận trước về <em>timer interrupt</em> và <em>context switching</em>, scheduler hoàn toàn có thể làm điều gì đó khi B và C đến: nó có thể <em>preempt</em> (ngắt) job A và quyết định chạy một job khác, có thể tiếp tục A sau đó. Theo định nghĩa, SJF là một scheduler <em>non-preemptive</em> (không ngắt giữa chừng), vì thế nó gặp vấn đề như đã mô tả.</p>
<p><img src="07/./img/fig7_5.PNG" alt="" /></p>
<p><em>Figure 7.5: STCF Simple Example</em></p>
<p>May mắn thay, có một loại scheduler thực hiện đúng điều này: thêm khả năng preemption vào SJF, gọi là <em>Shortest Time-to-Completion First (STCF)</em> hay <em>Preemptive Shortest Job First (PSJF)</em> [CK68]. Mỗi khi có một job mới đến hệ thống, STCF sẽ xác định trong số các job còn lại (bao gồm cả job mới) job nào có thời gian còn lại ngắn nhất, rồi lập lịch cho job đó. Trong ví dụ của chúng ta, STCF sẽ ngắt A và chạy B cùng C đến khi xong; chỉ khi đó thời gian còn lại của A mới được tiếp tục. Hình 7.5 minh họa điều này.</p>
<p>Kết quả là turnaround time trung bình cải thiện đáng kể: 50 giây $(((120 - 0) + (20 - 10) + (30 - 10))/3)$. Và giống như trước, với giả định mới này, STCF có thể chứng minh được là tối ưu. Nếu SJF tối ưu khi tất cả job đến cùng lúc, thì bạn chắc hẳn cũng thấy được trực giác đằng sau tính tối ưu của STCF.</p>
<h2 id="76-một-chỉ-số-mới-response-time"><a class="header" href="#76-một-chỉ-số-mới-response-time">7.6 Một chỉ số mới: Response Time</a></h2>
<p>Như vậy, nếu ta biết độ dài job, biết rằng các job chỉ dùng CPU, và chỉ quan tâm đến turnaround time, thì STCF là một chính sách tuyệt vời. Thực tế, với một số hệ thống batch computing ban đầu, loại thuật toán lập lịch này là hợp lý. Tuy nhiên, sự xuất hiện của máy <em>time-sharing</em> đã thay đổi tất cả. Giờ đây, người dùng ngồi trước terminal và đòi hỏi khả năng tương tác từ hệ thống. Từ đó, một chỉ số mới ra đời: <em>response time</em> (thời gian đáp ứng).</p>
<p>Chúng ta định nghĩa response time là khoảng thời gian từ lúc job đến hệ thống cho đến lần đầu tiên nó được lập lịch^[3]. Một cách chính thức:</p>
<p>$$
T_{response} = T_{firstrun} - T_{arrival} \quad (7.2)
$$</p>
<p><img src="07/./img/fig7_6.PNG" alt="" /></p>
<p><em>Figure 7.6: SJF Again (Bad for Response Time)</em></p>
<p><img src="07/./img/fig7_7.PNG" alt="" /></p>
<p><em>Figure 7.7: Round Robin (Good For Response Time)</em></p>
<p>^[3]: Một số định nghĩa khác bao gồm cả thời gian cho đến khi job tạo ra một “phản hồi”; định nghĩa ở đây là phiên bản tốt nhất, giả định rằng job tạo phản hồi ngay lập tức.</p>
<p>Ví dụ, nếu ta xét lịch từ Hình 7.5 (A đến lúc 0, B và C đến lúc 10), thì response time của mỗi job là: 0 cho A, 0 cho B, và 10 cho C (trung bình: 3.33).</p>
<p>Như bạn có thể đoán, STCF và các chính sách tương tự không thực sự tốt cho response time. Nếu ba job đến cùng lúc, job thứ ba sẽ phải chờ hai job trước chạy xong hoàn toàn trước khi được lập lịch. Trong khi rất tốt cho turnaround time, thì đây lại là điều tệ hại cho response time và tính tương tác. Hãy tưởng tượng bạn ngồi ở terminal, gõ lệnh, và phải chờ 10 giây mới thấy hệ thống phản hồi chỉ vì một job khác được lập lịch trước bạn — không hề dễ chịu.</p>
<p>Như vậy, chúng ta lại đối diện một vấn đề khác: làm thế nào để xây dựng scheduler nhạy cảm với response time?</p>
<h2 id="77-round-robin"><a class="header" href="#77-round-robin">7.7 Round Robin</a></h2>
<p>Để giải quyết vấn đề này, ta sẽ giới thiệu một thuật toán lập lịch mới, cổ điển gọi là <em>Round Robin (RR)</em> [K64]. Ý tưởng cơ bản rất đơn giản: thay vì chạy job đến khi hoàn tất, RR chạy một job trong một khoảng thời gian gọi là <em>time slice</em> (đôi khi gọi là <em>scheduling quantum</em>), rồi chuyển sang job tiếp theo trong hàng đợi. Quá trình này lặp đi lặp lại cho đến khi tất cả job hoàn tất. Vì lý do này, RR đôi khi còn gọi là <em>time-slicing</em>.</p>
<p>Lưu ý rằng độ dài của time slice phải là bội số của chu kỳ <em>timer interrupt</em>; ví dụ, nếu timer ngắt mỗi 10 mili-giây, thì time slice có thể là 10, 20 hoặc bội số khác của 10 ms.</p>
<p>Để hiểu rõ hơn về RR, hãy xét một ví dụ. Giả sử ba job A, B, và C đến cùng lúc trong hệ thống, và mỗi job cần chạy 5 giây. Một scheduler SJF sẽ chạy từng job đến hoàn tất rồi mới chuyển sang job khác (Hình 7.6). Ngược lại, RR với time slice 1 giây sẽ luân phiên qua các job rất nhanh (Hình 7.7).</p>
<p>Response time trung bình của RR là $(0+1+2)/3 = 1$; còn với SJF, response time trung bình là $(0+5+10)/3 = 5$.</p>
<blockquote>
<p><strong>TIP: AMORTIZATION CÓ THỂ GIẢM CHI PHÍ</strong>
Kỹ thuật tổng quát gọi là <em>amortization</em> thường được dùng trong hệ thống khi một thao tác có chi phí cố định. Bằng cách thực hiện thao tác ít lần hơn, tổng chi phí sẽ giảm. Ví dụ, nếu time slice đặt là 10 ms và chi phí context switch là 1 ms, thì khoảng 10% thời gian bị lãng phí cho context switch. Nếu muốn amortize chi phí này, ta có thể tăng time slice, ví dụ lên 100 ms. Khi đó, chưa đến 1% thời gian bị lãng phí, và chi phí của time-slicing đã được amortize.</p>
</blockquote>
<p>Như bạn thấy, độ dài time slice có vai trò then chốt trong RR. Time slice càng ngắn, hiệu năng của RR theo chỉ số response time càng tốt. Tuy nhiên, nếu quá ngắn, chi phí context switching sẽ trở nên chi phối và làm giảm hiệu năng tổng thể. Do đó, việc chọn độ dài time slice là một <em>trade-off</em> (cân bằng đánh đổi) đối với nhà thiết kế hệ thống: đủ dài để amortize chi phí switching nhưng không quá dài để làm hệ thống kém tương tác.</p>
<p>Lưu ý rằng chi phí context switching không chỉ đến từ việc OS lưu và khôi phục vài thanh ghi. Khi chương trình chạy, nó tạo ra rất nhiều trạng thái trong CPU cache, TLB, bộ dự đoán nhánh và các phần cứng trong chip khác. Chuyển sang job khác khiến các trạng thái này bị xóa và thay bằng trạng thái mới, gây ra chi phí hiệu năng đáng kể [MB91].</p>
<p>Với một time slice hợp lý, RR là một scheduler tuyệt vời nếu chỉ xét response time. Nhưng còn turnaround time thì sao? Hãy quay lại ví dụ trên. A, B, và C, mỗi job chạy 5 giây, đến cùng lúc, và RR dùng time slice 1 giây. Ta thấy từ hình minh họa rằng A hoàn tất ở thời điểm 13, B ở 14, và C ở 15, với turnaround time trung bình là 14. Rất tệ!</p>
<p>Không ngạc nhiên khi RR là một trong những chính sách tệ nhất nếu xét theo turnaround time. Trực giác mà nói, điều này hợp lý: RR kéo dài thời gian hoàn tất của mỗi job bằng cách chỉ chạy từng phần nhỏ rồi chuyển sang job khác. Vì turnaround time chỉ quan tâm đến khi job kết thúc, RR gần như <em>pessimal</em> (tệ hại nhất), thậm chí còn tệ hơn FIFO trong nhiều trường hợp.</p>
<p>Nói chung, bất kỳ chính sách nào (như RR) mà công bằng — chia CPU đều cho các process trong ngắn hạn — thì sẽ hoạt động tệ với chỉ số như turnaround time. Đây là một <em>trade-off</em> cố hữu: nếu chấp nhận “không công bằng”, bạn có thể cho job ngắn chạy xong sớm, nhưng đánh đổi bằng response time kém; còn nếu coi trọng công bằng, response time sẽ được cải thiện, nhưng turnaround time lại xấu đi. Kiểu đánh đổi này rất phổ biến trong hệ thống; bạn không thể “vừa giữ được cái bánh, vừa ăn nó”^[4].</p>
<p>Chúng ta đã phát triển hai loại scheduler. Loại thứ nhất (SJF, STCF) tối ưu turnaround time nhưng tệ cho response time. Loại thứ hai (RR) tối ưu response time nhưng tệ cho turnaround time. Và chúng ta vẫn còn hai giả định cần nới lỏng: giả định 4 (các job không làm I/O) và giả định 5 (thời gian chạy của mỗi job là đã biết). Hãy tiếp tục với chúng.</p>
<blockquote>
<p><strong>TIP: OVERLAP GIÚP TĂNG HIỆU SUẤT</strong>
Khi có thể, hãy <em>overlap</em> (chồng chéo) các thao tác để tối đa hóa việc sử dụng hệ thống. Overlap hữu ích trong nhiều lĩnh vực, chẳng hạn khi thực hiện disk I/O hoặc gửi thông điệp đến máy từ xa; trong cả hai trường hợp, bắt đầu một tác vụ rồi chuyển sang công việc khác là một ý tưởng tốt, giúp cải thiện hiệu suất và khả năng tận dụng tài nguyên của hệ thống.</p>
</blockquote>
<h2 id="78-kết-hợp-với-io"><a class="header" href="#78-kết-hợp-với-io">7.8 Kết hợp với I/O</a></h2>
<p>Trước tiên, ta nới lỏng giả định số 4 — hiển nhiên tất cả chương trình đều thực hiện I/O. Hãy tưởng tượng một chương trình không có input: nó sẽ tạo ra cùng một output mỗi lần chạy. Tưởng tượng một chương trình không có output: giống như “cái cây ngã trong rừng mà không ai thấy”; việc nó chạy chẳng có ý nghĩa gì.</p>
<p>Scheduler rõ ràng phải đưa ra quyết định khi một job khởi tạo yêu cầu I/O, vì job đang chạy sẽ không dùng CPU trong lúc chờ I/O hoàn tất; nó sẽ bị <em>blocked</em> (chặn). Nếu I/O gửi đến ổ cứng, process có thể bị chặn vài mili-giây hoặc lâu hơn, tùy vào tải I/O hiện tại của ổ. Do đó, scheduler có lẽ nên lập lịch một job khác dùng CPU tại thời điểm đó.</p>
<p>Scheduler cũng phải quyết định khi I/O hoàn tất. Khi đó, một <em>interrupt</em> được phát sinh, và OS sẽ đưa process phát lệnh I/O từ trạng thái <em>blocked</em> trở lại <em>ready state</em>. Tất nhiên, scheduler thậm chí có thể quyết định chạy job đó ngay lúc này. Vậy OS nên đối xử với mỗi job như thế nào?</p>
<p>Để hiểu rõ hơn, giả sử ta có hai job, A và B, mỗi job cần 50 ms CPU. Tuy nhiên, có một khác biệt rõ rệt: A chạy 10 ms rồi phát lệnh I/O (giả sử mỗi I/O mất 10 ms), còn B chỉ dùng CPU 50 ms và không thực hiện I/O. Scheduler chạy A trước, rồi đến B (Hình 7.8).</p>
<p>Giả sử ta muốn xây dựng một scheduler STCF. Làm thế nào để scheduler này tính đến thực tế rằng A bị chia thành 5 đoạn 10 ms, trong khi B chỉ có một nhu cầu CPU duy nhất 50 ms? Rõ ràng, chỉ đơn giản chạy từng job mà không xét I/O là vô nghĩa.</p>
<p>^[4]: Một câu nói gây nhầm lẫn, bởi đúng ra phải là “Bạn không thể vừa giữ bánh vừa ăn nó” (điều hiển nhiên, đúng không?). Thật đáng kinh ngạc khi Wikipedia có hẳn một trang về câu này; và còn thú vị để đọc nữa [W15]. Trong tiếng Ý, người ta nói “Avere la botte piena e la moglie ubriaca”.</p>
<p><img src="07/./img/fig7_8.PNG" alt="" /></p>
<p><img src="07/./img/fig7_9.PNG" alt="" /></p>
<p>Một cách tiếp cận phổ biến là coi mỗi đoạn 10 ms của A như một job độc lập. Như vậy, khi hệ thống khởi động, lựa chọn là lập lịch cho A (10 ms) hay B (50 ms). Với STCF, lựa chọn rõ ràng: chọn job ngắn hơn, tức A. Sau khi đoạn đầu của A hoàn tất, chỉ còn B, và nó bắt đầu chạy. Khi một đoạn mới của A được gửi vào, nó sẽ <em>preempt</em> B và chạy 10 ms.</p>
<p>Cách làm này cho phép <em>overlap</em>: CPU được một process sử dụng trong khi process khác chờ I/O, nhờ đó hệ thống tận dụng tốt hơn (Hình 7.9). Và như vậy, ta thấy cách scheduler kết hợp I/O: bằng cách coi mỗi <em>CPU burst</em> là một job, scheduler đảm bảo các process “tương tác” được chạy thường xuyên. Trong khi các job này thực hiện I/O, các job nặng CPU khác được chạy, giúp CPU được khai thác hiệu quả hơn.</p>
<h2 id="79-không-còn-oracle-nữa"><a class="header" href="#79-không-còn-oracle-nữa">7.9 Không còn “Oracle” nữa</a></h2>
<p>Với cách tiếp cận cơ bản cho I/O, ta đến với giả định cuối cùng: scheduler biết trước độ dài mỗi job. Như đã nói, đây có lẽ là giả định tệ nhất. Trên thực tế, trong một OS đa mục đích (general-purpose OS), OS thường biết rất ít về độ dài mỗi job. Vậy làm sao xây dựng cách tiếp cận hoạt động giống SJF/STCF mà không cần kiến thức tiên nghiệm? Hơn nữa, làm sao ta kết hợp được các ý tưởng từ RR để cải thiện response time?</p>
<h2 id="710-tóm-tắt"><a class="header" href="#710-tóm-tắt">7.10 Tóm tắt</a></h2>
<p>Chúng ta đã giới thiệu các ý tưởng cơ bản về scheduling và phát triển hai nhóm phương pháp. Nhóm thứ nhất chạy job ngắn nhất còn lại, tối ưu turnaround time. Nhóm thứ hai luân phiên qua tất cả job, tối ưu response time. Cả hai đều kém ở điểm mà nhóm kia mạnh, một <em>trade-off</em> vốn rất phổ biến trong hệ thống.</p>
<p>Chúng ta cũng đã thấy cách tích hợp I/O, nhưng vẫn chưa giải quyết được vấn đề cốt lõi: OS không thể nhìn thấy tương lai. Ngay sau đây, ta sẽ thấy cách khắc phục vấn đề này, bằng cách xây dựng một scheduler sử dụng quá khứ gần để dự đoán tương lai. Scheduler này được gọi là <em>multi-level feedback queue</em>, và nó sẽ là chủ đề của chương tiếp theo.</p>
<h2 id="tham-khảo-4"><a class="header" href="#tham-khảo-4">Tham khảo</a></h2>
<p>[B+79] “The Convoy Phenomenon”<br />
M. Blasgen, J. Gray, M. Mitoma, T. Price<br />
ACM Operating Systems Review, 13:2, April 1979<br />
Perhaps the first reference to convoys, which occurs in databases as well as the OS.</p>
<p>[C54] “Priority Assignment in Waiting Line Problems”<br />
A. Cobham<br />
Journal of Operations Research, 2:70, pages 70–76, 1954<br />
The pioneering paper on using an SJF approach in scheduling the repair of machines.</p>
<p>[K64] “Analysis of a Time-Shared Processor”<br />
Leonard Kleinrock<br />
Naval Research Logistics Quarterly, 11:1, pages 59–73, March 1964<br />
May be the first reference to the round-robin scheduling algorithm; certainly one of the first analyses of said approach to scheduling a time-shared system.</p>
<p>[CK68] “Computer Scheduling Methods and their Countermeasures”<br />
Edward G. Coffman and Leonard Kleinrock<br />
AFIPS ’68 (Spring), April 1968<br />
An excellent early introduction to and analysis of a number of basic scheduling disciplines.</p>
<p>[J91] “The Art of Computer Systems Performance Analysis:Techniques for Experimental Design, Measurement, Simulation, and Modeling”<br />
R. Jain<br />
Interscience, New York, April 1991<br />
The standard text on computer systems measurement. A great reference for your library, for sure.</p>
<p>[O45] “Animal Farm”<br />
George Orwell<br />
Secker and Warburg (London), 1945<br />
A great but depressing allegorical book about power and its corruptions. Some say it is a critique of Stalin and the pre-WWII Stalin era in the U.S.S.R; we say it’s a critique of pigs.</p>
<p>[PV56] “Machine Repair as a Priority Waiting-Line Problem”<br />
Thomas E. Phipps Jr. and W. R. Van Voorhis<br />
Operations Research, 4:1, pages 76–86, February 1956<br />
Follow-on work that generalizes the SJF approach to machine repair from Cobham’s original work; also postulates the utility of an STCF approach in such an environment. Specifically, “There are certain types of repair work, ... involving much dismantling and covering the floor with nuts and bolts, which certainly should not be interrupted once undertaken; in other cases it would be inadvisable to continue work on a long job if one or more short ones became available (p.81).”</p>
<p>[MB91] “The effect of context switches on cache performance”<br />
Jeffrey C. Mogul and Anita Borg<br />
ASPLOS, 1991<br />
A nice study on how cache performance can be affected by context switching; less of an issue in today’s systems where processors issue billions of instructions per second but context-switches still happen in the millisecond time range.</p>
<p>[W15] “You can’t have your cake and eat it”<br />
http://en.wikipedia.org/wiki/You can’t have your cake and eat it<br />
Wikipedia, as of December 2015<br />
The best part of this page is reading all the similar idioms from other languages. In Tamil, you can’t “have both the moustache and drink the soup.”</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-scheduling-multi-level-feedback-queue"><a class="header" href="#8-scheduling-multi-level-feedback-queue">8 Scheduling: Multi-Level Feedback Queue</a></h1>
<p>Trong chương này, chúng ta sẽ giải quyết vấn đề phát triển một trong những phương pháp <strong>scheduling</strong> (lập lịch) nổi tiếng nhất, được gọi là <strong>Multi-level Feedback Queue</strong> (MLFQ – Hàng đợi phản hồi đa mức). Bộ lập lịch MLFQ lần đầu tiên được mô tả bởi Corbato và cộng sự vào năm 1962 [C+62] trong một hệ thống có tên <strong>Compatible Time-Sharing System</strong> (CTSS – Hệ thống chia sẻ thời gian tương thích). Công trình này, cùng với các nghiên cứu sau đó trên hệ thống <strong>Multics</strong>, đã giúp Corbato nhận được giải thưởng cao quý nhất của ACM – <strong>Turing Award</strong>. Thuật toán lập lịch này sau đó đã được tinh chỉnh qua nhiều năm để trở thành các phiên bản triển khai mà bạn sẽ gặp trong một số hệ thống hiện đại.</p>
<p>Vấn đề cơ bản mà MLFQ cố gắng giải quyết gồm hai khía cạnh:</p>
<ol>
<li><strong>Tối ưu hóa turnaround time</strong> (thời gian hoàn thành), mà như chúng ta đã thấy ở phần trước, được thực hiện bằng cách chạy các job (công việc) ngắn trước. Tuy nhiên, hệ điều hành (OS) thường không biết chính xác một job sẽ chạy trong bao lâu – đây lại chính là thông tin mà các thuật toán như <strong>SJF</strong> (Shortest Job First) hoặc <strong>STCF</strong> (Shortest Time-to-Completion First) yêu cầu.</li>
<li><strong>Tăng tính phản hồi</strong> đối với người dùng tương tác (interactive users – ví dụ: người dùng đang ngồi trước màn hình chờ một process (tiến trình) hoàn thành), tức là giảm <strong>response time</strong> (thời gian phản hồi). Các thuật toán như <strong>Round Robin</strong> có thể giảm response time, nhưng lại rất tệ đối với turnaround time.</li>
</ol>
<p>Vậy, vấn đề đặt ra là: khi chúng ta <strong>không biết trước</strong> thông tin về một process, làm thế nào để xây dựng một scheduler (bộ lập lịch) đạt được cả hai mục tiêu trên? Làm thế nào để scheduler có thể <strong>học</strong> được đặc điểm của các job khi hệ thống đang chạy, từ đó đưa ra quyết định lập lịch tốt hơn?</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: HOW TO SCHEDULE WITHOUT PERFECT KNOWLEDGE?</strong><br />
Làm thế nào để thiết kế một scheduler vừa giảm thiểu response time cho các job tương tác, vừa giảm turnaround time, mà không cần biết trước độ dài của job?</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>TIP: LEARN FROM HISTORY</strong><br />
Multi-level Feedback Queue là một ví dụ điển hình về hệ thống <strong>học từ quá khứ để dự đoán tương lai</strong>. Cách tiếp cận này phổ biến trong hệ điều hành (và nhiều lĩnh vực khác của Khoa học Máy tính, bao gồm cả bộ dự đoán nhánh phần cứng – hardware branch predictors – và các thuật toán caching). Phương pháp này hiệu quả khi các job có <strong>các pha hành vi</strong> (behavior phases) và do đó có thể dự đoán được. Tuy nhiên, cần thận trọng vì nếu dự đoán sai, hệ thống có thể đưa ra quyết định còn tệ hơn cả khi không biết gì.</p>
</blockquote>
<h2 id="81-mlfq-các-quy-tắc-cơ-bản"><a class="header" href="#81-mlfq-các-quy-tắc-cơ-bản">8.1 MLFQ: Các quy tắc cơ bản</a></h2>
<p>Để xây dựng một scheduler như vậy, trong chương này chúng ta sẽ mô tả các thuật toán cơ bản đằng sau MLFQ. Mặc dù chi tiết triển khai của nhiều phiên bản MLFQ khác nhau [E95], nhưng hầu hết đều có nguyên tắc tương tự.</p>
<p>Trong mô hình này, MLFQ có một số hàng đợi (queue) riêng biệt, mỗi hàng đợi được gán một <strong>mức ưu tiên</strong> (priority) khác nhau. Tại một thời điểm bất kỳ, một job sẵn sàng chạy sẽ nằm trong <strong>một</strong> hàng đợi duy nhất. MLFQ sử dụng <strong>priority</strong> để quyết định job nào sẽ chạy: job có priority cao hơn (nằm ở hàng đợi cao hơn) sẽ được chọn chạy.</p>
<p>Tất nhiên, có thể có nhiều job trong cùng một hàng đợi, tức là có cùng priority. Trong trường hợp này, chúng ta sẽ sử dụng <strong>Round Robin</strong> để chia sẻ CPU giữa các job đó.</p>
<p>Hai quy tắc cơ bản đầu tiên của MLFQ:</p>
<ul>
<li><strong>Rule 1:</strong> Nếu Priority(A) &gt; Priority(B), A chạy (B không chạy).</li>
<li><strong>Rule 2:</strong> Nếu Priority(A) = Priority(B), A và B chạy theo Round Robin.</li>
</ul>
<p>Điểm mấu chốt của MLFQ nằm ở <strong>cách scheduler thiết lập priority</strong>. Thay vì gán một priority cố định cho mỗi job, MLFQ <strong>thay đổi priority dựa trên hành vi quan sát được</strong>:</p>
<ul>
<li>Nếu một job thường xuyên nhường CPU để chờ nhập liệu từ bàn phím, MLFQ sẽ giữ priority cao cho nó (đặc trưng của process tương tác).</li>
<li>Nếu một job sử dụng CPU liên tục trong thời gian dài, MLFQ sẽ giảm priority của nó.</li>
</ul>
<p>Bằng cách này, MLFQ <strong>học</strong> về process khi nó chạy và dùng <strong>lịch sử</strong> của job để dự đoán hành vi tương lai.</p>
<p>Ví dụ, nếu minh họa trạng thái các hàng đợi tại một thời điểm (Hình 8.1), ta có thể thấy: hai job (A và B) ở mức priority cao nhất, job C ở mức trung bình, và job D ở mức thấp nhất. Theo nguyên tắc MLFQ, scheduler sẽ luân phiên cấp CPU cho A và B, còn C và D sẽ không được chạy – điều này rõ ràng là không công bằng.</p>
<p><img src="08/./img/fig8_1.PNG" alt="" /></p>
<p>Tuy nhiên, chỉ nhìn vào một ảnh chụp tĩnh của các hàng đợi thì chưa thể hiểu rõ MLFQ hoạt động thế nào. Điều quan trọng là phải xem <strong>priority của job thay đổi theo thời gian</strong> ra sao – và đó chính là điều chúng ta sẽ tìm hiểu tiếp theo.</p>
<h2 id="82-lần-thử-thứ-nhất-cách-thay-đổi-priority"><a class="header" href="#82-lần-thử-thứ-nhất-cách-thay-đổi-priority">8.2 Lần thử thứ nhất: Cách thay đổi priority</a></h2>
<p>Bây giờ, chúng ta cần quyết định cách MLFQ sẽ thay đổi priority của một job (và do đó thay đổi hàng đợi của nó) trong suốt vòng đời. Cần nhớ rằng workload của chúng ta là sự kết hợp giữa:</p>
<ul>
<li>Các job tương tác, chạy ngắn (thường xuyên nhường CPU).</li>
<li>Các job <strong>CPU-bound</strong> (dùng CPU nhiều), chạy dài, không yêu cầu response time thấp.</li>
</ul>
<p>Để làm điều này, chúng ta cần một khái niệm mới: <strong>allotment</strong> của job.<br />
Allotment là <strong>lượng thời gian</strong> mà một job có thể chạy ở một mức priority nhất định trước khi scheduler giảm priority của nó. Để đơn giản, ban đầu ta giả sử allotment = một time slice.</p>
<p>Thuật toán điều chỉnh priority đầu tiên:</p>
<ul>
<li><strong>Rule 3:</strong> Khi một job vào hệ thống, nó được đặt ở mức priority cao nhất (hàng đợi trên cùng).</li>
<li><strong>Rule 4a:</strong> Nếu job dùng hết allotment khi chạy, priority của nó bị giảm (chuyển xuống một hàng đợi).</li>
<li><strong>Rule 4b:</strong> Nếu job nhường CPU (ví dụ: thực hiện I/O) trước khi allotment hết, nó giữ nguyên priority (allotment được đặt lại).</li>
</ul>
<p><img src="08/./img/fig8_2.PNG" alt="" /></p>
<p><strong>Hình 8.2:</strong> Job chạy dài theo thời gian</p>
<h3 id="ví-dụ-1-một-job-chạy-dài-duy-nhất"><a class="header" href="#ví-dụ-1-một-job-chạy-dài-duy-nhất"><strong>Ví dụ 1: Một job chạy dài duy nhất</strong></a></h3>
<p>Giả sử có một job chạy dài trong hệ thống, time slice = 10 ms, allotment = time slice. Hình 8.2 minh họa quá trình:</p>
<ul>
<li>Job bắt đầu ở priority cao nhất (Q2).</li>
<li>Sau 10 ms, scheduler giảm priority xuống Q1.</li>
<li>Sau một time slice ở Q1, job bị giảm xuống Q0 (thấp nhất) và ở đó mãi.</li>
</ul>
<h3 id="ví-dụ-2-xuất-hiện-một-job-ngắn"><a class="header" href="#ví-dụ-2-xuất-hiện-một-job-ngắn"><strong>Ví dụ 2: Xuất hiện một job ngắn</strong></a></h3>
<p>Giờ xét trường hợp phức tạp hơn để thấy MLFQ <strong>xấp xỉ SJF</strong>:</p>
<ul>
<li>Job A: chạy dài, CPU-bound.</li>
<li>Job B: chạy ngắn, tương tác.</li>
</ul>
<p>Giả sử A đã chạy một thời gian và đang ở priority thấp nhất. Khi B đến (T = 100 ms), nó được đưa vào priority cao nhất. Vì B chỉ chạy 20 ms, nó hoàn thành trước khi bị giảm xuống priority thấp hơn. Sau đó, A tiếp tục chạy ở priority thấp.</p>
<p>Từ ví dụ này, ta thấy: vì không biết job là ngắn hay dài, MLFQ <strong>giả định ban đầu là job ngắn</strong> và cho priority cao. Nếu đúng là job ngắn, nó sẽ hoàn thành nhanh; nếu không, nó sẽ dần bị đẩy xuống các hàng đợi thấp hơn, trở thành job batch dài hạn. Bằng cách này, MLFQ <strong>xấp xỉ SJF</strong>.</p>
<p><img src="08/./img/fig8_3.PNG" alt="" /></p>
<h3 id="ví-dụ-3-với-io"><a class="header" href="#ví-dụ-3-với-io"><strong>Ví dụ 3: với I/O</strong></a></h3>
<p>Bây giờ, hãy xem một ví dụ có liên quan đến <strong>I/O</strong> (Input/Output – nhập/xuất). Như <strong>Rule 4b</strong> đã nêu ở trên, nếu một <strong>process</strong> (tiến trình) nhường CPU trước khi sử dụng hết <strong>allotment</strong> (phần thời gian được cấp ở một mức ưu tiên), chúng ta sẽ giữ nó ở cùng mức <strong>priority</strong> (ưu tiên). Ý tưởng của quy tắc này rất đơn giản: nếu một <strong>interactive job</strong> (công việc tương tác), ví dụ, thực hiện nhiều thao tác I/O (chẳng hạn chờ nhập liệu từ bàn phím hoặc chuột), nó sẽ nhường CPU trước khi allotment kết thúc; trong trường hợp này, chúng ta không muốn phạt job đó, và do đó giữ nguyên mức priority.</p>
<p><strong>Hình 8.3 (bên phải)</strong> minh họa cách hoạt động: một interactive job B (màu xám) chỉ cần CPU trong 1 ms trước khi thực hiện I/O, cạnh tranh CPU với một <strong>batch job</strong> chạy dài A (màu đen). Cách tiếp cận MLFQ giữ B ở mức priority cao nhất vì B liên tục nhường CPU; nếu B là một interactive job, MLFQ đạt được mục tiêu chạy nhanh các job tương tác.</p>
<h3 id="vấn-đề-với-mlfq-hiện-tại"><a class="header" href="#vấn-đề-với-mlfq-hiện-tại"><strong>Vấn đề với MLFQ hiện tại</strong></a></h3>
<p>Như vậy, chúng ta đã có một MLFQ cơ bản. Nó dường như hoạt động khá tốt: chia sẻ CPU công bằng giữa các job chạy dài, và cho phép các job ngắn hoặc tương tác nhiều với I/O chạy nhanh. Tuy nhiên, cách tiếp cận này vẫn tồn tại những nhược điểm nghiêm trọng. Bạn có đoán ra không?<br />
(Đây là lúc bạn tạm dừng và suy nghĩ một cách “xảo quyệt” nhất có thể)</p>
<ol>
<li><strong>Starvation</strong> (đói CPU): nếu có “quá nhiều” interactive job trong hệ thống, chúng sẽ chiếm toàn bộ thời gian CPU, khiến các job chạy dài không bao giờ nhận được CPU (bị đói). Chúng ta muốn đảm bảo các job này vẫn có tiến triển, ngay cả trong tình huống này.</li>
<li><strong>Gaming the scheduler</strong> (lách luật bộ lập lịch): một người dùng thông minh có thể viết lại chương trình để “đánh lừa” scheduler, nhằm nhận được nhiều tài nguyên hơn mức công bằng. Thuật toán hiện tại dễ bị tấn công như sau: trước khi allotment hết, thực hiện một thao tác I/O (ví dụ ghi/đọc file) để nhường CPU; việc này giúp job ở lại cùng hàng đợi, và do đó nhận được tỷ lệ CPU cao hơn. Nếu làm khéo (ví dụ chạy 99% allotment rồi mới nhường CPU), một job có thể gần như độc chiếm CPU.</li>
<li><strong>Thay đổi hành vi theo thời gian</strong>: một chương trình ban đầu CPU-bound (dùng CPU nhiều) có thể chuyển sang giai đoạn tương tác. Với cách tiếp cận hiện tại, job này sẽ không được đối xử như các interactive job khác.</li>
</ol>
<blockquote>
<blockquote>
<p><strong>TIP: SCHEDULING MUST BE SECURE FROM ATTACK</strong><br />
Bạn có thể nghĩ rằng một <strong>scheduling policy</strong> (chính sách lập lịch), dù bên trong hệ điều hành hay trong bối cảnh rộng hơn (ví dụ: xử lý yêu cầu I/O trong hệ thống lưu trữ phân tán [Y+18]), không liên quan đến bảo mật. Nhưng ngày càng nhiều trường hợp cho thấy điều ngược lại. Hãy xem xét một <strong>data center</strong> hiện đại, nơi người dùng từ khắp thế giới chia sẻ CPU, bộ nhớ, mạng và hệ thống lưu trữ; nếu không cẩn trọng trong thiết kế và thực thi chính sách, một người dùng có thể gây hại cho người khác và giành lợi thế cho mình. Do đó, <strong>scheduling policy</strong> là một phần quan trọng của bảo mật hệ thống và cần được xây dựng cẩn thận.</p>
</blockquote>
</blockquote>
<h2 id="83-lần-thử-2-priority-boost"><a class="header" href="#83-lần-thử-2-priority-boost">8.3 Lần thử #2: Priority Boost</a></h2>
<p>Hãy thử thay đổi quy tắc để tránh vấn đề starvation. Chúng ta có thể làm gì để đảm bảo các job CPU-bound vẫn có tiến triển (dù ít)?</p>
<p>Ý tưởng đơn giản: định kỳ <strong>tăng priority</strong> cho tất cả job trong hệ thống. Có nhiều cách thực hiện, nhưng ta chọn cách đơn giản: đưa tất cả lên hàng đợi cao nhất. Do đó, có thêm quy tắc mới:</p>
<ul>
<li><strong>Rule 5:</strong> Sau một khoảng thời gian <strong>S</strong>, di chuyển tất cả job trong hệ thống lên hàng đợi cao nhất.</li>
</ul>
<p>Quy tắc mới này giải quyết hai vấn đề:</p>
<ol>
<li><strong>Không bị đói CPU</strong>: khi ở hàng đợi cao nhất, job sẽ chia sẻ CPU với các job ưu tiên cao khác theo Round Robin, và cuối cùng sẽ được chạy.</li>
<li><strong>Thay đổi hành vi</strong>: nếu một job CPU-bound trở thành interactive, scheduler sẽ xử lý đúng sau khi job được tăng priority.</li>
</ol>
<p><img src="08/./img/fig8_4.PNG" alt="" /></p>
<p><strong>Ví dụ:</strong> Một job chạy dài cạnh tranh CPU với hai job tương tác ngắn.</p>
<ul>
<li><strong>Hình 8.4 (trái):</strong> Không có priority boost → job chạy dài bị đói khi hai job ngắn xuất hiện.</li>
<li><strong>Hình 8.4 (phải):</strong> Có priority boost mỗi 100 ms (giá trị này có thể quá nhỏ, nhưng dùng để minh họa) → job chạy dài được tăng priority định kỳ và có cơ hội chạy.</li>
</ul>
<p>Tất nhiên, việc thêm khoảng thời gian S dẫn đến câu hỏi: <strong>S nên là bao nhiêu?</strong> John Ousterhout – một nhà nghiên cứu hệ thống nổi tiếng [O11] – gọi các giá trị như vậy là <strong>voo-doo constants</strong> (hằng số “ma thuật”), vì việc chọn đúng giá trị giống như cần phép thuật. Nếu S quá lớn → job chạy dài có thể bị đói; nếu quá nhỏ → job tương tác không được chia CPU hợp lý. Thường thì quản trị viên hệ thống sẽ điều chỉnh, hoặc hiện nay, dùng phương pháp tự động dựa trên <strong>machine learning</strong> [A+17].</p>
<h2 id="84-lần-thử-3-better-accounting"><a class="header" href="#84-lần-thử-3-better-accounting">8.4 Lần thử #3: Better Accounting</a></h2>
<p>Chúng ta còn một vấn đề: <strong>ngăn chặn việc lách luật scheduler</strong>. Thủ phạm chính là <strong>Rules 4a và 4b</strong>, cho phép job giữ nguyên priority nếu nhường CPU trước khi allotment hết. Giải pháp?</p>
<blockquote>
<blockquote>
<p><strong>TIP: AVOID VOO-DOO CONSTANTS (OUSTERHOUT’S LAW)</strong><br />
Tránh dùng <strong>voo-doo constants</strong> là ý tưởng tốt khi có thể. Nhưng như ví dụ trên, điều này thường khó. Có thể làm hệ thống tự học giá trị phù hợp, nhưng cũng không đơn giản. Kết quả thường thấy: một file cấu hình đầy giá trị mặc định, để quản trị viên giàu kinh nghiệm tinh chỉnh khi cần. Thực tế, chúng thường bị bỏ mặc, và chúng ta chỉ hy vọng giá trị mặc định hoạt động tốt. Mẹo này đến từ giáo sư OS John Ousterhout, nên được gọi là <strong>Ousterhout’s Law</strong>.</p>
</blockquote>
</blockquote>
<p><img src="08/./img/fig8_5.PNG" alt="" /></p>
<p><strong>Giải pháp:</strong> Thực hiện <strong>better accounting</strong> (ghi nhận chính xác hơn) thời gian CPU ở mỗi mức MLFQ. Thay vì quên allotment đã dùng khi job thực hiện I/O, scheduler sẽ <strong>ghi nhớ</strong>; khi job dùng hết allotment, nó bị giảm priority, bất kể dùng một lần dài hay nhiều lần ngắn. Do đó, gộp Rules 4a và 4b thành: <strong>Rule 4:</strong> Khi một job dùng hết allotment ở một mức (bất kể bao nhiêu lần nhường CPU), priority của nó bị giảm (chuyển xuống một hàng đợi).</p>
<p><strong>Ví dụ:</strong> <strong>Hình 8.5</strong> cho thấy:</p>
<ul>
<li><strong>Trái:</strong> Với Rules 4a và 4b cũ → job có thể thực hiện I/O trước khi allotment hết, giữ nguyên priority và chiếm CPU.</li>
<li><strong>Phải:</strong> Với better accounting → bất kể hành vi I/O, job sẽ dần bị giảm priority, không thể chiếm CPU quá mức.</li>
</ul>
<h2 id="85-tinh-chỉnh-mlfq-và-các-vấn-đề-khác"><a class="header" href="#85-tinh-chỉnh-mlfq-và-các-vấn-đề-khác">8.5 Tinh chỉnh MLFQ và các vấn đề khác</a></h2>
<p>Một số vấn đề khác cũng phát sinh với <strong>MLFQ scheduling</strong> (lập lịch hàng đợi phản hồi đa mức). Một câu hỏi lớn là làm thế nào để <strong>tham số hóa</strong> (parameterize) một bộ lập lịch như vậy. Ví dụ: nên có bao nhiêu hàng đợi? <strong>Time slice</strong> (lượng thời gian chia cho mỗi tiến trình trong một vòng lập lịch) cho mỗi hàng đợi nên dài bao nhiêu? <strong>Allotment</strong> (tổng thời gian được cấp ở một mức ưu tiên) là bao nhiêu? Bao lâu thì nên <strong>boost priority</strong> (tăng mức ưu tiên) để tránh <strong>starvation</strong> (đói CPU) và phản ánh sự thay đổi trong hành vi của tiến trình?</p>
<p>Không có câu trả lời đơn giản cho những câu hỏi này, và do đó chỉ có kinh nghiệm thực tế với các <strong>workload</strong> (khối lượng công việc) và việc tinh chỉnh bộ lập lịch sau đó mới có thể dẫn đến một sự cân bằng hợp lý.</p>
<p>Ví dụ, hầu hết các biến thể của MLFQ cho phép thay đổi độ dài time slice giữa các hàng đợi khác nhau. Các hàng đợi ưu tiên cao thường được cấp time slice ngắn; chúng bao gồm các <strong>interactive job</strong> (tác vụ tương tác), và do đó việc chuyển đổi nhanh giữa chúng là hợp lý (ví dụ: 10 mili-giây hoặc ít hơn). Ngược lại, các hàng đợi ưu tiên thấp chứa các <strong>long-running job</strong> (tác vụ chạy dài) vốn <strong>CPU-bound</strong> (phụ thuộc nhiều vào CPU); vì vậy, time slice dài hơn sẽ hiệu quả hơn (ví dụ: hàng trăm mili-giây).</p>
<p>Hình 8.6 minh họa một ví dụ trong đó hai job chạy 20 ms ở hàng đợi cao nhất (với time slice 10 ms), 40 ms ở hàng giữa (time slice 20 ms), và với time slice 40 ms ở hàng thấp nhất.</p>
<p><img src="08/./img/fig8_6.PNG" alt="" /></p>
<p><strong>Hình 8.6:</strong> Mức ưu tiên thấp hơn, lượng thời gian (quanta) dài hơn.</p>
<p>Triển khai MLFQ của <strong>Solaris</strong> — lớp lập lịch <strong>Time-Sharing</strong> (TS) — đặc biệt dễ cấu hình; nó cung cấp một tập hợp các bảng xác định chính xác cách mức ưu tiên của một <strong>process</strong> (tiến trình) thay đổi trong suốt vòng đời của nó, độ dài mỗi time slice, và tần suất tăng mức ưu tiên của một job [AD00]. Quản trị viên có thể chỉnh sửa bảng này để khiến bộ lập lịch hoạt động theo những cách khác nhau.</p>
<p>Giá trị mặc định của bảng là 60 hàng đợi, với độ dài time slice tăng dần từ 20 mili-giây (ưu tiên cao nhất) đến vài trăm mili-giây (ưu tiên thấp nhất), và mức ưu tiên được tăng khoảng mỗi 1 giây.</p>
<p>Các bộ lập lịch MLFQ khác không sử dụng bảng hoặc các quy tắc chính xác như mô tả trong chương này; thay vào đó, chúng điều chỉnh mức ưu tiên bằng các công thức toán học. Ví dụ, bộ lập lịch <strong>FreeBSD</strong> (phiên bản 4.3) sử dụng một công thức để tính mức ưu tiên hiện tại của một job, dựa trên lượng CPU mà process đã sử dụng [LM+89]; ngoài ra, mức sử dụng này bị <strong>decay</strong> (giảm dần) theo thời gian, cung cấp hiệu ứng tăng ưu tiên theo một cách khác so với mô tả ở đây. Xem bài báo của Epema để có cái nhìn tổng quan xuất sắc về các thuật toán <strong>decay-usage</strong> và đặc tính của chúng [E95].</p>
<p>Cuối cùng, nhiều bộ lập lịch còn có một số tính năng khác mà bạn có thể gặp. Ví dụ, một số bộ lập lịch dành các mức ưu tiên cao nhất cho công việc của hệ điều hành; do đó các job của người dùng thông thường sẽ không bao giờ đạt được mức ưu tiên cao nhất trong hệ thống. Một số hệ thống cũng cho phép người dùng cung cấp <strong>advice</strong> (gợi ý) để giúp thiết lập mức ưu tiên; ví dụ, bằng cách sử dụng tiện ích dòng lệnh <code>nice</code>, bạn có thể tăng hoặc giảm mức ưu tiên của một job (ở một mức độ nhất định) và do đó tăng hoặc giảm khả năng nó được chạy tại một thời điểm nhất định. Xem <strong>man page</strong> để biết thêm chi tiết.</p>
<blockquote>
<p><strong>TIP: USE ADVICE WHERE POSSIBLE</strong><br />
Vì hệ điều hành hiếm khi biết điều gì là tốt nhất cho từng process trong hệ thống, nên việc cung cấp các giao diện cho phép người dùng hoặc quản trị viên đưa ra một số gợi ý cho OS thường rất hữu ích. Chúng ta thường gọi những gợi ý này là <em>advice</em>, vì OS không nhất thiết phải tuân theo, nhưng có thể cân nhắc chúng để đưa ra quyết định tốt hơn. Những gợi ý như vậy hữu ích ở nhiều phần của OS, bao gồm bộ lập lịch (ví dụ: với <code>nice</code>), <strong>memory manager</strong> (trình quản lý bộ nhớ, ví dụ: <code>madvise</code>), và <strong>file system</strong> (hệ thống tệp, ví dụ: <em>informed prefetching</em> và <em>caching</em> [P+95]).</p>
</blockquote>
<h2 id="86-mlfq-tóm-tắt"><a class="header" href="#86-mlfq-tóm-tắt">8.6 MLFQ: Tóm tắt</a></h2>
<p>Chúng ta đã mô tả một phương pháp lập lịch được gọi là <strong>Multi-Level Feedback Queue</strong> (MLFQ — hàng đợi phản hồi đa mức). Hy vọng bạn đã thấy lý do tại sao nó được gọi như vậy: nó có nhiều mức hàng đợi, và sử dụng <strong>feedback</strong> (phản hồi) để xác định mức ưu tiên của một job nhất định. Lịch sử thực thi là kim chỉ nam: quan sát cách các job hoạt động theo thời gian và xử lý chúng tương ứng.</p>
<p>Bộ quy tắc MLFQ đã được tinh chỉnh, rải rác trong chương, được tổng hợp lại ở đây:</p>
<ul>
<li><strong>Rule 1:</strong> Nếu Priority(A) &gt; Priority(B), A chạy (B không chạy).</li>
<li><strong>Rule 2:</strong> Nếu Priority(A) = Priority(B), A và B chạy theo kiểu <strong>round-robin</strong> (xoay vòng) sử dụng time slice (độ dài quantum) của hàng đợi tương ứng.</li>
<li><strong>Rule 3:</strong> Khi một job vào hệ thống, nó được đặt ở mức ưu tiên cao nhất (hàng đợi trên cùng).</li>
<li><strong>Rule 4:</strong> Khi một job sử dụng hết allotment (tổng thời gian được cấp) ở một mức (bất kể nó đã nhường CPU bao nhiêu lần), mức ưu tiên của nó bị giảm (tức là nó xuống một hàng đợi).</li>
<li><strong>Rule 5:</strong> Sau một khoảng thời gian S, di chuyển tất cả các job trong hệ thống lên hàng đợi trên cùng.</li>
</ul>
<p>MLFQ thú vị ở chỗ: thay vì yêu cầu biết trước bản chất của một job, nó quan sát quá trình thực thi và ưu tiên nó tương ứng. Theo cách này, nó đạt được lợi ích của cả hai thế giới: có thể cung cấp hiệu năng tổng thể xuất sắc (tương tự <strong>SJF/STCF</strong>) cho các job tương tác ngắn hạn, đồng thời vẫn công bằng và đảm bảo tiến độ cho các workload dài hạn, tiêu tốn nhiều CPU.</p>
<p>Vì lý do này, nhiều hệ thống, bao gồm các biến thể <strong>BSD UNIX</strong> [LM+89, B86], <strong>Solaris</strong> [M06], và <strong>Windows NT</strong> cùng các hệ điều hành Windows sau này [CS97], sử dụng một dạng MLFQ làm bộ lập lịch (scheduler) cơ sở.</p>
<h2 id="tham-khảo-5"><a class="header" href="#tham-khảo-5">Tham khảo</a></h2>
<p>[AD00] “Multilevel Feedback Queue Scheduling in Solaris”<br />
Andrea Arpaci-Dusseau<br />
Available: http://www.ostep.org/Citations/notes-solaris.pdf<br />
A great short set of notes by one of the authors on the details of the Solaris scheduler. OK, we are probably biased in this description, but the notes are pretty darn good.</p>
<p>[B86] “The Design of the UNIX Operating System”<br />
M.J. Bach<br />
Prentice-Hall, 1986<br />
One of the classic old books on how a real UNIX operating system is built; a definite must-read for kernel hackers.</p>
<p>[C+62] “An Experimental Time-Sharing System”<br />
F. J. Corbato, M. M. Daggett, R. C. Daley<br />
IFIPS 1962<br />
A bit hard to read, but the source of many of the first ideas in multi-level feedback scheduling. Much of this later went into Multics, which one could argue was the most influential operating system of all time.</p>
<p>[CS97] “Inside Windows NT”<br />
Helen Custer and David A. Solomon<br />
Microsoft Press, 1997<br />
The NT book, if you want to learn about something other than UNIX. Of course, why would you? OK, we’re kidding; you might actually work for Microsoft some day you know.</p>
<p>[E95] “An Analysis of Decay-Usage Scheduling in Multiprocessors”<br />
D.H.J. Epema<br />
SIGMETRICS ’95<br />
A nice paper on the state of the art of scheduling back in the mid 1990s, including a good overview of the basic approach behind decay-usage schedulers.</p>
<p>[LM+89] “The Design and Implementation of the 4.3BSD UNIX Operating System”<br />
S.J. Leffler, M.K. McKusick, M.J. Karels, J.S. Quarterman<br />
Addison-Wesley, 1989<br />
Another OS classic, written by four of the main people behind BSD. The later versions of this book, while more up to date, don’t quite match the beauty of this one.</p>
<p>[M06] “Solaris Internals: Solaris 10 and OpenSolaris Kernel Architecture”<br />
Richard McDougall<br />
Prentice-Hall, 2006<br />
A good book about Solaris and how it works.</p>
<p>[O11] “John Ousterhout’s Home Page”
John Ousterhout
Available: http://www.stanford.edu/˜ouster/
The home page of the famous Professor Ousterhout. The two co-authors of this book had the pleasure of
taking graduate operating systems from Ousterhout while in graduate school; indeed, this is where the
two co-authors got to know each other, eventually leading to marriage, kids, and even this book. Thus,
you really can blame Ousterhout for this entire mess you’re in.</p>
<p>[P+95] “Informed Prefetching and Caching”
R.H. Patterson, G.A. Gibson, E. Ginting, D. Stodolsky, J. Zelenka
SOSP ’95
A fun paper about some very cool ideas in file systems, including how applications can give the OS
advice about what files it is accessing and how it plans to access them</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-lập-lịch-chia-sẻ-theo-tỷ-lệ-proportional-share"><a class="header" href="#9-lập-lịch-chia-sẻ-theo-tỷ-lệ-proportional-share">9. Lập lịch: Chia sẻ theo tỷ lệ (Proportional Share)</a></h1>
<p>Trong chương này, chúng ta sẽ tìm hiểu một loại <strong>scheduler</strong> (bộ lập lịch) khác được gọi là <strong>proportional-share scheduler</strong> (bộ lập lịch chia sẻ theo tỷ lệ), đôi khi còn được gọi là <strong>fair-share scheduler</strong> (bộ lập lịch chia sẻ công bằng).</p>
<p>Proportional-share dựa trên một ý tưởng đơn giản: thay vì tối ưu cho <strong>turnaround time</strong> (thời gian hoàn thành) hoặc <strong>response time</strong> (thời gian phản hồi), bộ lập lịch có thể cố gắng đảm bảo rằng mỗi <strong>job</strong> (tác vụ) nhận được một tỷ lệ phần trăm nhất định của thời gian CPU.</p>
<p>Một ví dụ tiêu biểu ban đầu về proportional-share scheduling được tìm thấy trong nghiên cứu của Waldspurger và Weihl [WW94], được gọi là <strong>lottery scheduling</strong> (lập lịch xổ số); tuy nhiên, ý tưởng này thực tế còn xuất hiện sớm hơn [KL88]. Ý tưởng cơ bản rất đơn giản: định kỳ tổ chức một “xổ số” để xác định process (tiến trình) nào sẽ được chạy tiếp theo; process nào cần chạy thường xuyên hơn sẽ được cấp nhiều “cơ hội trúng” hơn. Nghe đơn giản phải không? Giờ hãy đi vào chi tiết! Nhưng trước hết, chúng ta có một điểm mấu chốt:</p>
<blockquote>
<p><strong>CRUX: HOW TO SHARE THE CPU PROPORTIONALLY</strong><br />
Làm thế nào để thiết kế một bộ lập lịch chia sẻ CPU theo tỷ lệ? Những cơ chế chính để thực hiện điều đó là gì? Chúng hiệu quả đến mức nào?</p>
</blockquote>
<h2 id="91-khái-niệm-cơ-bản-ticket-đại-diện-cho-phần-chia-của-bạn"><a class="header" href="#91-khái-niệm-cơ-bản-ticket-đại-diện-cho-phần-chia-của-bạn">9.1 Khái niệm cơ bản: Ticket đại diện cho phần chia của bạn</a></h2>
<p>Cốt lõi của lottery scheduling là một khái niệm rất cơ bản: <strong>ticket</strong> (vé), được dùng để biểu diễn phần tài nguyên mà một process (hoặc người dùng, hoặc thực thể khác) nên nhận được. Tỷ lệ phần trăm số ticket mà một process sở hữu chính là tỷ lệ phần tài nguyên hệ thống mà nó được cấp.</p>
<p>Ví dụ: giả sử có hai process, A và B, trong đó A có 75 ticket và B chỉ có 25 ticket. Như vậy, chúng ta muốn A nhận 75% thời gian CPU và B nhận 25% còn lại.</p>
<p>Lottery scheduling đạt được điều này theo cách <strong>xác suất</strong> (probabilistic, nhưng không phải <strong>tất định</strong> — deterministic) bằng cách tổ chức một “xổ số” định kỳ (ví dụ: mỗi time slice). Cách tổ chức xổ số rất đơn giản: bộ lập lịch cần biết tổng số ticket (trong ví dụ này là 100). Sau đó, bộ lập lịch chọn một ticket thắng, là một số từ 0 đến 99^[1]. Giả sử A giữ các ticket từ 0 đến 74 và B giữ từ 75 đến 99, ticket thắng sẽ quyết định A hay B được chạy. Bộ lập lịch sau đó nạp trạng thái của process thắng và chạy nó.</p>
<blockquote>
<p><strong>TIP: USE RANDOMNESS</strong><br />
Một trong những điểm thú vị nhất của lottery scheduling là việc sử dụng <strong>randomness</strong> (tính ngẫu nhiên). Khi cần đưa ra quyết định, cách tiếp cận ngẫu nhiên thường là một phương pháp đơn giản và mạnh mẽ. Random có ít nhất ba ưu điểm so với các quyết định truyền thống:</p>
<ol>
<li>Random thường tránh được các tình huống “góc khuất” (corner case) mà thuật toán truyền thống có thể gặp khó khăn. Ví dụ: chính sách thay thế LRU (Least Recently Used — sẽ được nghiên cứu kỹ hơn trong chương về virtual memory) thường là một thuật toán tốt, nhưng có thể đạt hiệu năng tệ nhất với một số workload tuần hoàn-tuần tự. Random thì không có trường hợp tệ nhất như vậy.</li>
<li>Random nhẹ về tài nguyên, yêu cầu rất ít trạng thái để theo dõi các lựa chọn. Trong một thuật toán fair-share truyền thống, việc theo dõi lượng CPU mỗi process đã dùng cần <strong>per-process accounting</strong> (ghi nhận riêng cho từng process), phải cập nhật sau mỗi lần chạy. Random chỉ cần lưu trạng thái tối thiểu (ví dụ: số ticket mỗi process có).</li>
<li>Random có thể rất nhanh. Miễn là việc sinh số ngẫu nhiên nhanh, thì quyết định cũng nhanh, và do đó random có thể được dùng ở nhiều nơi yêu cầu tốc độ. Tất nhiên, càng yêu cầu nhanh thì random càng có xu hướng trở thành <strong>pseudo-random</strong> (giả ngẫu nhiên).</li>
</ol>
</blockquote>
<p>Ví dụ kết quả các ticket thắng của một lottery scheduler:</p>
<pre><code>63 85 70 39 76 17 29 41 36 39 10 99 68 83 63 62 43 0 49 49
</code></pre>
<p>Lịch chạy tương ứng:</p>
<pre><code>A   A A   A A A A A A   A   A A A A A A
  B     B             B   B
</code></pre>
<p>Như bạn thấy, việc sử dụng randomness trong lottery scheduling dẫn đến tính đúng đắn theo xác suất trong việc đạt tỷ lệ mong muốn, nhưng không có đảm bảo tuyệt đối. Trong ví dụ trên, B chỉ chạy 4 trên 20 time slice (20%), thay vì 25% như mong muốn. Tuy nhiên, khi hai job này chạy lâu hơn, xác suất đạt đúng tỷ lệ sẽ cao hơn.</p>
<p>^[1]: Các nhà khoa học máy tính luôn bắt đầu đếm từ 0. Điều này kỳ lạ với người ngoài ngành đến mức có người nổi tiếng đã viết về lý do tại sao chúng ta làm vậy [D82].</p>
<blockquote>
<p><strong>TIP: USE TICKETS TO REPRESENT SHARES</strong><br />
Một trong những cơ chế mạnh mẽ (và cơ bản) nhất trong thiết kế lottery (và stride) scheduling là <strong>ticket</strong>. Ticket được dùng để biểu diễn phần CPU của một process trong ví dụ này, nhưng có thể áp dụng rộng hơn. Ví dụ: trong nghiên cứu gần đây về quản lý virtual memory cho hypervisor, Waldspurger cho thấy ticket có thể được dùng để biểu diễn phần bộ nhớ của một hệ điều hành khách [W02]. Vì vậy, nếu bạn cần một cơ chế để biểu diễn tỷ lệ sở hữu, khái niệm này có thể chính là... “tấm vé” bạn cần.</p>
</blockquote>
<h2 id="92-các-cơ-chế-với-ticket"><a class="header" href="#92-các-cơ-chế-với-ticket">9.2 Các cơ chế với Ticket</a></h2>
<p>Lottery scheduling cung cấp nhiều cơ chế để thao tác với ticket theo những cách khác nhau và đôi khi hữu ích.</p>
<p><strong>1. Ticket currency</strong><br />
Currency cho phép một người dùng với một tập ticket phân bổ chúng cho các job của mình theo bất kỳ “đơn vị tiền tệ” nào họ muốn; hệ thống sẽ tự động chuyển đổi đơn vị này sang giá trị toàn cục.</p>
<p>Ví dụ: giả sử người dùng A và B mỗi người được cấp 100 ticket.</p>
<ul>
<li>Người dùng A chạy hai job, A1 và A2, và cấp cho mỗi job 500 ticket (trong tổng 1000 ticket theo “đơn vị” của A).</li>
<li>Người dùng B chỉ chạy một job và cấp cho nó 10 ticket (trong tổng 10 ticket theo “đơn vị” của B).</li>
</ul>
<p>Hệ thống sẽ chuyển đổi:</p>
<ul>
<li>A1 và A2 từ 500 ticket mỗi (theo đơn vị của A) thành 50 ticket mỗi (theo đơn vị toàn cục).</li>
<li>B1 từ 10 ticket thành 100 ticket (theo đơn vị toàn cục).</li>
</ul>
<p>Xổ số sau đó được tổ chức trên tổng số ticket toàn cục (200) để xác định job nào chạy.</p>
<pre><code>User A -&gt; 500 (A’s currency) to A1 -&gt; 50 (global currency)  
       -&gt; 500 (A’s currency) to A2 -&gt; 50 (global currency)  
User B -&gt; 10 (B’s currency) to B1 -&gt; 100 (global currency)  
</code></pre>
<p><strong>2. Ticket transfer</strong><br />
Một process có thể tạm thời chuyển ticket của mình cho process khác. Điều này đặc biệt hữu ích trong mô hình client/server, khi client gửi yêu cầu cho server xử lý. Để tăng tốc, client có thể chuyển ticket cho server để server có nhiều CPU hơn khi xử lý yêu cầu. Khi xong, server trả lại ticket cho client.</p>
<p><strong>3. Ticket inflation</strong><br />
Một process có thể tạm thời tăng hoặc giảm số ticket mình sở hữu. Trong môi trường cạnh tranh không tin tưởng, điều này không hợp lý (vì process tham lam có thể tự cấp cho mình nhiều ticket và chiếm CPU). Nhưng trong môi trường tin cậy, nếu một process biết mình cần nhiều CPU hơn, nó có thể tăng ticket để phản ánh nhu cầu đó mà không cần trao đổi với process khác.</p>
<pre><code class="language-c">// counter: dùng để theo dõi đã tìm thấy process thắng chưa
int counter = 0;
// winner: gọi bộ sinh số ngẫu nhiên để
//         lấy giá trị &gt;= 0 và &lt;= (totaltickets - 1)
int winner = getrandom(0, totaltickets);

// current: dùng để duyệt qua danh sách job
node_t *current = head;
while (current) {
  counter = counter + current-&gt;tickets;
  if (counter &gt; winner)
    break; // tìm thấy process thắng
  current = current-&gt;next;
}
// 'current' là process thắng: lập lịch cho nó...
</code></pre>
<p><strong>Hình 9.1:</strong> Mã quyết định lập lịch kiểu Lottery</p>
<h2 id="93-implementation"><a class="header" href="#93-implementation">9.3 Implementation</a></h2>
<p>Probably the most amazing thing about lottery scheduling is the simplicity of its implementation. All you need is a good random number generator to pick the winning ticket, a data structure to track the processes of the system (e.g., a list), and the total number of tickets. Let’s assume we keep the processes in a list. Here is an example comprised of three processes, A, B, and C, each with some number of tickets.</p>
<p><img src="09/./img/fig9_1_1.PNG" alt="" /></p>
<p>Để đưa ra quyết định lập lịch, trước tiên chúng ta phải chọn một số ngẫu nhiên (<strong>winner</strong>) từ tổng số ticket (400)^[2]. Giả sử chúng ta chọn số 300. Sau đó, ta chỉ cần duyệt qua danh sách, sử dụng một biến đếm (<strong>counter</strong>) đơn giản để giúp tìm ra ticket thắng (Hình 9.1).</p>
<p><img src="09/./img/fig9_1.PNG" alt="" /></p>
<p>Đoạn code sẽ duyệt danh sách <strong>process</strong> (tiến trình), cộng số ticket của mỗi process vào <code>counter</code> cho đến khi giá trị này vượt quá <code>winner</code>. Khi điều đó xảy ra, phần tử hiện tại trong danh sách chính là process thắng.</p>
<p>Với ví dụ ticket thắng là 300, quá trình diễn ra như sau:</p>
<ul>
<li>Ban đầu, <code>counter</code> được tăng lên 100 để tính số ticket của A; vì 100 &lt; 300, vòng lặp tiếp tục.</li>
<li>Sau đó, <code>counter</code> được cập nhật thành 150 (thêm ticket của B), vẫn nhỏ hơn 300 nên tiếp tục.</li>
<li>Cuối cùng, <code>counter</code> được cập nhật thành 400 (rõ ràng &gt; 300), và do đó vòng lặp kết thúc với <code>current</code> trỏ tới C (process thắng).</li>
</ul>
<p>^[2]: Thật bất ngờ, như Björn Lindberg đã chỉ ra, việc này có thể khó thực hiện đúng; xem thêm chi tiết tại: http://stackoverflow.com/questions/2509679/how-to-generate-a-random-number-from-within-a-range</p>
<p><img src="09/./img/fig9_2.PNG" alt="" /></p>
<p><strong>Hình 9.2:</strong> Nghiên cứu tính công bằng của Lottery Scheduling</p>
<p>Để quá trình này hiệu quả nhất, thông thường tốt nhất là sắp xếp danh sách theo thứ tự giảm dần số ticket. Thứ tự này không ảnh hưởng đến tính đúng đắn của thuật toán; tuy nhiên, nó giúp giảm số vòng lặp cần duyệt, đặc biệt khi có một vài process sở hữu phần lớn số ticket.</p>
<h2 id="94-ví-dụ-minh-họa"><a class="header" href="#94-ví-dụ-minh-họa">9.4 Ví dụ minh họa</a></h2>
<p>Để giúp hiểu rõ hơn động lực của lottery scheduling, chúng ta thực hiện một nghiên cứu ngắn về thời gian hoàn thành của hai <strong>job</strong> cạnh tranh với nhau, mỗi job có cùng số ticket (100) và cùng thời gian chạy (R, sẽ thay đổi).</p>
<p>Trong kịch bản này, chúng ta muốn mỗi job hoàn thành gần như cùng lúc, nhưng do tính ngẫu nhiên của lottery scheduling, đôi khi một job sẽ hoàn thành trước job kia.</p>
<p>Để định lượng sự khác biệt này, ta định nghĩa một chỉ số công bằng đơn giản <strong>F</strong>, bằng thời điểm job hoàn thành trước chia cho thời điểm job hoàn thành sau. Ví dụ: nếu R = 10, job đầu tiên hoàn thành ở thời điểm 10 và job thứ hai ở thời điểm 20, thì F = 10/20 = 0.5. Khi cả hai job hoàn thành gần như cùng lúc, F sẽ gần bằng 1. Mục tiêu của chúng ta là đạt F = 1 (bộ lập lịch hoàn toàn công bằng).</p>
<p>Hình 9.2 biểu diễn đồ thị giá trị công bằng trung bình khi thay đổi độ dài R của hai job từ 1 đến 1000, qua 30 lần thử (kết quả được tạo bởi trình mô phỏng ở cuối chương). Như bạn thấy, khi thời gian chạy của job ngắn, công bằng trung bình có thể khá thấp. Chỉ khi các job chạy qua nhiều time slice, lottery scheduler mới tiến gần đến kết quả công bằng mong muốn.</p>
<h2 id="95-gán-ticket-như-thế-nào"><a class="header" href="#95-gán-ticket-như-thế-nào">9.5 Gán ticket như thế nào?</a></h2>
<p>Một vấn đề chúng ta chưa giải quyết với lottery scheduling là: <strong>làm thế nào để gán ticket cho các job?</strong></p>
<p>Đây là một vấn đề khó, vì hành vi của hệ thống phụ thuộc mạnh vào cách phân bổ ticket. Một cách tiếp cận là giả định người dùng biết rõ nhất; trong trường hợp đó, mỗi người dùng được cấp một số ticket và họ có thể phân bổ cho các job của mình tùy ý. Tuy nhiên, đây thực chất không phải là giải pháp, vì nó không chỉ ra cách phân bổ tối ưu. Do đó, với một tập job cho trước, “bài toán gán ticket” vẫn còn bỏ ngỏ.</p>
<h2 id="96-stride-scheduling"><a class="header" href="#96-stride-scheduling">9.6 Stride Scheduling</a></h2>
<p>Bạn có thể tự hỏi: tại sao phải dùng ngẫu nhiên? Như đã thấy, randomness giúp tạo ra một bộ lập lịch đơn giản và gần đúng, nhưng đôi khi không đạt tỷ lệ chính xác, đặc biệt trong khoảng thời gian ngắn. Vì lý do này, Waldspurger đã phát minh <strong>stride scheduling</strong> — một bộ lập lịch fair-share <strong>deterministic</strong> (tất định) [W95].</p>
<p>Stride scheduling cũng khá đơn giản: mỗi job trong hệ thống có một <strong>stride</strong>, tỷ lệ nghịch với số ticket mà nó có. Trong ví dụ trước, với A, B, C lần lượt có 100, 50 và 250 ticket, ta tính stride bằng cách lấy một số lớn chia cho số ticket. Nếu lấy 10.000 chia cho số ticket, ta được stride của A, B, C lần lượt là 100, 200 và 40.</p>
<p>Mỗi khi một process chạy, ta tăng <strong>pass value</strong> (giá trị pass) của nó thêm stride để theo dõi tiến trình toàn cục.</p>
<p>Bộ lập lịch chọn process có pass value nhỏ nhất để chạy; khi chạy xong, tăng pass value của nó thêm stride.</p>
<p>Pseudocode từ Waldspurger [W95]:</p>
<pre><code class="language-c">curr = remove_min(queue); // chọn process có pass nhỏ nhất
schedule(curr);           // chạy trong một quantum
curr-&gt;pass += curr-&gt;stride; // cập nhật pass
insert(queue, curr);      // đưa lại vào hàng đợi
</code></pre>
<p>Ví dụ: ban đầu A, B, C đều có pass = 0. Giả sử chọn A, pass của A = 100. Tiếp theo chạy B, pass = 200. Chạy C, pass = 40. Lúc này C nhỏ nhất, chạy tiếp, pass = 80, rồi lại chạy C, pass = 120. Tiếp theo A (pass = 200, bằng B). Sau đó C chạy hai lần nữa (pass = 160, rồi 200). Khi tất cả pass bằng nhau, chu kỳ lặp lại.</p>
<p><img src="09/./img/fig9_3.PNG" alt="" /></p>
<p><strong>Hình 9.3:</strong> Dấu vết hoạt động của Stride Scheduling</p>
<p>Kết quả: C chạy 5 lần, A chạy 2 lần, B chạy 1 lần — đúng tỷ lệ ticket 250:100:50. Lottery đạt tỷ lệ theo xác suất, stride đạt chính xác sau mỗi chu kỳ.</p>
<p>Điểm khác biệt lớn: stride cần <strong>global state</strong> (trạng thái toàn cục). Nếu một job mới vào giữa chừng, đặt pass = 0 sẽ khiến nó chiếm CPU. Lottery thì không cần global state; chỉ cần thêm process mới với số ticket của nó và cập nhật tổng ticket.</p>
<h2 id="97-linux-completely-fair-scheduler-cfs"><a class="header" href="#97-linux-completely-fair-scheduler-cfs">9.7 Linux Completely Fair Scheduler (CFS)</a></h2>
<p>Dù có các nghiên cứu trước về fair-share scheduling, Linux hiện tại đạt mục tiêu tương tự theo cách khác. <strong>Completely Fair Scheduler (CFS)</strong> [J09] thực hiện fair-share scheduling một cách hiệu quả và mở rộng tốt.</p>
<p>Mục tiêu: giảm tối đa thời gian đưa ra quyết định lập lịch, nhờ thiết kế và cấu trúc dữ liệu phù hợp. Nghiên cứu tại Google cho thấy, ngay cả sau tối ưu mạnh, lập lịch vẫn chiếm ~5% CPU của toàn bộ datacenter [K+15]. Giảm overhead này là mục tiêu quan trọng.</p>
<p><img src="09/./img/fig9_4.PNG" alt="" /></p>
<p><strong>Hình 9.4:</strong> Ví dụ đơn giản về CFS</p>
<h3 id="hoạt-động-cơ-bản"><a class="header" href="#hoạt-động-cơ-bản">Hoạt động cơ bản</a></h3>
<p>Khác với hầu hết scheduler dựa trên time slice cố định, CFS chia CPU công bằng cho tất cả process cạnh tranh, dùng kỹ thuật <strong>virtual runtime (vruntime)</strong>. Khi process chạy, vruntime của nó tăng theo thời gian thực. Khi cần lập lịch, CFS chọn process có vruntime nhỏ nhất.</p>
<p>Vấn đề: khi nào dừng process hiện tại để chạy process khác? Nếu chuyển quá thường xuyên → công bằng cao nhưng overhead lớn (context switching nhiều). Nếu chuyển ít → hiệu năng cao nhưng công bằng ngắn hạn giảm.</p>
<p>CFS điều chỉnh qua tham số <code>sched_latency</code>: giá trị này quyết định tổng thời gian để tất cả process được chạy một lần. Mặc định ~48 ms; chia cho số process (n) để ra time slice động cho mỗi process.</p>
<p>Ví dụ: n = 4 → mỗi process có 12 ms. CFS chạy job đầu tiên 12 ms, rồi chọn job có vruntime thấp nhất tiếp theo. Trong Hình 9.4, 4 job (A, B, C, D) mỗi job chạy 2 time slice; sau đó C, D hoàn thành, A và B chạy luân phiên 24 ms.</p>
<h2 id="khi-có-quá-nhiều-process-đang-chạy"><a class="header" href="#khi-có-quá-nhiều-process-đang-chạy">Khi có “quá nhiều” process đang chạy</a></h2>
<p>Nhưng điều gì sẽ xảy ra nếu có “quá nhiều” <strong>process</strong> (tiến trình) đang chạy? Điều đó chẳng phải sẽ dẫn đến <strong>time slice</strong> (lượng thời gian chia cho mỗi tiến trình) quá nhỏ, và do đó gây ra quá nhiều <strong>context switch</strong> (chuyển ngữ cảnh) hay sao? Câu hỏi hay! Và câu trả lời là: đúng vậy.</p>
<p>Để giải quyết vấn đề này, <strong>CFS</strong> (Completely Fair Scheduler) bổ sung một tham số khác, <code>min_granularity</code>, thường được đặt ở giá trị như 6 ms. CFS sẽ không bao giờ đặt time slice của một process nhỏ hơn giá trị này, nhằm đảm bảo không tốn quá nhiều thời gian cho chi phí lập lịch (<strong>scheduling overhead</strong>).</p>
<p>Ví dụ: nếu có 10 process đang chạy, phép tính ban đầu sẽ chia <code>sched_latency</code> cho 10 để xác định time slice (kết quả: 4.8 ms). Tuy nhiên, do có <code>min_granularity</code>, CFS sẽ đặt time slice của mỗi process thành 6 ms. Mặc dù CFS sẽ không hoàn toàn công bằng tuyệt đối trong khoảng thời gian <code>sched_latency</code> mục tiêu (48 ms), nhưng nó sẽ gần đạt được, đồng thời vẫn duy trì hiệu suất CPU cao.</p>
<p>Lưu ý rằng CFS sử dụng <strong>periodic timer interrupt</strong> (ngắt định kỳ), nghĩa là nó chỉ có thể đưa ra quyết định tại các khoảng thời gian cố định. Ngắt này xảy ra thường xuyên (ví dụ: mỗi 1 ms), cho phép CFS “thức dậy” và xác định xem job hiện tại đã chạy hết thời gian của nó chưa. Nếu một job có time slice không phải là bội số hoàn hảo của khoảng thời gian ngắt, điều đó vẫn ổn; CFS theo dõi <strong>vruntime</strong> (thời gian chạy ảo) một cách chính xác, nghĩa là về lâu dài, nó sẽ tiệm cận việc chia sẻ CPU lý tưởng.</p>
<h3 id="trọng-số-weighting-và-niceness"><a class="header" href="#trọng-số-weighting-và-niceness">Trọng số (Weighting) và Niceness</a></h3>
<p>CFS cũng cho phép điều khiển mức ưu tiên (<strong>priority</strong>) của process, cho phép người dùng hoặc quản trị viên cấp cho một số process phần CPU lớn hơn. CFS không làm điều này bằng <strong>ticket</strong> như lottery scheduling, mà thông qua một cơ chế cổ điển của UNIX được gọi là <strong>nice level</strong> của process.</p>
<p>Tham số <code>nice</code> có thể được đặt từ -20 đến +19 cho một process, với giá trị mặc định là 0. Giá trị <code>nice</code> dương nghĩa là ưu tiên thấp hơn, còn giá trị âm nghĩa là ưu tiên cao hơn; nói cách khác, “quá nice” thì sẽ ít được hệ thống chú ý hơn trong lập lịch.</p>
<p>CFS ánh xạ giá trị <code>nice</code> của mỗi process sang một <strong>weight</strong> (trọng số), như trong bảng sau:</p>
<p><img src="09/img/fig9_4_1.PNG" alt="" /></p>
<p>Các trọng số này cho phép tính <strong>effective time slice</strong> (time slice hiệu dụng) của mỗi process (giống như cách tính trước đây), nhưng giờ có tính đến sự khác biệt về mức ưu tiên.</p>
<p>Công thức tính như sau, giả sử có n process:</p>
<p>$$
\text{time_slice}_i = \frac{\text{weight}<em>i}{\sum</em>{j=0}^{n-1} \text{weight}_j} \times \text{sched_latency}
$$
<em>(9.1)</em></p>
<p>Ví dụ: giả sử có hai job, A và B. A, vì là job “quý giá” nhất, được cấp ưu tiên cao hơn với <code>nice = -5</code>; B, vì “chúng ta ghét nó”<sup class="footnote-reference"><a href="#3">1</a></sup>, giữ mức ưu tiên mặc định (<code>nice = 0</code>). Điều này có nghĩa <code>weight_A</code> (từ bảng) là 3121, còn <code>weight_B</code> là 1024. Khi tính time slice, ta sẽ thấy A có khoảng 43% của <code>sched_latency</code> (tức ~36 ms), còn B có khoảng 14% (tức ~12 ms).</p>
<p>Ngoài việc tổng quát hóa phép tính time slice, cách CFS tính <strong>vruntime</strong> cũng phải được điều chỉnh. Công thức mới lấy thời gian chạy thực tế của process i (<code>runtime_i</code>) và nhân với tỷ lệ nghịch của trọng số process đó, bằng cách chia <strong>default weight</strong> (1024, ký hiệu <code>weight_0</code>) cho <code>weight_i</code>. Trong ví dụ này, vruntime của A sẽ tăng với tốc độ bằng 1/3 so với B.</p>
<p>$$
\text{vruntime}_i = \text{runtime}_i \times \frac{\text{weight}_0}{\text{weight}_i}
$$
<em>(9.2)</em></p>
<p>Một điểm thông minh trong việc xây dựng bảng trọng số là: bảng này giữ nguyên tỷ lệ chia sẻ CPU khi chênh lệch giá trị <code>nice</code> là hằng số. Ví dụ: nếu process A có <code>nice = 5</code> (thay vì -5) và process B có <code>nice = 10</code> (thay vì 0), CFS sẽ lập lịch chúng giống hệt như trước. Bạn có thể tự tính để thấy điều này.</p>
<h3 id="sử-dụng-red-black-tree"><a class="header" href="#sử-dụng-red-black-tree">Sử dụng Red-Black Tree</a></h3>
<p>Một trọng tâm lớn của CFS là <strong>hiệu suất</strong>. Với một scheduler, hiệu suất có nhiều khía cạnh, nhưng một trong số đó rất đơn giản: khi cần tìm job tiếp theo để chạy, bộ lập lịch phải làm điều đó nhanh nhất có thể.</p>
<p>Cấu trúc dữ liệu đơn giản như <strong>list</strong> (danh sách) không mở rộng tốt: các hệ thống hiện đại đôi khi có hàng nghìn process, và việc tìm kiếm trong một danh sách dài mỗi vài mili-giây là lãng phí.</p>
<p>CFS giải quyết điều này bằng cách lưu các process trong một <strong>red-black tree</strong> [B72]. Red-black tree là một dạng <strong>balanced tree</strong> (cây cân bằng); khác với <strong>binary tree</strong> (cây nhị phân) đơn giản (có thể thoái hóa thành dạng danh sách trong trường hợp chèn xấu nhất), cây cân bằng thực hiện thêm một số thao tác để duy trì độ sâu thấp, đảm bảo các thao tác có độ phức tạp <strong>logarithmic</strong> (O(log n)) thay vì tuyến tính.</p>
<p>CFS không lưu tất cả process trong cấu trúc này; chỉ các process đang chạy hoặc sẵn sàng chạy (<strong>runnable</strong>) mới được lưu. Nếu một process chuyển sang trạng thái ngủ (ví dụ: chờ I/O hoàn tất hoặc chờ gói tin mạng), nó sẽ bị loại khỏi cây và được quản lý ở nơi khác.</p>
<p>Ví dụ: giả sử có 10 job với giá trị vruntime lần lượt: 1, 5, 9, 10, 14, 18, 17, 21, 22, 24. Nếu lưu các job này trong một danh sách có thứ tự, việc tìm job tiếp theo để chạy rất đơn giản: chỉ cần lấy phần tử đầu tiên. Tuy nhiên, khi đưa job đó trở lại danh sách (đúng vị trí), ta phải quét danh sách để tìm chỗ chèn, một thao tác O(n). Việc tìm kiếm cũng kém hiệu quả, mất thời gian tuyến tính trung bình.</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">1</sup>
<p>Vâng, chúng tôi cố tình dùng ngữ pháp “sai” ở đây, xin đừng gửi báo lỗi. Vì sao? Chỉ là một ám chỉ nhẹ đến <em>Chúa tể những chiếc nhẫn</em> và nhân vật phản anh hùng Gollum yêu thích của chúng tôi, không có gì nghiêm trọng.</p>
</div>
<p><img src="09/img/fig9_5.PNG" alt="" /></p>
<p><strong>Hình 9.5:</strong> Cây Red-Black trong CFS</p>
<p>Khi lưu các giá trị này trong red-black tree, hầu hết các thao tác trở nên hiệu quả hơn. Các process được sắp xếp trong cây theo vruntime, và hầu hết các thao tác (như chèn hoặc xóa) đều có độ phức tạp O(log n). Khi n lên đến hàng nghìn, O(log n) nhanh hơn tuyến tính một cách đáng kể.</p>
<h3 id="xử-lý-io-và-các-process-đang-ngủ-sleeping-processes"><a class="header" href="#xử-lý-io-và-các-process-đang-ngủ-sleeping-processes">Xử lý I/O và các process đang ngủ (Sleeping Processes)</a></h3>
<p>Một vấn đề phát sinh khi chọn <strong>vruntime</strong> (thời gian chạy ảo) nhỏ nhất để chạy tiếp theo là với các <strong>job</strong> (tác vụ) đã ở trạng thái ngủ (<strong>sleep</strong>) trong một khoảng thời gian dài.</p>
<p>Hãy tưởng tượng có hai <strong>process</strong> (tiến trình) A và B:</p>
<ul>
<li>A chạy liên tục.</li>
<li>B ngủ trong một khoảng thời gian dài (ví dụ: 10 giây).</li>
</ul>
<p>Khi B thức dậy, vruntime của nó sẽ chậm hơn A tới 10 giây, và do đó (nếu không cẩn thận), B sẽ chiếm CPU trong 10 giây tiếp theo để “bù lại”, dẫn đến việc A bị <strong>starvation</strong> (đói CPU).</p>
<p><strong>CFS</strong> (Completely Fair Scheduler) xử lý trường hợp này bằng cách điều chỉnh vruntime của job khi nó thức dậy. Cụ thể, CFS đặt vruntime của job đó bằng giá trị nhỏ nhất tìm thấy trong <strong>cây</strong> (tree) — nhớ rằng cây này chỉ chứa các job đang chạy [B+18].</p>
<p>Bằng cách này, CFS tránh được starvation, nhưng không phải không có cái giá phải trả: các job ngủ trong thời gian ngắn và thức dậy thường xuyên có thể sẽ không bao giờ nhận được phần CPU công bằng của mình [AC97].</p>
<h3 id="các-tính-năng-thú-vị-khác-của-cfs"><a class="header" href="#các-tính-năng-thú-vị-khác-của-cfs">Các tính năng thú vị khác của CFS</a></h3>
<p>CFS có rất nhiều tính năng khác, quá nhiều để bàn hết ở thời điểm này. Nó bao gồm nhiều <strong>heuristic</strong> (phương pháp kinh nghiệm) để cải thiện hiệu năng <strong>cache</strong>, có các chiến lược xử lý hiệu quả khi có nhiều CPU (sẽ được thảo luận ở phần sau của sách), có khả năng lập lịch trên các nhóm process lớn (thay vì coi mỗi process là một thực thể độc lập), và nhiều tính năng thú vị khác.</p>
<p>Bạn có thể đọc các nghiên cứu gần đây, bắt đầu từ Bouron [B+18], để tìm hiểu thêm.</p>
<blockquote>
<p><strong>TIP: USE EFFICIENT DATA STRUCTURES WHEN APPROPRIATE</strong><br />
Trong nhiều trường hợp, một <strong>list</strong> (danh sách) là đủ. Nhưng cũng có nhiều trường hợp thì không. Việc biết khi nào nên dùng cấu trúc dữ liệu nào là một dấu hiệu của kỹ thuật tốt. Trong trường hợp được thảo luận ở đây, các danh sách đơn giản được dùng trong các scheduler trước đây không hoạt động tốt trên các hệ thống hiện đại, đặc biệt là trong các máy chủ tải nặng ở <strong>datacenter</strong>. Những hệ thống này có hàng nghìn process đang hoạt động; việc tìm kiếm trong một danh sách dài để chọn job tiếp theo cho mỗi lõi CPU vài mili-giây một lần sẽ lãng phí chu kỳ CPU quý giá.<br />
Một cấu trúc tốt hơn là cần thiết, và CFS đã cung cấp điều đó bằng cách triển khai xuất sắc <strong>red-black tree</strong>.<br />
Nói chung, khi chọn cấu trúc dữ liệu cho hệ thống bạn đang xây dựng, hãy cân nhắc kỹ <strong>mẫu truy cập</strong> (access pattern) và <strong>tần suất sử dụng</strong>; hiểu rõ những điều này sẽ giúp bạn triển khai cấu trúc phù hợp cho nhiệm vụ.</p>
</blockquote>
<h2 id="98-tóm-tắt"><a class="header" href="#98-tóm-tắt">9.8 Tóm tắt</a></h2>
<p>Chúng ta đã giới thiệu khái niệm <strong>proportional-share scheduling</strong> (lập lịch chia sẻ theo tỷ lệ) và thảo luận ngắn gọn ba phương pháp:</p>
<ul>
<li><strong>Lottery scheduling</strong>: sử dụng tính ngẫu nhiên một cách thông minh để đạt chia sẻ theo tỷ lệ.</li>
<li><strong>Stride scheduling</strong>: đạt được điều này một cách <strong>deterministic</strong> (tất định).</li>
<li><strong>Completely Fair Scheduler (CFS)</strong> của Linux: bộ lập lịch “thực” duy nhất được bàn trong chương này, hoạt động giống <strong>weighted round-robin</strong> (vòng quay ưu tiên theo trọng số) với time slice động, nhưng được thiết kế để mở rộng và hoạt động tốt dưới tải; theo hiểu biết của chúng ta, đây là bộ lập lịch fair-share được sử dụng rộng rãi nhất hiện nay.</li>
</ul>
<p>Không có bộ lập lịch nào là “thuốc chữa bách bệnh”, và các fair-share scheduler cũng có những vấn đề riêng. Một vấn đề là các phương pháp này không kết hợp tốt với I/O [AC97]; như đã đề cập, các job thực hiện I/O thỉnh thoảng có thể không nhận được phần CPU công bằng. Một vấn đề khác là chúng bỏ ngỏ bài toán khó về phân bổ ticket hoặc priority — ví dụ: làm sao biết trình duyệt của bạn nên được cấp bao nhiêu ticket, hoặc đặt <code>nice</code> value nào cho trình soạn thảo văn bản?</p>
<p>Các scheduler đa dụng khác (như <strong>MLFQ</strong> đã bàn trước đó, và các scheduler Linux tương tự) xử lý các vấn đề này tự động, do đó có thể dễ triển khai hơn.</p>
<p>Tin tốt là có nhiều lĩnh vực mà các vấn đề này không phải mối quan tâm chính, và các proportional-share scheduler được sử dụng rất hiệu quả. Ví dụ: trong một <strong>virtualized data center</strong> (trung tâm dữ liệu ảo hóa) hoặc <strong>cloud</strong>, nơi bạn muốn cấp 1/4 chu kỳ CPU cho máy ảo Windows và phần còn lại cho hệ thống Linux gốc, chia sẻ theo tỷ lệ có thể đơn giản và hiệu quả.</p>
<p>Ý tưởng này cũng có thể mở rộng cho các tài nguyên khác; xem Waldspurger [W02] để biết chi tiết về cách chia sẻ bộ nhớ theo tỷ lệ trong <strong>VMWare ESX Server</strong>.</p>
<h2 id="tham-khảo-6"><a class="header" href="#tham-khảo-6">Tham khảo</a></h2>
<p>[AC97] “Extending Proportional-Share Scheduling to a Network of Workstations”<br />
Andrea C. Arpaci-Dusseau and David E. Culler<br />
PDPTA’97, June 1997<br />
A paper by one of the authors on how to extend proportional-share scheduling to work better in a clustered environment.</p>
<p>[D82] “Why Numbering Should Start At Zero”<br />
Edsger Dijkstra, August 1982<br />
http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF<br />
A short note from E. Dijkstra, one of the pioneers of computer science. We’ll be hearing much more on this guy in the section on Concurrency. In the meanwhile, enjoy this note, which includes this motivating quote: “One of my colleagues — not a computing scientist — accused a number of younger computing scientists of ’pedantry’ because they started numbering at zero.” The note explains why doing so is logical.</p>
<p>[KL88] “A Fair Share Scheduler”<br />
J. Kay and P. Lauder<br />
CACM, Volume 31 Issue 1, January 1988<br />
An early reference to a fair-share scheduler.</p>
<p>[WW94] “Lottery Scheduling: Flexible Proportional-Share Resource Management”<br />
Carl A. Waldspurger and William E. Weihl<br />
OSDI ’94, November 1994<br />
The landmark paper on lottery scheduling that got the systems community re-energized about scheduling, fair sharing, and the power of simple randomized algorithms.</p>
<p>[W95] “Lottery and Stride Scheduling: Flexible<br />
Proportional-Share Resource Management”<br />
Carl A. Waldspurger<br />
Ph.D. Thesis, MIT, 1995<br />
The award-winning thesis of Waldspurger’s that outlines lottery and stride scheduling. If you’re thinking of writing a Ph.D. dissertation at some point, you should always have a good example around, to give you something to strive for: this is such a good one.</p>
<p>[W02] “Memory Resource Management in VMware ESX Server”<br />
Carl A. Waldspurger<br />
OSDI ’02, Boston, Massachusetts<br />
The paper to read about memory management in VMMs (a.k.a., hypervisors). In addition to being relatively easy to read, the paper contains numerous cool ideas about this new type of VMM-level memory management.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-multiprocessor-scheduling-lập-lịch-trên-đa-bộ-xử-lý--nâng-cao"><a class="header" href="#10-multiprocessor-scheduling-lập-lịch-trên-đa-bộ-xử-lý--nâng-cao">10. Multiprocessor Scheduling (Lập lịch trên đa bộ xử lý – nâng cao)</a></h1>
<p>Chương này sẽ giới thiệu những khái niệm cơ bản về multiprocessor scheduling (lập lịch trên hệ thống đa bộ xử lý). Vì đây là một chủ đề tương đối nâng cao, nên tốt nhất là bạn nên học sau khi đã nghiên cứu chi tiết về concurrency (tính đồng thời) – tức phần “easy piece” thứ hai của cuốn sách.</p>
<p>Sau nhiều năm chỉ tồn tại trong các hệ thống máy tính cao cấp, ngày nay multiprocessor systems (hệ thống đa bộ xử lý) đã trở nên phổ biến, xuất hiện trong cả máy tính để bàn, laptop, và thậm chí cả thiết bị di động. Sự gia tăng này chủ yếu nhờ multicore processor (bộ xử lý đa lõi), trong đó nhiều CPU core (lõi CPU) được tích hợp trên một chip duy nhất. Các chip này trở nên phổ biến vì các kiến trúc sư máy tính gặp khó khăn trong việc làm cho một CPU đơn nhanh hơn mà không tiêu tốn quá nhiều năng lượng. Do đó, hầu hết chúng ta hiện nay đều có vài CPU sẵn sàng phục vụ — nghe có vẻ tuyệt, đúng không?</p>
<p>Tất nhiên, sự xuất hiện của nhiều CPU cũng mang lại nhiều vấn đề. Vấn đề chính là: một ứng dụng điển hình (ví dụ một chương trình C bạn viết) chỉ sử dụng một CPU; thêm nhiều CPU không khiến ứng dụng đơn lẻ đó chạy nhanh hơn. Để giải quyết, bạn phải viết lại ứng dụng để chạy song song, có thể bằng cách dùng threads (luồng) như đã bàn trong phần hai của cuốn sách. Multithreaded applications (ứng dụng đa luồng) có thể phân chia công việc cho nhiều CPU và do đó chạy nhanh hơn khi có thêm tài nguyên CPU.</p>
<blockquote>
<p><strong>ASIDE: ADVANCED CHAPTERS</strong>
Các chương nâng cao yêu cầu kiến thức từ nhiều phần của cuốn sách để hiểu đầy đủ, mặc dù về mặt logic chúng phù hợp ở những phần trước đó. Ví dụ, chương này về multiprocessor scheduling sẽ dễ hiểu hơn nếu bạn đã đọc phần giữa về concurrency; tuy nhiên, về mặt cấu trúc, nó lại phù hợp ở phần về virtualization (ảo hóa) và CPU scheduling (lập lịch CPU). Do đó, khuyến nghị là các chương này nên được học “không theo thứ tự”; trong trường hợp này, sau phần hai của cuốn sách.</p>
</blockquote>
<p><img src="10/./img/fig10_1.PNG" alt="" /></p>
<p><em>Figure 10.1: Single CPU With Cache</em></p>
<p>Ngoài các ứng dụng, một vấn đề mới nảy sinh cho operating system (hệ điều hành), đó là multiprocessor scheduling. Trước giờ ta đã bàn nhiều nguyên tắc về single-processor scheduling (lập lịch trên hệ thống một bộ xử lý); vậy làm sao mở rộng chúng cho nhiều CPU? Những vấn đề mới nào cần giải quyết? Do đó, câu hỏi đặt ra:</p>
<blockquote>
<p><strong>CRUX: HOW TO SCHEDULE JOBS ON MULTIPLE CPUS</strong>
Hệ điều hành nên lập lịch jobs (tác vụ) trên nhiều CPU như thế nào? Vấn đề mới nào phát sinh? Các kỹ thuật cũ có còn hiệu quả không, hay cần những ý tưởng mới?</p>
</blockquote>
<h2 id="101-kiến-thức-nền-kiến-trúc-multiprocessor"><a class="header" href="#101-kiến-thức-nền-kiến-trúc-multiprocessor">10.1 Kiến thức nền: Kiến trúc multiprocessor</a></h2>
<p>Để hiểu vấn đề trong multiprocessor scheduling, ta phải nắm sự khác biệt cơ bản giữa phần cứng single-CPU và multi-CPU. Khác biệt này nằm ở hardware caches (bộ nhớ đệm phần cứng, xem Hình 10.1) và cách dữ liệu được chia sẻ giữa nhiều bộ xử lý. Ta sẽ bàn ở mức khái quát; chi tiết có thể tham khảo [CSG99] hoặc các khóa học kiến trúc máy tính nâng cao.</p>
<p>Trong hệ thống single CPU, tồn tại một hệ thống phân cấp cache nhằm giúp CPU chạy chương trình nhanh hơn. Cache là bộ nhớ nhỏ, nhanh, dùng để lưu tạm các bản sao dữ liệu phổ biến vốn nằm trong main memory (bộ nhớ chính). Main memory thì chứa toàn bộ dữ liệu nhưng truy cập chậm hơn nhiều. Bằng cách giữ dữ liệu thường xuyên dùng trong cache, hệ thống khiến bộ nhớ lớn và chậm trông giống như một bộ nhớ nhanh.</p>
<p><img src="10/./img/fig10_2.PNG" alt="" /></p>
<p><em>Figure 10.2: Two CPUs With Caches Sharing Memory</em></p>
<p>Ví dụ: giả sử có một chương trình thực hiện lệnh load để lấy dữ liệu từ bộ nhớ trong một hệ thống single CPU. CPU có một cache nhỏ (ví dụ 64 KB) và một main memory lớn. Lần đầu tiên load, dữ liệu nằm ở main memory nên phải mất hàng chục hoặc hàng trăm nanosecond. CPU, đoán rằng dữ liệu có thể sẽ được dùng lại, sẽ lưu một bản sao trong cache. Lần sau, khi load lại cùng dữ liệu đó, CPU sẽ tìm trong cache; nếu có, nó chỉ mất vài nanosecond để lấy, khiến chương trình chạy nhanh hơn.</p>
<p>Cache dựa trên nguyên lý locality (tính cục bộ), có hai loại: temporal locality (cục bộ theo thời gian) và spatial locality (cục bộ theo không gian). Temporal locality: dữ liệu được truy cập một lần thì có khả năng sẽ được truy cập lại sớm (ví dụ biến trong vòng lặp). Spatial locality: khi chương trình truy cập địa chỉ x thì có khả năng sẽ truy cập các địa chỉ gần x (ví dụ duyệt mảng). Nhờ tính cục bộ này, hệ thống phần cứng có thể dự đoán dữ liệu nào nên đưa vào cache.</p>
<p>Nhưng điều gì xảy ra khi ta có nhiều CPU cùng dùng chung một main memory (Hình 10.2)?</p>
<p>Trong trường hợp này, caching trở nên phức tạp hơn nhiều. Ví dụ: chương trình trên CPU 1 đọc dữ liệu D tại địa chỉ A; vì cache CPU 1 chưa có, hệ thống lấy từ main memory. Sau đó, chương trình sửa dữ liệu tại A thành D′ nhưng chỉ cập nhật cache CPU 1 (ghi xuống main memory chậm nên thường trì hoãn). Nếu OS sau đó chuyển chương trình sang CPU 2, chương trình lại đọc A; vì cache CPU 2 chưa có, hệ thống lấy từ main memory và nhận giá trị cũ D thay vì D′. Sai rồi! Đây gọi là vấn đề cache coherence (tính nhất quán của cache). Có rất nhiều nghiên cứu giải quyết vấn đề này [SHW11]. Ở đây ta chỉ nói khái quát; chi tiết bạn nên học trong các khóa kiến trúc máy tính.</p>
<p>Giải pháp cơ bản được phần cứng cung cấp: giám sát các truy cập bộ nhớ để đảm bảo mọi CPU thấy cùng một trạng thái bộ nhớ chung. Một cách phổ biến trên hệ thống bus là dùng bus snooping [G83]; mỗi cache theo dõi các cập nhật trên bus nối với main memory. Khi thấy dữ liệu mà nó giữ bị thay đổi, nó sẽ tự vô hiệu hóa bản sao (invalidate) hoặc cập nhật. Tuy write-back cache (ghi chậm xuống bộ nhớ) làm mọi thứ phức tạp hơn, nhưng ý tưởng chính vẫn tương tự.</p>
<h2 id="102-Đừng-quên-synchronization"><a class="header" href="#102-Đừng-quên-synchronization">10.2 Đừng quên Synchronization</a></h2>
<p>Mặc dù cache đã xử lý coherence, liệu chương trình (hoặc chính OS) có cần lo lắng khi truy cập dữ liệu chia sẻ không? Đáp án là <strong>có</strong>. Đây chính là nội dung lớn trong phần concurrency.</p>
<p>Khi truy cập (đặc biệt là cập nhật) dữ liệu chia sẻ trên nhiều CPU, ta cần mutual exclusion primitives (cơ chế loại trừ lẫn nhau) như locks để đảm bảo tính đúng đắn. Ví dụ: với một shared queue, nếu nhiều CPU thêm/xóa phần tử đồng thời mà không dùng lock, sẽ phát sinh lỗi logic, ngay cả khi hệ thống có protocol coherence. Locks đảm bảo cập nhật atomically (nguyên tử).</p>
<p>Xem ví dụ đoạn code xóa phần tử khỏi linked list ở Hình 10.3. Nếu hai threads chạy cùng lúc trên hai CPU, cả hai đều đọc cùng một giá trị <code>head</code>, và cả hai đều cố gắng xóa cùng một phần tử — dẫn tới lỗi nghiêm trọng (như double free).</p>
<pre><code class="language-c">typedef struct __Node_t {
  int value;
  struct __Node_t *next;
} Node_t;

// ...

int List_Pop() {
  Node_t *tmp = head; // remember old head
  int value = head-&gt;value; // ... and its value
  head = head-&gt;next; // advance to next
  free(tmp); // free old head
  return value; // return value @head
}
</code></pre>
<p><em>Hình 10.3: Code xóa phần tử trong danh sách liên kết</em></p>
<p>Giải pháp: dùng lock. Ví dụ: khai báo <code>pthread_mutex_t m;</code> rồi đặt <code>lock(&amp;m)</code> ở đầu hàm và <code>unlock(&amp;m)</code> ở cuối. Tuy nhiên, khi số CPU tăng, việc truy cập cấu trúc dữ liệu đồng bộ sẽ trở nên chậm hơn.</p>
<h2 id="103-cache-affinity"><a class="header" href="#103-cache-affinity">10.3 Cache Affinity</a></h2>
<p>Một vấn đề khác trong multiprocessor scheduling là cache affinity [TTG95]. Nghĩa là: khi một process chạy trên một CPU, nó tạo ra trạng thái trong cache và TLB của CPU đó. Lần sau chạy lại trên cùng CPU, nó sẽ nhanh hơn. Nếu bị chuyển CPU liên tục, hiệu năng giảm vì phải nạp lại cache. Do đó, scheduler nên xem xét cache affinity, cố gắng giữ process trên cùng một CPU nếu có thể.</p>
<h2 id="104-single-queue-scheduling-lập-lịch-hàng-đợi-đơn"><a class="header" href="#104-single-queue-scheduling-lập-lịch-hàng-đợi-đơn">10.4 Single-Queue Scheduling (Lập lịch hàng đợi đơn)</a></h2>
<p>Với phần kiến thức nền tảng đã có, bây giờ chúng ta sẽ thảo luận cách xây dựng một <strong>scheduler</strong> (bộ lập lịch) cho hệ thống <strong>multiprocessor</strong> (đa bộ xử lý). Cách tiếp cận cơ bản nhất là tái sử dụng khung lập lịch cho <strong>single processor</strong> (bộ xử lý đơn), bằng cách đưa tất cả các <strong>job</strong> (công việc) cần lập lịch vào <strong>một hàng đợi duy nhất</strong>; chúng ta gọi cách này là <strong>single-queue multiprocessor scheduling</strong> hay viết tắt là <strong>SQMS</strong>.</p>
<p>Cách tiếp cận này có ưu điểm là <strong>đơn giản</strong>; không cần nhiều công sức để lấy một chính sách lập lịch hiện có (chọn job tốt nhất để chạy tiếp theo) và điều chỉnh nó để hoạt động trên nhiều CPU (ví dụ: nếu có hai CPU, nó sẽ chọn hai job tốt nhất để chạy).</p>
<p>Tuy nhiên, SQMS có những hạn chế rõ ràng. Vấn đề đầu tiên là <strong>thiếu khả năng mở rộng</strong> (scalability). Để đảm bảo scheduler hoạt động đúng trên nhiều CPU, lập trình viên sẽ phải chèn một số cơ chế <strong>locking</strong> (khóa) vào mã nguồn, như đã mô tả ở phần trước. Lock đảm bảo rằng khi mã SQMS truy cập vào hàng đợi duy nhất (ví dụ: để tìm job tiếp theo để chạy), kết quả sẽ chính xác.</p>
<p>Đáng tiếc là lock có thể làm giảm hiệu năng nghiêm trọng, đặc biệt khi số lượng CPU trong hệ thống tăng lên [A90]. Khi mức độ tranh chấp (contention) đối với lock này tăng, hệ thống sẽ tốn nhiều thời gian hơn cho việc xử lý lock và ít thời gian hơn cho công việc thực sự cần làm (lưu ý: sẽ rất tốt nếu có số liệu đo thực tế ở đây).</p>
<p>Vấn đề lớn thứ hai của SQMS là <strong>cache affinity</strong> (tính gắn kết với bộ nhớ đệm CPU). Ví dụ, giả sử chúng ta có 5 job cần chạy (A, B, C, D, E) và 4 bộ xử lý. Hàng đợi lập lịch của chúng ta sẽ trông như sau:</p>
<p><img src="10/./img/fig10_3_1.PNG" alt="" /></p>
<p>Theo thời gian, giả sử mỗi job chạy trong một <strong>time slice</strong> (lượng thời gian CPU cấp cho một lần chạy) rồi một job khác được chọn, ta có thể có lịch chạy trên các CPU như sau:</p>
<p><img src="10/./img/fig10_3_2.PNG" alt="" /></p>
<p>Vì mỗi CPU chỉ đơn giản chọn job tiếp theo từ hàng đợi dùng chung toàn cục, nên mỗi job sẽ bị “nhảy” từ CPU này sang CPU khác, hoàn toàn ngược lại với nguyên tắc tối ưu cache affinity.</p>
<p>Để xử lý vấn đề này, hầu hết các SQMS scheduler bao gồm một cơ chế <strong>affinity</strong> để tăng khả năng một <strong>process</strong> (tiến trình) sẽ tiếp tục chạy trên cùng một CPU nếu có thể. Cụ thể, có thể giữ affinity cho một số job, nhưng di chuyển các job khác để cân bằng tải. Ví dụ, với 5 job như trên, ta có thể lập lịch như sau:</p>
<p><img src="10/./img/fig10_3_3.PNG" alt="" /></p>
<p>Trong cách sắp xếp này, các job A đến D không bị di chuyển giữa các CPU, chỉ có job E di chuyển, do đó giữ được affinity cho hầu hết. Lần tiếp theo, bạn có thể chọn di chuyển một job khác để đạt <strong>affinity fairness</strong> (công bằng về affinity). Tuy nhiên, triển khai cơ chế này có thể phức tạp.</p>
<p>Tóm lại, SQMS có điểm mạnh và điểm yếu: dễ triển khai nếu đã có scheduler cho single CPU (vốn chỉ có một hàng đợi), nhưng không mở rộng tốt (do chi phí đồng bộ hóa) và không dễ duy trì cache affinity.</p>
<h2 id="105-multi-queue-scheduling-lập-lịch-đa-hàng-đợi"><a class="header" href="#105-multi-queue-scheduling-lập-lịch-đa-hàng-đợi">10.5 Multi-Queue Scheduling (Lập lịch đa hàng đợi)</a></h2>
<p>Do các vấn đề của single-queue scheduler, một số hệ thống chọn cách dùng <strong>nhiều hàng đợi</strong>, ví dụ: mỗi CPU một hàng đợi. Cách này gọi là <strong>multi-queue multiprocessor scheduling</strong> (MQMS).</p>
<p>Trong MQMS, khung lập lịch cơ bản bao gồm nhiều hàng đợi lập lịch. Mỗi hàng đợi có thể áp dụng một <strong>scheduling discipline</strong> (kỷ luật lập lịch) nhất định, như <strong>round robin</strong>, mặc dù bất kỳ thuật toán nào cũng có thể dùng. Khi một job vào hệ thống, nó được đặt vào <strong>một</strong> hàng đợi duy nhất, theo một <strong>heuristic</strong> (quy tắc kinh nghiệm) nào đó (ví dụ: ngẫu nhiên, hoặc chọn hàng đợi có ít job hơn). Sau đó, job được lập lịch gần như độc lập, tránh được vấn đề chia sẻ thông tin và đồng bộ hóa của cách single-queue.</p>
<p>Ví dụ, giả sử hệ thống có 2 CPU (CPU 0 và CPU 1), và một số job vào hệ thống: A, B, C, D. Vì mỗi CPU có một hàng đợi lập lịch riêng, OS phải quyết định đưa mỗi job vào hàng đợi nào. Có thể như sau:</p>
<p><img src="10/./img/fig10_3_4.PNG" alt="" /></p>
<p>Tùy theo chính sách lập lịch của hàng đợi, mỗi CPU sẽ có hai job để chọn khi quyết định chạy. Ví dụ, với round robin, hệ thống có thể tạo ra lịch chạy như sau:</p>
<p><img src="10/./img/fig10_3_5.PNG" alt="" /></p>
<p>MQMS có ưu thế rõ rệt so với SQMS ở chỗ nó <strong>tự nhiên mở rộng tốt hơn</strong>. Khi số CPU tăng, số hàng đợi cũng tăng, do đó lock và cache contention không trở thành vấn đề trung tâm. Ngoài ra, MQMS vốn dĩ duy trì cache affinity: job ở nguyên trên cùng một CPU và tận dụng dữ liệu đã được cache.</p>
<p>Tuy nhiên, cách tiếp cận này lại xuất hiện một vấn đề mới, mang tính cơ bản: <strong>load imbalance</strong> (mất cân bằng tải). Giả sử vẫn như trên (4 job, 2 CPU), nhưng một job (C) kết thúc. Khi đó, các hàng đợi lập lịch sẽ như sau:</p>
<p><img src="10/./img/fig10_3_6.PNG" alt="" /></p>
<p>Nếu chạy round robin trên mỗi hàng đợi, ta sẽ có lịch chạy:</p>
<p><img src="10/./img/fig10_3_7.PNG" alt="" /></p>
<p>Như thấy, A nhận gấp đôi CPU so với B và D, điều này không mong muốn. Tệ hơn, giả sử cả A và C kết thúc, chỉ còn B và D. Khi đó:</p>
<p><img src="10/./img/fig10_3_8.PNG" alt="" /></p>
<p><img src="10/./img/fig10_3_9.PNG" alt="" /></p>
<p>Thật tệ — CPU 0 bị <strong>idle</strong> (nhàn rỗi)! Và biểu đồ sử dụng CPU trông thật “buồn”.</p>
<blockquote>
<blockquote>
<p><strong>CRUX: HOW TO DEAL WITH LOAD IMBALANCE</strong><br />
Làm thế nào để một multi-queue multiprocessor scheduler xử lý load imbalance, nhằm đạt được mục tiêu lập lịch mong muốn?</p>
</blockquote>
</blockquote>
<p>Câu trả lời hiển nhiên là <strong>di chuyển job</strong> — kỹ thuật gọi là <strong>migration</strong>. Bằng cách di chuyển một job từ CPU này sang CPU khác, ta có thể đạt cân bằng tải thực sự.</p>
<p>Ví dụ: nếu một CPU rảnh và CPU kia có job, OS chỉ cần di chuyển một trong B hoặc D sang CPU 0. Kết quả: tải cân bằng, mọi người đều vui.</p>
<p><img src="10/./img/fig10_3_10.PNG" alt="" /></p>
<p>Trường hợp khó hơn: A ở một mình trên CPU 0, B và D luân phiên trên CPU 1.</p>
<p><img src="10/./img/fig10_3_11.PNG" alt="" /></p>
<p>Lúc này, di chuyển một job duy nhất không giải quyết được vấn đề. Giải pháp là <strong>liên tục migration</strong> một hoặc nhiều job. Một cách là luân phiên đổi job: ban đầu A ở CPU 0, B và D ở CPU 1; sau vài time slice, di chuyển B sang CPU 0 để chạy cùng A, trong khi D chạy một mình trên CPU 1. Kết quả: tải cân bằng.</p>
<p><img src="10/./img/fig10_3_12.PNG" alt="" /></p>
<p>Tất nhiên, còn nhiều mẫu migration khác. Nhưng câu hỏi khó là: <strong>khi nào</strong> hệ thống nên thực hiện migration?</p>
<p>Một cách cơ bản là dùng kỹ thuật <strong>work stealing</strong> [FLR98]. Với work stealing, một hàng đợi <strong>source</strong> (nguồn) ít job sẽ thỉnh thoảng “nhìn” sang hàng đợi <strong>target</strong> (đích) để xem nó đầy thế nào. Nếu target đầy hơn đáng kể, source sẽ “steal” (lấy) một hoặc nhiều job từ target để cân bằng tải.</p>
<p>Tuy nhiên, kỹ thuật này có sự đánh đổi: nếu kiểm tra các hàng đợi khác quá thường xuyên → overhead cao, khó mở rộng (đi ngược mục tiêu MQMS). Nếu kiểm tra quá ít → nguy cơ load imbalance nghiêm trọng. Việc tìm ngưỡng phù hợp vẫn là một “nghệ thuật đen” (black art) trong thiết kế chính sách hệ thống.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Ít ai biết rằng hành tinh Cybertron đã bị hủy diệt bởi các quyết định lập lịch CPU tồi tệ. Và đây sẽ là lần đầu tiên và cuối cùng cuốn sách nhắc tới Transformers.</p>
</div>
<h2 id="106-linux-multiprocessor-schedulers-bộ-lập-lịch-đa-bộ-xử-lý-trong-linux"><a class="header" href="#106-linux-multiprocessor-schedulers-bộ-lập-lịch-đa-bộ-xử-lý-trong-linux">10.6 Linux Multiprocessor Schedulers (Bộ lập lịch đa bộ xử lý trong Linux)</a></h2>
<p>Điều thú vị là trong cộng đồng <strong>Linux</strong>, chưa có một giải pháp chung nào được thống nhất để xây dựng <strong>multiprocessor scheduler</strong> (bộ lập lịch cho hệ thống đa bộ xử lý). Theo thời gian, đã xuất hiện ba bộ lập lịch khác nhau: <strong>O(1) scheduler</strong>, <strong>Completely Fair Scheduler (CFS)</strong>, và <strong>BF Scheduler (BFS)</strong>^[2]. Xem luận án của Meehean để có cái nhìn tổng quan xuất sắc về điểm mạnh và điểm yếu của các bộ lập lịch này [M11]; ở đây chúng ta chỉ tóm tắt một số điểm cơ bản.</p>
<p>Cả <strong>O(1)</strong> và <strong>CFS</strong> đều sử dụng <strong>multiple queues</strong> (nhiều hàng đợi), trong khi <strong>BFS</strong> sử dụng <strong>single queue</strong> (một hàng đợi), cho thấy rằng cả hai cách tiếp cận đều có thể thành công. Tất nhiên, có nhiều chi tiết khác biệt giữa các bộ lập lịch này.</p>
<p>Ví dụ: <strong>O(1) scheduler</strong> là một <strong>priority-based scheduler</strong> (bộ lập lịch dựa trên mức ưu tiên) — tương tự như <strong>MLFQ</strong> đã thảo luận trước đó — thay đổi <strong>priority</strong> (mức ưu tiên) của một <strong>process</strong> (tiến trình) theo thời gian, rồi lập lịch cho các tiến trình có priority cao nhất để đạt được các mục tiêu lập lịch khác nhau; trong đó, <strong>interactivity</strong> (tính tương tác) là một trọng tâm đặc biệt.</p>
<p>Ngược lại, <strong>CFS</strong> là một phương pháp <strong>deterministic proportional-share</strong> (chia sẻ tỷ lệ có tính quyết định), giống với <strong>Stride scheduling</strong> đã đề cập trước đó. <strong>BFS</strong>, bộ lập lịch duy nhất trong ba loại sử dụng single queue, cũng là proportional-share, nhưng dựa trên một cơ chế phức tạp hơn gọi là <strong>Earliest Eligible Virtual Deadline First (EEVDF)</strong> [SA96].</p>
<p>Bạn có thể tự tìm hiểu thêm về các thuật toán hiện đại này; đến thời điểm này, bạn đã có đủ kiến thức để hiểu cách chúng hoạt động.</p>
<h2 id="107-summary-tóm-tắt"><a class="header" href="#107-summary-tóm-tắt">10.7 Summary (Tóm tắt)</a></h2>
<p>Chúng ta đã xem xét nhiều cách tiếp cận khác nhau đối với <strong>multiprocessor scheduling</strong> (lập lịch đa bộ xử lý).</p>
<ul>
<li><strong>Single-queue approach (SQMS)</strong>: khá đơn giản để xây dựng và cân bằng tải tốt, nhưng vốn dĩ gặp khó khăn khi mở rộng ra nhiều bộ xử lý và trong việc duy trì <strong>cache affinity</strong> (tính gắn kết với bộ nhớ đệm CPU).</li>
<li><strong>Multiple-queue approach (MQMS)</strong>: mở rộng tốt hơn và xử lý cache affinity hiệu quả, nhưng gặp vấn đề với <strong>load imbalance</strong> (mất cân bằng tải) và phức tạp hơn.</li>
</ul>
<p>Dù chọn cách tiếp cận nào, cũng không có câu trả lời đơn giản: xây dựng một <strong>general-purpose scheduler</strong> (bộ lập lịch đa dụng) vẫn là một nhiệm vụ đầy thách thức, vì chỉ một thay đổi nhỏ trong mã nguồn cũng có thể dẫn đến sự khác biệt lớn trong hành vi hệ thống. Chỉ nên thực hiện công việc này nếu bạn <strong>thực sự biết rõ mình đang làm gì</strong>, hoặc ít nhất là <strong>được trả một khoản tiền lớn để làm</strong>.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Bạn có thể tự tìm hiểu BF viết tắt cho cụm từ gì; xin lưu ý, nó <strong>không dành cho những người yếu tim</strong>.</p>
</div>
<h2 id="tham-khảo-7"><a class="header" href="#tham-khảo-7">Tham khảo</a></h2>
<p>[A90] “The Performance of Spin Lock Alternatives for Shared-Memory Multiprocessors”<br />
Thomas E. Anderson<br />
IEEE TPDS Volume 1:1, January 1990<br />
A classic paper on how different locking alternatives do and don’t scale. By Tom Anderson, very well known researcher in both systems and networking. And author of a very fine OS textbook, we must say.</p>
<p>[B+10] “An Analysis of Linux Scalability to Many Cores Abstract”<br />
Silas Boyd-Wickizer, Austin T. Clements, Yandong Mao, Aleksey Pesterev, M. Frans Kaashoek, Robert Morris, Nickolai Zeldovich<br />
OSDI ’10, Vancouver, Canada, October 2010<br />
A terrific modern paper on the difficulties of scaling Linux to many cores.</p>
<p>[CSG99] “Parallel Computer Architecture: A Hardware/Software Approach”<br />
David E. Culler, Jaswinder Pal Singh, and Anoop Gupta
Morgan Kaufmann, 1999<br />
A treasure filled with details about parallel machines and algorithms. As Mark Hill humorously observes on the jacket, the book contains more information than most research papers.</p>
<p>[FLR98] “The Implementation of the Cilk-5 Multithreaded Language”<br />
Matteo Frigo, Charles E. Leiserson, Keith Randall<br />
PLDI ’98, Montreal, Canada, June 1998<br />
Cilk is a lightweight language and runtime for writing parallel programs, and an excellent example of the work-stealing paradigm.</p>
<p>[G83] “Using Cache Memory To Reduce Processor-Memory Traffic”<br />
James R. Goodman<br />
ISCA ’83, Stockholm, Sweden, June 1983<br />
The pioneering paper on how to use bus snooping, i.e., paying attention to requests you see on the bus, to build a cache coherence protocol. Goodman’s research over many years at Wisconsin is full of cleverness, this being but one example.</p>
<p>[M11] “Towards Transparent CPU Scheduling”<br />
Joseph T. Meehean<br />
Doctoral Dissertation at University of Wisconsin—Madison, 2011<br />
A dissertation that covers a lot of the details of how modern Linux multiprocessor scheduling works. Pretty awesome! But, as co-advisors of Joe’s, we may be a bit biased here.</p>
<p>[SHW11] “A Primer on Memory Consistency and Cache Coherence”<br />
Daniel J. Sorin, Mark D. Hill, and David A. Wood<br />
Synthesis Lectures in Computer Architecture<br />
Morgan and Claypool Publishers, May 2011<br />
A definitive overview of memory consistency and multiprocessor caching. Required reading for anyone who likes to know way too much about a given topic.</p>
<p>[SA96] “Earliest Eligible Virtual Deadline First: A Flexible and Accurate Mechanism for Proportional Share Resource Allocation”<br />
Ion Stoica and Hussein Abdel-Wahab<br />
Technical Report TR-95-22, Old Dominion University, 1996<br />
A tech report on this cool scheduling idea, from Ion Stoica, now a professor at U.C. Berkeley and world expert in networking, distributed systems, and many other things.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-abstraction-address-spaces"><a class="header" href="#the-abstraction-address-spaces">The Abstraction: Address Spaces</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interlude-memory-api"><a class="header" href="#interlude-memory-api">Interlude: Memory API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="153-dynamic-hardware-based-relocation--tái-định-vị-động-dựa-trên-phần-cứng"><a class="header" href="#153-dynamic-hardware-based-relocation--tái-định-vị-động-dựa-trên-phần-cứng">15.3 Dynamic (Hardware-based) Relocation — Tái định vị động (dựa trên phần cứng)</a></h2>
<p>Để hiểu cơ chế dịch địa chỉ (address translation) dựa trên phần cứng, trước tiên chúng ta sẽ xem xét phiên bản đầu tiên của nó. Ý tưởng này xuất hiện trong các máy tính time-sharing (chia sẻ thời gian) đầu tiên vào cuối những năm 1950, được gọi là <strong>base and bounds</strong> (cơ chế thanh ghi cơ sở và giới hạn). Kỹ thuật này cũng được gọi là <strong>dynamic relocation</strong> (tái định vị động); trong chương này, chúng ta sẽ sử dụng hai thuật ngữ này thay thế cho nhau [SS74].</p>
<p>Cụ thể, mỗi CPU sẽ cần hai thanh ghi phần cứng: một gọi là <strong>base register</strong> (thanh ghi cơ sở) và một gọi là <strong>bounds register</strong> (thanh ghi giới hạn, đôi khi gọi là limit register). Cặp base–bounds này cho phép chúng ta đặt <strong>address space</strong> (không gian địa chỉ) của process (tiến trình) ở bất kỳ vị trí nào trong <strong>physical memory</strong> (bộ nhớ vật lý), đồng thời đảm bảo process chỉ có thể truy cập vào không gian địa chỉ của chính nó.</p>
<blockquote>
<p><strong>ASIDE: SOFTWARE-BASED RELOCATION</strong><br />
Trong giai đoạn đầu, trước khi có hỗ trợ phần cứng, một số hệ thống thực hiện tái định vị (relocation) ở dạng đơn giản hoàn toàn bằng phần mềm. Kỹ thuật cơ bản này được gọi là <strong>static relocation</strong> (tái định vị tĩnh), trong đó một phần mềm gọi là <strong>loader</strong> sẽ lấy một file thực thi (executable) sắp chạy và ghi lại (rewrite) các địa chỉ của nó sang một vị trí offset mong muốn trong physical memory.</p>
<p>Ví dụ: nếu một lệnh là tải dữ liệu từ địa chỉ 1000 vào một thanh ghi (ví dụ: <code>movl 1000, %eax</code>), và không gian địa chỉ của chương trình được nạp bắt đầu tại địa chỉ 3000 (thay vì 0 như chương trình nghĩ), loader sẽ ghi lại lệnh này để cộng thêm offset 3000 vào mỗi địa chỉ (ví dụ: <code>movl 4000, %eax</code>). Bằng cách này, việc tái định vị tĩnh của không gian địa chỉ process được thực hiện.</p>
<p>Tuy nhiên, static relocation có nhiều vấn đề. Quan trọng nhất là nó <strong>không cung cấp bảo vệ</strong> (protection), vì process có thể tạo ra các địa chỉ sai và truy cập trái phép vào bộ nhớ của process khác hoặc thậm chí bộ nhớ của OS. Nói chung, cần có hỗ trợ phần cứng để đạt được bảo vệ thực sự [WL+93]. Một nhược điểm khác là khi đã đặt xong, rất khó để di chuyển không gian địa chỉ sang vị trí khác [M65].</p>
</blockquote>
<p>Trong cơ chế này, mỗi chương trình được viết và biên dịch như thể nó được nạp tại địa chỉ 0. Tuy nhiên, khi chương trình bắt đầu chạy, OS sẽ quyết định vị trí trong physical memory để nạp nó và thiết lập base register bằng giá trị đó. Trong ví dụ ở trên, OS quyết định nạp process tại địa chỉ vật lý 32 KB và đặt base register bằng giá trị này.</p>
<p>Khi process chạy, điều thú vị bắt đầu xảy ra. Mỗi khi process tạo ra một tham chiếu bộ nhớ, CPU sẽ dịch địa chỉ theo công thức:</p>
<pre><code>physical address = virtual address + base
</code></pre>
<p>Mỗi tham chiếu bộ nhớ do process tạo ra là một <strong>virtual address</strong> (địa chỉ ảo); phần cứng sẽ cộng giá trị trong base register vào địa chỉ này để tạo ra <strong>physical address</strong> (địa chỉ vật lý) và gửi tới hệ thống bộ nhớ.</p>
<p>Để hiểu rõ hơn, hãy theo dõi quá trình thực thi một lệnh. Cụ thể, xét lệnh sau từ ví dụ trước:</p>
<pre><code>128: movl 0x0(%ebx), %eax
</code></pre>
<p><strong>Program Counter (PC)</strong> đang ở giá trị 128; khi phần cứng cần nạp lệnh này, nó sẽ cộng giá trị PC với base register (32 KB = 32768) để được địa chỉ vật lý 32896; sau đó phần cứng nạp lệnh từ địa chỉ vật lý này. Tiếp theo, CPU bắt đầu thực thi lệnh. Tại một thời điểm, process sẽ thực hiện:</p>
<blockquote>
<p><strong>TIP: HARDWARE-BASED DYNAMIC RELOCATION</strong><br />
Với dynamic relocation, chỉ cần một chút phần cứng là có thể tạo ra hiệu quả lớn. Base register được dùng để biến đổi virtual address (do chương trình tạo ra) thành physical address. Bounds register (hoặc limit register) đảm bảo các địa chỉ này nằm trong phạm vi hợp lệ của address space. Kết hợp lại, chúng cung cấp một cơ chế ảo hóa bộ nhớ đơn giản và hiệu quả.</p>
</blockquote>
<p>Lệnh load từ virtual address 15 KB, CPU sẽ cộng giá trị này với base register (32 KB) để được physical address 47 KB và lấy dữ liệu mong muốn.</p>
<p>Việc biến đổi virtual address thành physical address chính là kỹ thuật <strong>address translation</strong> (dịch địa chỉ). Vì quá trình này diễn ra khi chương trình đang chạy (runtime) và chúng ta có thể di chuyển address space ngay cả khi process đã chạy, nên kỹ thuật này được gọi là <strong>dynamic relocation</strong> [M65].</p>
<p>Bạn có thể thắc mắc: bounds register ở đâu? Thực tế, bounds register được dùng để bảo vệ. CPU sẽ kiểm tra xem virtual address có nằm trong giới hạn hay không; trong ví dụ trên, bounds register sẽ được đặt là 16 KB. Nếu process tạo ra một virtual address lớn hơn hoặc bằng bounds, hoặc âm, CPU sẽ phát sinh <strong>exception</strong> và process có thể bị chấm dứt. Mục đích của bounds là đảm bảo tất cả địa chỉ do process tạo ra đều hợp lệ.</p>
<p>Cần lưu ý rằng base và bounds register là các cấu trúc phần cứng nằm trên chip (mỗi CPU một cặp). Bộ phận của CPU hỗ trợ dịch địa chỉ thường được gọi là <strong>Memory Management Unit (MMU)</strong>; khi phát triển các kỹ thuật quản lý bộ nhớ phức tạp hơn, chúng ta sẽ bổ sung thêm mạch vào MMU.</p>
<p>Một lưu ý nhỏ: bounds register có thể được định nghĩa theo hai cách. Cách thứ nhất (như ở trên) là lưu kích thước của address space, và phần cứng sẽ so sánh virtual address với giá trị này trước khi cộng base. Cách thứ hai là lưu địa chỉ vật lý của điểm kết thúc address space, và phần cứng sẽ cộng base trước rồi mới kiểm tra giới hạn. Cả hai cách là tương đương về mặt logic; để đơn giản, chúng ta thường giả định cách thứ nhất.</p>
<h3 id="ví-dụ-dịch-địa-chỉ"><a class="header" href="#ví-dụ-dịch-địa-chỉ">Ví dụ dịch địa chỉ</a></h3>
<p>Giả sử một process có address space kích thước 4 KB (rất nhỏ, chỉ để minh họa) được nạp tại địa chỉ vật lý 16 KB. Kết quả dịch địa chỉ sẽ như sau:</p>
<p><em>(Bảng minh họa kết quả dịch địa chỉ — giữ nguyên như bản gốc)</em></p>
<p>Như bạn thấy, chỉ cần cộng base address với virtual address (có thể coi như offset trong address space) là ra physical address. Chỉ khi virtual address quá lớn hoặc âm thì mới gây ra lỗi (fault) và phát sinh exception.</p>
<h2 id="154-hardware-support-a-summary--tóm-tắt-hỗ-trợ-phần-cứng"><a class="header" href="#154-hardware-support-a-summary--tóm-tắt-hỗ-trợ-phần-cứng">15.4 Hardware Support: A Summary — Tóm tắt hỗ trợ phần cứng</a></h2>
<p>Tóm tắt lại, phần cứng cần hỗ trợ những gì (xem thêm <em>Figure 15.3</em>, trang 9):</p>
<ul>
<li>
<p>Như đã thảo luận trong chương về <strong>CPU virtualization</strong> (ảo hóa CPU), cần có hai chế độ CPU: <strong>privileged mode</strong> (kernel mode) — OS chạy ở chế độ này và có toàn quyền truy cập máy; và <strong>user mode</strong> — ứng dụng chạy ở chế độ này và bị giới hạn quyền. Một bit trong <strong>processor status word</strong> sẽ cho biết CPU đang ở chế độ nào; khi có sự kiện đặc biệt (ví dụ: system call, exception hoặc interrupt), CPU sẽ chuyển chế độ.</p>
</li>
<li>
<p>Phần cứng phải cung cấp base và bounds register; mỗi CPU có một cặp, là một phần của MMU. Khi chương trình người dùng chạy, phần cứng sẽ dịch mỗi địa chỉ bằng cách cộng base với virtual address do chương trình tạo ra. Đồng thời, phần cứng phải kiểm tra tính hợp lệ của địa chỉ bằng bounds register và mạch logic trong CPU.</p>
</li>
<li>
<p>Phần cứng cần cung cấp các lệnh đặc biệt để thay đổi base và bounds register, cho phép OS thay đổi chúng khi chuyển đổi process. Các lệnh này là <strong>privileged instructions</strong> (lệnh đặc quyền); chỉ ở kernel mode mới có thể thay đổi. Hãy tưởng tượng mức độ hỗn loạn mà một process có thể gây ra<sup class="footnote-reference"><a href="#1">1</a></sup> nếu nó có thể tùy ý thay đổi base register khi đang chạy. Nghĩ thôi cũng đủ thấy đây là cơn ác mộng.</p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Is there anything other than “havoc” that can be “wreaked”? [W17]</p>
</div>
<blockquote>
<p><strong>ASIDE: DATA STRUCTURE — THE FREE LIST</strong><br />
Hệ điều hành (OS) phải theo dõi những phần bộ nhớ trống (free memory) chưa được sử dụng, để có thể cấp phát bộ nhớ cho các process (tiến trình). Có thể sử dụng nhiều cấu trúc dữ liệu khác nhau cho nhiệm vụ này; cấu trúc đơn giản nhất (mà chúng ta giả định ở đây) là <strong>free list</strong> (danh sách vùng trống), đơn giản chỉ là một danh sách các khoảng (range) của physical memory (bộ nhớ vật lý) hiện chưa được sử dụng.</p>
</blockquote>
<p><strong>Figure 15.3: Dynamic Relocation — Hardware Requirements</strong><br />
<em>(Yêu cầu phần cứng cho tái định vị động)</em></p>
<p>Cuối cùng, CPU phải có khả năng tạo ra <strong>exception</strong> (ngoại lệ) trong các tình huống khi một chương trình người dùng cố gắng truy cập bộ nhớ trái phép (với một địa chỉ “out of bounds” — vượt ngoài giới hạn). Trong trường hợp này, CPU sẽ dừng việc thực thi chương trình người dùng và chuyển quyền điều khiển cho <strong>out-of-bounds exception handler</strong> (trình xử lý ngoại lệ vượt giới hạn) của OS. Trình xử lý này sẽ quyết định cách phản ứng, thường là chấm dứt process vi phạm.<br />
Tương tự, nếu một chương trình người dùng cố gắng thay đổi giá trị của các thanh ghi đặc quyền (privileged) như base register và bounds register, CPU sẽ phát sinh exception và gọi <strong>handler</strong> xử lý tình huống “cố gắng thực hiện một thao tác đặc quyền khi đang ở user mode”. CPU cũng phải cung cấp một cơ chế để OS thông báo vị trí của các handler này; do đó cần thêm một số lệnh đặc quyền.</p>
<h2 id="155-operating-system-issues--các-vấn-đề-của-hệ-điều-hành"><a class="header" href="#155-operating-system-issues--các-vấn-đề-của-hệ-điều-hành">15.5 Operating System Issues — Các vấn đề của Hệ điều hành</a></h2>
<p>Cũng giống như phần cứng cung cấp các tính năng mới để hỗ trợ <strong>dynamic relocation</strong> (tái định vị động), OS cũng phải xử lý các vấn đề mới; sự kết hợp giữa hỗ trợ phần cứng và quản lý của OS dẫn đến việc triển khai một dạng <strong>virtual memory</strong> (bộ nhớ ảo) đơn giản. Cụ thể, có một số thời điểm quan trọng mà OS phải can thiệp để thực hiện cơ chế virtual memory dựa trên base-and-bounds.</p>
<p><strong>Thứ nhất</strong>, OS phải hành động khi một process được tạo, tìm chỗ trống trong bộ nhớ để đặt address space của nó. Với giả định rằng mỗi address space (a) nhỏ hơn kích thước physical memory và (b) có cùng kích thước, việc này khá đơn giản: OS có thể coi physical memory như một mảng các slot (ô nhớ) và theo dõi trạng thái từng slot (trống hay đã dùng). Khi một process mới được tạo, OS sẽ tìm trong cấu trúc dữ liệu (thường gọi là free list) để tìm chỗ trống cho address space mới và đánh dấu là đã sử dụng. Nếu address space có kích thước thay đổi, việc quản lý sẽ phức tạp hơn — vấn đề này sẽ được bàn ở các chương sau.</p>
<p><strong>Figure 15.4: Dynamic Relocation — Operating System Responsibilities</strong><br />
<em>(Trách nhiệm của hệ điều hành trong tái định vị động)</em></p>
<p>Ví dụ: Trong Figure 15.2 (trang 5), OS sử dụng slot đầu tiên của physical memory cho chính nó, và đã tái định vị process từ ví dụ trước vào slot bắt đầu tại địa chỉ vật lý 32 KB. Hai slot còn lại (16 KB–32 KB và 48 KB–64 KB) đang trống; do đó free list sẽ gồm hai mục này.</p>
<p><strong>Thứ hai</strong>, OS phải thu hồi bộ nhớ khi một process kết thúc (thoát bình thường hoặc bị buộc dừng do vi phạm). Khi process kết thúc, OS sẽ đưa vùng nhớ của nó trở lại free list và dọn dẹp các cấu trúc dữ liệu liên quan.</p>
<p><strong>Thứ ba</strong>, OS phải thực hiện thêm một số bước khi xảy ra <strong>context switch</strong> (chuyển ngữ cảnh). Mỗi CPU chỉ có một cặp base–bounds register, và giá trị của chúng khác nhau cho mỗi process (vì mỗi process được nạp ở địa chỉ vật lý khác nhau). Do đó, OS phải lưu và khôi phục cặp thanh ghi này khi chuyển đổi giữa các process. Cụ thể, khi OS dừng một process, nó phải lưu giá trị base và bounds register vào bộ nhớ, trong một cấu trúc dữ liệu riêng cho process như <strong>process structure</strong> hoặc <strong>process control block (PCB)</strong>. Khi OS chạy lại process (hoặc chạy lần đầu), nó phải thiết lập base và bounds register trên CPU với giá trị đúng của process đó.</p>
<p>Cần lưu ý: khi một process bị dừng (không chạy), OS có thể di chuyển address space của nó sang vị trí khác trong bộ nhớ khá dễ dàng. Để làm điều này, OS sẽ <strong>deschedule</strong> process, sao chép address space từ vị trí hiện tại sang vị trí mới, sau đó cập nhật giá trị base register đã lưu (trong process structure) để trỏ tới vị trí mới. Khi process chạy lại, base register mới được khôi phục và process tiếp tục chạy mà không hề biết rằng mã lệnh và dữ liệu của mình đã ở vị trí khác trong bộ nhớ.</p>
<p><strong>Thứ tư</strong>, OS phải cung cấp các <strong>exception handler</strong> (trình xử lý ngoại lệ) như đã đề cập; OS cài đặt các handler này khi khởi động (boot time) thông qua các lệnh đặc quyền. Ví dụ, nếu một process cố truy cập bộ nhớ ngoài giới hạn, CPU sẽ phát sinh exception; OS phải sẵn sàng xử lý, thường là chấm dứt process vi phạm. OS cần bảo vệ nghiêm ngặt hệ thống, và sẽ không “nhẹ tay” với process cố truy cập bộ nhớ hoặc thực thi lệnh trái phép.</p>
<p><strong>Figure 15.5: Limited Direct Execution (Dynamic Relocation) @ Boot</strong><br />
<em>(Thực thi trực tiếp có giới hạn — tái định vị động khi khởi động)</em></p>
<p>Các Figure 15.5 và 15.6 (trang 12) minh họa tương tác phần cứng/OS theo dòng thời gian. Figure đầu cho thấy OS làm gì khi khởi động để chuẩn bị hệ thống; Figure thứ hai cho thấy khi một process (Process A) bắt đầu chạy, việc dịch địa chỉ được phần cứng xử lý hoàn toàn, không cần OS can thiệp. Tại một thời điểm, một <strong>timer interrupt</strong> xảy ra, OS chuyển sang Process B, process này thực hiện một “bad load” (truy cập địa chỉ bộ nhớ trái phép); lúc này OS phải can thiệp, chấm dứt process, giải phóng bộ nhớ và xóa entry của nó khỏi <strong>process table</strong>. Như bạn thấy, chúng ta vẫn theo mô hình <strong>limited direct execution</strong>: hầu hết thời gian, OS chỉ cần thiết lập phần cứng và để process chạy trực tiếp trên CPU; chỉ khi process vi phạm thì OS mới can thiệp.</p>
<h2 id="156-summary--tóm-tắt"><a class="header" href="#156-summary--tóm-tắt">15.6 Summary — Tóm tắt</a></h2>
<p>Trong chương này, chúng ta đã mở rộng khái niệm <strong>limited direct execution</strong> với một cơ chế cụ thể dùng trong virtual memory, gọi là <strong>address translation</strong> (dịch địa chỉ). Với address translation, OS có thể kiểm soát mọi truy cập bộ nhớ của process, đảm bảo chúng nằm trong giới hạn của address space. Yếu tố then chốt để kỹ thuật này hiệu quả là hỗ trợ phần cứng, giúp dịch địa chỉ nhanh chóng cho mỗi lần truy cập, biến virtual address (cách process nhìn bộ nhớ) thành physical address (cách bộ nhớ thực tế được tổ chức). Tất cả diễn ra hoàn toàn <strong>transparent</strong> (minh bạch) với process — nó không hề biết rằng các truy cập bộ nhớ đang được dịch.</p>
<p><strong>Figure 15.6: Limited Direct Execution (Dynamic Relocation) @ Runtime</strong><br />
<em>(Thực thi trực tiếp có giới hạn — tái định vị động khi chạy)</em></p>
<p>Chúng ta cũng đã thấy một dạng ảo hóa cụ thể, gọi là <strong>base and bounds</strong> hoặc <strong>dynamic relocation</strong>. Cơ chế này rất hiệu quả vì chỉ cần thêm một chút logic phần cứng để cộng base register vào virtual address và kiểm tra địa chỉ có nằm trong bounds hay không. Nó cũng cung cấp <strong>protection</strong> (bảo vệ): OS và phần cứng phối hợp để đảm bảo không process nào có thể tạo ra truy cập bộ nhớ ngoài address space của chính nó. Bảo vệ là một trong những mục tiêu quan trọng nhất của OS; nếu không có nó, OS không thể kiểm soát hệ thống (process có thể ghi đè vùng nhớ quan trọng như trap table và chiếm quyền điều khiển).</p>
<p>Tuy nhiên, kỹ thuật dynamic relocation đơn giản này vẫn có nhược điểm. Ví dụ, như trong Figure 15.2 (trang 5), process được tái định vị sử dụng physical memory từ 32 KB đến 48 KB; nhưng vì stack và heap của process không lớn, phần bộ nhớ giữa chúng bị bỏ trống. Kiểu lãng phí này gọi là <strong>internal fragmentation</strong> (phân mảnh bên trong), khi không gian bên trong đơn vị cấp phát không được sử dụng hết và bị bỏ phí. Trong cách tiếp cận hiện tại, dù có</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-segmentation-phân-đoạn-bộ-nhớ"><a class="header" href="#16-segmentation-phân-đoạn-bộ-nhớ">16 Segmentation (Phân đoạn bộ nhớ)</a></h1>
<p>Cho đến nay, chúng ta đã đặt toàn bộ <strong>address space</strong> (không gian địa chỉ) của mỗi <strong>process</strong> (tiến trình) vào bộ nhớ. Với <strong>base register</strong> (thanh ghi cơ sở) và <strong>bounds register</strong> (thanh ghi giới hạn), <strong>OS</strong> (hệ điều hành) có thể dễ dàng tái định vị (relocate) các process sang các vị trí khác nhau trong <strong>physical memory</strong> (bộ nhớ vật lý). Tuy nhiên, bạn có thể nhận thấy một điều thú vị về các address space này: có một khoảng “trống” lớn ngay ở giữa, giữa <strong>stack</strong> và <strong>heap</strong>.</p>
<p>Như bạn có thể hình dung từ <em>Figure 16.1</em>, mặc dù khoảng trống giữa stack và heap không được process sử dụng, nó vẫn chiếm physical memory khi chúng ta tái định vị toàn bộ address space vào một vị trí nào đó trong physical memory. Do đó, cách tiếp cận đơn giản sử dụng một cặp base–bounds register để ảo hóa bộ nhớ là lãng phí. Nó cũng khiến việc chạy một chương trình trở nên khó khăn khi toàn bộ address space không thể vừa trong bộ nhớ; vì vậy, cơ chế base and bounds không linh hoạt như mong muốn. Và do đó:</p>
<blockquote>
<p><strong>THE CRUX: HOW TO SUPPORT A LARGE ADDRESS SPACE</strong><br />
Làm thế nào để hỗ trợ một address space lớn với (có thể) rất nhiều khoảng trống giữa stack và heap? Lưu ý rằng trong các ví dụ của chúng ta, với address space nhỏ (giả định), sự lãng phí có vẻ không quá nghiêm trọng. Tuy nhiên, hãy tưởng tượng một address space 32-bit (kích thước 4 GB); một chương trình điển hình chỉ sử dụng vài megabyte bộ nhớ, nhưng vẫn yêu cầu toàn bộ address space phải nằm trong bộ nhớ.</p>
</blockquote>
<h2 id="161-segmentation-generalized-basebounds"><a class="header" href="#161-segmentation-generalized-basebounds">16.1 Segmentation: Generalized Base/Bounds</a></h2>
<p>Để giải quyết vấn đề này, một ý tưởng đã ra đời, gọi là <strong>segmentation</strong> (phân đoạn bộ nhớ). Đây là một ý tưởng khá cũ, xuất hiện ít nhất từ đầu những năm 1960 [H61, G62]. Ý tưởng rất đơn giản: thay vì chỉ có một cặp base–bounds register trong <strong>MMU</strong> (Memory Management Unit — đơn vị quản lý bộ nhớ), tại sao không có một cặp base–bounds cho mỗi <strong>logical segment</strong> (đoạn logic) của address space?</p>
<p><strong>Segment</strong> là một phần liên tục của address space với độ dài xác định. Trong address space chuẩn của chúng ta, có ba segment khác nhau về mặt logic: <strong>code</strong>, <strong>stack</strong>, và <strong>heap</strong>. Segmentation cho phép OS đặt từng segment này ở các vị trí khác nhau trong physical memory, từ đó tránh việc lấp đầy physical memory bằng các vùng virtual address space không sử dụng.</p>
<p><img src="16/img/fig16_1.PNG" alt="" /></p>
<p><strong>Figure 16.1: An Address Space (Again)</strong><br />
<em>(Một không gian địa chỉ — minh họa lại)</em></p>
<p>Hãy xem một ví dụ. Giả sử chúng ta muốn đặt address space từ <em>Figure 16.1</em> vào physical memory. Với một cặp base–bounds cho mỗi segment, chúng ta có thể đặt từng segment độc lập trong physical memory. Ví dụ, xem <em>Figure 16.2</em> (trang 3); ở đó bạn thấy một physical memory 64 KB với ba segment này (và 16 KB dành riêng cho OS).</p>
<p><img src="16/img/fig16_2.PNG" alt="" /></p>
<p><strong>Figure 16.2: Placing Segments In Physical Memory</strong><br />
<em>(Đặt các segment trong bộ nhớ vật lý)</em></p>
<p>Như bạn thấy trong sơ đồ, chỉ vùng bộ nhớ được sử dụng mới chiếm chỗ trong physical memory; do đó, các address space lớn với nhiều vùng không sử dụng (thường gọi là <strong>sparse address spaces</strong>) vẫn có thể được chứa.</p>
<p>Cấu trúc phần cứng trong MMU để hỗ trợ segmentation đúng như bạn mong đợi: trong trường hợp này, là một tập hợp ba cặp base–bounds register. <em>Figure 16.3</em> dưới đây cho thấy giá trị các thanh ghi cho ví dụ trên; mỗi bounds register lưu kích thước của một segment.</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Base</th><th>Size</th></tr></thead><tbody>
<tr><td>Code</td><td>32K</td><td>2K</td></tr>
<tr><td>Heap</td><td>34K</td><td>3K</td></tr>
<tr><td>Stack</td><td>28K</td><td>2K</td></tr>
</tbody></table>
</div>
<p><strong>Figure 16.3: Segment Register Values</strong><br />
<em>(Giá trị thanh ghi phân đoạn)</em></p>
<p>Bạn có thể thấy từ hình rằng <strong>code segment</strong> được đặt tại địa chỉ vật lý 32 KB và có kích thước 2 KB, còn <strong>heap segment</strong> được đặt tại 34 KB và có kích thước 3 KB. Giá trị kích thước segment ở đây giống hệt bounds register đã giới thiệu trước đó; nó cho phần cứng biết chính xác có bao nhiêu byte hợp lệ trong segment này (và do đó, cho phép phần cứng xác định khi nào chương trình truy cập trái phép ra ngoài giới hạn).</p>
<p>Hãy làm một ví dụ dịch địa chỉ, sử dụng address space trong <em>Figure 16.1</em>. Giả sử có một tham chiếu tới virtual address 100 (nằm trong code segment, như thấy trực quan ở <em>Figure 16.1</em>, trang 2). Khi tham chiếu diễn ra (ví dụ, khi nạp lệnh), phần cứng sẽ cộng giá trị base với offset trong segment này (100 trong trường hợp này) để ra địa chỉ vật lý mong muốn: 100 + 32 KB = 32868. Sau đó, nó kiểm tra địa chỉ có nằm trong bounds hay không (100 &lt; 2 KB), thấy hợp lệ, và gửi yêu cầu tới địa chỉ vật lý 32868.</p>
<blockquote>
<p><strong>ASIDE: THE SEGMENTATION FAULT</strong><br />
Thuật ngữ <strong>segmentation fault</strong> hoặc <strong>segmentation violation</strong> xuất phát từ việc truy cập bộ nhớ trái phép trên một máy sử dụng segmentation. Thú vị là thuật ngữ này vẫn tồn tại, ngay cả trên các máy không hỗ trợ segmentation. Hoặc không thú vị lắm, nếu bạn không hiểu tại sao code của mình liên tục bị lỗi.</p>
</blockquote>
<p>Bây giờ, hãy xem một địa chỉ trong heap: virtual address 4200 (xem lại <em>Figure 16.1</em>). Nếu chỉ cộng virtual address 4200 với base của heap (34 KB), ta được địa chỉ vật lý 39016 — đây không phải kết quả đúng. Trước tiên, ta cần lấy <strong>offset</strong> trong heap, tức là byte nào trong segment này địa chỉ đang trỏ tới. Vì heap bắt đầu tại virtual address 4 KB (4096), offset của 4200 là 4200 − 4096 = 104. Sau đó, ta cộng offset này (104) với base register của heap (34 KB) để được kết quả đúng: 34920.</p>
<p>Nếu ta thử truy cập một địa chỉ trái phép (ví dụ: virtual address ≥ 7 KB, vượt quá cuối heap), phần cứng sẽ phát hiện địa chỉ vượt giới hạn, tạo <strong>trap</strong> vào OS, và nhiều khả năng dẫn tới việc chấm dứt process vi phạm. Và giờ bạn đã biết nguồn gốc của thuật ngữ mà mọi lập trình viên C đều e ngại: segmentation violation hoặc segmentation fault.</p>
<h2 id="162-which-segment-are-we-referring-to"><a class="header" href="#162-which-segment-are-we-referring-to">16.2 Which Segment Are We Referring To?</a></h2>
<p>(Chúng ta đang tham chiếu tới segment nào?)</p>
<p>Phần cứng sử dụng <strong>segment register</strong> trong quá trình dịch địa chỉ. Làm thế nào nó biết offset trong segment và địa chỉ thuộc segment nào?</p>
<p>Một cách tiếp cận phổ biến, đôi khi gọi là <strong>explicit approach</strong> (cách tiếp cận tường minh), là chia address space thành các segment dựa trên một vài bit cao nhất của virtual address; kỹ thuật này được sử dụng trong hệ thống <strong>VAX/VMS</strong> [LL82]. Trong ví dụ của chúng ta, có ba segment; do đó cần 2 bit để thực hiện. Nếu dùng 2 bit cao nhất của virtual address 14-bit để chọn segment, virtual address sẽ trông như sau:</p>
<p><img src="16/img/fig16_2_1.PNG" alt="" /></p>
<p>Trong ví dụ này, nếu 2 bit cao nhất là <code>00</code>, phần cứng biết virtual address nằm trong code segment, và sẽ dùng cặp base–bounds của code để dịch địa chỉ sang physical address đúng. Nếu 2 bit cao nhất là <code>01</code>, phần cứng biết địa chỉ nằm trong heap, và sẽ dùng cặp base–bounds của heap.</p>
<p>Hãy lấy lại ví dụ heap virtual address ở trên (4200) và dịch nó để làm rõ. Virtual address 4200 ở dạng nhị phân:</p>
<p><img src="16/img/fig16_2_2.PNG" alt="" /></p>
<p>Như bạn có thể thấy từ hình minh họa, <strong>2 bit cao nhất</strong> (01) cho phần cứng biết chúng ta đang tham chiếu đến <strong>segment</strong> (phân đoạn) nào. <strong>12 bit thấp</strong> còn lại là <strong>offset</strong> (độ lệch) bên trong segment: <code>0000 0110 1000</code>, hay ở dạng hex là <code>0x068</code>, hoặc 104 ở hệ thập phân.</p>
<p>Do đó, phần cứng chỉ cần lấy 2 bit cao nhất để xác định <strong>segment register</strong> (thanh ghi phân đoạn) cần sử dụng, sau đó lấy 12 bit tiếp theo làm offset trong segment. Bằng cách cộng <strong>base register</strong> (thanh ghi cơ sở) với offset, phần cứng sẽ tính ra <strong>địa chỉ vật lý</strong> (physical address) cuối cùng.</p>
<p>Lưu ý rằng offset cũng giúp việc kiểm tra giới hạn (<strong>bounds check</strong>) trở nên đơn giản hơn: chúng ta chỉ cần kiểm tra xem offset có nhỏ hơn giá trị bounds hay không; nếu không, địa chỉ đó là bất hợp lệ.</p>
<p>Vì vậy, nếu base và bounds được lưu trong các mảng (mỗi phần tử ứng với một segment), phần cứng sẽ thực hiện tương tự như đoạn code sau để lấy được địa chỉ vật lý mong muốn:</p>
<pre><code class="language-c">// lấy 2 bit cao nhất của VA (Virtual Address - địa chỉ ảo) 14-bit
Segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT;
// lấy offset
Offset = VirtualAddress &amp; OFFSET_MASK;
if (Offset &gt;= Bounds[Segment]) {
  RaiseException(PROTECTION_FAULT);
} else {
  PhysAddr = Base[Segment] + Offset;
}
Register = AccessMemory(PhysAddr);
</code></pre>
<p>Trong ví dụ đang xét, chúng ta có thể gán giá trị cho các hằng số ở trên. Cụ thể:</p>
<ul>
<li><code>SEG_MASK</code> sẽ được đặt là <code>0x3000</code></li>
<li><code>SEG_SHIFT</code> là 12</li>
<li><code>OFFSET_MASK</code> là <code>0xFFF</code></li>
</ul>
<p>Bạn cũng có thể nhận thấy rằng khi chúng ta dùng 2 bit cao nhất, nhưng chỉ có <strong>3 segment</strong> (code, heap, stack), thì sẽ có một segment trong không gian địa chỉ (<strong>address space</strong>) không được sử dụng.</p>
<p>Để tận dụng tối đa <strong>virtual address space</strong> (bộ nhớ ảo) và tránh lãng phí một segment, một số hệ thống đặt code chung với heap trong cùng một segment, và do đó chỉ cần dùng <strong>1 bit</strong> để chọn segment cần sử dụng [LL82].</p>
<p>Một vấn đề khác khi sử dụng một số bit cao nhất để chọn <strong>segment</strong> (đoạn bộ nhớ) là nó giới hạn việc sử dụng <strong>virtual address space</strong> (không gian địa chỉ ảo). Cụ thể, mỗi segment bị giới hạn ở một kích thước tối đa, trong ví dụ của chúng ta là 4 KB (việc dùng 2 bit cao nhất để chọn segment ngụ ý rằng address space 16 KB sẽ bị chia thành 4 phần, tức mỗi phần 4 KB). Nếu một chương trình đang chạy muốn mở rộng một segment (ví dụ heap hoặc stack) vượt quá giới hạn này, chương trình sẽ không thể thực hiện được.</p>
<p>Có những cách khác để phần cứng xác định một địa chỉ thuộc segment nào. Trong <strong>implicit approach</strong> (cách tiếp cận ngầm định), phần cứng xác định segment bằng cách quan sát cách địa chỉ được hình thành. Ví dụ, nếu địa chỉ được tạo ra từ <strong>program counter</strong> (tức là khi nạp lệnh — instruction fetch), thì địa chỉ đó thuộc code segment; nếu địa chỉ dựa trên <strong>stack pointer</strong> hoặc <strong>base pointer</strong>, nó phải thuộc stack segment; bất kỳ địa chỉ nào khác sẽ thuộc heap.</p>
<h2 id="163-what-about-the-stack-còn-stack-thì-sao"><a class="header" href="#163-what-about-the-stack-còn-stack-thì-sao">16.3 What About The Stack? (Còn stack thì sao?)</a></h2>
<p>Cho đến giờ, chúng ta đã bỏ qua một thành phần quan trọng của address space: <strong>stack</strong>. Stack đã được tái định vị tới địa chỉ vật lý 28 KB trong sơ đồ ở trên, nhưng có một điểm khác biệt quan trọng: nó <strong>tăng trưởng ngược</strong> (tức là hướng về các địa chỉ thấp hơn). Trong physical memory, nó “bắt đầu” tại 28 KB<sup class="footnote-reference"><a href="#1">1</a></sup> và phát triển ngược về 26 KB, tương ứng với virtual address từ 16 KB đến 14 KB; do đó, quá trình dịch địa chỉ phải thực hiện khác đi.</p>
<p>Điều đầu tiên chúng ta cần là một chút hỗ trợ bổ sung từ phần cứng. Thay vì chỉ lưu giá trị base và bounds, phần cứng cũng cần biết hướng tăng trưởng của segment (ví dụ: một bit được đặt là 1 nếu segment tăng theo hướng địa chỉ dương, và 0 nếu tăng theo hướng âm). Cách nhìn cập nhật về những gì phần cứng theo dõi được thể hiện trong <em>Figure 16.4</em>:</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Base</th><th>Size (max 4K)</th><th>Grows Positive?</th></tr></thead><tbody>
<tr><td>Code 00</td><td>32K</td><td>2K</td><td>1</td></tr>
<tr><td>Heap 01</td><td>34K</td><td>3K</td><td>1</td></tr>
<tr><td>Stack 11</td><td>28K</td><td>2K</td><td>0</td></tr>
</tbody></table>
</div>
<p><strong>Figure 16.4: Segment Registers (With Negative-Growth Support)</strong><br />
<em>(Thanh ghi phân đoạn với hỗ trợ tăng trưởng ngược)</em></p>
<p>Khi phần cứng hiểu rằng segment có thể tăng trưởng theo hướng âm, nó phải dịch các virtual address như vậy theo cách hơi khác. Hãy lấy một ví dụ về địa chỉ stack ảo và dịch nó để hiểu quy trình.</p>
<p>Trong ví dụ này, giả sử chúng ta muốn truy cập virtual address 15 KB, vốn sẽ ánh xạ tới physical address 27 KB. Virtual address này ở dạng nhị phân là:<br />
<code>11 1100 0000 0000</code> (hex <code>0x3C00</code>).</p>
<p>Phần cứng dùng 2 bit cao nhất (<code>11</code>) để xác định segment, sau đó còn lại offset là 3 KB. Để có được offset âm đúng, ta phải lấy 3 KB trừ đi kích thước tối đa của segment: trong ví dụ này, một segment có thể là 4 KB, do đó offset âm đúng là 3 KB − 4 KB = −1 KB. Ta chỉ cần cộng offset âm (−1 KB) này với base (28 KB) để ra physical address đúng: 27 KB.</p>
<p>Việc kiểm tra bounds có thể được thực hiện bằng cách đảm bảo giá trị tuyệt đối của offset âm nhỏ hơn hoặc bằng kích thước hiện tại của segment (trong trường hợp này là 2 KB).</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Mặc dù để đơn giản, chúng ta nói stack “bắt đầu” tại 28 KB, nhưng thực tế giá trị này là byte ngay <strong>trước</strong> vùng tăng trưởng ngược; byte hợp lệ đầu tiên thực sự là 28 KB trừ 1. Ngược lại, các vùng tăng trưởng xuôi bắt đầu tại địa chỉ của byte đầu tiên của segment. Chúng ta chọn cách này vì nó giúp việc tính toán physical address trở nên đơn giản: physical address chỉ là base cộng với offset âm.</p>
</div>
<h2 id="164-support-for-sharing-hỗ-trợ-chia-sẻ"><a class="header" href="#164-support-for-sharing-hỗ-trợ-chia-sẻ">16.4 Support for Sharing (Hỗ trợ chia sẻ)</a></h2>
<p>Khi hỗ trợ segmentation phát triển, các nhà thiết kế hệ thống sớm nhận ra rằng họ có thể đạt được những hiệu quả mới với một chút hỗ trợ phần cứng bổ sung. Cụ thể, để tiết kiệm bộ nhớ, đôi khi việc chia sẻ một số segment giữa các address space là hữu ích. Đặc biệt, <strong>code sharing</strong> (chia sẻ mã lệnh) là phổ biến và vẫn được sử dụng trong các hệ thống ngày nay.</p>
<p>Để hỗ trợ chia sẻ, chúng ta cần thêm một chút hỗ trợ từ phần cứng, dưới dạng <strong>protection bits</strong> (các bit bảo vệ). Hỗ trợ cơ bản thêm một vài bit cho mỗi segment, cho biết chương trình có thể đọc hoặc ghi segment hay không, hoặc có thể thực thi mã nằm trong segment đó hay không. Bằng cách đặt code segment ở chế độ chỉ đọc (<strong>read-only</strong>), cùng một mã lệnh có thể được chia sẻ giữa nhiều process, mà không lo ảnh hưởng đến tính cách ly; trong khi mỗi process vẫn nghĩ rằng nó đang truy cập bộ nhớ riêng, OS thực chất đang chia sẻ vùng bộ nhớ không thể bị process sửa đổi, do đó ảo tưởng này được duy trì.</p>
<p>Một ví dụ về thông tin bổ sung được phần cứng (và OS) theo dõi được thể hiện trong <em>Figure 16.5</em>. Như bạn thấy, code segment được đặt ở chế độ đọc và thực thi (<strong>read</strong> và <strong>execute</strong>), do đó cùng một segment vật lý trong bộ nhớ có thể được ánh xạ vào nhiều virtual address space.</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Base</th><th>Size (max 4K)</th><th>Grows Positive?</th><th>Protection</th></tr></thead><tbody>
<tr><td>Code 00</td><td>32K</td><td>2K</td><td>1</td><td>Read-Execute</td></tr>
<tr><td>Heap 01</td><td>34K</td><td>3K</td><td>1</td><td>Read-Write</td></tr>
<tr><td>Stack 11</td><td>28K</td><td>2K</td><td>0</td><td>Read-Write</td></tr>
</tbody></table>
</div>
<p><strong>Figure 16.5: Segment Register Values (with Protection)</strong><br />
<em>(Giá trị thanh ghi phân đoạn với bảo vệ)</em></p>
<p>Với protection bits, thuật toán phần cứng đã mô tả trước đó cũng phải thay đổi. Ngoài việc kiểm tra virtual address có nằm trong bounds hay không, phần cứng còn phải kiểm tra xem một truy cập cụ thể có được phép hay không. Nếu một user process cố ghi vào segment chỉ đọc, hoặc thực thi từ segment không cho phép thực thi, phần cứng sẽ phát sinh <strong>exception</strong>, và OS sẽ xử lý process vi phạm.</p>
<h2 id="165-fine-grained-vs-coarse-grained-segmentation"><a class="header" href="#165-fine-grained-vs-coarse-grained-segmentation">16.5 Fine-grained vs. Coarse-grained Segmentation</a></h2>
<p>(Phân đoạn mịn so với phân đoạn thô)</p>
<p>Hầu hết các ví dụ của chúng ta cho đến nay tập trung vào các hệ thống chỉ có một vài segment (ví dụ: code, stack, heap); chúng ta có thể coi segmentation này là <strong>coarse-grained</strong> (phân đoạn thô), vì nó chia address space thành các khối lớn, thô. Tuy nhiên, một số hệ thống đời đầu (ví dụ: <strong>Multics</strong> [CV65, DD68]) linh hoạt hơn và cho phép address space bao gồm một số lượng lớn các segment nhỏ hơn, gọi là <strong>fine-grained segmentation</strong> (phân đoạn mịn).</p>
<p><img src="16/img/fig16_6.PNG" alt="" /></p>
<p>Hỗ trợ nhiều segment đòi hỏi thêm hỗ trợ phần cứng, với một <strong>segment table</strong> (bảng phân đoạn) nào đó được lưu trong bộ nhớ. Các bảng phân đoạn như vậy thường hỗ trợ tạo ra một số lượng rất lớn segment, cho phép hệ thống sử dụng segment theo những cách linh hoạt hơn so với những gì chúng ta đã thảo luận. Ví dụ, các máy đời đầu như <strong>Burroughs B5000</strong> hỗ trợ hàng nghìn segment, và mong đợi trình biên dịch (compiler) chia nhỏ code và dữ liệu thành các segment riêng biệt mà OS và phần cứng sẽ hỗ trợ [RK68]. Suy nghĩ vào thời điểm đó là: bằng cách có các segment mịn, OS có thể hiểu rõ hơn segment nào đang được sử dụng và segment nào không, từ đó tận dụng <strong>main memory</strong> (bộ nhớ chính) hiệu quả hơn.</p>
<h2 id="166-os-support-hỗ-trợ-từ-hệ-điều-hành"><a class="header" href="#166-os-support-hỗ-trợ-từ-hệ-điều-hành">16.6 OS Support (Hỗ trợ từ Hệ điều hành)</a></h2>
<p>Đến đây, bạn đã có một ý tưởng cơ bản về cách <strong>segmentation</strong> (phân đoạn bộ nhớ) hoạt động. Các phần của <strong>address space</strong> (không gian địa chỉ) được tái định vị (relocate) vào <strong>physical memory</strong> (bộ nhớ vật lý) khi hệ thống chạy, và nhờ đó tiết kiệm được một lượng lớn physical memory so với cách tiếp cận đơn giản chỉ dùng một cặp <strong>base/bounds register</strong> (thanh ghi cơ sở/giới hạn) cho toàn bộ address space. Cụ thể, toàn bộ vùng trống giữa <strong>stack</strong> và <strong>heap</strong> không cần phải được cấp phát trong physical memory, cho phép chúng ta chứa nhiều address space hơn trong physical memory và hỗ trợ một virtual address space (bộ nhớ ảo) lớn và thưa (sparse) cho mỗi <strong>process</strong> (tiến trình).</p>
<p>Tuy nhiên, segmentation đặt ra một số vấn đề mới cho <strong>OS</strong> (hệ điều hành). Vấn đề đầu tiên là một vấn đề cũ: OS nên làm gì khi xảy ra <strong>context switch</strong> (chuyển ngữ cảnh)? Có lẽ bạn đã đoán được: các <strong>segment register</strong> (thanh ghi phân đoạn) phải được lưu và khôi phục. Rõ ràng, mỗi process có virtual address space riêng, và OS phải đảm bảo thiết lập đúng các thanh ghi này trước khi cho process chạy lại.</p>
<p>Vấn đề thứ hai là sự tương tác của OS khi các segment tăng (hoặc giảm) kích thước. Ví dụ, một chương trình có thể gọi <code>malloc()</code> để cấp phát một đối tượng. Trong một số trường hợp, heap hiện tại có thể đáp ứng yêu cầu, và <code>malloc()</code> sẽ tìm vùng trống cho đối tượng và trả về một con trỏ cho hàm gọi. Tuy nhiên, trong các trường hợp khác, chính heap segment có thể cần mở rộng. Khi đó, thư viện cấp phát bộ nhớ sẽ thực hiện một <strong>system call</strong> (call hệ thống) để mở rộng heap (ví dụ: system call <code>sbrk()</code> truyền thống của UNIX). OS sau đó (thường) sẽ cấp thêm không gian, cập nhật <strong>segment size register</strong> (thanh ghi kích thước segment) thành kích thước mới (lớn hơn), và thông báo cho thư viện biết việc mở rộng thành công; thư viện khi đó có thể cấp phát vùng nhớ cho đối tượng mới và trả về thành công cho chương trình gọi. Lưu ý rằng OS có thể từ chối yêu cầu nếu không còn physical memory, hoặc nếu nó quyết định rằng process gọi đã sử dụng quá nhiều.</p>
<blockquote>
<p><strong>TIP: IF 1000 SOLUTIONS EXIST, NO GREAT ONE DOES</strong><br />
Việc tồn tại quá nhiều thuật toán khác nhau nhằm giảm thiểu <strong>external fragmentation</strong> (phân mảnh bên ngoài) cho thấy một sự thật cơ bản hơn: không có một cách “tốt nhất” để giải quyết vấn đề. Do đó, chúng ta chọn một giải pháp hợp lý và hy vọng nó đủ tốt. Giải pháp thực sự duy nhất (như chúng ta sẽ thấy trong các chương tiếp theo) là tránh vấn đề ngay từ đầu, bằng cách không bao giờ cấp phát bộ nhớ theo các khối có kích thước thay đổi.</p>
</blockquote>
<p>Vấn đề cuối cùng, và có lẽ quan trọng nhất, là quản lý vùng trống trong physical memory. Khi một address space mới được tạo, OS phải tìm được chỗ trong physical memory cho các segment của nó. Trước đây, chúng ta giả định rằng mỗi address space có cùng kích thước, và do đó physical memory có thể được coi như một tập hợp các slot (ô nhớ) để đặt các process. Giờ đây, mỗi process có nhiều segment, và mỗi segment có thể có kích thước khác nhau.</p>
<p>Vấn đề chung phát sinh là physical memory nhanh chóng bị lấp đầy bởi các “lỗ” nhỏ của vùng trống, khiến việc cấp phát segment mới hoặc mở rộng segment hiện tại trở nên khó khăn. Chúng ta gọi vấn đề này là <strong>external fragmentation</strong> [R69]; xem <em>Figure 16.6</em> (trái).</p>
<p>Trong ví dụ, một process muốn cấp phát một segment 20 KB. Trong ví dụ này, có 24 KB trống, nhưng không nằm trong một vùng liên tục (mà ở ba khối rời rạc). Do đó, OS không thể đáp ứng yêu cầu 20 KB. Các vấn đề tương tự có thể xảy ra khi có yêu cầu mở rộng một segment; nếu số byte tiếp theo trong physical memory không có sẵn, OS sẽ phải từ chối yêu cầu, ngay cả khi vẫn còn byte trống ở nơi khác trong physical memory.</p>
<p>Một giải pháp cho vấn đề này là <strong>compaction</strong> (nén bộ nhớ vật lý) bằng cách sắp xếp lại các segment hiện có. Ví dụ, OS có thể dừng các process đang chạy, sao chép dữ liệu của chúng vào một vùng liên tục trong bộ nhớ, thay đổi giá trị segment register để trỏ tới vị trí vật lý mới, và nhờ đó có một vùng trống lớn để sử dụng. Bằng cách này, OS có thể đáp ứng yêu cầu cấp phát mới. Tuy nhiên, compaction rất tốn kém, vì việc sao chép segment tiêu tốn nhiều tài nguyên bộ nhớ và thường sử dụng khá nhiều thời gian CPU; xem <em>Figure 16.6</em> (phải) để thấy sơ đồ bộ nhớ vật lý sau khi compaction. Trớ trêu thay, compaction cũng khiến việc mở rộng các segment hiện có trở nên khó khăn, và có thể dẫn đến việc phải sắp xếp lại thêm để đáp ứng các yêu cầu đó.</p>
<p>Một cách tiếp cận đơn giản hơn là sử dụng một thuật toán quản lý <strong>free list</strong> (danh sách vùng trống) nhằm cố gắng giữ các vùng bộ nhớ lớn sẵn sàng cho việc cấp phát. Có hàng trăm cách tiếp cận đã được đề xuất, bao gồm các thuật toán kinh điển như <strong>best-fit</strong> (giữ danh sách các vùng trống và trả về vùng gần nhất về kích thước so với yêu cầu), <strong>worst-fit</strong>, <strong>first-fit</strong>, và các phương pháp phức tạp hơn như <strong>buddy algorithm</strong> [K68]. Một khảo sát xuất sắc của Wilson et al. [W+95] là điểm khởi đầu tốt nếu bạn muốn tìm hiểu thêm về các thuật toán này, hoặc bạn có thể chờ đến khi chúng ta đề cập đến một số nguyên lý cơ bản trong chương sau. Tuy nhiên, dù thuật toán có thông minh đến đâu, external fragmentation vẫn tồn tại; một thuật toán tốt chỉ cố gắng giảm thiểu nó.</p>
<h2 id="167-summary-tóm-tắt"><a class="header" href="#167-summary-tóm-tắt">16.7 Summary (Tóm tắt)</a></h2>
<p>Segmentation giải quyết được nhiều vấn đề và giúp chúng ta xây dựng một cơ chế ảo hóa bộ nhớ hiệu quả hơn. Ngoài việc hỗ trợ <strong>dynamic relocation</strong> (tái định vị động), segmentation còn hỗ trợ tốt hơn cho <strong>sparse address space</strong> (không gian địa chỉ thưa), bằng cách tránh lãng phí bộ nhớ lớn giữa các segment logic của address space. Nó cũng nhanh, vì các phép tính mà segmentation yêu cầu rất đơn giản và phù hợp với phần cứng; chi phí dịch địa chỉ là tối thiểu. Một lợi ích phụ nữa là <strong>code sharing</strong> (chia sẻ mã lệnh). Nếu code được đặt trong một segment riêng, segment đó có thể được chia sẻ giữa nhiều chương trình đang chạy.</p>
<p>Tuy nhiên, như chúng ta đã thấy, việc cấp phát các segment có kích thước thay đổi trong bộ nhớ dẫn đến một số vấn đề cần khắc phục. Vấn đề đầu tiên, như đã thảo luận ở trên, là <strong>external fragmentation</strong>. Vì segment có kích thước thay đổi, vùng nhớ trống bị chia nhỏ thành các mảnh kích thước lẻ, khiến việc đáp ứng yêu cầu cấp phát bộ nhớ trở nên khó khăn. Có thể sử dụng các thuật toán thông minh [W+95] hoặc định kỳ compaction bộ nhớ, nhưng vấn đề này là cơ bản và khó tránh.</p>
<p>Vấn đề thứ hai, và có lẽ quan trọng hơn, là segmentation vẫn chưa đủ linh hoạt để hỗ trợ một sparse address space tổng quát hoàn toàn. Ví dụ, nếu chúng ta có một heap lớn nhưng sử dụng thưa, tất cả nằm trong một segment logic, thì toàn bộ heap vẫn phải nằm trong bộ nhớ để có thể truy cập. Nói cách khác, nếu mô hình sử dụng address space của chúng ta không khớp chính xác với cách segmentation được thiết kế để hỗ trợ, segmentation sẽ hoạt động không hiệu quả. Do đó, chúng ta cần tìm các giải pháp mới. Sẵn sàng khám phá chúng chứ?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-quản-lý-vùng-trống-free-space-management"><a class="header" href="#17-quản-lý-vùng-trống-free-space-management">17 Quản lý vùng trống (Free-Space Management)</a></h1>
<p>Trong chương này, chúng ta sẽ tạm rẽ sang một hướng khác so với chủ đề ảo hóa bộ nhớ (virtualizing memory) để bàn về một khía cạnh nền tảng của bất kỳ hệ thống quản lý bộ nhớ nào, dù đó là thư viện <code>malloc</code> (quản lý các page của heap của một process – tiến trình) hay chính hệ điều hành (OS – Operating System) quản lý các phần của không gian địa chỉ (address space) của một process. Cụ thể, chúng ta sẽ thảo luận về các vấn đề xoay quanh <strong>free-space management</strong> (quản lý vùng trống).</p>
<p>Hãy làm rõ vấn đề hơn. Việc quản lý vùng trống có thể rất dễ dàng, như chúng ta sẽ thấy khi bàn về khái niệm <strong>paging</strong> (phân trang). Nó dễ khi vùng nhớ bạn quản lý được chia thành các đơn vị có kích thước cố định; trong trường hợp đó, bạn chỉ cần giữ một danh sách các đơn vị cố định này; khi một client yêu cầu một đơn vị, bạn chỉ việc trả về phần tử đầu tiên.</p>
<p>Quản lý vùng trống trở nên khó khăn (và thú vị) hơn khi vùng trống bạn quản lý bao gồm các đơn vị có kích thước thay đổi; điều này xảy ra trong thư viện cấp phát bộ nhớ ở mức người dùng (user-level memory-allocation library, như <code>malloc()</code> và <code>free()</code>) và trong OS khi quản lý bộ nhớ vật lý bằng <strong>segmentation</strong> (phân đoạn) để triển khai <strong>virtual memory</strong> (bộ nhớ ảo). Trong cả hai trường hợp, vấn đề được gọi là <strong>external fragmentation</strong> (phân mảnh bên ngoài): vùng trống bị chia nhỏ thành nhiều mảnh có kích thước khác nhau và do đó bị phân mảnh; các yêu cầu cấp phát sau đó có thể thất bại vì không có một vùng liên tục đủ lớn để đáp ứng, mặc dù tổng dung lượng trống vẫn lớn hơn kích thước yêu cầu.</p>
<p><img src="17/img/fig17_1_2.PNG" alt="Figure: Ví dụ về external fragmentation" /></p>
<p>Hình dưới đây minh họa ví dụ về vấn đề này. Trong trường hợp này, tổng vùng trống là 20 byte; tuy nhiên, nó bị phân mảnh thành hai khối, mỗi khối 10 byte. Do đó, một yêu cầu cấp phát 15 byte sẽ thất bại mặc dù tổng dung lượng trống là 20 byte. Và đây chính là vấn đề mà chương này sẽ giải quyết.</p>
<blockquote>
<p><strong>CRUX: CÁCH QUẢN LÝ VÙNG TRỐNG</strong></p>
<p>Làm thế nào để quản lý vùng trống khi phải đáp ứng các yêu cầu có kích thước thay đổi? Chiến lược nào có thể được sử dụng để giảm thiểu phân mảnh? Chi phí về thời gian và bộ nhớ của các phương pháp thay thế là gì?</p>
</blockquote>
<h2 id="171-các-giả-định-assumptions"><a class="header" href="#171-các-giả-định-assumptions">17.1 Các giả định (Assumptions)</a></h2>
<p>Phần lớn nội dung thảo luận sẽ tập trung vào lịch sử phong phú của các <strong>allocator</strong> (bộ cấp phát) trong thư viện cấp phát bộ nhớ ở mức người dùng. Chúng tôi tham khảo khảo sát xuất sắc của Wilson [W+95] và khuyến khích bạn đọc quan tâm tìm đọc tài liệu gốc để biết thêm chi tiết^[1].</p>
<p>Chúng ta giả định một giao diện cơ bản như <code>malloc()</code> và <code>free()</code>. Cụ thể, <code>void *malloc(size_t size)</code> nhận một tham số duy nhất <code>size</code>, là số byte mà ứng dụng yêu cầu; hàm này trả về một con trỏ (pointer) không có kiểu cụ thể, hay còn gọi là <strong>void pointer</strong> trong ngôn ngữ C, trỏ tới một vùng nhớ có kích thước bằng hoặc lớn hơn giá trị yêu cầu. Hàm bổ sung <code>void free(void *ptr)</code> nhận một con trỏ và giải phóng khối bộ nhớ tương ứng. Lưu ý hệ quả của giao diện này: khi người dùng giải phóng vùng nhớ, họ không thông báo cho thư viện biết kích thước của nó; do đó, thư viện phải tự xác định kích thước của khối bộ nhớ khi chỉ được cung cấp con trỏ. Chúng ta sẽ bàn về cách thực hiện điều này ở phần sau của chương.</p>
<p>Vùng nhớ mà thư viện này quản lý được gọi là <strong>heap</strong>, và cấu trúc dữ liệu tổng quát dùng để quản lý vùng trống trong heap là một dạng <strong>free list</strong> (danh sách vùng trống). Cấu trúc này chứa các tham chiếu tới tất cả các khối vùng trống trong vùng nhớ được quản lý. Tất nhiên, cấu trúc dữ liệu này không nhất thiết phải là danh sách tuyến tính, mà có thể là bất kỳ cấu trúc nào giúp theo dõi vùng trống.</p>
<p>Chúng ta cũng giả định rằng mối quan tâm chính là <strong>external fragmentation</strong> như đã mô tả ở trên. Các allocator cũng có thể gặp vấn đề <strong>internal fragmentation</strong> (phân mảnh bên trong); nếu một allocator cấp phát khối bộ nhớ lớn hơn yêu cầu, phần dư thừa (không được yêu cầu và không sử dụng) trong khối đó được xem là internal fragmentation (vì lãng phí xảy ra bên trong đơn vị đã cấp phát) và cũng là một dạng lãng phí bộ nhớ. Tuy nhiên, để đơn giản và vì external fragmentation thú vị hơn, chúng ta sẽ tập trung chủ yếu vào external fragmentation.</p>
<p>Chúng ta cũng giả định rằng một khi bộ nhớ đã được cấp phát cho client, nó không thể được di chuyển sang vị trí khác trong bộ nhớ. Ví dụ, nếu một chương trình gọi <code>malloc()</code> và nhận được một con trỏ tới một vùng trong heap, vùng nhớ đó về cơ bản được “sở hữu” bởi chương trình (và không thể bị thư viện di chuyển) cho đến khi chương trình trả lại nó thông qua call <code>free()</code> tương ứng. Do đó, không thể thực hiện <strong>compaction</strong> (gom khối) vùng trống, mặc dù đây là một kỹ thuật hữu ích để chống phân mảnh^[2]. Tuy nhiên, compaction có thể được OS sử dụng để xử lý phân mảnh khi triển khai segmentation (như đã bàn trong chương về segmentation).</p>
<p>^[1]: Tài liệu này dài gần 80 trang; bạn thực sự phải rất quan tâm mới đọc hết!<br />
^[2]: Khi bạn đưa một con trỏ tới một khối bộ nhớ cho chương trình C, thường rất khó để xác định tất cả các tham chiếu (pointer) tới vùng đó, vì chúng có thể được lưu trong các biến khác hoặc thậm chí trong thanh ghi tại một thời điểm thực thi. Điều này có thể không đúng với các ngôn ngữ có kiểu mạnh và thu gom rác (garbage-collected), vốn cho phép compaction như một kỹ thuật chống phân mảnh.</p>
<p>Cuối cùng, chúng ta giả định rằng allocator quản lý một vùng byte liên tục. Trong một số trường hợp, allocator có thể yêu cầu mở rộng vùng này; ví dụ, thư viện cấp phát bộ nhớ ở mức người dùng có thể gọi vào kernel để mở rộng heap (thông qua system call như <code>sbrk</code>) khi hết chỗ. Tuy nhiên, để đơn giản, chúng ta giả định rằng vùng này có kích thước cố định trong suốt vòng đời của nó.</p>
<h2 id="172-các-cơ-chế-mức-thấp-low-level-mechanisms"><a class="header" href="#172-các-cơ-chế-mức-thấp-low-level-mechanisms">17.2 Các cơ chế mức thấp (Low-level Mechanisms)</a></h2>
<p>Trước khi đi sâu vào một số chi tiết về <strong>policy</strong> (chính sách cấp phát), trước hết chúng ta sẽ tìm hiểu một số cơ chế phổ biến được sử dụng trong hầu hết các <strong>allocator</strong> (bộ cấp phát). Đầu tiên, chúng ta sẽ thảo luận về các nguyên tắc cơ bản của <strong>splitting</strong> (chia nhỏ) và <strong>coalescing</strong> (gộp khối), những kỹ thuật thường gặp trong hầu hết các allocator. Tiếp theo, chúng ta sẽ xem cách theo dõi kích thước của các vùng đã cấp phát một cách nhanh chóng và tương đối dễ dàng. Cuối cùng, chúng ta sẽ bàn về cách xây dựng một danh sách đơn giản bên trong vùng trống để theo dõi phần nào đang trống và phần nào đã được sử dụng.</p>
<h3 id="splitting-và-coalescing"><a class="header" href="#splitting-và-coalescing">Splitting và Coalescing</a></h3>
<p>Một <strong>free list</strong> (danh sách vùng trống) chứa tập hợp các phần tử mô tả vùng trống còn lại trong <strong>heap</strong>. Giả sử chúng ta có một heap 30 byte như sau:</p>
<p><img src="17/img/fig17_1_2.PNG" alt="" /></p>
<p>Free list cho heap này sẽ có hai phần tử. Một phần tử mô tả đoạn trống 10 byte đầu tiên (byte 0–9), và một phần tử mô tả đoạn trống còn lại (byte 20–29):</p>
<p><img src="17/img/fig17_1_3.PNG" alt="" /></p>
<p>Như đã mô tả ở trên, một yêu cầu cấp phát lớn hơn 10 byte sẽ thất bại (trả về <code>NULL</code>), vì không có một khối bộ nhớ liên tục nào đủ lớn để đáp ứng. Một yêu cầu đúng bằng 10 byte có thể được đáp ứng dễ dàng bởi một trong hai khối trống. Nhưng điều gì xảy ra nếu yêu cầu nhỏ hơn 10 byte?</p>
<p>Giả sử chúng ta có một yêu cầu chỉ lấy 1 byte bộ nhớ. Trong trường hợp này, allocator sẽ thực hiện một thao tác gọi là <strong>splitting</strong>: nó sẽ tìm một khối trống đủ lớn để đáp ứng yêu cầu và chia nó thành hai phần. Phần thứ nhất sẽ được trả về cho người gọi; phần thứ hai sẽ vẫn nằm trong free list. Trong ví dụ trên, nếu yêu cầu 1 byte được đưa ra và allocator quyết định sử dụng phần tử thứ hai trong danh sách để đáp ứng yêu cầu, call <code>malloc()</code> sẽ trả về địa chỉ 20 (địa chỉ của vùng 1 byte được cấp phát) và danh sách sẽ trở thành:</p>
<p><img src="17/img/fig17_1_4.PNG" alt="" /></p>
<p>Trong hình minh họa, bạn có thể thấy danh sách về cơ bản vẫn giữ nguyên; thay đổi duy nhất là vùng trống giờ bắt đầu tại byte 21 thay vì 20, và độ dài vùng trống này chỉ còn 9 byte^[3]. Do đó, splitting thường được sử dụng trong allocator khi yêu cầu nhỏ hơn kích thước của bất kỳ khối trống nào.</p>
<p>Một cơ chế bổ sung thường thấy trong nhiều allocator là <strong>coalescing</strong> vùng trống. Lấy lại ví dụ ở trên (trống 10 byte, dùng 10 byte, trống 10 byte).</p>
<p>Với heap nhỏ này, điều gì xảy ra khi một ứng dụng gọi <code>free(10)</code>, trả lại vùng ở giữa heap? Nếu chúng ta chỉ đơn giản thêm vùng trống này vào danh sách mà không xử lý gì thêm, chúng ta có thể nhận được danh sách như sau:</p>
<p><img src="17/img/fig17_1_5.PNG" alt="" /></p>
<p>Hãy chú ý vấn đề: mặc dù toàn bộ heap giờ đã trống, nó lại bị chia thành ba khối 10 byte. Do đó, nếu người dùng yêu cầu 20 byte, việc duyệt danh sách sẽ không tìm thấy khối trống đủ lớn và sẽ trả về lỗi.</p>
<p>Để tránh vấn đề này, allocator sẽ <strong>coalesce</strong> vùng trống khi một khối bộ nhớ được giải phóng. Ý tưởng rất đơn giản: khi trả lại một khối trống, hãy kiểm tra kỹ địa chỉ của khối này và các khối trống lân cận; nếu vùng vừa được giải phóng nằm ngay cạnh một (hoặc hai, như trong ví dụ này) khối trống hiện có, hãy gộp chúng thành một khối trống lớn hơn. Với coalescing, danh sách cuối cùng sẽ như sau:</p>
<p><img src="17/img/fig17_1_6.PNG" alt="" /></p>
<p>Thực tế, đây chính là trạng thái ban đầu của heap trước khi có bất kỳ cấp phát nào. Nhờ coalescing, allocator có thể đảm bảo tốt hơn rằng các khối trống lớn sẽ sẵn sàng cho ứng dụng.</p>
<p>^[3]: Phần thảo luận này giả định không có <strong>header</strong> (phần tiêu đề lưu thông tin quản lý), đây là giả định không thực tế nhưng giúp đơn giản hóa vấn đề.</p>
<h3 id="theo-dõi-kích-thước-vùng-đã-cấp-phát-tracking-the-size-of-allocated-regions"><a class="header" href="#theo-dõi-kích-thước-vùng-đã-cấp-phát-tracking-the-size-of-allocated-regions">Theo dõi kích thước vùng đã cấp phát (Tracking The Size Of Allocated Regions)</a></h3>
<p>Bạn có thể nhận thấy rằng giao diện <code>free(void *ptr)</code> không nhận tham số kích thước; do đó, giả định rằng khi có một con trỏ, thư viện <code>malloc</code> có thể nhanh chóng xác định kích thước của vùng bộ nhớ được giải phóng và đưa vùng này trở lại free list.</p>
<p>Để thực hiện điều này, hầu hết các allocator lưu một lượng nhỏ thông tin bổ sung trong một <strong>header block</strong> (khối tiêu đề) được giữ trong bộ nhớ, thường nằm ngay trước khối bộ nhớ được cấp phát cho người dùng. Hãy xem một ví dụ (Hình 17.1). Trong ví dụ này, chúng ta đang xét một khối đã cấp phát có kích thước 20 byte, được trỏ bởi <code>ptr</code>; giả sử người dùng gọi <code>malloc()</code> và lưu kết quả vào <code>ptr</code>, ví dụ:<br />
<code>ptr = malloc(20);</code></p>
<p><img src="17/img/fig17_1.PNG" alt="Figure 17.1: An Allocated Region Plus Header" /></p>
<p><strong>Hình 17.1:</strong> Một vùng đã cấp phát kèm header</p>
<p>Header tối thiểu sẽ chứa kích thước của vùng đã cấp phát (trong trường hợp này là 20); nó cũng có thể chứa các con trỏ bổ sung để tăng tốc giải phóng, một <strong>magic number</strong> (số đặc biệt) để kiểm tra tính toàn vẹn dữ liệu, và các thông tin khác. Giả sử một header đơn giản chỉ chứa kích thước vùng và magic number, như sau:</p>
<pre><code class="language-c">typedef struct {
  int size;
  int magic;
} header_t;
</code></pre>
<p><img src="17/img/fig17_2.PNG" alt="Figure 17.2: Specific Contents Of The Header" /></p>
<p><strong>Hình 17.2:</strong> Nội dung cụ thể của header</p>
<p>Ví dụ trên sẽ trông giống như trong Hình 17.2. Khi người dùng gọi <code>free(ptr)</code>, thư viện sẽ dùng phép toán con trỏ đơn giản để xác định vị trí bắt đầu của header:</p>
<pre><code class="language-c">void free(void *ptr) {
  header_t *hptr = (header_t *) ptr - 1;
  ...
}
</code></pre>
<p>Sau khi có con trỏ tới header, thư viện có thể dễ dàng kiểm tra xem magic number có khớp với giá trị mong đợi hay không như một bước kiểm tra hợp lệ (<code>assert(hptr-&gt;magic == 1234567)</code>), và tính toán tổng kích thước của vùng vừa được giải phóng bằng phép cộng đơn giản (tức là cộng kích thước của header với kích thước vùng dữ liệu của người dùng). Lưu ý một chi tiết nhỏ nhưng quan trọng: kích thước của vùng trống là kích thước của header cộng với kích thước vùng được cấp phát cho người dùng. Do đó, khi người dùng yêu cầu N byte bộ nhớ, thư viện không tìm kiếm một khối trống có kích thước N, mà tìm một khối trống có kích thước <strong>N + kích thước header</strong>.</p>
<h3 id="nhúng-một-free-list-embedding-a-free-list"><a class="header" href="#nhúng-một-free-list-embedding-a-free-list">Nhúng một Free List (Embedding A Free List)</a></h3>
<p>Cho đến giờ, chúng ta mới chỉ xem <strong>free list</strong> (danh sách vùng trống) đơn giản của mình như một thực thể khái niệm; nó chỉ là một danh sách mô tả các khối bộ nhớ trống trong <strong>heap</strong>. Nhưng làm thế nào để xây dựng danh sách này <strong>ngay bên trong</strong> chính vùng trống đó?</p>
<p>Trong một danh sách thông thường, khi cần cấp phát một <strong>node</strong> mới, bạn chỉ việc gọi <code>malloc()</code> để lấy bộ nhớ cho node đó. Thật không may, bên trong thư viện cấp phát bộ nhớ (<strong>memory-allocation library</strong>), bạn <strong>không thể</strong> làm như vậy! Thay vào đó, bạn cần xây dựng danh sách <strong>ngay bên trong</strong> vùng trống. Đừng lo nếu điều này nghe có vẻ hơi kỳ lạ; đúng là hơi khác thường, nhưng hoàn toàn có thể thực hiện được.</p>
<p>Giả sử chúng ta có một khối bộ nhớ 4096 byte để quản lý (tức heap là 4KB). Để quản lý nó như một free list, trước tiên chúng ta phải khởi tạo danh sách; ban đầu, danh sách sẽ chỉ có <strong>một phần tử</strong>, kích thước 4096 byte (trừ đi kích thước header). Đây là mô tả của một node trong danh sách:</p>
<pre><code class="language-c">typedef struct __node_t {
  int size;
  struct __node_t *next;
} node_t;
</code></pre>
<p>Bây giờ, hãy xem một đoạn code khởi tạo heap và đặt phần tử đầu tiên của free list vào chính vùng trống đó. Chúng ta giả định rằng heap được xây dựng từ một vùng trống lấy được thông qua call <strong>system call</strong> <code>mmap()</code>; đây không phải là cách duy nhất để tạo heap, nhưng phù hợp cho ví dụ này. Đoạn code như sau:</p>
<pre><code class="language-c">// mmap() trả về một con trỏ tới một vùng trống
node_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE,
                    MAP_ANON|MAP_PRIVATE, -1, 0);
head-&gt;size = 4096 - sizeof(node_t);
head-&gt;next = NULL;
</code></pre>
<p><img src="17/img/fig17_3.PNG" alt="Figure 17.3: A Heap With One Free Chunk" /></p>
<p><strong>Hình 17.3:</strong> Một heap với một khối trống duy nhất</p>
<p>Sau khi chạy đoạn code này, trạng thái danh sách là: nó có một phần tử duy nhất, kích thước 4088 byte. Đúng, đây là một heap rất nhỏ, nhưng đủ để minh họa. Con trỏ <code>head</code> chứa địa chỉ bắt đầu của vùng này; giả sử nó là 16KB (mặc dù bất kỳ địa chỉ ảo nào cũng được). Trực quan, heap trông giống như trong <strong>Hình 17.3</strong>.</p>
<p><strong>Hình 17.4:</strong> Heap sau một lần cấp phát<br />
<img src="17/img/fig17_4.PNG" alt="Figure 17.4: A Heap: After One Allocation" /></p>
<p>Bây giờ, giả sử có một yêu cầu cấp phát bộ nhớ, ví dụ 100 byte. Để xử lý yêu cầu này, thư viện sẽ tìm một khối trống đủ lớn; vì chỉ có một khối trống (kích thước 4088 byte), khối này sẽ được chọn. Sau đó, khối này sẽ được <strong>chia</strong> thành hai: một khối đủ lớn để đáp ứng yêu cầu (cộng với header, như đã mô tả ở trên) và phần còn lại là khối trống. Giả sử header dài 8 byte (gồm một số nguyên <code>size</code> và một số nguyên <code>magic number</code>), vùng nhớ trong heap lúc này sẽ giống như trong <strong>Hình 17.4</strong>.</p>
<p><img src="17/img/fig17_5.PNG" alt="Figure 17.5: Free Space With Three Chunks Allocated" /></p>
<p><strong>Hình 17.5:</strong> Vùng trống khi đã cấp phát ba khối</p>
<p>Như vậy, với yêu cầu 100 byte, thư viện đã cấp phát 108 byte từ khối trống duy nhất, trả về một con trỏ (được đánh dấu <code>ptr</code> trong hình) tới vùng này, lưu thông tin header ngay trước vùng cấp phát để dùng khi <code>free()</code>, và thu nhỏ node trống duy nhất trong danh sách xuống còn 3980 byte (4088 trừ 108).</p>
<p>Bây giờ, hãy xem heap khi có <strong>ba vùng đã cấp phát</strong>, mỗi vùng 100 byte (hoặc 108 byte nếu tính cả header). Hình minh họa heap này được thể hiện trong <strong>Hình 17.5</strong>.</p>
<p><img src="17/img/fig17_6.PNG" alt="Figure 17.6: Free Space With Two Chunks Allocated" /></p>
<p><strong>Hình 17.6:</strong> Vùng trống khi còn hai khối đã cấp phát</p>
<p>Như bạn thấy, 324 byte đầu tiên của heap hiện đã được cấp phát, và ta thấy ba header trong vùng này cùng ba vùng 100 byte đang được chương trình sử dụng. Free list vẫn đơn giản: chỉ một node (được <code>head</code> trỏ tới), nhưng giờ chỉ còn 3764 byte sau ba lần chia. Nhưng điều gì xảy ra khi chương trình trả lại một phần bộ nhớ qua <code>free()</code>?</p>
<p>Trong ví dụ này, ứng dụng trả lại <strong>khối ở giữa</strong> bằng cách gọi <code>free(16500)</code> (giá trị 16500 có được bằng cách cộng địa chỉ bắt đầu vùng nhớ 16384 với 108 byte của khối trước đó và 8 byte header của khối này). Giá trị này được thể hiện trong hình trước bởi con trỏ <code>sptr</code>.</p>
<p><strong>Hình 17.7:</strong> Free list không được coalescing<br />
<img src="17/img/fig17_7.PNG" alt="Figure 17.7: A Non-Coalesced Free List" /></p>
<p>Thư viện ngay lập tức xác định kích thước vùng trống, rồi thêm khối này vào free list. Giả sử chúng ta chèn vào đầu free list, vùng nhớ lúc này sẽ giống như trong <strong>Hình 17.6</strong>.</p>
<p>Bây giờ, chúng ta có một danh sách bắt đầu bằng một khối trống nhỏ (100 byte, được <code>head</code> trỏ tới) và một khối trống lớn (3764 byte). Cuối cùng, danh sách của chúng ta đã có hơn một phần tử! Và đúng vậy, vùng trống đã bị <strong>phân mảnh</strong> — một hiện tượng không mong muốn nhưng thường gặp.</p>
<p>Ví dụ cuối cùng: giả sử bây giờ hai khối đang sử dụng còn lại được giải phóng. <strong>Nếu không coalescing</strong>, bạn sẽ gặp phân mảnh (Hình 17.7). Như bạn thấy, chúng ta có một “mớ hỗn độn”! Tại sao? Đơn giản là vì chúng ta quên gộp danh sách. Mặc dù toàn bộ bộ nhớ đang trống, nó bị chia nhỏ thành nhiều mảnh, khiến nó <strong>trông như</strong> bị phân mảnh dù thực tế không phải. Giải pháp rất đơn giản: duyệt qua danh sách và gộp các khối liền kề; khi hoàn tất, heap sẽ trở lại nguyên vẹn.</p>
<h3 id="mở-rộng-heap-growing-the-heap"><a class="header" href="#mở-rộng-heap-growing-the-heap">Mở rộng Heap (Growing The Heap)</a></h3>
<p>Chúng ta nên thảo luận về một cơ chế cuối cùng thường xuất hiện trong nhiều thư viện cấp phát bộ nhớ. Cụ thể, bạn sẽ làm gì nếu <strong>heap</strong> (vùng nhớ động) hết chỗ? Cách tiếp cận đơn giản nhất là… thất bại. Trong một số trường hợp, đây là lựa chọn duy nhất, và việc trả về <code>NULL</code> là một cách xử lý “đường đường chính chính”. Đừng cảm thấy tệ! Bạn đã cố gắng, và dù thất bại, bạn vẫn đã “chiến đấu” hết mình.</p>
<p>Hầu hết các <strong>allocator</strong> (bộ cấp phát) truyền thống bắt đầu với một heap có kích thước nhỏ, sau đó yêu cầu thêm bộ nhớ từ <strong>OS</strong> (hệ điều hành) khi hết chỗ. Thông thường, điều này có nghĩa là chúng sẽ thực hiện một call <strong>system call</strong> (call hệ thống) nào đó (ví dụ: <code>sbrk</code> trong hầu hết các hệ thống UNIX) để mở rộng heap, rồi cấp phát các khối mới từ đó. Để xử lý yêu cầu <code>sbrk</code>, OS sẽ tìm các <strong>physical page</strong> (trang bộ nhớ vật lý) còn trống, ánh xạ chúng vào <strong>address space</strong> (không gian địa chỉ) của <strong>process</strong> (tiến trình) yêu cầu, rồi trả về giá trị địa chỉ kết thúc của heap mới; tại thời điểm đó, một heap lớn hơn đã sẵn sàng, và yêu cầu cấp phát có thể được xử lý thành công.</p>
<h2 id="173-các-chiến-lược-cơ-bản-basic-strategies"><a class="header" href="#173-các-chiến-lược-cơ-bản-basic-strategies">17.3 Các chiến lược cơ bản (Basic Strategies)</a></h2>
<p>Bây giờ khi chúng ta đã có một số cơ chế nền tảng, hãy cùng xem qua một số chiến lược cơ bản để quản lý vùng trống. Các cách tiếp cận này chủ yếu dựa trên những <strong>policy</strong> (chính sách) khá đơn giản mà chính bạn cũng có thể nghĩ ra; hãy thử suy nghĩ trước khi đọc tiếp để xem bạn có thể tìm ra tất cả các phương án (hoặc thậm chí những phương án mới) hay không.</p>
<p>Một allocator lý tưởng vừa phải nhanh, vừa phải giảm thiểu phân mảnh (<strong>fragmentation</strong>). Thật không may, vì luồng yêu cầu cấp phát và giải phóng có thể tùy ý (do lập trình viên quyết định), bất kỳ chiến lược nào cũng có thể hoạt động rất tệ nếu gặp bộ dữ liệu đầu vào “khó chịu”. Do đó, chúng ta sẽ không mô tả một phương pháp “tốt nhất”, mà chỉ bàn về một số phương pháp cơ bản, cùng ưu và nhược điểm của chúng.</p>
<h3 id="best-fit"><a class="header" href="#best-fit">Best Fit</a></h3>
<p>Chiến lược <strong>best fit</strong> khá đơn giản: trước tiên, duyệt qua <strong>free list</strong> (danh sách vùng trống) và tìm các khối bộ nhớ trống có kích thước <strong>bằng hoặc lớn hơn</strong> kích thước yêu cầu. Sau đó, trả về khối <strong>nhỏ nhất</strong> trong nhóm ứng viên này; đây chính là khối “best-fit” (có thể gọi là “smallest fit” – vừa khít nhất). Chỉ cần một lần duyệt qua free list là đủ để tìm khối phù hợp.</p>
<p>Trực giác đằng sau best fit rất rõ ràng: bằng cách trả về một khối gần với kích thước mà người dùng yêu cầu, best fit cố gắng giảm thiểu lãng phí bộ nhớ. Tuy nhiên, cái giá phải trả là hiệu năng; các triển khai đơn giản sẽ chịu chi phí tìm kiếm rất lớn khi phải duyệt toàn bộ danh sách để tìm khối phù hợp.</p>
<h3 id="worst-fit"><a class="header" href="#worst-fit">Worst Fit</a></h3>
<p>Chiến lược <strong>worst fit</strong> là đối lập với best fit: tìm khối lớn nhất và cấp phát phần bộ nhớ được yêu cầu; phần còn lại (vẫn là một khối lớn) được giữ lại trong free list. Worst fit cố gắng để lại các khối lớn thay vì tạo ra nhiều khối nhỏ như có thể xảy ra với best fit. Tuy nhiên, một lần nữa, phương pháp này yêu cầu duyệt toàn bộ vùng trống, và do đó có thể tốn kém. Tệ hơn, hầu hết các nghiên cứu cho thấy nó hoạt động kém, dẫn đến phân mảnh nhiều hơn trong khi vẫn có chi phí cao.</p>
<h3 id="first-fit"><a class="header" href="#first-fit">First Fit</a></h3>
<p>Phương pháp <strong>first fit</strong> chỉ đơn giản là tìm khối đầu tiên đủ lớn và cấp phát phần bộ nhớ được yêu cầu cho người dùng. Phần còn lại của khối vẫn được giữ lại để phục vụ các yêu cầu sau.</p>
<p>First fit có ưu điểm là nhanh — không cần duyệt toàn bộ danh sách vùng trống — nhưng đôi khi làm “ô nhiễm” phần đầu của free list với các khối nhỏ. Do đó, cách mà allocator quản lý thứ tự của free list trở thành một vấn đề. Một cách tiếp cận là sử dụng <strong>address-based ordering</strong> (sắp xếp theo địa chỉ); bằng cách giữ danh sách được sắp xếp theo địa chỉ của vùng trống, việc coalescing trở nên dễ dàng hơn và phân mảnh có xu hướng giảm.</p>
<h3 id="next-fit"><a class="header" href="#next-fit">Next Fit</a></h3>
<p>Thay vì luôn bắt đầu tìm kiếm theo kiểu first fit từ đầu danh sách, thuật toán <strong>next fit</strong> giữ thêm một con trỏ tới vị trí trong danh sách mà lần tìm kiếm trước đã dừng lại. Ý tưởng là phân tán việc tìm kiếm vùng trống đều hơn trên toàn bộ danh sách, tránh việc “băm nhỏ” phần đầu danh sách. Hiệu năng của phương pháp này khá giống với first fit, vì vẫn tránh được việc duyệt toàn bộ danh sách.</p>
<h3 id="ví-dụ"><a class="header" href="#ví-dụ">Ví dụ</a></h3>
<p>Dưới đây là một vài ví dụ về các chiến lược trên. Hãy hình dung một free list có ba phần tử, kích thước lần lượt là 10, 30 và 20 (chúng ta sẽ bỏ qua header và các chi tiết khác, chỉ tập trung vào cách các chiến lược hoạt động):</p>
<p><img src="17/img/fig17_7_1.PNG" alt="" /></p>
<p>Giả sử có một yêu cầu cấp phát kích thước 15. Cách tiếp cận <strong>best fit</strong> sẽ duyệt toàn bộ danh sách và tìm ra rằng khối 20 là phù hợp nhất, vì nó là khối nhỏ nhất có thể chứa yêu cầu. Free list sau đó sẽ là:</p>
<p><img src="17/img/fig17_7_2.PNG" alt="" /></p>
<p>Như trong ví dụ này, và thường xảy ra với best fit, một khối trống nhỏ sẽ bị bỏ lại. Cách tiếp cận <strong>worst fit</strong> tương tự nhưng thay vào đó tìm khối lớn nhất, trong ví dụ này là khối 30. Free list sau đó sẽ là:</p>
<p><img src="17/img/fig17_7_3.PNG" alt="" /></p>
<p>Chiến lược <strong>first fit</strong> trong ví dụ này làm điều tương tự như worst fit, cũng tìm khối trống đầu tiên có thể đáp ứng yêu cầu. Sự khác biệt nằm ở chi phí tìm kiếm; cả best fit và worst fit đều duyệt toàn bộ danh sách, trong khi first fit chỉ kiểm tra các khối trống cho đến khi tìm được khối phù hợp, do đó giảm chi phí tìm kiếm.</p>
<p>Những ví dụ này chỉ mới “lướt qua bề mặt” của các chính sách cấp phát. Để hiểu sâu hơn, cần có phân tích chi tiết hơn với các tải công việc thực tế và hành vi allocator phức tạp hơn (ví dụ: coalescing). Có lẽ đây sẽ là một bài tập thú vị cho phần bài tập về nhà?</p>
<h2 id="174-các-cách-tiếp-cận-khác-other-approaches"><a class="header" href="#174-các-cách-tiếp-cận-khác-other-approaches">17.4 Các cách tiếp cận khác (Other Approaches)</a></h2>
<p>Ngoài các phương pháp cơ bản đã mô tả ở trên, đã có rất nhiều kỹ thuật và thuật toán được đề xuất nhằm cải thiện việc cấp phát bộ nhớ theo nhiều cách khác nhau. Dưới đây là một số ví dụ để bạn tham khảo (tức là để bạn suy nghĩ nhiều hơn một chút ngoài phương pháp <strong>best-fit allocation</strong>).</p>
<h3 id="segregated-lists-danh-sách-phân-tách"><a class="header" href="#segregated-lists-danh-sách-phân-tách">Segregated Lists (Danh sách phân tách)</a></h3>
<p>Một cách tiếp cận thú vị đã tồn tại từ lâu là sử dụng <strong>segregated lists</strong> (danh sách phân tách). Ý tưởng cơ bản rất đơn giản: nếu một ứng dụng cụ thể thường xuyên có một (hoặc một vài) yêu cầu cấp phát với kích thước phổ biến, hãy giữ một danh sách riêng chỉ để quản lý các đối tượng có kích thước đó; tất cả các yêu cầu khác sẽ được chuyển đến một <strong>memory allocator</strong> (bộ cấp phát bộ nhớ) tổng quát hơn.</p>
<p>Lợi ích của cách tiếp cận này là rõ ràng. Bằng cách dành riêng một phần bộ nhớ cho một kích thước yêu cầu cụ thể, vấn đề <strong>fragmentation</strong> (phân mảnh) sẽ ít đáng lo ngại hơn; hơn nữa, các yêu cầu cấp phát và giải phóng có kích thước phù hợp có thể được xử lý rất nhanh, vì không cần tìm kiếm phức tạp trong danh sách.</p>
<p>Giống như bất kỳ ý tưởng hay nào, cách tiếp cận này cũng mang đến những phức tạp mới cho hệ thống. Ví dụ: nên dành bao nhiêu bộ nhớ cho <strong>pool</strong> (bể bộ nhớ) phục vụ các yêu cầu chuyên biệt của một kích thước nhất định, so với pool tổng quát? Một allocator cụ thể, <strong>slab allocator</strong> do kỹ sư xuất sắc Jeff Bonwick thiết kế (dùng trong <strong>Solaris kernel</strong>), xử lý vấn đề này theo một cách rất hay [B94].</p>
<p>Cụ thể, khi kernel khởi động, nó sẽ cấp phát một số <strong>object cache</strong> (bộ đệm đối tượng) cho các đối tượng kernel có khả năng được yêu cầu thường xuyên (như <strong>lock</strong>, <strong>file-system inode</strong>, v.v.); các object cache này chính là các free list phân tách theo kích thước và phục vụ nhanh chóng các yêu cầu cấp phát/giải phóng bộ nhớ. Khi một cache nhất định sắp hết vùng trống, nó sẽ yêu cầu một số <strong>slab</strong> bộ nhớ từ allocator tổng quát hơn (tổng dung lượng yêu cầu là bội số của <strong>page size</strong> và kích thước đối tượng). Ngược lại, khi <strong>reference count</strong> (bộ đếm tham chiếu) của tất cả đối tượng trong một slab về 0, allocator tổng quát có thể thu hồi slab đó từ allocator chuyên biệt — điều này thường được thực hiện khi hệ thống <strong>VM</strong> (virtual memory) cần thêm bộ nhớ.</p>
<blockquote>
<p><strong>ASIDE: KỸ SƯ GIỎI THỰC SỰ LÀ RẤT GIỎI</strong><br />
Các kỹ sư như Jeff Bonwick (người không chỉ viết slab allocator được nhắc đến ở đây mà còn là trưởng nhóm phát triển hệ thống file tuyệt vời ZFS) chính là trái tim của Silicon Valley. Đằng sau hầu hết các sản phẩm hoặc công nghệ vĩ đại là một con người (hoặc một nhóm nhỏ) vượt trội về tài năng, khả năng và sự tận tâm. Như Mark Zuckerberg (Facebook) từng nói: “Một người xuất sắc trong vai trò của họ không chỉ giỏi hơn một chút so với người khá giỏi. Họ giỏi hơn gấp 100 lần.” Đây là lý do tại sao, ngay cả ngày nay, một hoặc hai người vẫn có thể khởi nghiệp và thay đổi bộ mặt thế giới mãi mãi (hãy nghĩ đến Google, Apple hoặc Facebook). Hãy làm việc chăm chỉ và bạn có thể trở thành một “người 100x” như vậy! Nếu không, hãy tìm cách làm việc cùng họ; bạn sẽ học được nhiều trong một ngày hơn hầu hết mọi người học trong một tháng.</p>
</blockquote>
<p>Slab allocator còn vượt xa hầu hết các phương pháp segregated list khác ở chỗ nó giữ các đối tượng trống trong danh sách ở trạng thái <strong>pre-initialized</strong> (đã được khởi tạo sẵn). Bonwick chỉ ra rằng việc khởi tạo và hủy cấu trúc dữ liệu là tốn kém [B94]; bằng cách giữ các đối tượng đã giải phóng trong trạng thái đã khởi tạo, slab allocator tránh được chu kỳ khởi tạo/hủy lặp lại cho mỗi đối tượng và do đó giảm đáng kể chi phí.</p>
<h3 id="buddy-allocation-cấp-phát-theo-cặp-buddy"><a class="header" href="#buddy-allocation-cấp-phát-theo-cặp-buddy">Buddy Allocation (Cấp phát theo cặp “buddy”)</a></h3>
<p>Vì <strong>coalescing</strong> (gộp khối) là rất quan trọng đối với một allocator, một số phương pháp đã được thiết kế xoay quanh việc làm cho coalescing trở nên đơn giản. Một ví dụ điển hình là <strong>binary buddy allocator</strong> [K65].</p>
<p>Trong hệ thống này, bộ nhớ trống ban đầu được coi như một khối lớn có kích thước ( 2^N ). Khi có yêu cầu cấp phát, quá trình tìm kiếm sẽ chia đôi vùng trống một cách đệ quy cho đến khi tìm được một khối đủ lớn để đáp ứng yêu cầu (và nếu chia đôi thêm nữa sẽ tạo ra khối quá nhỏ). Tại thời điểm đó, khối được yêu cầu sẽ được trả về cho người dùng. Ví dụ dưới đây minh họa một vùng trống 64KB được chia nhỏ để tìm khối 7KB (<strong>Hình 17.8</strong>).</p>
<p><img src="17/img/fig17_7_4.PNG" alt="Figure 17.8: Example Buddy-managed Heap" /></p>
<p><strong>Hình 17.8:</strong> Ví dụ heap được quản lý bằng buddy</p>
<p>Trong ví dụ, khối 8KB ngoài cùng bên trái được cấp phát (được tô màu xám đậm) và trả về cho người dùng; lưu ý rằng phương pháp này có thể gặp <strong>internal fragmentation</strong> (phân mảnh bên trong), vì chỉ được phép cấp phát các khối có kích thước là lũy thừa của 2.</p>
<p>Điểm hay của buddy allocation nằm ở chỗ khi khối đó được giải phóng. Khi trả lại khối 8KB vào free list, allocator sẽ kiểm tra xem “buddy” 8KB của nó có trống không; nếu có, nó sẽ gộp hai khối thành một khối 16KB. Sau đó, allocator kiểm tra xem buddy của khối 16KB này có trống không; nếu có, lại gộp tiếp thành khối 32KB. Quá trình coalescing đệ quy này tiếp tục lên trên cây, hoặc cho đến khi khôi phục toàn bộ vùng trống, hoặc dừng lại khi gặp một buddy đang được sử dụng.</p>
<p>Lý do buddy allocation hoạt động hiệu quả là vì rất dễ xác định buddy của một khối cụ thể. Làm thế nào? Hãy nghĩ về địa chỉ của các khối trong vùng trống ở trên. Nếu bạn quan sát kỹ, bạn sẽ thấy địa chỉ của mỗi cặp buddy chỉ khác nhau ở <strong>một bit duy nhất</strong>; bit nào khác nhau được xác định bởi cấp (level) trong cây buddy. Và đó là ý tưởng cơ bản của cơ chế binary buddy allocation. Để biết chi tiết hơn, hãy xem khảo sát của Wilson [W+95].</p>
<h3 id="các-ý-tưởng-khác-other-ideas"><a class="header" href="#các-ý-tưởng-khác-other-ideas">Các ý tưởng khác (Other Ideas)</a></h3>
<p>Một vấn đề lớn của nhiều phương pháp ở trên là <strong>khả năng mở rộng</strong> (scaling) kém. Cụ thể, việc tìm kiếm trong danh sách có thể rất chậm. Do đó, các allocator tiên tiến sử dụng cấu trúc dữ liệu phức tạp hơn để giảm chi phí này, đánh đổi sự đơn giản lấy hiệu năng. Ví dụ: <strong>balanced binary tree</strong>, <strong>splay tree</strong>, hoặc <strong>partially-ordered tree</strong> [W+95].</p>
<p>Vì các hệ thống hiện đại thường có nhiều bộ xử lý và chạy các tải công việc đa luồng (<strong>multi-threaded workloads</strong>, bạn sẽ học chi tiết trong phần về <strong>Concurrency</strong>), không có gì ngạc nhiên khi nhiều nỗ lực đã được dành để làm cho allocator hoạt động tốt trên hệ thống đa bộ xử lý. Hai ví dụ tiêu biểu là nghiên cứu của Berger et al. [B+00] và Evans [E06]; hãy tìm đọc để biết chi tiết.</p>
<p>Đây chỉ là hai trong số hàng ngàn ý tưởng mà con người đã nghĩ ra về memory allocator; nếu tò mò, bạn hãy tự tìm hiểu thêm. Nếu không, hãy đọc về cách hoạt động của <strong>glibc allocator</strong> [S15] để có cái nhìn thực tế hơn.</p>
<h2 id="175-tóm-tắt-summary"><a class="header" href="#175-tóm-tắt-summary">17.5 Tóm tắt (Summary)</a></h2>
<p>Trong chương này, chúng ta đã thảo luận về những dạng cơ bản nhất của <strong>memory allocator</strong> (bộ cấp phát bộ nhớ). Các allocator như vậy tồn tại ở khắp nơi: được liên kết vào mọi chương trình C bạn viết, cũng như trong OS nền tảng đang quản lý bộ nhớ cho các cấu trúc dữ liệu của chính nó. Giống như nhiều hệ thống khác, có rất nhiều sự đánh đổi khi xây dựng một hệ thống như vậy, và càng biết rõ về <strong>workload</strong> (tải công việc) mà allocator phải xử lý, bạn càng có thể tinh chỉnh nó để hoạt động tốt hơn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-paging-giới-thiệu"><a class="header" href="#18-paging-giới-thiệu">18. Paging: Giới thiệu</a></h1>
<p>Người ta đôi khi nói rằng hệ điều hành (operating system – OS) thường áp dụng một trong hai cách tiếp cận khi giải quyết hầu hết các vấn đề quản lý không gian bộ nhớ.<br />
Cách tiếp cận thứ nhất là chia nhỏ không gian thành các phần có kích thước thay đổi (variable-sized pieces), như chúng ta đã thấy với segmentation (phân đoạn) trong virtual memory (bộ nhớ ảo).<br />
Đáng tiếc, giải pháp này có những khó khăn vốn có. Cụ thể, khi chia một không gian thành các khối có kích thước khác nhau, chính không gian đó có thể bị <strong>phân mảnh</strong> (fragmentation), và do đó việc cấp phát (allocation) trở nên khó khăn hơn theo thời gian.</p>
<p>Vì vậy, có thể đáng để xem xét cách tiếp cận thứ hai: chia nhỏ không gian thành các phần có kích thước cố định (fixed-sized pieces). Trong virtual memory, ý tưởng này được gọi là <strong>paging</strong> (phân trang), và nó bắt nguồn từ một hệ thống quan trọng thời kỳ đầu – <strong>Atlas</strong> [KE+62, L78].</p>
<p>Thay vì chia không gian địa chỉ (address space) của một process (tiến trình) thành một số segment (đoạn) logic có kích thước thay đổi (ví dụ: code, heap, stack), chúng ta chia nó thành các đơn vị có kích thước cố định, mỗi đơn vị được gọi là <strong>page</strong> (trang). Tương ứng, chúng ta xem physical memory (bộ nhớ vật lý) như một mảng các ô có kích thước cố định gọi là <strong>page frame</strong> (khung trang); mỗi frame có thể chứa một page của virtual memory.<br />
Thách thức đặt ra là:</p>
<blockquote>
<p><strong>THE CRUX:</strong></p>
<p><strong>HOW TO VIRTUALIZE MEMORY WITH PAGES</strong><br />
Làm thế nào để ảo hóa bộ nhớ bằng pages, nhằm tránh các vấn đề của segmentation? Các kỹ thuật cơ bản là gì? Làm sao để các kỹ thuật này hoạt động hiệu quả, với chi phí về không gian và thời gian tối thiểu?</p>
</blockquote>
<h2 id="181-ví-dụ-đơn-giản-và-tổng-quan"><a class="header" href="#181-ví-dụ-đơn-giản-và-tổng-quan">18.1 Ví dụ đơn giản và tổng quan</a></h2>
<p>Để làm rõ hơn cách tiếp cận này, hãy minh họa bằng một ví dụ đơn giản.</p>
<p><strong>Hình 18.1</strong> trình bày một ví dụ về một address space rất nhỏ, chỉ có tổng cộng 64 byte, với bốn page 16 byte (các virtual page 0, 1, 2 và 3).<br />
Trong thực tế, address space thường lớn hơn nhiều, phổ biến là 32-bit (tương đương 4 GB address space), hoặc thậm chí 64-bit^[1]. Trong sách này, chúng ta sẽ thường dùng các ví dụ nhỏ để dễ tiếp thu.</p>
<p>^[1]: Một address space 64-bit rất khó hình dung vì nó cực kỳ lớn. Một phép so sánh: nếu address space 32-bit có kích thước bằng một sân tennis, thì address space 64-bit có kích thước xấp xỉ cả châu Âu (!).</p>
<p><img src="18/img/fig18_1.PNG" alt="Figure 18.1: A Simple 64-byte Address Space" /></p>
<p><strong>Hình 18.1: A Simple 64-byte Address Space</strong></p>
<p>Physical memory, như thể hiện trong <strong>Hình 18.2</strong>, cũng bao gồm một số ô có kích thước cố định, trong trường hợp này là tám page frame (tổng cộng 128 byte physical memory – cũng rất nhỏ).<br />
Như bạn thấy trong sơ đồ, các page của virtual address space được đặt tại các vị trí khác nhau trong physical memory; sơ đồ cũng cho thấy OS sử dụng một phần physical memory cho chính nó.</p>
<p>Paging, như chúng ta sẽ thấy, có nhiều ưu điểm so với các cách tiếp cận trước đây. Có lẽ cải tiến quan trọng nhất là <strong>tính linh hoạt</strong>: với một cơ chế paging hoàn chỉnh, hệ thống có thể hỗ trợ trừu tượng hóa address space một cách hiệu quả, bất kể process sử dụng address space như thế nào; ví dụ, chúng ta không cần giả định heap và stack sẽ phát triển theo hướng nào hoặc được dùng ra sao.</p>
<p><img src="18/img/fig18_2.PNG" alt="" /></p>
<p><strong>Hình 18.2: A 64-Byte Address Space In A 128-Byte Physical Memory</strong></p>
<p>Một ưu điểm khác là <strong>sự đơn giản trong quản lý vùng trống</strong> mà paging mang lại.<br />
Ví dụ, khi OS muốn đặt address space 64 byte của chúng ta vào physical memory 8 page, nó chỉ cần tìm 4 page trống; có thể OS duy trì một <strong>free list</strong> (danh sách trang trống) và chỉ việc lấy 4 page đầu tiên từ danh sách này.<br />
Trong ví dụ, OS đã đặt virtual page 0 của address space (AS) vào physical frame 3, virtual page 1 vào frame 7, page 2 vào frame 5, và page 3 vào frame 2. Các frame 1, 4 và 6 hiện đang trống.</p>
<p>Để ghi nhận vị trí của từng virtual page trong physical memory, OS thường duy trì một cấu trúc dữ liệu <strong>per-process</strong> (riêng cho từng process) gọi là <strong>page table</strong> (bảng trang). Vai trò chính của page table là lưu trữ <strong>address translation</strong> (bản dịch địa chỉ) cho từng virtual page của address space, cho phép biết mỗi page nằm ở đâu trong physical memory.</p>
<p>Với ví dụ đơn giản này (<strong>Hình 18.2</strong>), page table sẽ có bốn mục:</p>
<ul>
<li>(Virtual Page 0 → Physical Frame 3)</li>
<li>(VP 1 → PF 7)</li>
<li>(VP 2 → PF 5)</li>
<li>(VP 3 → PF 2)</li>
</ul>
<p>Cần nhớ rằng page table này là <strong>per-process</strong> (đa số cấu trúc page table chúng ta thảo luận là per-process; ngoại lệ sẽ được đề cập là <strong>inverted page table</strong>). Nếu một process khác chạy trong ví dụ trên, OS sẽ phải quản lý một page table khác cho nó, vì các virtual page của nó sẽ ánh xạ (map) tới các physical page khác (trừ khi có chia sẻ bộ nhớ).</p>
<p>Giờ đây, chúng ta đã đủ thông tin để thực hiện một ví dụ dịch địa chỉ (address translation).<br />
Giả sử process với address space 64 byte này thực hiện một truy cập bộ nhớ:</p>
<pre><code>movl &lt;virtual address&gt;, %eax
</code></pre>
<p>Cụ thể, hãy chú ý đến việc nạp dữ liệu từ <code>&lt;virtual address&gt;</code> vào thanh ghi <code>eax</code> (và bỏ qua việc fetch lệnh đã xảy ra trước đó).</p>
<p>Để <strong>translate</strong> (dịch) virtual address mà process tạo ra, trước tiên chúng ta phải tách nó thành hai thành phần:</p>
<ul>
<li><strong>Virtual Page Number (VPN)</strong> – số hiệu trang ảo</li>
<li><strong>Offset</strong> – độ lệch trong trang</li>
</ul>
<p>Với ví dụ này, vì virtual address space của process là 64 byte, chúng ta cần 6 bit cho virtual address (2^6 = 64). Virtual address có thể được biểu diễn như sau:</p>
<pre><code>Va5 Va4 Va3 Va2 Va1 Va0
</code></pre>
<p>Trong đó, <code>Va5</code> là bit cao nhất, <code>Va0</code> là bit thấp nhất.<br />
Vì page size là 16 byte, chúng ta có thể chia virtual address như sau:</p>
<p>Page size là 16 byte trong address space 64 byte; do đó, chúng ta cần chọn 4 page, và 2 bit cao nhất của địa chỉ sẽ đảm nhiệm việc này. Như vậy, chúng ta có 2-bit VPN. Các bit còn lại (4 bit) cho biết byte nào trong page được truy cập – đây chính là offset.</p>
<p>Khi một process tạo ra virtual address, OS và phần cứng phải phối hợp để dịch nó thành physical address.<br />
Ví dụ, giả sử lệnh load ở trên truy cập virtual address 21:</p>
<pre><code>movl 21, %eax
</code></pre>
<p>Chuyển “21” sang nhị phân, ta được <code>010101</code>.<br />
Phân tích địa chỉ này, ta thấy:</p>
<ul>
<li>VPN = <code>01</code> (tức virtual page 1)</li>
<li>Offset = <code>0101</code> (byte thứ 5 trong page)</li>
</ul>
<p>Tra VPN trong page table, ta thấy virtual page 1 nằm ở physical frame 7 (PFN = 7, nhị phân <code>111</code>).<br />
Do đó, ta dịch địa chỉ ảo này bằng cách thay VPN bằng PFN, rồi thực hiện load từ physical memory.</p>
<p><img src="18/img/fig18_3.PNG" alt="" /></p>
<p><strong>Hình 18.3: The Address Translation Process</strong></p>
<p><img src="18/img/fig18_4.PNG" alt="" /></p>
<p><strong>Hình 18.4: Example: Page Table in Kernel Physical Memory</strong></p>
<p>Lưu ý rằng <strong>offset</strong> (độ lệch) vẫn giữ nguyên (tức là không được dịch), vì offset chỉ cho biết byte nào <strong>bên trong</strong> page (trang) mà chúng ta muốn truy cập. Địa chỉ vật lý (physical address) cuối cùng của chúng ta là <code>1110101</code> (117 ở hệ thập phân), và đây chính xác là nơi mà lệnh load sẽ lấy dữ liệu (xem <strong>Hình 18.2</strong>, trang 2).</p>
<p>Với phần tổng quan cơ bản này, giờ đây chúng ta có thể đặt ra (và hy vọng trả lời) một số câu hỏi cơ bản về <strong>paging</strong> (phân trang).<br />
Ví dụ: Các <strong>page table</strong> (bảng trang) này được lưu ở đâu? Nội dung điển hình của một page table gồm những gì, và kích thước của chúng lớn đến mức nào? Paging có làm hệ thống chậm đi quá mức không? Những câu hỏi này và các vấn đề thú vị khác sẽ được giải đáp, ít nhất là một phần, trong phần dưới đây. Hãy tiếp tục đọc.</p>
<h2 id="182-page-table-được-lưu-ở-đâu"><a class="header" href="#182-page-table-được-lưu-ở-đâu">18.2 Page Table được lưu ở đâu?</a></h2>
<p>Page table có thể trở nên cực kỳ lớn, lớn hơn nhiều so với segment table (bảng phân đoạn) nhỏ hoặc cặp base/bounds (địa chỉ cơ sở/giới hạn) mà chúng ta đã thảo luận trước đây.<br />
Ví dụ, hãy tưởng tượng một address space (không gian địa chỉ) 32-bit điển hình, với kích thước page là 4KB. Virtual address (địa chỉ ảo) này sẽ được chia thành <strong>20-bit VPN</strong> (Virtual Page Number – số hiệu trang ảo) và <strong>12-bit offset</strong> (nhớ rằng với page 1KB cần 10 bit cho offset, và chỉ cần thêm 2 bit nữa để thành 4KB).</p>
<p>Một VPN 20-bit có nghĩa là có ( 2^{20} ) phép ánh xạ (translation) mà OS (hệ điều hành) phải quản lý cho mỗi process (tiến trình) – tức khoảng một triệu ánh xạ.<br />
Giả sử chúng ta cần 4 byte cho mỗi <strong>PTE</strong> (Page Table Entry – mục trong bảng trang) để lưu trữ thông tin dịch địa chỉ vật lý cùng các thông tin hữu ích khác, thì tổng dung lượng cần cho mỗi page table sẽ là 4MB – một con số rất lớn.<br />
Bây giờ, hãy tưởng tượng có 100 process đang chạy: điều này có nghĩa là OS sẽ cần tới 400MB bộ nhớ <strong>chỉ</strong> để lưu các bản dịch địa chỉ! Ngay cả trong thời đại hiện nay, khi máy tính có hàng gigabyte bộ nhớ, việc dùng một phần lớn bộ nhớ chỉ để lưu translation nghe cũng khá “điên rồ”. Và chúng ta thậm chí chưa dám nghĩ đến kích thước của page table cho một address space 64-bit – điều đó sẽ quá khủng khiếp và có thể khiến bạn nản lòng ngay lập tức.</p>
<blockquote>
<p><strong>ASIDE: DATA STRUCTURE — THE PAGE TABLE</strong><br />
Một trong những cấu trúc dữ liệu quan trọng nhất trong hệ thống quản lý bộ nhớ của OS hiện đại là <strong>page table</strong>. Nói chung, page table lưu trữ các ánh xạ từ địa chỉ ảo sang địa chỉ vật lý, cho phép hệ thống biết mỗi page của address space thực sự nằm ở đâu trong physical memory.<br />
Vì mỗi address space cần các ánh xạ như vậy, nên thông thường sẽ có <strong>một page table cho mỗi process</strong> trong hệ thống. Cấu trúc chính xác của page table có thể do phần cứng quyết định (trong các hệ thống cũ) hoặc được OS quản lý linh hoạt hơn (trong các hệ thống hiện đại).</p>
</blockquote>
<p>Vì page table quá lớn, chúng ta không lưu chúng trong phần cứng on-chip đặc biệt của MMU (Memory Management Unit – đơn vị quản lý bộ nhớ) để chứa page table của process đang chạy. Thay vào đó, page table của mỗi process được lưu <strong>trong bộ nhớ</strong> ở đâu đó.<br />
Tạm thời, hãy giả định rằng page table nằm trong physical memory do OS quản lý; sau này chúng ta sẽ thấy rằng phần lớn bộ nhớ của OS cũng có thể được ảo hóa, và do đó page table có thể được lưu trong virtual memory của OS (thậm chí được swap ra đĩa), nhưng điều này hiện tại sẽ gây rối, nên ta sẽ bỏ qua.</p>
<p><strong>Hình 18.4</strong> (trang 5) minh họa một page table trong bộ nhớ của OS; bạn có thấy tập hợp nhỏ các ánh xạ ở đó không?</p>
<h2 id="183-thực-sự-có-gì-trong-page-table"><a class="header" href="#183-thực-sự-có-gì-trong-page-table">18.3 Thực sự có gì trong Page Table?</a></h2>
<p>Hãy nói một chút về tổ chức của page table. Page table chỉ là một cấu trúc dữ liệu dùng để ánh xạ từ virtual address (hoặc chính xác hơn là virtual page number – VPN) sang physical address (physical frame number – PFN). Do đó, về lý thuyết, bất kỳ cấu trúc dữ liệu nào cũng có thể dùng được.<br />
Dạng đơn giản nhất được gọi là <strong>linear page table</strong> (bảng trang tuyến tính), chỉ đơn giản là một mảng. OS sẽ <strong>index</strong> (đánh chỉ số) mảng này bằng VPN, và tra PTE tại chỉ số đó để tìm PFN mong muốn.<br />
Hiện tại, chúng ta sẽ giả định cấu trúc tuyến tính đơn giản này; ở các chương sau, chúng ta sẽ dùng các cấu trúc dữ liệu nâng cao hơn để giải quyết một số vấn đề của paging.</p>
<p>Về nội dung của mỗi PTE, có một số bit quan trọng cần hiểu:</p>
<ul>
<li><strong>Valid bit</strong>: cho biết ánh xạ này có hợp lệ hay không. Ví dụ, khi một chương trình bắt đầu chạy, nó sẽ có code và heap ở một đầu của address space, và stack ở đầu kia. Tất cả không gian chưa dùng ở giữa sẽ được đánh dấu <strong>invalid</strong>. Nếu process cố truy cập vùng bộ nhớ này, nó sẽ tạo ra một trap (ngắt) tới OS, và OS có thể sẽ chấm dứt process đó.<br />
Valid bit rất quan trọng để hỗ trợ <strong>sparse address space</strong> (không gian địa chỉ thưa thớt); bằng cách đánh dấu invalid cho tất cả các page chưa dùng, chúng ta không cần cấp phát physical frame cho chúng, từ đó tiết kiệm đáng kể bộ nhớ.</li>
</ul>
<p><img src="18/img/fig18_5.PNG" alt="" /></p>
<p><strong>Hình 18.5: An x86 Page Table Entry (PTE)</strong></p>
<p>Ngoài ra, còn có <strong>protection bits</strong> (bit bảo vệ), cho biết page có thể được đọc, ghi hoặc thực thi hay không. Truy cập page theo cách không được phép bởi các bit này sẽ tạo ra trap tới OS.</p>
<p>Một số bit khác cũng quan trọng nhưng tạm thời chúng ta chưa bàn sâu:</p>
<ul>
<li><strong>Present bit</strong>: cho biết page này đang ở physical memory hay đã được lưu trên đĩa (swapped out). Cơ chế này sẽ được tìm hiểu kỹ hơn khi chúng ta học về <strong>swap</strong> – kỹ thuật di chuyển một phần address space ra đĩa để hỗ trợ address space lớn hơn physical memory. Swapping cho phép OS giải phóng physical memory bằng cách chuyển các page ít dùng ra đĩa.</li>
<li><strong>Dirty bit</strong>: cho biết page đã bị sửa đổi kể từ khi được nạp vào bộ nhớ hay chưa.</li>
<li><strong>Reference bit</strong> (hay <strong>accessed bit</strong>): cho biết page đã được truy cập hay chưa, hữu ích để xác định page nào được dùng thường xuyên và nên giữ lại trong bộ nhớ. Thông tin này rất quan trọng trong <strong>page replacement</strong> (thay thế trang), một chủ đề sẽ được nghiên cứu chi tiết ở các chương sau.</li>
</ul>
<p><strong>Hình 18.5</strong> cho thấy một ví dụ về PTE trong kiến trúc x86 [I09]. Nó bao gồm:</p>
<ul>
<li>Present bit (P)</li>
<li>Read/Write bit (R/W) – xác định có cho phép ghi vào page hay không</li>
<li>User/Supervisor bit (U/S) – xác định process ở user mode có thể truy cập page hay không</li>
<li>Một số bit (PWT, PCD, PAT, G) – xác định cách phần cứng caching hoạt động với page này</li>
<li>Accessed bit (A) và Dirty bit (D)</li>
<li>Cuối cùng là Page Frame Number (PFN) – số hiệu khung trang vật lý</li>
</ul>
<p>Bạn có thể đọc <strong>Intel Architecture Manuals</strong> [I09] để biết thêm chi tiết về hỗ trợ paging trong x86. Tuy nhiên, cần lưu ý: đọc các tài liệu này, dù rất hữu ích (và chắc chắn cần thiết cho những ai viết code để dùng page table trong OS), có thể khá khó khăn lúc đầu. Cần một chút kiên nhẫn và nhiều quyết tâm.</p>
<blockquote>
<p><strong>ASIDE: TẠI SAO KHÔNG CÓ BIT VALID?</strong><br />
Bạn có thể nhận thấy trong ví dụ của Intel, không có valid bit riêng biệt, mà chỉ có present bit (P). Nếu bit này được đặt (P=1), nghĩa là page vừa <strong>present</strong> vừa <strong>valid</strong>. Nếu không (P=0), nghĩa là page có thể không có trong bộ nhớ (nhưng vẫn valid), hoặc có thể không valid.</p>
<p>Khi có một truy cập tới page với P = 0, phần cứng sẽ kích hoạt một <strong>trap</strong> (bẫy) tới <strong>OS</strong> (Operating System – hệ điều hành). Lúc này, OS phải sử dụng các cấu trúc dữ liệu bổ sung mà nó duy trì để xác định xem page đó có <strong>valid</strong> (hợp lệ) hay không. Nếu hợp lệ, có thể page này cần được <strong>swapped back in</strong> (nạp lại từ bộ nhớ phụ vào bộ nhớ chính). Nếu không hợp lệ, điều đó có nghĩa là chương trình đang cố gắng truy cập vào vùng bộ nhớ trái phép.</p>
<p>Cách thiết kế tiết kiệm này khá phổ biến trong phần cứng, vốn thường chỉ cung cấp <strong>tập hợp tối thiểu các tính năng</strong> để OS có thể xây dựng nên một hệ thống dịch vụ đầy đủ.</p>
<p><em>(Giải thích thêm: Trong kiến trúc Intel, việc gộp hai khái niệm “valid” và “present” vào một bit giúp giảm độ phức tạp phần cứng, nhưng yêu cầu OS phải xử lý logic phân biệt khi xảy ra lỗi truy cập bộ nhớ.)</em></p>
</blockquote>
<h2 id="184-paging-cũng-quá-chậm"><a class="header" href="#184-paging-cũng-quá-chậm">18.4 Paging: Cũng Quá Chậm</a></h2>
<p>Với <strong>page table</strong> (bảng trang) được lưu trong bộ nhớ, chúng ta đã biết rằng chúng có thể quá lớn. Hóa ra, chúng cũng có thể làm chậm hệ thống.<br />
Ví dụ, hãy xét lệnh đơn giản sau:</p>
<pre><code>movl 21, %eax
</code></pre>
<p>Một lần nữa, chúng ta chỉ xem xét việc truy cập rõ ràng tới địa chỉ 21 và không quan tâm đến việc <strong>instruction fetch</strong> (nạp lệnh). Trong ví dụ này, chúng ta giả định phần cứng sẽ thực hiện việc <strong>dịch địa chỉ</strong> (translation) cho chúng ta.<br />
Để lấy được dữ liệu mong muốn, hệ thống trước tiên phải dịch <strong>virtual address</strong> (địa chỉ ảo) 21 thành <strong>physical address</strong> (địa chỉ vật lý) 117. Như vậy, trước khi lấy dữ liệu từ địa chỉ 117, hệ thống phải truy xuất <strong>page table entry</strong> (PTE – mục trong bảng trang) tương ứng từ page table của process (tiến trình), thực hiện dịch địa chỉ, rồi mới nạp dữ liệu từ <strong>physical memory</strong> (bộ nhớ vật lý).</p>
<p>Để làm được điều này, phần cứng phải biết page table của process đang chạy hiện tại nằm ở đâu.<br />
Giả sử tạm thời rằng có một <strong>page-table base register</strong> (thanh ghi cơ sở bảng trang) chứa địa chỉ vật lý của vị trí bắt đầu của page table. Để tìm vị trí của PTE mong muốn, phần cứng sẽ thực hiện các bước sau:</p>
<pre><code>VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
</code></pre>
<p>Trong ví dụ của chúng ta, <code>VPN_MASK</code> sẽ được đặt là <code>0x30</code> (hex 30, hay nhị phân <code>110000</code>) để trích ra các bit VPN từ toàn bộ virtual address; <code>SHIFT</code> được đặt là 4 (số bit của offset), để dịch các bit VPN xuống tạo thành số nguyên VPN chính xác.<br />
Ví dụ, với virtual address 21 (<code>010101</code>), phép <strong>masking</strong> biến giá trị này thành <code>010000</code>; phép dịch (shift) biến nó thành <code>01</code>, tức virtual page 1 như mong muốn. Chúng ta sau đó dùng giá trị này làm chỉ số trong mảng PTE mà page-table base register trỏ tới.</p>
<p>Khi đã biết địa chỉ vật lý của PTE, phần cứng có thể nạp PTE từ bộ nhớ, lấy ra <strong>PFN</strong> (Physical Frame Number – số hiệu khung trang vật lý), và ghép nó với offset từ virtual address để tạo thành physical address mong muốn.<br />
Cụ thể, bạn có thể hình dung PFN được dịch trái (left-shift) bởi <code>SHIFT</code>, rồi thực hiện phép <strong>bitwise OR</strong> với offset để tạo địa chỉ cuối cùng như sau:</p>
<pre><code>offset = VirtualAddress &amp; OFFSET_MASK
PhysAddr = (PFN &lt;&lt; SHIFT) | offset
</code></pre>
<p>Cuối cùng, phần cứng có thể nạp dữ liệu mong muốn từ bộ nhớ và đưa nó vào thanh ghi <code>eax</code>. Chương trình đã thành công trong việc nạp một giá trị từ bộ nhớ.</p>
<p>Tóm lại, chúng ta mô tả giao thức ban đầu cho những gì xảy ra ở mỗi lần truy cập bộ nhớ. <strong>Hình 18.6</strong> (trang 9) minh họa cách tiếp cận này.<br />
Với <strong>mỗi</strong> lần truy cập bộ nhớ (dù là instruction fetch hay load/store rõ ràng), paging yêu cầu chúng ta thực hiện <strong>thêm một lần truy cập bộ nhớ</strong> để trước tiên lấy bản dịch địa chỉ từ page table. Đây là một khối lượng công việc lớn! Các lần truy cập bộ nhớ bổ sung rất tốn kém, và trong trường hợp này có thể làm chậm process đi gấp đôi hoặc hơn.</p>
<p>Bây giờ, bạn có thể thấy rằng có <strong>hai</strong> vấn đề thực sự mà chúng ta phải giải quyết. Nếu không thiết kế cẩn thận cả phần cứng lẫn phần mềm, page table sẽ khiến hệ thống vừa chạy quá chậm, vừa chiếm quá nhiều bộ nhớ.<br />
Mặc dù paging có vẻ là một giải pháp tuyệt vời cho nhu cầu <strong>memory virtualization</strong> (ảo hóa bộ nhớ) của chúng ta, nhưng hai vấn đề then chốt này phải được khắc phục trước.</p>
<pre><code>1  // Extract the VPN from the virtual address
2  VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT
3
4  // Form the address of the page-table entry (PTE)
5  PTEAddr = PTBR + (VPN * sizeof(PTE))
6
7  // Fetch the PTE
8  PTE = AccessMemory(PTEAddr)
9
10 // Check if process can access the page
11 if (PTE.Valid == False)
12     RaiseException(SEGMENTATION_FAULT)
13 else if (CanAccess(PTE.ProtectBits) == False)
14     RaiseException(PROTECTION_FAULT)
15 else
16     // Access OK: form physical address and fetch it
17     offset = VirtualAddress &amp; OFFSET_MASK
18     PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset
19     Register = AccessMemory(PhysAddr)
</code></pre>
<p><strong>Hình 18.6: Accessing Memory With Paging</strong></p>
<h2 id="185-a-memory-trace-dấu-vết-truy-cập-bộ-nhớ"><a class="header" href="#185-a-memory-trace-dấu-vết-truy-cập-bộ-nhớ">18.5 A Memory Trace (Dấu vết truy cập bộ nhớ)</a></h2>
<p>Trước khi kết thúc, chúng ta sẽ lần theo một ví dụ truy cập bộ nhớ đơn giản để minh họa tất cả các truy cập bộ nhớ phát sinh khi sử dụng <strong>paging</strong> (phân trang). Đoạn code (viết bằng C, trong tệp <code>array.c</code>) mà chúng ta quan tâm như sau:</p>
<pre><code class="language-c">int array[1000];
...
for (i = 0; i &lt; 1000; i++)
    array[i] = 0;
</code></pre>
<p>Chúng ta biên dịch <code>array.c</code> và chạy nó với các lệnh sau:</p>
<pre><code>prompt&gt; gcc -o array array.c -Wall -O
prompt&gt; ./array
</code></pre>
<p>Tất nhiên, để thực sự hiểu được đoạn code này (vốn chỉ khởi tạo một mảng) sẽ tạo ra những truy cập bộ nhớ nào, chúng ta cần biết (hoặc giả định) thêm một số thông tin.<br />
Trước hết, chúng ta cần <strong>disassemble</strong> (dịch ngược) tệp nhị phân kết quả (sử dụng <code>objdump</code> trên Linux hoặc <code>otool</code> trên Mac) để xem các lệnh assembly được dùng để khởi tạo mảng trong vòng lặp. Kết quả thu được như sau:</p>
<pre><code>1024 movl $0x0,(%edi,%eax,4)
1028 incl %eax
1032 cmpl $0x03e8,%eax
1036 jne 1024
</code></pre>
<p>Nếu bạn biết một chút về <strong>x86</strong>, đoạn code này khá dễ hiểu^[2].</p>
<ul>
<li>Lệnh đầu tiên (<code>movl $0x0,(%edi,%eax,4)</code>) ghi giá trị 0 (<code>$0x0</code>) vào địa chỉ bộ nhớ ảo của phần tử mảng; địa chỉ này được tính bằng cách lấy giá trị trong <code>%edi</code> cộng với <code>%eax</code> nhân 4. Như vậy, <code>%edi</code> giữ <strong>địa chỉ cơ sở</strong> của mảng, còn <code>%eax</code> giữ <strong>chỉ số mảng</strong> (<code>i</code>). Chúng ta nhân với 4 vì mảng là mảng số nguyên (integer), mỗi phần tử có kích thước 4 byte.</li>
<li>Lệnh thứ hai (<code>incl %eax</code>) tăng chỉ số mảng trong <code>%eax</code>.</li>
<li>Lệnh thứ ba (<code>cmpl $0x03e8,%eax</code>) so sánh giá trị trong <code>%eax</code> với <code>0x03e8</code> (thập phân là 1000).</li>
<li>Nếu hai giá trị chưa bằng nhau (điều mà lệnh <code>jne</code> kiểm tra), lệnh thứ tư (<code>jne 1024</code>) sẽ nhảy về đầu vòng lặp.</li>
</ul>
<p>Để hiểu các truy cập bộ nhớ mà chuỗi lệnh này tạo ra (ở cả mức địa chỉ ảo và địa chỉ vật lý), chúng ta cần giả định một số điều về vị trí của đoạn code và mảng trong <strong>virtual memory</strong> (bộ nhớ ảo), cũng như nội dung và vị trí của <strong>page table</strong> (bảng trang).</p>
<p>Trong ví dụ này, giả sử <strong>virtual address space</strong> (không gian địa chỉ ảo) có kích thước 64KB (rất nhỏ so với thực tế). Chúng ta cũng giả định <strong>page size</strong> (kích thước trang) là 1KB.</p>
<p>Điều tiếp theo cần biết là nội dung của page table và vị trí của nó trong <strong>physical memory</strong> (bộ nhớ vật lý). Giả sử chúng ta có một page table tuyến tính (linear, dạng mảng) và nó được đặt tại địa chỉ vật lý 1KB (1024).</p>
<p>Về nội dung, chỉ có một vài <strong>virtual page</strong> (trang ảo) cần quan tâm trong ví dụ này:</p>
<ul>
<li>Trước hết là virtual page chứa đoạn code. Vì page size là 1KB, địa chỉ ảo 1024 nằm trên trang thứ hai của virtual address space (VPN = 1, vì VPN = 0 là trang đầu tiên). Giả sử virtual page này ánh xạ tới <strong>physical frame</strong> 4 (VPN 1 → PFN 4).</li>
<li>Tiếp theo là mảng. Mảng có kích thước 4000 byte (1000 số nguyên), và giả sử nó nằm tại các địa chỉ ảo từ 40000 đến 44000 (không bao gồm byte cuối). Các virtual page cho dải địa chỉ này là VPN = 39 … VPN = 42. Giả sử ánh xạ virtual-to-physical như sau:
<ul>
<li>VPN 39 → PFN 7</li>
<li>VPN 40 → PFN 8</li>
<li>VPN 41 → PFN 9</li>
<li>VPN 42 → PFN 10</li>
</ul>
</li>
</ul>
<p>^[2]: Ở đây chúng ta đơn giản hóa một chút, giả định mỗi lệnh có kích thước 4 byte; thực tế, lệnh x86 có kích thước thay đổi.</p>
<p><img src="18/img/fig18_7.PNG" alt="" /></p>
<p><strong>Hình 18.7: A Virtual (And Physical) Memory Trace</strong></p>
<p>Bây giờ chúng ta đã sẵn sàng để theo dõi các truy cập bộ nhớ của chương trình.<br />
Khi chạy, mỗi <strong>instruction fetch</strong> (nạp lệnh) sẽ tạo ra <strong>hai</strong> truy cập bộ nhớ:</p>
<ol>
<li>Một truy cập tới page table để tìm physical frame chứa lệnh.</li>
<li>Một truy cập tới chính lệnh đó để nạp vào CPU xử lý.</li>
</ol>
<p>Ngoài ra, còn có một truy cập bộ nhớ rõ ràng từ lệnh <code>mov</code>, điều này sẽ thêm một truy cập page table trước (để dịch địa chỉ ảo của mảng sang địa chỉ vật lý đúng) và sau đó là truy cập tới phần tử mảng.</p>
<p>Toàn bộ quá trình cho <strong>5 vòng lặp đầu tiên</strong> được minh họa trong <strong>Hình 18.7</strong> (trang 11):</p>
<ul>
<li>Biểu đồ dưới cùng: các truy cập bộ nhớ lệnh (instruction memory references) trên trục y màu đen (địa chỉ ảo bên trái, địa chỉ vật lý bên phải).</li>
<li>Biểu đồ giữa: các truy cập mảng (array accesses) màu xám đậm (cũng với địa chỉ ảo bên trái, địa chỉ vật lý bên phải).</li>
<li>Biểu đồ trên cùng: các truy cập page table màu xám nhạt (chỉ địa chỉ vật lý, vì page table trong ví dụ này nằm trong physical memory).</li>
</ul>
<p>Trục x của toàn bộ trace thể hiện các truy cập bộ nhớ trong 5 vòng lặp đầu tiên; mỗi vòng lặp có 10 truy cập bộ nhớ, bao gồm:</p>
<ul>
<li>4 instruction fetch</li>
<li>1 cập nhật bộ nhớ rõ ràng (explicit memory update)</li>
<li>5 truy cập page table để dịch 4 instruction fetch và 1 cập nhật bộ nhớ.</li>
</ul>
<p>Hãy thử phân tích các mẫu (pattern) xuất hiện trong hình minh họa. Đặc biệt, điều gì sẽ thay đổi khi vòng lặp tiếp tục chạy vượt quá 5 vòng đầu tiên? Những vị trí bộ nhớ mới nào sẽ được truy cập? Bạn có thể tìm ra không?</p>
<p>Đây mới chỉ là một ví dụ đơn giản (chỉ vài dòng C), nhưng bạn có thể cảm nhận được sự phức tạp khi phân tích hành vi bộ nhớ thực tế của các ứng dụng. Đừng lo: nó sẽ <strong>còn phức tạp hơn</strong>, vì các cơ chế mà chúng ta sắp giới thiệu sẽ làm tăng thêm độ phức tạp cho hệ thống vốn đã phức tạp này. Xin lỗi^[3]!</p>
<h2 id="186-tóm-tắt"><a class="header" href="#186-tóm-tắt">18.6 Tóm tắt</a></h2>
<p>Chúng ta đã giới thiệu khái niệm <strong>paging</strong> như một giải pháp cho thách thức ảo hóa bộ nhớ. Paging có nhiều ưu điểm so với các phương pháp trước (như segmentation):</p>
<ul>
<li>Thứ nhất, nó không gây ra <strong>external fragmentation</strong> (phân mảnh bên ngoài), vì paging (theo thiết kế) chia bộ nhớ thành các đơn vị có kích thước cố định.</li>
<li>Thứ hai, nó rất linh hoạt, cho phép sử dụng <strong>virtual address space</strong> (không gian địa chỉ ảo) một cách thưa thớt (sparse).</li>
</ul>
<p>Tuy nhiên, nếu triển khai paging mà không cẩn thận, hệ thống sẽ:</p>
<ul>
<li>Chạy chậm hơn (do nhiều truy cập bộ nhớ bổ sung để truy cập page table).</li>
<li>Lãng phí bộ nhớ (do bộ nhớ bị chiếm bởi page table thay vì dữ liệu ứng dụng hữu ích).</li>
</ul>
<p>Vì vậy, chúng ta cần suy nghĩ kỹ hơn để xây dựng một hệ thống paging <strong>không chỉ hoạt động được mà còn hoạt động hiệu quả</strong>.<br />
May mắn thay, hai chương tiếp theo sẽ cho chúng ta thấy cách thực hiện điều đó.</p>
<p>^[3]: Thực ra chúng tôi không thật sự xin lỗi. Nhưng chúng tôi xin lỗi vì… không xin lỗi, nếu điều đó có thể hiểu được.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-paging-faster-translations-tlbs"><a class="header" href="#19-paging-faster-translations-tlbs"><strong>19. Paging: Faster Translations (TLBs)</strong></a></h1>
<p>(Paging: Dịch địa chỉ nhanh hơn với TLB)</p>
<p>Việc sử dụng <strong>paging</strong> (phân trang) như cơ chế cốt lõi để hỗ trợ <strong>virtual memory</strong> (bộ nhớ ảo) có thể dẫn đến chi phí hiệu năng cao. Bằng cách chia nhỏ <strong>address space</strong> (không gian địa chỉ) thành các đơn vị nhỏ, kích thước cố định (tức là <strong>page</strong>), paging đòi hỏi một lượng lớn thông tin ánh xạ. Vì thông tin ánh xạ này thường được lưu trong <strong>physical memory</strong> (bộ nhớ vật lý), nên về mặt logic, paging yêu cầu một lần truy cập bộ nhớ bổ sung cho mỗi <strong>virtual address</strong> (địa chỉ ảo) được chương trình tạo ra. Việc phải truy cập bộ nhớ để lấy thông tin dịch địa chỉ trước mỗi lần nạp lệnh (<strong>instruction fetch</strong>) hoặc mỗi thao tác load/store rõ ràng là quá chậm. Và đây chính là vấn đề của chúng ta:</p>
<blockquote>
<p><strong>THE CRUX: HOW TO SPEED UP ADDRESS TRANSLATION</strong><br />
Làm thế nào để tăng tốc quá trình dịch địa chỉ, và nói chung là tránh được lần truy cập bộ nhớ bổ sung mà paging dường như yêu cầu? Cần hỗ trợ phần cứng gì? OS cần tham gia ở mức nào?</p>
</blockquote>
<p>Khi muốn tăng tốc, OS thường cần sự hỗ trợ. Và sự hỗ trợ này thường đến từ “người bạn cũ” của OS: <strong>hardware</strong> (phần cứng). Để tăng tốc dịch địa chỉ, chúng ta sẽ bổ sung một thành phần gọi là (vì lý do lịch sử [CP78]) <strong>translation-lookaside buffer</strong> hay <strong>TLB</strong> [CG68, C95]. <strong>TLB</strong> là một phần của <strong>memory-management unit</strong> (MMU — đơn vị quản lý bộ nhớ) trên chip, và đơn giản là một <strong>hardware cache</strong> (bộ nhớ đệm phần cứng) lưu trữ các ánh xạ <strong>virtual-to-physical address translations</strong> (dịch địa chỉ từ ảo sang vật lý) được sử dụng thường xuyên; vì vậy, một tên gọi chính xác hơn sẽ là <strong>address-translation cache</strong>.</p>
<p>Mỗi khi có một <strong>virtual memory reference</strong> (tham chiếu bộ nhớ ảo), phần cứng sẽ kiểm tra TLB trước để xem bản dịch mong muốn có ở đó không; nếu có, quá trình dịch sẽ được thực hiện (nhanh chóng) mà không cần truy vấn <strong>page table</strong> (bảng trang — chứa toàn bộ các bản dịch). Do tác động lớn đến hiệu năng, TLB thực sự là yếu tố khiến virtual memory khả thi [C95].</p>
<pre><code>VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT
(Success, TlbEntry) = TLB_Lookup(VPN)
if (Success == True)
  // TLB Hit
  if (CanAccess(TlbEntry.ProtectBits) == True)
    Offset = VirtualAddress &amp; OFFSET_MASK
    PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset
    Register = AccessMemory(PhysAddr)
  else
    RaiseException(PROTECTION_FAULT)
else
  // TLB Miss
  PTEAddr = PTBR + (VPN * sizeof(PTE))
  PTE = AccessMemory(PTEAddr)
  if (PTE.Valid == False)
    RaiseException(SEGMENTATION_FAULT)
  else if (CanAccess(PTE.ProtectBits) == False)
    RaiseException(PROTECTION_FAULT)
  else
    TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)
    RetryInstruction()
</code></pre>
<p><strong>Figure 19.1: TLB Control Flow Algorithm</strong><br />
<em>(Thuật toán luồng điều khiển của TLB)</em></p>
<h2 id="191-tlb-basic-algorithm-thuật-toán-cơ-bản-của-tlb"><a class="header" href="#191-tlb-basic-algorithm-thuật-toán-cơ-bản-của-tlb"><strong>19.1 TLB Basic Algorithm</strong> (Thuật toán cơ bản của TLB)</a></h2>
<p><em>Figure 19.1</em> minh họa sơ đồ cách phần cứng có thể xử lý một <strong>virtual address translation</strong> (dịch địa chỉ ảo), giả sử sử dụng <strong>linear page table</strong> (bảng trang tuyến tính — tức page table là một mảng) và <strong>hardware-managed TLB</strong> (TLB do phần cứng quản lý — phần cứng đảm nhiệm phần lớn việc truy cập page table; chúng ta sẽ giải thích thêm bên dưới).</p>
<p>Thuật toán phần cứng thực hiện như sau:</p>
<ul>
<li>
<p>Đầu tiên, trích xuất <strong>virtual page number</strong> (VPN — số trang ảo) từ virtual address (Dòng 1 trong <em>Figure 19.1</em>), và kiểm tra xem TLB có chứa bản dịch cho VPN này không (Dòng 2).</p>
</li>
<li>
<p>Nếu có, đây là một <strong>TLB hit</strong> (trúng TLB), nghĩa là TLB đã có bản dịch. Thành công! Lúc này, ta trích xuất <strong>page frame number</strong> (PFN — số khung trang) từ entry tương ứng trong TLB, ghép nó với <strong>offset</strong> từ virtual address ban đầu, tạo thành <strong>physical address</strong> (PA — địa chỉ vật lý) mong muốn, và truy cập bộ nhớ (Dòng 5–7), giả sử <strong>protection checks</strong> (kiểm tra bảo vệ) không thất bại (Dòng 4).</p>
</li>
<li>
<p>Nếu CPU không tìm thấy bản dịch trong TLB (<strong>TLB miss</strong>), sẽ cần thêm công việc. Trong ví dụ này, phần cứng truy cập page table để tìm bản dịch (Dòng 11–12), và giả sử <strong>virtual memory reference</strong> do <strong>process</strong> (tiến trình) tạo ra là hợp lệ và có thể truy cập (Dòng 13, 15), phần cứng sẽ cập nhật TLB với bản dịch này (Dòng 18). Các thao tác này tốn kém, chủ yếu vì cần một lần truy cập bộ nhớ bổ sung để lấy thông tin từ page table (Dòng 12). Cuối cùng, khi TLB đã được cập nhật, phần cứng sẽ thực thi lại lệnh; lần này, bản dịch được tìm thấy trong TLB và truy cập bộ nhớ diễn ra nhanh chóng.</p>
</li>
</ul>
<p>Giống như mọi <strong>cache</strong>, TLB được xây dựng dựa trên giả định rằng trong hầu hết các trường hợp, bản dịch sẽ được tìm thấy trong cache (tức là hit). Nếu đúng, chi phí thêm vào là rất nhỏ, vì TLB nằm gần lõi xử lý và được thiết kế để rất nhanh. Khi xảy ra miss, chi phí cao của paging sẽ xuất hiện; page table phải được truy cập để tìm bản dịch, dẫn đến một lần truy cập bộ nhớ bổ sung (hoặc nhiều hơn nếu page table phức tạp). Nếu điều này xảy ra thường xuyên, chương trình sẽ chạy chậm thấy rõ; so với hầu hết các lệnh CPU, truy cập bộ nhớ là rất tốn kém, và <strong>TLB miss</strong> dẫn đến nhiều lần truy cập bộ nhớ hơn. Do đó, mục tiêu của chúng ta là tránh TLB miss càng nhiều càng tốt.</p>
<h2 id="192-example-accessing-an-array-ví-dụ-truy-cập-một-mảng"><a class="header" href="#192-example-accessing-an-array-ví-dụ-truy-cập-một-mảng"><strong>19.2 Example: Accessing An Array</strong> (Ví dụ: Truy cập một mảng)</a></h2>
<p>Để làm rõ cách TLB hoạt động, hãy xem xét một <strong>virtual address trace</strong> (dấu vết địa chỉ ảo) đơn giản và xem TLB có thể cải thiện hiệu năng như thế nào.</p>
<p>Giả sử chúng ta có một mảng gồm 10 số nguyên 4 byte trong bộ nhớ, bắt đầu tại <strong>virtual address</strong> 100. Giả sử thêm rằng chúng ta có một <strong>virtual address space</strong> 8-bit nhỏ, với <strong>page size</strong> (kích thước trang) là 16 byte; do đó, một virtual address được chia thành <strong>VPN</strong> 4-bit (có 16 virtual pages) và <strong>offset</strong> 4-bit (mỗi page có 16 byte).</p>
<p><em>Figure 19.2</em> (trang 4) cho thấy mảng được bố trí trên 16 page 16-byte của hệ thống. Như bạn thấy, phần tử đầu tiên của mảng (a) bắt đầu tại (VPN=06, offset=04); chỉ có ba số nguyên 4 byte nằm vừa trên page này. Mảng tiếp tục sang page tiếp theo (VPN=07), nơi chứa bốn phần tử tiếp theo (a ... a). Cuối cùng, ba phần tử còn lại của mảng 10 phần tử (a ... a) nằm trên page tiếp theo của address space (VPN=08).</p>
<p>Xét một vòng lặp đơn giản truy cập từng phần tử mảng, ví dụ trong C:</p>
<pre><code class="language-c">int i, sum = 0;
for (i = 0; i &lt; 10; i++) {
  sum += a[i];
}
</code></pre>
<p>Để đơn giản, ta giả định rằng các truy cập bộ nhớ duy nhất mà vòng lặp tạo ra là tới mảng (bỏ qua biến <code>i</code> và <code>sum</code>, cũng như bản thân các lệnh). Khi phần tử đầu tiên (a) được truy cập, CPU sẽ thấy một lệnh load tới virtual address 100. Phần cứng trích xuất VPN từ địa chỉ này (VPN=06) và dùng nó để kiểm tra TLB xem có bản dịch hợp lệ không. Giả sử đây là lần đầu chương trình truy cập mảng, kết quả sẽ là <strong>TLB miss</strong>.</p>
<p>Lần truy cập tiếp theo là tới a, và đây là tin tốt: <strong>TLB hit</strong>! Vì phần tử thứ hai nằm ngay cạnh phần tử đầu tiên, nó nằm trên cùng một page; và vì page này đã được truy cập khi lấy phần tử đầu tiên, bản dịch đã có trong TLB. Lần truy cập tới a tiếp theo cũng hit, vì nó cũng nằm trên cùng page với a và a.</p>
<p><img src="19/img/fig19_2.PNG" alt="" /></p>
<p><em>Figure 19.2: Ví dụ: Một mảng trong không gian địa chỉ nhỏ.</em></p>
<p>Không may, khi chương trình truy cập a tiếp theo, ta gặp một <strong>TLB miss</strong> khác. Tuy nhiên, một lần nữa, các phần tử tiếp theo (a ... a) sẽ hit trong TLB, vì tất cả đều nằm trên cùng một page trong bộ nhớ.</p>
<p>Cuối cùng, việc truy cập vào <strong>a</strong> gây ra một <code>TLB miss</code> (lỗi tra cứu TLB). Phần cứng một lần nữa tham chiếu đến <code>page table</code> (bảng trang) để xác định vị trí của <code>virtual page</code> (trang ảo) này trong <code>physical memory</code> (bộ nhớ vật lý), và cập nhật TLB tương ứng. Hai lần truy cập cuối cùng (a và a) được hưởng lợi từ việc cập nhật TLB này; khi phần cứng tra cứu TLB để tìm bản dịch địa chỉ, cả hai lần đều dẫn đến <strong>hit</strong> (trúng).</p>
<p>Tóm tắt lại hoạt động của TLB trong mười lần truy cập vào mảng: <strong>miss, hit, hit, miss, hit, hit, hit, miss, hit, hit</strong>. Do đó, <code>TLB hit rate</code> (tỉ lệ trúng TLB) — được tính bằng số lần hit chia cho tổng số lần truy cập — là <strong>70%</strong>. Mặc dù con số này không quá cao (thực tế, chúng ta mong muốn tỉ lệ này tiệm cận 100%), nhưng nó khác 0, điều này có thể gây bất ngờ. Ngay cả khi đây là lần đầu tiên chương trình truy cập vào mảng, TLB vẫn cải thiện hiệu năng nhờ <code>spatial locality</code> (tính cục bộ không gian). Các phần tử của mảng được sắp xếp sát nhau trong các trang (tức là chúng gần nhau về mặt vị trí trong bộ nhớ), và vì vậy chỉ lần truy cập đầu tiên đến một phần tử trên một trang mới gây ra <code>TLB miss</code>.</p>
<p>Cũng cần lưu ý vai trò của <code>page size</code> (kích thước trang) trong ví dụ này. Nếu <code>page size</code> chỉ đơn giản lớn gấp đôi (32 byte thay vì 16 byte), việc truy cập mảng sẽ gặp ít lỗi miss hơn nữa. Vì <code>page size</code> điển hình thường vào khoảng 4KB, nên các kiểu truy cập mảng dày đặc (dense, array-based accesses) như thế này đạt hiệu năng TLB rất tốt, chỉ gặp một lỗi miss cho mỗi trang được truy cập.</p>
<blockquote>
<p><strong>TIP: USE CACHING WHEN POSSIBLE</strong><br />
<strong>(MẸO: SỬ DỤNG CƠ CHẾ CACHE KHI CÓ THỂ)</strong><br />
<strong>Caching</strong> (bộ nhớ đệm) là một trong những kỹ thuật tối ưu hiệu năng cơ bản nhất trong hệ thống máy tính, được sử dụng lặp đi lặp lại để làm cho “trường hợp phổ biến chạy nhanh” [HP06]. Ý tưởng đằng sau <strong>hardware caches</strong> (bộ nhớ đệm phần cứng) là tận dụng <strong>locality</strong> (tính cục bộ) trong các tham chiếu lệnh và dữ liệu. Thông thường có hai loại locality: <strong>temporal locality</strong> (tính cục bộ theo thời gian) và <strong>spatial locality</strong> (tính cục bộ theo không gian).<br />
Với temporal locality, ý tưởng là một lệnh hoặc dữ liệu vừa được truy cập gần đây thì nhiều khả năng sẽ được truy cập lại sớm trong tương lai. Hãy nghĩ đến các biến vòng lặp hoặc các lệnh trong vòng lặp; chúng được truy cập lặp đi lặp lại theo thời gian.<br />
Với spatial locality, ý tưởng là nếu một chương trình truy cập bộ nhớ tại địa chỉ x, thì nhiều khả năng nó sẽ sớm truy cập bộ nhớ gần x. Hãy hình dung việc duyệt qua một mảng, truy cập một phần tử rồi đến phần tử tiếp theo.<br />
Tất nhiên, các đặc tính này phụ thuộc vào bản chất cụ thể của chương trình, vì vậy chúng không phải là các quy luật tuyệt đối mà chỉ là các nguyên tắc kinh nghiệm.<br />
Hardware caches, dù cho lệnh, dữ liệu, hay dịch địa chỉ (như TLB của chúng ta), đều tận dụng locality bằng cách giữ các bản sao dữ liệu trong <strong>on-chip memory</strong> (bộ nhớ trên chip) nhỏ và nhanh. Thay vì phải truy cập bộ nhớ (chậm) để đáp ứng yêu cầu, bộ xử lý có thể kiểm tra trước xem có bản sao gần đó trong cache không; nếu có, bộ xử lý có thể truy cập nhanh (chỉ vài chu kỳ CPU) và tránh mất thời gian tốn kém khi truy cập bộ nhớ (nhiều nanosecond).<br />
Bạn có thể tự hỏi: nếu cache (như TLB) tuyệt vời như vậy, sao không làm cache lớn hơn và giữ toàn bộ dữ liệu trong đó? Tiếc là ở đây chúng ta gặp phải các giới hạn cơ bản như các định luật vật lý. Nếu muốn cache nhanh, nó phải nhỏ, vì các vấn đề như tốc độ ánh sáng và các ràng buộc vật lý khác trở nên quan trọng. Bất kỳ cache lớn nào, theo định nghĩa, sẽ chậm, và do đó phản tác dụng. Vì vậy, chúng ta buộc phải dùng cache nhỏ và nhanh; câu hỏi còn lại là làm thế nào để sử dụng chúng tốt nhất nhằm cải thiện hiệu năng.</p>
</blockquote>
<p>Một điểm cuối cùng về hiệu năng của <strong>TLB</strong>: nếu chương trình, ngay sau khi vòng lặp này kết thúc, truy cập lại mảng, chúng ta có thể thấy kết quả còn tốt hơn nữa, giả sử TLB đủ lớn để lưu các bản dịch cần thiết: hit, hit, hit, hit, hit, hit, hit, hit, hit, hit. Trong trường hợp này, <strong>TLB hit rate</strong> (tỉ lệ trúng TLB) sẽ cao nhờ <strong>temporal locality</strong>, tức là việc tham chiếu lại nhanh chóng các mục dữ liệu theo thời gian. Giống như mọi cache, TLB dựa vào cả <strong>spatial locality</strong> và <strong>temporal locality</strong> để đạt hiệu quả, đây là các đặc tính của chương trình. Nếu chương trình có các đặc tính này (và nhiều chương trình có), TLB hit rate sẽ cao.</p>
<pre><code>VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT
(Success, TlbEntry) = TLB_Lookup(VPN)
if (Success == True) // TLB Hit
  if (CanAccess(TlbEntry.ProtectBits) == True)
    Offset = VirtualAddress &amp; OFFSET_MASK
    PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset
    Register = AccessMemory(PhysAddr)
  else
    RaiseException(PROTECTION_FAULT)
else
  RaiseException(TLB_MISS) // TLB Miss
</code></pre>
<p><strong>Figure 19.3: TLB Control Flow Algorithm (OS Handled)</strong><br />
<em>(Thuật toán luồng điều khiển TLB — do OS xử lý)</em></p>
<h2 id="193-who-handles-the-tlb-miss"><a class="header" href="#193-who-handles-the-tlb-miss"><strong>19.3 Who Handles The TLB Miss?</strong></a></h2>
<p>(Ai xử lý TLB miss?)</p>
<p>Một câu hỏi cần trả lời: ai sẽ xử lý một <strong>TLB miss</strong>? Có hai khả năng: <strong>hardware</strong> (phần cứng) hoặc <strong>software</strong> (OS).</p>
<p>Trong những ngày đầu, phần cứng có <strong>complex instruction sets</strong> (tập lệnh phức tạp, đôi khi gọi là <strong>CISC</strong> — <em>complex-instruction set computers</em>) và những người thiết kế phần cứng không mấy tin tưởng “đám OS” kia. Vì vậy, phần cứng sẽ xử lý toàn bộ TLB miss. Để làm được điều này, phần cứng phải biết chính xác <strong>page tables</strong> (bảng trang) nằm ở đâu trong bộ nhớ (thông qua <strong>page-table base register</strong>, được dùng ở Dòng 11 trong <em>Figure 19.1</em>), cũng như định dạng chính xác của chúng; khi xảy ra miss, phần cứng sẽ “walk” page table, tìm <strong>page-table entry</strong> đúng và trích xuất bản dịch mong muốn, cập nhật TLB với bản dịch đó, và thực thi lại lệnh.</p>
<p>Một ví dụ về kiến trúc “cũ” có <strong>hardware-managed TLBs</strong> là kiến trúc Intel x86, sử dụng <strong>multi-level page table</strong> (bảng trang nhiều cấp) cố định (xem chi tiết ở chương sau); page table hiện tại được trỏ bởi thanh ghi CR3 [I09].</p>
<p>Các kiến trúc hiện đại hơn (ví dụ: MIPS R10k [H93] hoặc Sun’s SPARC v9 [WG00], cả hai đều là <strong>RISC</strong> — <em>reduced-instruction set computers</em>) có cái gọi là <strong>software-managed TLB</strong>. Khi xảy ra TLB miss, phần cứng chỉ đơn giản phát sinh một <strong>exception</strong> (ngoại lệ) (Dòng 11 trong <em>Figure 19.3</em>), tạm dừng luồng lệnh hiện tại, nâng mức đặc quyền lên <strong>kernel mode</strong>, và nhảy tới một <strong>trap handler</strong>. Như bạn có thể đoán, trap handler này là mã trong OS được viết với mục đích xử lý TLB miss. Khi chạy, mã này sẽ tra cứu bản dịch trong page table, sử dụng các lệnh “đặc quyền” để cập nhật TLB, và quay lại từ trap; tại thời điểm này, phần cứng sẽ thực thi lại lệnh (dẫn đến TLB hit).</p>
<p>Hãy thảo luận một vài chi tiết quan trọng:</p>
<ul>
<li>Thứ nhất, <strong>return-from-trap instruction</strong> (lệnh quay lại từ trap) cần khác một chút so với return-from-trap mà ta đã thấy khi xử lý <strong>system call</strong>. Trong trường hợp system call, return-from-trap sẽ tiếp tục thực thi tại lệnh ngay sau trap vào OS, giống như việc quay lại từ một call thủ tục sẽ tiếp tục tại lệnh ngay sau call.</li>
<li>Trong trường hợp trap do TLB miss, khi return-from-trap, phần cứng phải tiếp tục thực thi tại <strong>chính lệnh gây ra trap</strong>; lần thử lại này sẽ khiến lệnh chạy lại, và lần này sẽ là TLB hit. Do đó, tùy thuộc vào nguyên nhân gây ra trap hoặc exception, phần cứng phải lưu <strong>PC</strong> (program counter) khác nhau khi trap vào OS, để có thể khôi phục đúng khi cần.</li>
</ul>
<blockquote>
<p><strong>ASIDE: RISC VS. CISC</strong><br />
Vào những năm 1980, một cuộc chiến lớn đã diễn ra trong cộng đồng kiến trúc máy tính. Một bên là phe <strong>CISC</strong> (<em>Complex Instruction Set Computing</em>), bên kia là <strong>RISC</strong> (<em>Reduced Instruction Set Computing</em>) [PS81]. Phe RISC được dẫn dắt bởi David Patterson tại Berkeley và John Hennessy tại Stanford (cũng là đồng tác giả của một số cuốn sách nổi tiếng [HP06]), mặc dù sau này John Cocke được trao giải Turing cho công trình tiên phong về RISC [CM00].<br />
<strong>CISC instruction sets</strong> thường có rất nhiều lệnh, và mỗi lệnh tương đối mạnh. Ví dụ, có thể có một lệnh sao chép chuỗi, nhận hai con trỏ và một độ dài, rồi sao chép byte từ nguồn sang đích. Ý tưởng của CISC là các lệnh nên là các nguyên thủy cấp cao, giúp <strong>assembly language</strong> (ngôn ngữ hợp ngữ) dễ dùng hơn và mã nguồn gọn hơn.<br />
<strong>RISC instruction sets</strong> thì hoàn toàn ngược lại. Một quan sát then chốt của RISC là tập lệnh thực chất là đích đến của <strong>compiler</strong> (trình biên dịch), và tất cả những gì compiler cần là một vài nguyên thủy đơn giản để tạo ra mã hiệu năng cao. Vì vậy, những người ủng hộ RISC lập luận rằng hãy loại bỏ càng nhiều phần cứng càng tốt (đặc biệt là <strong>microcode</strong>), và làm cho phần còn lại đơn giản, đồng nhất và nhanh.<br />
Trong những ngày đầu, các chip RISC tạo ra tác động lớn, vì chúng nhanh hơn một cách rõ rệt [BC91]; nhiều bài báo khoa học đã được viết; một số công ty được thành lập (ví dụ: MIPS và Sun). Tuy nhiên, theo thời gian, các nhà sản xuất CISC như Intel đã tích hợp nhiều kỹ thuật của RISC vào lõi của bộ xử lý của họ, ví dụ bằng cách thêm các giai đoạn pipeline ban đầu để biến đổi các lệnh phức tạp thành các <strong>micro-instructions</strong> (vi lệnh) có thể được xử lý theo cách giống RISC. Những cải tiến này, cộng với số lượng transistor ngày càng tăng trên mỗi chip, đã giúp CISC duy trì khả năng cạnh tranh. Kết quả cuối cùng là cuộc tranh luận dần lắng xuống, và ngày nay cả hai loại bộ xử lý đều có thể được thiết kế để chạy nhanh.</p>
</blockquote>
<p>Thứ hai, khi chạy <code>TLB miss-handling code</code> (mã xử lý lỗi TLB miss), hệ điều hành (OS) cần đặc biệt cẩn trọng để không gây ra một chuỗi vô hạn các <code>TLB misses</code> (lỗi tra cứu TLB). Có nhiều giải pháp tồn tại; ví dụ, bạn có thể lưu <code>TLB miss handlers</code> (trình xử lý lỗi TLB miss) trong <code>physical memory</code> (bộ nhớ vật lý) — nơi chúng không được ánh xạ và không chịu sự chi phối của <code>address translation</code> (dịch địa chỉ), hoặc dành riêng một số mục (entry) trong TLB cho các bản dịch luôn hợp lệ (permanently-valid translations) và sử dụng một số slot dịch địa chỉ cố định này cho chính <code>handler code</code> (mã xử lý) đó; các <code>wired translations</code> (bản dịch cố định) này luôn cho kết quả hit trong TLB.</p>
<blockquote>
<p><strong>ASIDE: TLB VALID BIT != PAGE TABLE VALID BIT</strong><br />
(<strong>Lưu ý: Bit hợp lệ trong TLB khác với bit hợp lệ trong page table</strong>)<br />
Một lỗi phổ biến là nhầm lẫn giữa <strong>valid bit</strong> (bit hợp lệ) trong <strong>TLB</strong> và valid bit trong <strong>page table</strong> (bảng trang). Trong page table, khi một <strong>page-table entry</strong> (PTE — mục bảng trang) được đánh dấu <strong>invalid</strong> (không hợp lệ), điều đó có nghĩa là page chưa được <strong>process</strong> (tiến trình) cấp phát, và một chương trình hoạt động đúng sẽ không được phép truy cập vào page đó. Phản ứng thông thường khi truy cập một page không hợp lệ là phát sinh <strong>trap</strong> (bẫy) tới <strong>OS</strong> (hệ điều hành), và OS sẽ phản hồi bằng cách chấm dứt process đó.<br />
Ngược lại, <strong>TLB valid bit</strong> chỉ đơn giản cho biết một entry trong TLB có chứa bản dịch hợp lệ hay không. Ví dụ, khi hệ thống khởi động, trạng thái ban đầu phổ biến của mỗi entry trong TLB là <strong>invalid</strong>, vì chưa có bản dịch địa chỉ nào được cache ở đó. Khi <strong>virtual memory</strong> (bộ nhớ ảo) được kích hoạt, và khi các chương trình bắt đầu chạy và truy cập <strong>virtual address space</strong> (không gian địa chỉ ảo) của chúng, TLB sẽ dần được lấp đầy, và các entry hợp lệ sẽ nhanh chóng xuất hiện trong TLB.<br />
TLB valid bit cũng rất hữu ích khi thực hiện <strong>context switch</strong> (chuyển ngữ cảnh), như chúng ta sẽ thảo luận bên dưới. Bằng cách đặt tất cả các entry trong TLB về trạng thái invalid, hệ thống có thể đảm bảo rằng process sắp chạy sẽ không vô tình sử dụng một <strong>virtual-to-physical translation</strong> (bản dịch từ địa chỉ ảo sang địa chỉ vật lý) từ một process trước đó.</p>
</blockquote>
<p>Lợi thế chính của cách tiếp cận <strong>software-managed</strong> (TLB do phần mềm quản lý) là tính linh hoạt: OS có thể sử dụng bất kỳ <strong>data structure</strong> (cấu trúc dữ liệu) nào để triển khai page table, mà không cần thay đổi phần cứng. Một lợi thế khác là sự đơn giản, như thấy trong luồng điều khiển TLB (dòng 11 trong <em>Figure 19.3</em>, so với dòng 11–19 trong <em>Figure 19.1</em>). Phần cứng không làm nhiều khi xảy ra miss: chỉ cần phát sinh <strong>exception</strong> và để <strong>TLB miss handler</strong> của OS xử lý phần còn lại.</p>
<h3 id="194-tlb-contents-whats-in-there"><a class="header" href="#194-tlb-contents-whats-in-there"><strong>19.4 TLB Contents: What’s In There?</strong></a></h3>
<p>(Nội dung của TLB: Bên trong có gì?)</p>
<p>Hãy xem chi tiết nội dung của <strong>hardware TLB</strong> (TLB phần cứng). Một TLB điển hình có thể có 32, 64 hoặc 128 entry và thuộc loại <strong>fully associative</strong> (hoàn toàn kết hợp). Điều này có nghĩa là bất kỳ bản dịch nào cũng có thể nằm ở bất kỳ vị trí nào trong TLB, và phần cứng sẽ tìm kiếm toàn bộ TLB song song để tìm bản dịch mong muốn. Một entry TLB có thể trông như sau:</p>
<pre><code>VPN  |  PFN  |  other bits
</code></pre>
<p>Lưu ý rằng cả <strong>VPN</strong> (virtual page number — số trang ảo) và <strong>PFN</strong> (page frame number — số khung trang) đều có trong mỗi entry, vì bản dịch có thể nằm ở bất kỳ vị trí nào (trong thuật ngữ phần cứng, TLB được gọi là <strong>fully-associative cache</strong>). Phần cứng tìm kiếm song song các entry để xem có khớp hay không.</p>
<p>Điều thú vị hơn là các “other bits” (các bit khác). Ví dụ, TLB thường có <strong>valid bit</strong> cho biết entry có chứa bản dịch hợp lệ hay không. Ngoài ra còn có <strong>protection bits</strong> (bit bảo vệ), xác định cách một page có thể được truy cập (giống như trong page table). Ví dụ, <strong>code pages</strong> có thể được đánh dấu <strong>read</strong> và <strong>execute</strong>, trong khi <strong>heap pages</strong> có thể được đánh dấu <strong>read</strong> và <strong>write</strong>. Ngoài ra có thể có một số trường khác, bao gồm <strong>address-space identifier</strong> (ASID — định danh không gian địa chỉ), <strong>dirty bit</strong> (bit bẩn), v.v.; xem thêm bên dưới để biết chi tiết.</p>
<h3 id="195-tlb-issue-context-switches"><a class="header" href="#195-tlb-issue-context-switches"><strong>19.5 TLB Issue: Context Switches</strong></a></h3>
<p>(Vấn đề TLB: Chuyển ngữ cảnh)</p>
<p>Với TLB, các vấn đề mới nảy sinh khi chuyển đổi giữa các <strong>process</strong> (và do đó là giữa các <strong>address space</strong>). Cụ thể, TLB chứa các <strong>virtual-to-physical translations</strong> chỉ hợp lệ cho process đang chạy; các bản dịch này không có ý nghĩa với process khác. Do đó, khi chuyển từ process này sang process khác, phần cứng hoặc OS (hoặc cả hai) phải đảm bảo rằng process sắp chạy sẽ không vô tình sử dụng các bản dịch từ process trước đó.</p>
<p>Để hiểu rõ hơn, hãy xem một ví dụ: Khi một process (P1) đang chạy, nó giả định rằng TLB có thể đang cache các bản dịch hợp lệ cho nó, tức là lấy từ page table của P1. Giả sử, trong ví dụ này, <strong>virtual page</strong> thứ 10 của P1 được ánh xạ tới <strong>physical frame</strong> 100. Giả sử có một process khác (P2), và OS sắp thực hiện <strong>context switch</strong> để chạy nó. Giả sử <strong>virtual page</strong> thứ 10 của P2 được ánh xạ tới <strong>physical frame</strong> 170. Nếu các entry của cả hai process đều có trong TLB, nội dung TLB sẽ là:</p>
<div class="table-wrapper"><table><thead><tr><th>VPN</th><th>PFN</th><th>valid</th><th>prot</th></tr></thead><tbody>
<tr><td>10</td><td>100</td><td>1</td><td>rwx</td></tr>
<tr><td>—</td><td>—</td><td>0</td><td>—</td></tr>
<tr><td>10</td><td>170</td><td>1</td><td>rwx</td></tr>
<tr><td>—</td><td>—</td><td>0</td><td>—</td></tr>
</tbody></table>
</div>
<p>Trong TLB trên, rõ ràng có vấn đề: VPN 10 có thể dịch thành PFN 100 (P1) hoặc PFN 170 (P2), nhưng phần cứng không thể phân biệt entry nào thuộc về process nào. Do đó, chúng ta cần làm thêm để TLB có thể hỗ trợ <strong>virtualization</strong> (ảo hóa) giữa nhiều process một cách đúng đắn và hiệu quả.</p>
<blockquote>
<p><strong>THE CRUX: HOW TO MANAGE TLB CONTENTS ON A CONTEXT SWITCH</strong><br />
Khi <strong>context-switching</strong> giữa các process, các bản dịch trong TLB của process trước không có ý nghĩa với process sắp chạy. Phần cứng hoặc OS nên làm gì để giải quyết vấn đề này?</p>
</blockquote>
<p>Có một số giải pháp khả thi:</p>
<ul>
<li>Một cách là <strong>flush</strong> (xóa) TLB khi context switch, làm trống nó trước khi chạy process tiếp theo. Trong hệ thống <strong>software-based</strong>, điều này có thể thực hiện bằng một lệnh phần cứng đặc quyền; với <strong>hardware-managed TLB</strong>, việc flush có thể được thực hiện khi <strong>page-table base register</strong> (PTBR) thay đổi (OS phải thay đổi PTBR khi context switch). Trong cả hai trường hợp, thao tác flush chỉ đơn giản là đặt tất cả valid bit về 0, xóa sạch nội dung TLB.</li>
</ul>
<p>Bằng cách flush TLB mỗi lần context switch, chúng ta có một giải pháp hoạt động, vì process sẽ không bao giờ gặp phải bản dịch sai trong TLB. Tuy nhiên, chi phí là: mỗi lần process chạy, nó sẽ gặp <strong>TLB miss</strong> khi truy cập dữ liệu và code pages của mình. Nếu OS chuyển đổi process thường xuyên, chi phí này có thể cao.</p>
<p>Để giảm chi phí này, một số hệ thống bổ sung hỗ trợ phần cứng để cho phép chia sẻ TLB qua các lần context switch. Cụ thể, một số hệ thống phần cứng cung cấp trường <strong>address space identifier</strong> (ASID) trong TLB. Có thể coi ASID như một <strong>process identifier</strong> (PID), nhưng thường có ít bit hơn (ví dụ: 8 bit cho ASID so với 32 bit cho PID). Nếu thêm ASID vào ví dụ TLB ở trên, các process có thể chia sẻ TLB dễ dàng: chỉ cần trường ASID để phân biệt các bản dịch giống hệt nhau. Here is a depiction of a TLB with the added ASID field:</p>
<div class="table-wrapper"><table><thead><tr><th>VPN</th><th>PFN</th><th>valid</th><th>prot</th><th>ASID</th></tr></thead><tbody>
<tr><td>10</td><td>100</td><td>1</td><td>rwx</td><td>1</td></tr>
<tr><td>—</td><td>—</td><td>0</td><td>—</td><td>—</td></tr>
<tr><td>10</td><td>170</td><td>1</td><td>rwx</td><td>2</td></tr>
<tr><td>—</td><td>—</td><td>0</td><td>—</td><td>—</td></tr>
</tbody></table>
</div>
<p>Với <strong>address-space identifiers</strong>, TLB có thể chứa bản dịch từ các process khác nhau cùng lúc mà không bị nhầm lẫn. Tất nhiên, phần cứng cũng cần biết process nào đang chạy để thực hiện dịch địa chỉ, và do đó OS phải, khi context switch, thiết lập một <strong>privileged register</strong> (thanh ghi đặc quyền) tới ASID của process hiện tại.</p>
<p>Ngoài ra, bạn có thể nghĩ đến một trường hợp khác khi hai entry trong TLB khá giống nhau. Trong ví dụ này, có hai entry cho hai process khác nhau với hai VPN khác nhau nhưng trỏ tới cùng một <strong>physical page</strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>VPN</th><th>PFN</th><th>valid</th><th>prot</th><th>ASID</th></tr></thead><tbody>
<tr><td>10</td><td>101</td><td>1</td><td>r-x</td><td>1</td></tr>
<tr><td>—</td><td>—</td><td>0</td><td>—</td><td>—</td></tr>
<tr><td>50</td><td>101</td><td>1</td><td>r-x</td><td>2</td></tr>
<tr><td>—</td><td>—</td><td>0</td><td>—</td><td>—</td></tr>
</tbody></table>
</div>
<p>Tình huống này có thể xảy ra, ví dụ, khi hai process chia sẻ một page (ví dụ: <strong>code page</strong>). Trong ví dụ trên, P1 chia sẻ physical page 101 với P2; P1 ánh xạ page này vào page thứ 10 trong address space của nó, trong khi P2 ánh xạ nó vào page thứ 50 trong address space của nó. Việc chia sẻ code pages (trong các binary hoặc <strong>shared libraries</strong>) giúp giảm số lượng page vật lý đang được dùng, từ đó giảm memory overhead.</p>
<h3 id="197-a-real-tlb-entry"><a class="header" href="#197-a-real-tlb-entry"><strong>19.7 A Real TLB Entry</strong></a></h3>
<p>(Một entry TLB thực tế)</p>
<p>Cuối cùng, hãy cùng xem nhanh một ví dụ TLB thực tế. Ví dụ này đến từ <strong>MIPS R4000</strong> [H93], một hệ thống hiện đại sử dụng <strong>software-managed TLBs</strong> (TLB do phần mềm quản lý); một entry TLB của MIPS đã được giản lược đôi chút có thể thấy trong <em>Figure 19.4</em>.</p>
<p><img src="19/img/fig19_4.PNG" alt="" /></p>
<p><strong>Figure 19.4: A MIPS TLB Entry</strong><br />
<em>(Một entry TLB của MIPS)</em></p>
<p>MIPS R4000 hỗ trợ <strong>address space</strong> (không gian địa chỉ) 32-bit với <strong>page</strong> 4KB. Do đó, trong một <strong>virtual address</strong> (địa chỉ ảo) điển hình, ta sẽ kỳ vọng có <strong>VPN</strong> (virtual page number — số trang ảo) 20-bit và <strong>offset</strong> 12-bit. Tuy nhiên, như bạn thấy trong TLB, chỉ có 19 bit cho VPN; lý do là <strong>user addresses</strong> (địa chỉ người dùng) chỉ chiếm một nửa address space (phần còn lại dành cho <strong>kernel</strong>), nên chỉ cần 19 bit VPN. VPN này được dịch sang tối đa <strong>PFN</strong> (physical frame number — số khung trang vật lý) 24-bit, do đó có thể hỗ trợ hệ thống với tối đa 64GB <strong>main memory</strong> (bộ nhớ chính vật lý) (2^24 page 4KB).</p>
<p>Có một số bit thú vị khác trong MIPS TLB:</p>
<ul>
<li><strong>Global bit</strong> (G): dùng cho các page được <strong>globally-shared</strong> (chia sẻ toàn cục) giữa các <strong>process</strong> (tiến trình). Nếu global bit được bật, <strong>ASID</strong> sẽ bị bỏ qua. </li>
<li><strong>ASID</strong> 8-bit: OS có thể dùng để phân biệt các address space (như đã mô tả ở trên). Câu hỏi đặt ra: OS nên làm gì nếu có hơn 256 (2^8) process chạy cùng lúc?</li>
<li>3 bit <strong>Coherence</strong> (C): xác định cách phần cứng cache một page (vượt ngoài phạm vi ghi chú này).</li>
<li><strong>Dirty bit</strong>: được đánh dấu khi page đã bị ghi (sẽ thấy cách sử dụng sau).</li>
<li><strong>Valid bit</strong>: cho phần cứng biết entry có chứa bản dịch hợp lệ hay không.</li>
<li><strong>Page mask field</strong> (không hiển thị): hỗ trợ nhiều kích thước page; sau này chúng ta sẽ thấy tại sao page lớn lại hữu ích.</li>
<li>Một số bit trong tổng số 64 bit không được sử dụng (tô xám trong sơ đồ).</li>
</ul>
<blockquote>
<p><strong>TIP: RAM ISN’T ALWAYS RAM (CULLER’S LAW)</strong><br />
Thuật ngữ <strong>random-access memory</strong> (RAM — bộ nhớ truy cập ngẫu nhiên) ngụ ý rằng bạn có thể truy cập bất kỳ phần nào của RAM nhanh như nhau. Mặc dù nhìn chung nên nghĩ về RAM theo cách này, nhưng do các đặc tính phần cứng/OS như TLB, việc truy cập một page bộ nhớ cụ thể có thể tốn kém, đặc biệt nếu page đó hiện không được ánh xạ trong TLB. Vì vậy, luôn nên nhớ mẹo triển khai: RAM không phải lúc nào cũng là RAM. Đôi khi việc truy cập ngẫu nhiên address space của bạn, đặc biệt nếu số lượng page được truy cập vượt quá <strong>TLB coverage</strong> (phạm vi bao phủ của TLB), có thể dẫn đến suy giảm hiệu năng nghiêm trọng. Vì một trong các cố vấn của chúng tôi, David Culler, thường chỉ ra TLB là nguồn gốc của nhiều vấn đề hiệu năng, nên chúng tôi đặt tên định luật này để vinh danh ông: <strong>Culler’s Law</strong>.</p>
</blockquote>
<p>Thông thường, MIPS TLB có 32 hoặc 64 entry như vậy, phần lớn được dùng bởi <strong>user processes</strong> khi chúng chạy. Tuy nhiên, một số entry được dành riêng cho OS. Một <strong>wired register</strong> có thể được OS thiết lập để báo cho phần cứng biết cần dành bao nhiêu slot TLB cho OS; OS sử dụng các ánh xạ dự trữ này cho <strong>code</strong> và <strong>data</strong> mà nó muốn truy cập trong các thời điểm quan trọng, khi một <strong>TLB miss</strong> sẽ gây vấn đề (ví dụ: trong <strong>TLB miss handler</strong>).</p>
<p>Vì MIPS TLB là <strong>software managed</strong>, cần có các lệnh để cập nhật TLB. MIPS cung cấp bốn lệnh như vậy:</p>
<ul>
<li><code>TLBP</code>: dò TLB để xem một bản dịch cụ thể có ở đó không.</li>
<li><code>TLBR</code>: đọc nội dung một entry TLB vào các <strong>register</strong>.</li>
<li><code>TLBWI</code>: thay thế một entry TLB cụ thể.</li>
<li><code>TLBWR</code>: thay thế một entry TLB ngẫu nhiên.</li>
</ul>
<p>OS sử dụng các lệnh này để quản lý nội dung TLB. Tất nhiên, điều quan trọng là các lệnh này phải là <strong>privileged</strong> (đặc quyền); hãy tưởng tượng điều gì sẽ xảy ra nếu một <strong>user process</strong> có thể sửa nội dung TLB (gợi ý: gần như bất cứ điều gì, bao gồm chiếm quyền điều khiển máy, chạy “OS” độc hại của riêng nó, hoặc thậm chí “làm biến mất Mặt Trời”).</p>
<h3 id="198-summary"><a class="header" href="#198-summary"><strong>19.8 Summary</strong></a></h3>
<p>(Tóm tắt)</p>
<p>Chúng ta đã thấy cách phần cứng có thể giúp tăng tốc <strong>address translation</strong> (dịch địa chỉ). Bằng cách cung cấp một <strong>on-chip TLB</strong> nhỏ, chuyên dụng như một <strong>address-translation cache</strong>, hầu hết các <strong>memory references</strong> (tham chiếu bộ nhớ) sẽ được xử lý mà không cần truy cập <strong>page table</strong> trong <strong>main memory</strong>. Do đó, trong trường hợp phổ biến, hiệu năng chương trình gần như không bị ảnh hưởng bởi việc bộ nhớ đang được <strong>virtualized</strong> (ảo hóa) — một thành tựu tuyệt vời cho <strong>operating system</strong> (hệ điều hành), và chắc chắn là yếu tố thiết yếu để sử dụng <strong>paging</strong> trong các hệ thống hiện đại.</p>
<p>Tuy nhiên, TLB không phải lúc nào cũng mang lại “màu hồng” cho mọi chương trình. Đặc biệt, nếu số lượng page mà chương trình truy cập trong một khoảng thời gian ngắn vượt quá số page có thể chứa trong TLB, chương trình sẽ tạo ra nhiều <strong>TLB misses</strong> và chạy chậm hơn đáng kể. Hiện tượng này được gọi là <strong>exceeding the TLB coverage</strong> (vượt quá phạm vi bao phủ của TLB), và có thể là vấn đề nghiêm trọng với một số chương trình. Một giải pháp, như sẽ thảo luận ở chương sau, là hỗ trợ <strong>larger page sizes</strong> (kích thước page lớn hơn); bằng cách ánh xạ các <strong>data structures</strong> (cấu trúc dữ liệu) quan trọng vào các vùng của address space được ánh xạ bởi page lớn, <strong>coverage</strong> hiệu quả của TLB có thể được tăng lên. Hỗ trợ <strong>large pages</strong> thường được khai thác bởi các chương trình như <strong>database management system</strong> (DBMS — hệ quản trị cơ sở dữ liệu), vốn có một số cấu trúc dữ liệu vừa lớn vừa được truy cập ngẫu nhiên.</p>
<p>Một vấn đề khác đáng nhắc tới: <strong>TLB access</strong> (truy cập TLB) có thể dễ dàng trở thành nút thắt cổ chai trong <strong>CPU pipeline</strong>, đặc biệt với loại <strong>physically-indexed cache</strong> (bộ nhớ đệm đánh chỉ số theo địa chỉ vật lý). Với loại cache này, address translation phải diễn ra trước khi cache được truy cập, điều này có thể làm chậm đáng kể. Vì vấn đề tiềm ẩn này, người ta đã nghiên cứu nhiều cách thông minh để truy cập cache bằng <strong>virtual addresses</strong>, tránh bước dịch địa chỉ tốn kém trong trường hợp <strong>cache hit</strong>. Loại <strong>virtually-indexed cache</strong> này giải quyết một số vấn đề hiệu năng, nhưng cũng đưa ra các thách thức mới trong <strong>hardware design</strong> (thiết kế phần cứng). Xem khảo sát của Wiggins [W03] để biết thêm chi tiết.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-paging-smaller-tables"><a class="header" href="#20-paging-smaller-tables">20 Paging: Smaller Tables</a></h1>
<p>(Paging: Bảng trang nhỏ hơn)</p>
<p>Chúng ta sẽ giải quyết vấn đề thứ hai mà <strong>paging</strong> (phân trang) gây ra: <strong>page table</strong> (bảng trang) quá lớn và tiêu tốn quá nhiều bộ nhớ. Hãy bắt đầu với <strong>linear page table</strong> (bảng trang tuyến tính). Như bạn có thể nhớ<sup class="footnote-reference"><a href="#1">1</a></sup>, linear page table có thể rất lớn. Giả sử một <strong>address space</strong> (không gian địa chỉ) 32-bit (2^32 byte), với <strong>page</strong> 4KB (2^12 byte) và mỗi <strong>page-table entry</strong> (PTE — mục bảng trang) có kích thước 4 byte. Một address space như vậy sẽ có khoảng một triệu <strong>virtual pages</strong> (trang ảo) (2^32 / 2^12); nhân với kích thước mỗi PTE, ta thấy page table có kích thước 4MB. Cũng cần nhớ: thông thường, mỗi <strong>process</strong> (tiến trình) trong hệ thống sẽ có một page table riêng! Với 100 process đang hoạt động (không hiếm trong hệ thống hiện đại), chúng ta sẽ phải cấp phát hàng trăm MB bộ nhớ chỉ để lưu page table! Do đó, chúng ta cần tìm các kỹ thuật để giảm gánh nặng này. Có khá nhiều kỹ thuật, vậy hãy bắt đầu. Nhưng trước tiên, là một điểm mấu chốt:</p>
<blockquote>
<p><strong>CRUX: HOW TO MAKE PAGE TABLES SMALLER?</strong><br />
(Làm thế nào để làm nhỏ page table?)<br />
Các page table dạng mảng đơn giản (thường gọi là linear page table) quá lớn, chiếm quá nhiều bộ nhớ trong các hệ thống thông thường. Làm thế nào để làm nhỏ page table? Ý tưởng chính là gì? Những sự kém hiệu quả nào sẽ phát sinh từ các cấu trúc dữ liệu mới này?</p>
</blockquote>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Hoặc có thể bạn không nhớ; cơ chế paging này đang trở nên khá phức tạp, đúng không? Dù sao, hãy luôn đảm bảo rằng bạn hiểu rõ vấn đề mình đang giải quyết trước khi chuyển sang phần giải pháp; thực tế, nếu bạn hiểu rõ vấn đề, bạn thường có thể tự suy ra giải pháp. Ở đây, vấn đề đã rõ: linear page table đơn giản (dạng mảng) là quá lớn.</p>
</div>
<h2 id="201-simple-solution-bigger-pages"><a class="header" href="#201-simple-solution-bigger-pages">20.1 Simple Solution: Bigger Pages</a></h2>
<p>(Giải pháp đơn giản: Page lớn hơn)</p>
<p>Chúng ta có thể giảm kích thước page table theo một cách đơn giản: sử dụng page lớn hơn. Lấy lại ví dụ address space 32-bit, nhưng lần này giả sử page có kích thước 16KB. Khi đó, chúng ta sẽ có <strong>VPN</strong> (virtual page number) 18-bit và <strong>offset</strong> 14-bit. Giữ nguyên kích thước mỗi PTE là 4 byte, ta sẽ có 2^18 entry trong linear page table, tức tổng kích thước là 1MB cho mỗi page table — giảm 4 lần so với ban đầu (không ngạc nhiên, mức giảm này phản ánh đúng mức tăng gấp 4 của kích thước page).</p>
<blockquote>
<p><strong>ASIDE: MULTIPLE PAGE SIZES</strong><br />
(Nhiều kích thước page)<br />
Nhiều kiến trúc (ví dụ: MIPS, SPARC, x86-64) hiện hỗ trợ nhiều kích thước page. Thông thường, kích thước page nhỏ (4KB hoặc 8KB) được sử dụng. Tuy nhiên, nếu một ứng dụng “thông minh” yêu cầu, một page lớn duy nhất (ví dụ: 4MB) có thể được dùng cho một phần cụ thể của address space, cho phép ứng dụng đặt một <strong>data structure</strong> (cấu trúc dữ liệu) lớn và thường xuyên được sử dụng vào đó, đồng thời chỉ tiêu tốn một entry trong <strong>TLB</strong>. Kiểu sử dụng page lớn này phổ biến trong <strong>database management systems</strong> (hệ quản trị cơ sở dữ liệu) và các ứng dụng thương mại cao cấp khác. Lý do chính của việc hỗ trợ nhiều kích thước page không phải để tiết kiệm không gian page table, mà là để giảm áp lực lên TLB, cho phép chương trình truy cập nhiều hơn vào address space của nó mà không gặp quá nhiều <strong>TLB misses</strong>. Tuy nhiên, như các nghiên cứu đã chỉ ra [N+02], việc sử dụng nhiều kích thước page khiến <strong>virtual memory manager</strong> (bộ quản lý bộ nhớ ảo) của OS trở nên phức tạp hơn đáng kể, và do đó page lớn đôi khi dễ sử dụng nhất khi OS cung cấp một giao diện mới để ứng dụng yêu cầu trực tiếp.</p>
</blockquote>
<p>Vấn đề lớn của cách tiếp cận này là page lớn dẫn đến lãng phí bên trong mỗi page, gọi là <strong>internal fragmentation</strong> (phân mảnh bên trong — vì phần lãng phí nằm bên trong đơn vị cấp phát). Ứng dụng có thể cấp phát page nhưng chỉ dùng một phần nhỏ, khiến bộ nhớ nhanh chóng bị lấp đầy bởi các page quá lớn này. Do đó, hầu hết hệ thống sử dụng kích thước page tương đối nhỏ trong trường hợp phổ biến: 4KB (như x86) hoặc 8KB (như SPARCv9). Vậy là vấn đề của chúng ta sẽ không thể giải quyết đơn giản như vậy.</p>
<h2 id="202-hybrid-approach-paging-and-segments"><a class="header" href="#202-hybrid-approach-paging-and-segments">20.2 Hybrid Approach: Paging and Segments</a></h2>
<p>(Cách tiếp cận lai: Paging và Segmentation)</p>
<p>Khi bạn có hai cách tiếp cận hợp lý nhưng khác nhau, bạn nên xem xét việc kết hợp chúng để tận dụng ưu điểm của cả hai. Chúng ta gọi sự kết hợp này là <strong>hybrid</strong> (lai). Ví dụ, tại sao chỉ ăn sô-cô-la hoặc chỉ bơ đậu phộng khi bạn có thể kết hợp chúng thành một món tuyệt vời như Reese’s Peanut Butter Cup [M28]?</p>
<p>Nhiều năm trước, những người tạo ra hệ thống <strong>Multics</strong> (đặc biệt là Jack Dennis) đã nảy ra ý tưởng này khi xây dựng hệ thống virtual memory của Multics [M07]. Cụ thể, Dennis đã nghĩ đến việc kết hợp paging và segmentation để giảm chi phí bộ nhớ của page table. Chúng ta có thể thấy tại sao điều này hiệu quả bằng cách xem xét kỹ hơn một linear page table điển hình. Giả sử chúng ta có một address space mà phần heap và stack được sử dụng rất nhỏ. Trong ví dụ này, ta dùng một address space 16KB với page 1KB (<em>Figure 20.1</em>); page table cho address space này được thể hiện trong <em>Figure 20.2</em>.</p>
<p><img src="20/img/fig20_1.PNG" alt="" /></p>
<p><strong>Figure 20.1: A 16KB Address Space With 1KB Pages</strong></p>
<p><em>(Không gian địa chỉ 16KB với page 1KB)</em></p>
<p><img src="20/img/fig20_2.PNG" alt="" /></p>
<p><strong>Figure 20.2: A Page Table For 16KB Address Space</strong></p>
<p><em>(Page table cho không gian địa chỉ 16KB)</em></p>
<p>Ví dụ này giả định:</p>
<ul>
<li>Page code duy nhất (VPN 0) ánh xạ tới <strong>physical page</strong> 10</li>
<li>Page heap duy nhất (VPN 4) ánh xạ tới physical page 23</li>
<li>Hai page stack ở cuối address space (VPN 14 và 15) ánh xạ tới physical page 28 và 4</li>
</ul>
<p>Như bạn thấy, phần lớn page table không được sử dụng, đầy các entry invalid. Thật lãng phí! Và đây mới chỉ là address space 16KB. Hãy tưởng tượng page table của address space 32-bit và lượng không gian lãng phí tiềm tàng! Thực ra, đừng tưởng tượng — nó quá khủng khiếp.</p>
<p>Vì vậy, cách tiếp cận hybrid của chúng ta: thay vì có một page table duy nhất cho toàn bộ address space của process, tại sao không có một page table cho mỗi <strong>logical segment</strong> (đoạn logic)? Trong ví dụ này, ta có thể có ba page table: một cho code, một cho heap, và một cho stack.</p>
<p>Hãy nhớ rằng với segmentation, chúng ta có <strong>base register</strong> (thanh ghi cơ sở) cho biết mỗi segment nằm ở đâu trong physical memory, và <strong>bound/limit register</strong> (thanh ghi giới hạn) cho biết kích thước segment. Trong hybrid này, chúng ta vẫn giữ các cấu trúc đó trong <strong>MMU</strong>; nhưng ở đây, base không trỏ tới segment, mà chứa địa chỉ vật lý của page table của segment đó. Bound register dùng để chỉ điểm kết thúc của page table (tức là số lượng page hợp lệ).</p>
<p>Ví dụ: Giả sử address space 32-bit với page 4KB, chia thành bốn segment. Ta chỉ dùng ba segment: code, heap, stack.</p>
<p>Để xác định một địa chỉ thuộc segment nào, ta dùng 2 bit cao nhất của address space. Giả sử:</p>
<ul>
<li><code>00</code> là segment không dùng</li>
<li><code>01</code> cho code</li>
<li><code>10</code> cho heap</li>
<li><code>11</code> cho stack</li>
</ul>
<p>Khi đó, virtual address sẽ như sau:</p>
<pre><code>31 30 29 ... 12 11 ... 0
Seg      VPN      Offset
</code></pre>
<p>Trong phần cứng, giả sử rằng tồn tại ba cặp <strong>base/bounds</strong> (địa chỉ cơ sở/giới hạn), mỗi cặp dành riêng cho <strong>code</strong>, <strong>heap</strong> và <strong>stack</strong>. Khi một <strong>process</strong> (tiến trình) đang chạy, thanh ghi <strong>base</strong> của mỗi segment (đoạn) sẽ chứa địa chỉ vật lý của một <strong>linear page table</strong> (bảng trang tuyến tính) dành cho segment đó; do đó, mỗi process trong hệ thống hiện có ba page table liên kết với nó. Khi xảy ra <strong>context switch</strong> (chuyển ngữ cảnh), các thanh ghi này phải được thay đổi để phản ánh vị trí của các page table thuộc process mới được chuyển sang chạy.</p>
<p>Khi xảy ra <strong>TLB miss</strong> (trượt TLB – tình huống khi địa chỉ cần tìm không có trong Translation Lookaside Buffer), giả sử đây là <strong>hardware-managed TLB</strong> (TLB được phần cứng quản lý, tức phần cứng chịu trách nhiệm xử lý TLB miss), phần cứng sẽ sử dụng các bit <strong>segment</strong> (SN) để xác định cặp base/bounds nào cần dùng. Sau đó, phần cứng lấy địa chỉ vật lý trong thanh ghi base tương ứng và kết hợp nó với <strong>VPN</strong> (Virtual Page Number – số trang ảo) như sau để tạo ra địa chỉ của <strong>page table entry</strong> (PTE – mục nhập bảng trang):</p>
<pre><code>SN      = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SN_SHIFT
VPN     = (VirtualAddress &amp; VPN_MASK) &gt;&gt; VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
</code></pre>
<p>Chuỗi thao tác này có thể trông quen thuộc; nó gần như giống hệt với những gì chúng ta đã thấy trước đây khi làm việc với <strong>linear page table</strong>. Điểm khác biệt duy nhất, tất nhiên, là việc sử dụng một trong ba thanh ghi base của segment thay vì chỉ một thanh ghi base của page table duy nhất.</p>
<blockquote>
<blockquote>
<p><strong>TIP: USE HYBRIDS</strong></p>
<p>Khi bạn có hai ý tưởng tốt nhưng dường như đối lập nhau, bạn nên xem xét khả năng kết hợp chúng thành một <strong>hybrid</strong> (lai ghép) để tận dụng được ưu điểm của cả hai. Ví dụ, các giống ngô lai được biết là khỏe mạnh và bền bỉ hơn bất kỳ giống ngô tự nhiên nào. Tất nhiên, không phải mọi hybrid đều là ý tưởng hay; hãy xem loài <strong>Zeedonk</strong> (hay <strong>Zonkey</strong>), là kết quả lai giữa <strong>Zebra</strong> (ngựa vằn) và <strong>Donkey</strong> (lừa). Nếu bạn không tin rằng sinh vật này tồn tại, hãy tra cứu và chuẩn bị để ngạc nhiên.</p>
</blockquote>
</blockquote>
<p>Điểm khác biệt then chốt trong mô hình <strong>hybrid</strong> (lai) của chúng ta là sự tồn tại của một <strong>bounds register</strong> (thanh ghi giới hạn) cho mỗi <strong>segment</strong> (đoạn). Mỗi bounds register lưu giá trị của <strong>page</strong> (trang) hợp lệ lớn nhất trong segment đó. Ví dụ, nếu <strong>code segment</strong> (đoạn code) đang sử dụng ba page đầu tiên (0, 1 và 2), thì <strong>page table</strong> (bảng trang) của code segment sẽ chỉ có ba entry được cấp phát và bounds register sẽ được đặt là 3; mọi truy cập bộ nhớ vượt quá cuối segment sẽ tạo ra một <strong>exception</strong> (ngoại lệ) và nhiều khả năng dẫn đến việc chấm dứt <strong>process</strong> (tiến trình). Theo cách này, mô hình hybrid của chúng ta tiết kiệm đáng kể bộ nhớ so với <strong>linear page table</strong> (bảng trang tuyến tính); các page chưa cấp phát giữa <strong>stack</strong> và <strong>heap</strong> sẽ không còn chiếm chỗ trong page table (chỉ để đánh dấu là không hợp lệ).</p>
<p>Tuy nhiên, như bạn có thể nhận thấy, cách tiếp cận này không phải không có vấn đề. Thứ nhất, nó vẫn yêu cầu chúng ta sử dụng segmentation; như đã thảo luận trước đây, segmentation không linh hoạt như mong muốn, vì nó giả định một mô hình sử dụng address space nhất định; nếu chúng ta có một heap lớn nhưng sử dụng thưa thớt, chẳng hạn, ta vẫn có thể gặp nhiều lãng phí trong page table. Thứ hai, mô hình hybrid này khiến <strong>external fragmentation</strong> (phân mảnh bên ngoài) xuất hiện trở lại. Trong khi phần lớn bộ nhớ được quản lý theo đơn vị kích thước page, thì các page table giờ đây có thể có kích thước tùy ý (theo bội số của PTE). Do đó, việc tìm không gian trống cho chúng trong bộ nhớ trở nên phức tạp hơn. Vì những lý do này, các nhà thiết kế hệ thống tiếp tục tìm kiếm những cách tốt hơn để triển khai các page table nhỏ hơn.</p>
<h2 id="203-multi-level-page-tables"><a class="header" href="#203-multi-level-page-tables">20.3 Multi-level Page Tables</a></h2>
<p>(Bảng trang nhiều cấp)</p>
<p>Một cách tiếp cận khác không dựa vào segmentation nhưng giải quyết cùng vấn đề: làm thế nào để loại bỏ tất cả các vùng <strong>invalid</strong> (không hợp lệ) trong page table thay vì giữ chúng trong bộ nhớ? Chúng ta gọi cách tiếp cận này là <strong>multi-level page table</strong> (bảng trang nhiều cấp), vì nó biến linear page table thành một cấu trúc giống như cây. Cách tiếp cận này hiệu quả đến mức nhiều hệ thống hiện đại áp dụng nó (ví dụ: x86 [BOH10]). Sau đây, chúng ta sẽ mô tả chi tiết.</p>
<p>Ý tưởng cơ bản của multi-level page table rất đơn giản. Đầu tiên, chia nhỏ page table thành các đơn vị kích thước bằng một page. Sau đó, nếu toàn bộ một page của các <strong>page-table entries</strong> (PTE) là invalid, thì không cấp phát page đó trong page table.</p>
<p>Để theo dõi xem một page của page table có hợp lệ hay không (và nếu hợp lệ thì nằm ở đâu trong bộ nhớ), ta sử dụng một cấu trúc mới gọi là <strong>page directory</strong> (thư mục trang). Page directory có thể cho biết vị trí của một page trong page table, hoặc cho biết toàn bộ page đó không chứa page hợp lệ nào.</p>
<p><img src="20/img/fig20_3.PNG" alt="" />
<strong>Figure 20.3: Linear (Left) And Multi-Level (Right) Page Tables</strong><br />
<em>(Bảng trang tuyến tính — trái, và bảng trang nhiều cấp — phải)</em></p>
<p><em>Figure 20.3</em> minh họa ví dụ:</p>
<ul>
<li>Bên trái là linear page table cổ điển; mặc dù phần lớn các vùng ở giữa address space là invalid, ta vẫn phải cấp phát không gian page table cho các vùng này (tức là hai page ở giữa của page table).</li>
<li>Bên phải là multi-level page table; page directory chỉ đánh dấu hai page của page table là hợp lệ (đầu tiên và cuối cùng), do đó chỉ hai page này tồn tại trong bộ nhớ.</li>
</ul>
<p>Có thể hình dung multi-level table như một cách “làm biến mất” các phần không cần thiết của linear page table (giải phóng các frame cho mục đích khác), đồng thời theo dõi các page đã được cấp phát bằng page directory.</p>
<p>Trong một bảng hai cấp đơn giản, page directory chứa một entry cho mỗi page của page table. Nó bao gồm nhiều <strong>page directory entries</strong> (PDE). Một PDE (tối thiểu) có một <strong>valid bit</strong> và một <strong>page frame number</strong> (PFN), tương tự như một PTE. Tuy nhiên, ý nghĩa của valid bit ở đây hơi khác: nếu PDE hợp lệ, điều đó có nghĩa là ít nhất một page của page table mà entry này trỏ tới (thông qua PFN) là hợp lệ, tức là trong ít nhất một PTE trên page đó, valid bit được đặt thành 1. Nếu PDE không hợp lệ (bằng 0), phần còn lại của PDE không có ý nghĩa.</p>
<p><strong>Ưu điểm của multi-level page table</strong> so với các cách tiếp cận trước:</p>
<ol>
<li>Chỉ cấp phát không gian page table tỷ lệ thuận với lượng address space đang sử dụng → gọn nhẹ và hỗ trợ tốt <strong>sparse address space</strong> (không gian địa chỉ thưa).</li>
<li>Nếu được thiết kế cẩn thận, mỗi phần của page table vừa khít trong một page, giúp quản lý bộ nhớ dễ dàng hơn; OS chỉ cần lấy page trống tiếp theo khi cần cấp phát hoặc mở rộng page table.</li>
</ol>
<blockquote>
<p><strong>TIP: UNDERSTAND TIME-SPACE TRADE-OFFS</strong><br />
(Hiểu sự đánh đổi giữa thời gian và không gian)<br />
Khi xây dựng một cấu trúc dữ liệu, luôn cần cân nhắc sự đánh đổi giữa thời gian và không gian. Thông thường, nếu muốn truy cập nhanh hơn, bạn sẽ phải trả giá bằng việc sử dụng nhiều bộ nhớ hơn.</p>
</blockquote>
<p>So sánh với linear page table đơn giản (không phân trang) <sup class="footnote-reference"><a href="#2">2</a></sup>, vốn chỉ là một mảng PTE được đánh chỉ số bởi VPN: với cấu trúc này, toàn bộ linear page table phải nằm liên tục trong physical memory. Với một page table lớn (ví dụ 4MB), việc tìm một khối bộ nhớ vật lý trống liên tục lớn như vậy là một thách thức. Với cấu trúc nhiều cấp, ta thêm một mức gián tiếp thông qua page directory, trỏ tới các phần của page table; mức gián tiếp này cho phép đặt các page của page table ở bất kỳ đâu trong physical memory.</p>
<p>Tuy nhiên, multi-level table cũng có chi phí: khi xảy ra <strong>TLB miss</strong>, cần hai lần tải dữ liệu từ bộ nhớ để lấy thông tin dịch địa chỉ (một lần cho page directory, một lần cho PTE), so với chỉ một lần ở linear page table. Đây là ví dụ nhỏ về <strong>time-space trade-off</strong>: chúng ta muốn bảng nhỏ hơn (và đã đạt được), nhưng không miễn phí; mặc dù trong trường hợp phổ biến (<strong>TLB hit</strong>) hiệu năng là như nhau, nhưng khi TLB miss, chi phí cao hơn.</p>
<p>Một nhược điểm khác là <strong>độ phức tạp</strong>: dù phần cứng hay OS xử lý tra cứu page table (khi TLB miss), thì việc này chắc chắn phức tạp hơn so với linear page table. Thường thì chúng ta chấp nhận tăng độ phức tạp để cải thiện hiệu năng hoặc giảm chi phí; với multi-level table, chúng ta làm tra cứu page table phức tạp hơn để tiết kiệm bộ nhớ quý giá.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Ở đây, chúng ta giả định rằng tất cả page table đều nằm hoàn toàn trong physical memory (tức là không bị swap ra đĩa); giả định này sẽ được nới lỏng ở phần sau.</p>
</div>
<h3 id="a-detailed-multi-level-example"><a class="header" href="#a-detailed-multi-level-example">A Detailed Multi-Level Example</a></h3>
<p>(Một ví dụ chi tiết về bảng trang nhiều cấp)</p>
<p>Để hiểu rõ hơn ý tưởng của multi-level page table, hãy xét một ví dụ:</p>
<ul>
<li>Address space nhỏ 16KB</li>
<li>Page 64 byte</li>
</ul>
<p>Như vậy, ta có virtual address 14-bit, với 8 bit cho VPN và 6 bit cho offset. Linear page table sẽ có 2^8 (256) entry, ngay cả khi chỉ một phần nhỏ address space được sử dụng. <em>Figure 20.4</em> minh họa một ví dụ như vậy.</p>
<p><img src="20/img/fig20_4.PNG" alt="" />
<strong>Figure 20.4: A 16KB Address Space With 64-byte Pages</strong><br />
<em>(Không gian địa chỉ 16KB với page 64 byte)</em></p>
<p>Trong ví dụ này:</p>
<ul>
<li>Virtual pages 0 và 1 dành cho code</li>
<li>Virtual pages 4 và 5 dành cho heap</li>
<li>Virtual pages 254 và 255 dành cho stack</li>
<li>Các page còn lại không dùng.</li>
</ul>
<p>Để xây dựng <strong>two-level page table</strong> (bảng trang hai cấp) cho address space này, ta bắt đầu với linear page table đầy đủ và chia nó thành các đơn vị kích thước page.</p>
<ul>
<li>Page table đầy đủ có 256 entry</li>
<li>Mỗi PTE = 4 byte → page table = 1KB (256 × 4 byte)</li>
<li>Với page 64 byte, page table 1KB được chia thành 16 page</li>
</ul>
<p>Chỉ số <strong>page-table index</strong> (viết tắt là <strong>PTIndex</strong>) này có thể được dùng để đánh chỉ số vào chính <strong>page table</strong>, từ đó cho chúng ta địa chỉ của <strong>PTE</strong> (page-table entry — mục bảng trang):</p>
<pre><code>PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * sizeof(PTE))
</code></pre>
<p>Lưu ý rằng <strong>page-frame number</strong> (PFN — số khung trang vật lý) lấy từ <strong>page-directory entry</strong> (PDE — mục thư mục trang) phải được dịch trái (left-shift) vào đúng vị trí trước khi kết hợp với chỉ số page table để tạo thành địa chỉ của PTE.</p>
<p>Để xem toàn bộ quá trình này có hợp lý không, chúng ta sẽ điền một số giá trị thực tế vào <strong>multi-level page table</strong> (bảng trang nhiều cấp) và dịch một địa chỉ ảo cụ thể. Hãy bắt đầu với <strong>page directory</strong> (thư mục trang) cho ví dụ này (bên trái <em>Figure 20.5</em>).</p>
<p><img src="20/img/fig20_5.PNG" alt="" />
<strong>Figure 20.5: A Page Directory, And Pieces Of Page Table</strong><br />
<em>(Một thư mục trang và các phần của bảng trang)</em></p>
<p>Trong hình, bạn có thể thấy mỗi PDE mô tả thông tin về một page của page table trong address space. Trong ví dụ này, chúng ta có hai vùng hợp lệ trong address space (ở đầu và cuối), và một số lượng lớn ánh xạ không hợp lệ ở giữa.</p>
<p>Trong <strong>physical page</strong> 100 (PFN của page 0 trong page table), chúng ta có page đầu tiên chứa 16 PTE cho 16 VPN đầu tiên trong address space. Xem phần giữa của <em>Figure 20.5</em> để biết nội dung của phần này trong page table.</p>
<p>Page này của page table chứa ánh xạ cho 16 VPN đầu tiên; trong ví dụ, VPN 0 và 1 là hợp lệ (code segment), cũng như VPN 4 và 5 (heap). Do đó, bảng có thông tin ánh xạ cho từng page này. Các entry còn lại được đánh dấu <strong>invalid</strong> (không hợp lệ).</p>
<p>Page hợp lệ còn lại của page table nằm trong PFN 101. Page này chứa ánh xạ cho 16 VPN cuối cùng của address space; xem phần bên phải của <em>Figure 20.5</em> để biết chi tiết.</p>
<p>Trong ví dụ, VPN 254 và 255 (stack) có ánh xạ hợp lệ. Hy vọng từ ví dụ này, chúng ta có thể thấy lượng bộ nhớ tiết kiệm được khi dùng cấu trúc đánh chỉ số nhiều cấp. Trong ví dụ này, thay vì cấp phát đủ 16 page cho một linear page table, chúng ta chỉ cấp phát 3 page: một cho page directory, và hai cho các phần của page table có ánh xạ hợp lệ. Với address space lớn (32-bit hoặc 64-bit), mức tiết kiệm sẽ còn lớn hơn nhiều.</p>
<blockquote>
<p><strong>TIP: BE WARY OF COMPLEXITY</strong><br />
(Cẩn trọng với độ phức tạp)<br />
Các nhà thiết kế hệ thống nên thận trọng khi thêm độ phức tạp vào hệ thống. Một kỹ sư hệ thống giỏi sẽ triển khai hệ thống ít phức tạp nhất nhưng vẫn hoàn thành nhiệm vụ. Ví dụ, nếu dung lượng đĩa dồi dào, bạn không nên thiết kế một hệ thống file cố gắng tiết kiệm từng byte; tương tự, nếu bộ xử lý nhanh, tốt hơn là viết một module trong OS rõ ràng, dễ hiểu thay vì tối ưu CPU đến mức cực đoan bằng mã hợp ngữ khó bảo trì. Hãy cảnh giác với sự phức tạp không cần thiết, trong mã tối ưu sớm hoặc các hình thức khác; những cách tiếp cận như vậy khiến hệ thống khó hiểu, khó bảo trì và khó gỡ lỗi. Như Antoine de Saint-Exupery từng viết: “Sự hoàn hảo đạt được không phải khi không còn gì để thêm vào, mà là khi không còn gì để bớt đi.” Điều ông không viết: “Nói về sự hoàn hảo thì dễ hơn nhiều so với việc đạt được nó.”</p>
</blockquote>
<p>Cuối cùng, hãy sử dụng thông tin này để thực hiện một phép dịch địa chỉ. Đây là một địa chỉ tham chiếu tới byte thứ 0 của VPN 254: <code>0x3F80</code>, hay ở dạng nhị phân là <code>11 1111 1000 0000</code>.</p>
<p>Nhớ rằng chúng ta sẽ dùng 4 bit cao nhất của VPN để đánh chỉ số vào page directory. Do đó, <code>1111</code> sẽ chọn entry cuối cùng (thứ 15, nếu bắt đầu từ 0) của page directory ở trên. Entry này trỏ tới một page hợp lệ của page table nằm tại địa chỉ PFN 101. Sau đó, chúng ta dùng 4 bit tiếp theo của VPN (<code>1110</code>) để đánh chỉ số vào page này của page table và tìm PTE mong muốn. <code>1110</code> là entry áp chót (thứ 14) trên page, và cho biết page 254 của address space được ánh xạ tới <strong>physical page</strong> 55. Bằng cách ghép PFN=55 (hex <code>0x37</code>) với offset=<code>000000</code>, chúng ta có thể tạo ra <strong>physical address</strong> mong muốn và gửi yêu cầu tới hệ thống bộ nhớ:</p>
<pre><code>PhysAddr = (PTE.PFN &lt;&lt; SHIFT) + offset 
         = 00 1101 1100 0000 
         = 0x0DC0
</code></pre>
<p>Bây giờ, bạn đã có ý tưởng về cách xây dựng một <strong>two-level page table</strong> (bảng trang hai cấp), sử dụng page directory trỏ tới các page của page table. Tuy nhiên, công việc của chúng ta chưa kết thúc. Như sẽ thảo luận ngay sau đây, đôi khi hai cấp page table là chưa đủ.</p>
<h3 id="more-than-two-levels"><a class="header" href="#more-than-two-levels">More Than Two Levels</a></h3>
<p>(Hơn hai cấp)</p>
<p>Trong ví dụ trên, chúng ta giả định multi-level page table chỉ có hai cấp: một page directory và các phần của page table. Trong một số trường hợp, một cây sâu hơn là khả thi (và thực sự cần thiết).</p>
<p>Hãy lấy một ví dụ đơn giản để thấy tại sao multi-level table sâu hơn lại hữu ích. Trong ví dụ này, giả sử chúng ta có <strong>virtual address space</strong> 30-bit, và <strong>page</strong> nhỏ (512 byte). Khi đó, virtual address có thành phần <strong>virtual page number</strong> (VPN) 21-bit và <strong>offset</strong> 9-bit.</p>
<p>Hãy nhớ mục tiêu khi xây dựng multi-level page table: làm cho mỗi phần của page table vừa trong một page. Cho đến giờ, chúng ta mới chỉ xét bản thân page table; nhưng nếu page directory trở nên quá lớn thì sao?</p>
<p>Để xác định cần bao nhiêu cấp trong multi-level table để tất cả các phần của page table vừa trong một page, ta bắt đầu bằng việc xác định số lượng PTE có thể chứa trong một page. Với kích thước page 512 byte và giả sử mỗi PTE là 4 byte, ta có thể chứa 128 PTE trên một page. Khi đánh chỉ số vào một page của page table, ta sẽ cần <strong>7 bit</strong> ít quan trọng nhất (log₂ 128) của VPN làm chỉ số:</p>
<p>Bây giờ, khi đánh chỉ số vào <strong>upper-level page directory</strong> (thư mục trang cấp cao), chúng ta sử dụng các bit cao nhất của <strong>virtual address</strong> (PD Index 0 trong sơ đồ); chỉ số này được dùng để lấy <strong>page-directory entry</strong> (PDE — mục thư mục trang) từ page directory cấp cao nhất. Nếu hợp lệ, cấp thứ hai của page directory sẽ được tra cứu bằng cách kết hợp <strong>physical frame number</strong> (PFN — số khung trang vật lý) từ PDE cấp cao nhất với phần tiếp theo của <strong>VPN</strong> (PD Index 1). Cuối cùng, nếu hợp lệ, địa chỉ của <strong>PTE</strong> (page-table entry — mục bảng trang) có thể được hình thành bằng cách sử dụng <strong>page-table index</strong> kết hợp với địa chỉ từ PDE cấp thứ hai. Ồ! Khá nhiều bước chỉ để tra cứu một mục trong <strong>multi-level table</strong> (bảng nhiều cấp).</p>
<h3 id="the-translation-process-remember-the-tlb"><a class="header" href="#the-translation-process-remember-the-tlb">The Translation Process: Remember the TLB</a></h3>
<p>(Quy trình dịch địa chỉ: Đừng quên TLB)</p>
<p>Để tóm tắt toàn bộ quá trình dịch địa chỉ sử dụng <strong>two-level page table</strong> (bảng trang hai cấp), chúng ta một lần nữa trình bày luồng điều khiển dưới dạng thuật toán (<em>Figure 20.6</em>). Hình này cho thấy điều gì xảy ra trong phần cứng (giả sử <strong>hardware-managed TLB</strong> — TLB do phần cứng quản lý) khi có mỗi lần tham chiếu bộ nhớ.</p>
<p><img src="20/img/fig20_6.PNG" alt="" />
<strong>Figure 20.6: Multi-level Page Table Control Flow</strong><br />
<em>(Luồng điều khiển bảng trang nhiều cấp)</em></p>
<p>Như bạn thấy trong hình, trước khi bất kỳ truy cập phức tạp nào tới multi-level page table diễn ra, phần cứng sẽ kiểm tra TLB trước; nếu <strong>hit</strong>, <strong>physical address</strong> (địa chỉ vật lý) sẽ được tạo trực tiếp mà không cần truy cập page table, giống như trước đây. Chỉ khi <strong>TLB miss</strong> xảy ra, phần cứng mới cần thực hiện toàn bộ quá trình tra cứu nhiều cấp. Trên đường này, bạn có thể thấy chi phí của two-level page table truyền thống: cần thêm hai lần truy cập bộ nhớ để tìm một bản dịch hợp lệ.</p>
<h2 id="204-inverted-page-tables"><a class="header" href="#204-inverted-page-tables">20.4 Inverted Page Tables</a></h2>
<p>(Bảng trang đảo)</p>
<p>Một cách tiết kiệm không gian cực đoan hơn trong thế giới page table là <strong>inverted page table</strong> (bảng trang đảo). Ở đây, thay vì có nhiều page table (một cho mỗi <strong>process</strong> trong hệ thống), chúng ta giữ một page table duy nhất, trong đó mỗi entry tương ứng với một <strong>physical page</strong> (trang vật lý) của hệ thống. Entry này cho biết process nào đang sử dụng page đó, và <strong>virtual page</strong> (trang ảo) nào của process đó được ánh xạ tới page vật lý này.</p>
<p>Việc tìm entry đúng bây giờ là vấn đề tìm kiếm trong cấu trúc dữ liệu này. Quét tuyến tính sẽ tốn kém, do đó thường xây dựng một <strong>hash table</strong> (bảng băm) trên cấu trúc cơ sở để tăng tốc tra cứu. <strong>PowerPC</strong> là một ví dụ về kiến trúc sử dụng cách này [JM98].</p>
<p>Nói chung hơn, inverted page table minh họa cho điều chúng ta đã nói từ đầu: page table chỉ là <strong>data structure</strong> (cấu trúc dữ liệu). Bạn có thể làm nhiều điều “điên rồ” với cấu trúc dữ liệu — làm chúng nhỏ hơn hoặc lớn hơn, chậm hơn hoặc nhanh hơn. Multi-level và inverted page table chỉ là hai ví dụ trong số rất nhiều cách có thể áp dụng.</p>
<h2 id="205-swapping-the-page-tables-to-disk"><a class="header" href="#205-swapping-the-page-tables-to-disk">20.5 Swapping the Page Tables to Disk</a></h2>
<p>(Đưa page table ra đĩa)</p>
<p>Cuối cùng, chúng ta bàn về việc nới lỏng một giả định cuối cùng. Cho đến nay, chúng ta giả định rằng page table nằm trong <strong>kernel-owned physical memory</strong> (bộ nhớ vật lý thuộc quyền quản lý của kernel). Ngay cả với nhiều thủ thuật để giảm kích thước page table, vẫn có khả năng chúng quá lớn để vừa trong bộ nhớ cùng lúc. Do đó, một số hệ thống đặt page table trong <strong>kernel virtual memory</strong> (bộ nhớ ảo của kernel), cho phép hệ thống <strong>swap</strong> (hoán đổi) một số page table này ra đĩa khi bộ nhớ bị áp lực. Chúng ta sẽ nói kỹ hơn về điều này trong một chương sau (cụ thể là nghiên cứu tình huống về <strong>VAX/VMS</strong>), khi đã hiểu rõ hơn cách di chuyển các page vào và ra khỏi bộ nhớ.</p>
<h2 id="206-summary"><a class="header" href="#206-summary">20.6 Summary</a></h2>
<p>(Tóm tắt)</p>
<p>Chúng ta đã thấy cách các page table thực tế được xây dựng; không nhất thiết chỉ là mảng tuyến tính mà có thể là các <strong>data structure</strong> phức tạp hơn. Sự đánh đổi (trade-off) mà các bảng này đưa ra là giữa <strong>time</strong> (thời gian) và <strong>space</strong> (không gian) — bảng càng lớn, thời gian xử lý một <strong>TLB miss</strong> càng nhanh, và ngược lại — do đó, lựa chọn cấu trúc phù hợp phụ thuộc mạnh mẽ vào các ràng buộc của môi trường cụ thể.</p>
<p>Trong một hệ thống bị giới hạn bộ nhớ (như nhiều hệ thống cũ), các cấu trúc nhỏ là hợp lý; trong một hệ thống có lượng bộ nhớ hợp lý và với <strong>workload</strong> (khối lượng công việc) sử dụng tích cực nhiều page, một bảng lớn hơn để tăng tốc xử lý TLB miss có thể là lựa chọn đúng. Với <strong>software-managed TLBs</strong> (TLB do phần mềm quản lý), toàn bộ không gian thiết kế cấu trúc dữ liệu được mở ra cho các nhà sáng tạo hệ điều hành (ám chỉ: chính bạn). Bạn có thể nghĩ ra những cấu trúc mới nào? Chúng giải quyết vấn đề gì? Hãy suy nghĩ về những câu hỏi này khi bạn đi ngủ, và mơ những giấc mơ lớn mà chỉ các nhà phát triển hệ điều hành mới có thể mơ.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-beyond-physical-memory-mechanisms"><a class="header" href="#21-beyond-physical-memory-mechanisms">21 Beyond Physical Memory: Mechanisms</a></h1>
<p>(Vượt ra ngoài bộ nhớ vật lý: Các cơ chế)</p>
<p>Cho đến nay, chúng ta đã giả định rằng <strong>address space</strong> (không gian địa chỉ) là rất nhỏ và vừa khít trong <strong>physical memory</strong> (bộ nhớ vật lý). Thực tế, chúng ta còn giả định rằng mọi address space của mọi <strong>process</strong> (tiến trình) đang chạy đều vừa trong bộ nhớ. Bây giờ, chúng ta sẽ nới lỏng các giả định lớn này và giả định rằng ta muốn hỗ trợ nhiều address space lớn chạy đồng thời. Để làm được điều đó, chúng ta cần một tầng bổ sung trong <strong>memory hierarchy</strong> (hệ phân cấp bộ nhớ).</p>
<p>Cho đến giờ, chúng ta giả định rằng tất cả các <strong>page</strong> (trang) đều nằm trong physical memory. Tuy nhiên, để hỗ trợ address space lớn, <strong>OS</strong> (hệ điều hành) sẽ cần một nơi để “cất giữ” các phần của address space hiện không được sử dụng nhiều. Nói chung, đặc điểm của vị trí này là nó phải có dung lượng lớn hơn bộ nhớ; do đó, nó thường chậm hơn (nếu nhanh hơn, chúng ta đã dùng nó làm bộ nhớ rồi, đúng không?). Trong các hệ thống hiện đại, vai trò này thường do <strong>hard disk drive</strong> (ổ đĩa cứng) đảm nhiệm. Vì vậy, trong memory hierarchy, các ổ cứng lớn và chậm nằm ở đáy, với bộ nhớ ở ngay phía trên. Và đây chính là vấn đề mấu chốt:</p>
<blockquote>
<p><strong>THE CRUX: HOW TO GO BEYOND PHYSICAL MEMORY</strong><br />
(Làm thế nào để vượt ra ngoài giới hạn bộ nhớ vật lý)<br />
Làm thế nào để OS sử dụng một thiết bị lớn hơn, chậm hơn để cung cấp một cách trong suốt ảo tưởng về một <strong>virtual address space</strong> (không gian địa chỉ ảo) lớn?</p>
</blockquote>
<p>Một câu hỏi bạn có thể đặt ra: tại sao chúng ta muốn hỗ trợ một address space lớn cho một process? Câu trả lời, một lần nữa, là vì <strong>tính tiện lợi và dễ sử dụng</strong>. Với một address space lớn, bạn không cần lo lắng liệu có đủ chỗ trong bộ nhớ cho các <strong>data structure</strong> (cấu trúc dữ liệu) của chương trình hay không; thay vào đó, bạn chỉ cần viết chương trình một cách tự nhiên, cấp phát bộ nhớ khi cần. Đây là một ảo tưởng mạnh mẽ mà OS cung cấp, giúp cuộc sống của bạn đơn giản hơn rất nhiều.</p>
<p>Ngược lại, trong các hệ thống cũ sử dụng <strong>memory overlays</strong> (lớp phủ bộ nhớ), lập trình viên phải tự di chuyển các phần code hoặc dữ liệu vào và ra khỏi bộ nhớ khi cần [D97]. Hãy thử tưởng tượng: trước khi gọi một hàm hoặc truy cập dữ liệu, bạn phải đảm bảo code hoặc dữ liệu đó đã nằm trong bộ nhớ; thật phiền phức!</p>
<blockquote>
<p><strong>ASIDE: STORAGE TECHNOLOGIES</strong><br />
(Công nghệ lưu trữ)<br />
Chúng ta sẽ tìm hiểu sâu hơn về cách các <strong>I/O device</strong> (thiết bị vào/ra) hoạt động ở phần sau (xem chương về I/O devices). Hãy kiên nhẫn! Và tất nhiên, thiết bị chậm hơn không nhất thiết phải là ổ cứng, mà có thể là thiết bị hiện đại hơn như <strong>Flash-based SSD</strong> (ổ SSD dùng bộ nhớ flash). Chúng ta cũng sẽ bàn về những thứ đó. Hiện tại, hãy giả định rằng chúng ta có một thiết bị lớn và tương đối chậm, có thể dùng để giúp xây dựng ảo tưởng về một <strong>virtual memory</strong> (bộ nhớ ảo) rất lớn, thậm chí lớn hơn cả physical memory.</p>
</blockquote>
<p>Không chỉ cho một process, việc bổ sung <strong>swap space</strong> (không gian hoán đổi) cho phép OS hỗ trợ ảo tưởng về một virtual memory lớn cho nhiều process chạy đồng thời. Sự ra đời của <strong>multiprogramming</strong> (đa chương trình — chạy nhiều chương trình “cùng lúc” để tận dụng tốt hơn máy tính) gần như đòi hỏi khả năng hoán đổi một số page ra ngoài, vì các máy tính đời đầu rõ ràng không thể chứa tất cả page cần thiết cho mọi process cùng lúc. Do đó, sự kết hợp giữa multiprogramming và tính tiện lợi dẫn đến nhu cầu hỗ trợ sử dụng nhiều bộ nhớ hơn mức vật lý sẵn có. Đây là điều mà tất cả các hệ thống <strong>VM</strong> (virtual memory) hiện đại đều làm; và giờ chúng ta sẽ tìm hiểu kỹ hơn.</p>
<h2 id="211-swap-space"><a class="header" href="#211-swap-space">21.1 Swap Space</a></h2>
<p>(Không gian hoán đổi)</p>
<p>Điều đầu tiên chúng ta cần làm là <strong>dành một phần dung lượng trên đĩa</strong> để di chuyển các page ra vào. Trong OS, chúng ta thường gọi vùng này là <strong>swap space</strong>, vì ta <strong>swap</strong> (hoán đổi) các page từ bộ nhớ ra đó và từ đó vào bộ nhớ. Do đó, ta sẽ giả định rằng OS có thể đọc và ghi vào swap space theo đơn vị kích thước page.</p>
<p>Để làm được điều này, OS cần ghi nhớ <strong>địa chỉ trên đĩa</strong> của một page nhất định. Kích thước của swap space rất quan trọng, vì nó quyết định số lượng tối đa các page bộ nhớ có thể được hệ thống sử dụng tại một thời điểm. Để đơn giản, tạm giả định rằng nó rất lớn.</p>
<p><img src="21/img/fig21_1.PNG" alt="" />
<strong>Figure 21.1: Physical Memory and Swap Space</strong><br />
<em>(Bộ nhớ vật lý và không gian hoán đổi)</em></p>
<p>Trong ví dụ nhỏ (<em>Figure 21.1</em>), bạn có thể thấy một ví dụ với <strong>physical memory</strong> 4 page và <strong>swap space</strong> 8 page. Trong ví dụ, ba process (Proc 0, Proc 1, Proc 2) đang chia sẻ physical memory; mỗi process chỉ có một số page hợp lệ trong bộ nhớ, phần còn lại nằm trong swap space trên đĩa. Một process thứ tư (Proc 3) có toàn bộ page bị hoán đổi ra đĩa, và rõ ràng không chạy tại thời điểm này. Một khối swap vẫn còn trống. Ngay cả từ ví dụ nhỏ này, hy vọng bạn có thể thấy việc sử dụng swap space cho phép hệ thống “giả vờ” rằng bộ nhớ lớn hơn thực tế.</p>
<p>Cần lưu ý rằng swap space không phải là vị trí duy nhất trên đĩa cho lưu lượng hoán đổi. Ví dụ, giả sử bạn đang chạy một <strong>program binary</strong> (tệp thực thi chương trình) như <code>ls</code> hoặc chương trình <code>main</code> do bạn biên dịch. Các <strong>code page</strong> (trang mã) từ binary này ban đầu nằm trên đĩa, và khi chương trình chạy, chúng được nạp vào bộ nhớ (hoặc tất cả cùng lúc khi chương trình bắt đầu, hoặc — như trong các hệ thống hiện đại — từng page một khi cần). Tuy nhiên, nếu hệ thống cần giải phóng bộ nhớ vật lý cho mục đích khác, nó có thể tái sử dụng không gian bộ nhớ của các code page này, vì biết rằng có thể nạp lại chúng từ binary trên đĩa trong <strong>file system</strong> (hệ thống tệp).</p>
<h2 id="212-the-present-bit"><a class="header" href="#212-the-present-bit">21.2 The Present Bit</a></h2>
<p>(Bit hiện diện)</p>
<p>Bây giờ, khi đã có không gian trên đĩa, chúng ta cần bổ sung một số cơ chế ở tầng cao hơn trong hệ thống để hỗ trợ việc hoán đổi page ra/vào đĩa. Giả sử, để đơn giản, rằng chúng ta có một hệ thống với <strong>hardware-managed TLB</strong> (TLB do phần cứng quản lý).</p>
<p>Hãy nhớ lại điều gì xảy ra khi có một <strong>memory reference</strong> (tham chiếu bộ nhớ). Process đang chạy tạo ra các tham chiếu tới virtual memory (cho việc nạp lệnh hoặc truy cập dữ liệu), và trong trường hợp này, phần cứng dịch chúng sang <strong>physical address</strong> (địa chỉ vật lý) trước khi lấy dữ liệu mong muốn từ bộ nhớ.</p>
<p>Nhớ rằng phần cứng trước tiên trích xuất <strong>VPN</strong> (virtual page number — số trang ảo) từ virtual address, kiểm tra TLB để tìm khớp (<strong>TLB hit</strong>), và nếu hit, tạo ra physical address tương ứng và lấy dữ liệu từ bộ nhớ. Đây là trường hợp phổ biến và nhanh (không cần thêm truy cập bộ nhớ).</p>
<p>Nếu VPN không có trong TLB (<strong>TLB miss</strong>), phần cứng sẽ tìm <strong>page table</strong> (bảng trang) trong bộ nhớ (sử dụng <strong>page table base register</strong>) và tra cứu <strong>PTE</strong> (page-table entry) cho page này bằng VPN làm chỉ số. Nếu page hợp lệ và có mặt trong physical memory, phần cứng trích xuất PFN từ PTE, nạp nó vào TLB, và thực thi lại lệnh, lần này tạo ra TLB hit; mọi thứ vẫn ổn.</p>
<p>Nếu chúng ta muốn cho phép các <strong>page</strong> được <strong>swapped</strong> ra <strong>disk</strong>, thì cần bổ sung thêm nhiều cơ chế hỗ trợ. Cụ thể, khi phần cứng truy cập vào <strong>PTE</strong> (page-table entry – mục nhập bảng trang), nó có thể phát hiện rằng page đó <strong>không hiện diện</strong> trong <strong>physical memory</strong> (bộ nhớ vật lý). Cách mà phần cứng (hoặc <strong>OS</strong>, trong trường hợp <strong>software-managed TLB</strong> – TLB do phần mềm quản lý) xác định điều này là thông qua một thông tin mới trong mỗi PTE, gọi là <strong>present bit</strong> (bit hiện diện).</p>
<ul>
<li>Nếu <strong>present bit</strong> được đặt bằng 1, điều đó có nghĩa là page đang hiện diện trong physical memory và mọi thao tác tiếp tục diễn ra như bình thường.</li>
<li>Nếu <strong>present bit</strong> được đặt bằng 0, page không nằm trong bộ nhớ mà đang được lưu trữ ở đâu đó trên disk.</li>
</ul>
<p><em>(Giải thích thêm: present bit là một cờ (flag) quan trọng giúp phân biệt giữa page đang ở trong RAM và page đã bị hoán đổi ra bộ nhớ phụ, từ đó OS có thể quyết định hành động tiếp theo như nạp lại page từ disk.)</em></p>
<blockquote>
<p><strong>ASIDE: SWAPPING TERMINOLOGY AND OTHER THINGS</strong><br />
(Thuật ngữ hoán đổi và một số vấn đề khác)<br />
Thuật ngữ trong các hệ thống <strong>virtual memory</strong> (bộ nhớ ảo) có thể hơi gây nhầm lẫn và thay đổi tùy theo máy và hệ điều hành. Ví dụ, <strong>page fault</strong> (lỗi trang) nói chung có thể chỉ bất kỳ tham chiếu nào tới <strong>page table</strong> (bảng trang) dẫn đến một loại lỗi nào đó: điều này có thể bao gồm loại lỗi mà chúng ta đang thảo luận ở đây, tức là <strong>page-not-present fault</strong> (lỗi trang không hiện diện), nhưng đôi khi cũng có thể chỉ các truy cập bộ nhớ bất hợp pháp. Thực tế, thật kỳ lạ khi chúng ta gọi một truy cập hoàn toàn hợp lệ (tới một page đã được ánh xạ vào virtual address space của một <strong>process</strong> (tiến trình), nhưng tại thời điểm đó không nằm trong physical memory) là một “fault” (lỗi); thực ra, nó nên được gọi là <strong>page miss</strong> (trượt trang). Nhưng thường thì, khi mọi người nói một chương trình đang “page faulting”, họ muốn nói rằng nó đang truy cập các phần của virtual address space mà OS đã hoán đổi ra đĩa.</p>
<p>Chúng tôi cho rằng lý do hành vi này được gọi là “fault” liên quan đến cơ chế trong OS để xử lý nó. Khi có điều gì bất thường xảy ra, tức là khi phần cứng gặp một tình huống mà nó không biết cách xử lý, phần cứng sẽ đơn giản chuyển quyền điều khiển cho OS, hy vọng OS có thể xử lý tốt hơn. Trong trường hợp này, một page mà process muốn truy cập bị thiếu trong bộ nhớ; phần cứng chỉ có thể làm một việc duy nhất là phát sinh <strong>exception</strong> (ngoại lệ), và OS tiếp quản từ đó. Vì điều này giống hệt với những gì xảy ra khi một process làm điều gì đó bất hợp pháp, nên không có gì ngạc nhiên khi chúng ta gọi hoạt động này là một “fault”.</p>
</blockquote>
<p>Hành động truy cập một page không nằm trong physical memory thường được gọi là <strong>page fault</strong>. Khi xảy ra page fault, OS sẽ được gọi để xử lý. Một đoạn code cụ thể, gọi là <strong>page-fault handler</strong> (trình xử lý lỗi trang), sẽ chạy và phải xử lý page fault, như chúng ta sẽ mô tả dưới đây.</p>
<h2 id="213-the-page-fault"><a class="header" href="#213-the-page-fault">21.3 The Page Fault</a></h2>
<p>(Lỗi trang)</p>
<p>Hãy nhớ rằng với <strong>TLB miss</strong> (trượt TLB), chúng ta có hai loại hệ thống: <strong>hardware-managed TLB</strong> (TLB do phần cứng quản lý — phần cứng tra cứu page table để tìm bản dịch mong muốn) và <strong>software-managed TLB</strong> (TLB do phần mềm quản lý — OS thực hiện). Trong cả hai loại hệ thống, nếu một page không hiện diện, OS sẽ chịu trách nhiệm xử lý page fault. <strong>Page-fault handler</strong> của OS sẽ chạy để xác định cần làm gì. Hầu như tất cả các hệ thống đều xử lý page fault bằng phần mềm; ngay cả với hardware-managed TLB, phần cứng cũng tin tưởng OS để quản lý nhiệm vụ quan trọng này.</p>
<p>Nếu một page không hiện diện và đã bị hoán đổi ra đĩa, OS sẽ cần hoán đổi page đó vào bộ nhớ để xử lý page fault. Do đó, câu hỏi đặt ra: làm thế nào OS biết được vị trí của page cần tìm? Trong nhiều hệ thống, page table là nơi tự nhiên để lưu trữ thông tin này.</p>
<blockquote>
<p><strong>ASIDE: WHY HARDWARE DOESN’T HANDLE PAGE FAULTS</strong><br />
(Tại sao phần cứng không xử lý page fault)<br />
Từ kinh nghiệm với TLB, chúng ta biết rằng các nhà thiết kế phần cứng thường không muốn tin tưởng OS làm nhiều việc. Vậy tại sao họ lại tin tưởng OS xử lý page fault? Có một vài lý do chính. Thứ nhất, page fault tới đĩa là chậm; ngay cả khi OS mất nhiều thời gian để xử lý lỗi, thực thi hàng loạt lệnh, thì bản thân thao tác đĩa vốn đã chậm đến mức chi phí bổ sung của phần mềm là không đáng kể. Thứ hai, để có thể xử lý page fault, phần cứng sẽ phải hiểu về swap space, cách phát lệnh I/O tới đĩa, và nhiều chi tiết khác mà hiện tại nó không biết nhiều. Vì vậy, vì cả lý do hiệu năng và đơn giản, OS xử lý page fault, và ngay cả các kỹ sư phần cứng cũng hài lòng với điều đó.</p>
</blockquote>
<p>Do đó, OS có thể sử dụng các bit trong PTE vốn thường dùng cho dữ liệu như PFN của page để lưu địa chỉ trên đĩa. Khi OS nhận được page fault cho một page, nó sẽ tra cứu PTE để tìm địa chỉ, và phát lệnh tới đĩa để nạp page vào bộ nhớ.</p>
<p>Khi I/O đĩa hoàn tất, OS sẽ cập nhật page table để đánh dấu page là <strong>present</strong> (hiện diện), cập nhật trường PFN của PTE để ghi lại vị trí trong bộ nhớ của page vừa được nạp, và thực thi lại lệnh. Lần thử tiếp theo có thể tạo ra một TLB miss, khi đó sẽ được xử lý và cập nhật TLB với bản dịch (hoặc có thể cập nhật TLB ngay khi xử lý page fault để bỏ qua bước này). Cuối cùng, lần thực thi lại cuối cùng sẽ tìm thấy bản dịch trong TLB và tiếp tục lấy dữ liệu hoặc lệnh mong muốn từ bộ nhớ tại địa chỉ vật lý đã dịch.</p>
<p>Lưu ý rằng trong khi I/O đang diễn ra, process sẽ ở trạng thái <strong>blocked</strong> (bị chặn). Do đó, OS có thể chạy các process sẵn sàng khác trong khi page fault đang được xử lý. Vì I/O tốn kém, việc chồng lấp giữa I/O (page fault) của một process và việc thực thi của process khác là một cách nữa để hệ thống <strong>multiprogramming</strong> (đa chương trình) tận dụng hiệu quả phần cứng.</p>
<h2 id="214-what-if-memory-is-full"><a class="header" href="#214-what-if-memory-is-full">21.4 What If Memory Is Full?</a></h2>
<p>(Điều gì xảy ra nếu bộ nhớ đầy?)</p>
<p>Trong quy trình mô tả ở trên, bạn có thể nhận thấy rằng chúng ta giả định có nhiều bộ nhớ trống để nạp một page từ swap space. Tất nhiên, điều này có thể không đúng; bộ nhớ có thể đã đầy (hoặc gần đầy). Do đó, OS có thể muốn trước tiên <strong>page out</strong> (đưa ra ngoài) một hoặc nhiều page để tạo chỗ cho page mới sắp được nạp vào. Quá trình chọn một page để loại bỏ hoặc thay thế được gọi là <strong>page-replacement policy</strong> (chính sách thay thế trang).</p>
<p>Thực tế, đã có rất nhiều nghiên cứu để tạo ra một page-replacement policy tốt, vì loại bỏ nhầm page có thể gây tổn thất lớn cho hiệu năng chương trình. Quyết định sai có thể khiến chương trình chạy với tốc độ như đĩa thay vì tốc độ bộ nhớ; với công nghệ hiện tại, điều đó có nghĩa là chương trình có thể chạy chậm hơn 10.000 hoặc 100.000 lần. Do đó, chính sách này là thứ chúng ta nên nghiên cứu chi tiết; và đó chính xác là những gì chúng ta sẽ làm ở chương tiếp theo. Hiện tại, chỉ cần hiểu rằng chính sách này tồn tại, được xây dựng dựa trên các cơ chế đã mô tả ở đây.</p>
<h2 id="215-page-fault-control-flow"><a class="header" href="#215-page-fault-control-flow">21.5 Page Fault Control Flow</a></h2>
<p>(Luồng điều khiển khi xảy ra lỗi trang)</p>
<p>Với tất cả kiến thức này, chúng ta có thể phác thảo sơ bộ luồng điều khiển hoàn chỉnh của việc truy cập bộ nhớ. Nói cách khác, khi ai đó hỏi bạn “chuyện gì xảy ra khi một chương trình lấy dữ liệu từ bộ nhớ?”, bạn nên có ý tưởng khá rõ về tất cả các khả năng khác nhau. Xem luồng điều khiển trong <em>Figure 21.2</em> và <em>Figure 21.3</em> để biết chi tiết; hình đầu tiên cho thấy phần cứng làm gì trong quá trình dịch địa chỉ, và hình thứ hai cho thấy OS làm gì khi xảy ra page fault.</p>
<p><img src="21/img/fig21_2.PNG" alt="" />
<strong>Figure 21.2: Page-Fault Control Flow Algorithm (Hardware)</strong><br />
<em>(Thuật toán luồng điều khiển lỗi trang — phần cứng)</em></p>
<p><img src="21/img/fig21_3.PNG" alt="" />
<strong>Figure 21.3: Page-Fault Control Flow Algorithm (Software)</strong><br />
<em>(Thuật toán luồng điều khiển lỗi trang — phần mềm)</em></p>
<p>Từ sơ đồ <strong>hardware control flow</strong> trong <em>Figure 21.2</em>, có thể thấy rằng hiện có ba trường hợp quan trọng cần hiểu khi xảy ra <strong>TLB miss</strong>.</p>
<p>Thứ nhất, page vừa <strong>present</strong> vừa <strong>valid</strong> (Lines 18–21); trong trường hợp này, <strong>TLB miss handler</strong> chỉ cần lấy <strong>PFN</strong> từ <strong>PTE</strong>, thực hiện lại lệnh (lần này sẽ dẫn đến <strong>TLB hit</strong>) và tiếp tục như đã mô tả nhiều lần trước đó.</p>
<p>Thứ hai (Lines 22–23), <strong>page fault handler</strong> phải được kích hoạt; mặc dù đây là một page hợp lệ để process truy cập (nó <strong>valid</strong>), nhưng nó không <strong>present</strong> trong <strong>physical memory</strong>.</p>
<p>Thứ ba (và cuối cùng), truy cập có thể hướng tới một page <strong>invalid</strong>, ví dụ do lỗi trong chương trình (Lines 13–14). Trong trường hợp này, các bit khác trong PTE không còn ý nghĩa; phần cứng sẽ <strong>trap</strong> truy cập không hợp lệ này, và <strong>OS trap handler</strong> sẽ chạy, nhiều khả năng sẽ chấm dứt process vi phạm.</p>
<p>Từ sơ đồ <strong>software control flow</strong> trong <em>Figure 21.3</em>, có thể thấy OS cần thực hiện những bước cơ bản nào để xử lý <strong>page fault</strong>. Trước tiên, OS phải tìm một <strong>physical frame</strong> để chứa page sắp được nạp vào; nếu không có frame trống, cần chờ <strong>replacement algorithm</strong> chạy và loại bỏ một số page khỏi bộ nhớ, giải phóng chúng để sử dụng. Khi đã có physical frame, <strong>handler</strong> sẽ gửi yêu cầu <strong>I/O</strong> để đọc page từ <strong>swap space</strong>. Cuối cùng, khi thao tác chậm này hoàn tất, OS sẽ cập nhật <strong>page table</strong> và thực hiện lại lệnh. Lần thực hiện lại này sẽ dẫn đến một <strong>TLB miss</strong>, và sau đó, khi thực hiện lại thêm lần nữa, sẽ là <strong>TLB hit</strong>, lúc này phần cứng có thể truy cập dữ liệu mong muốn.</p>
<h2 id="216-when-replacements-really-occur"><a class="header" href="#216-when-replacements-really-occur">21.6 When Replacements Really Occur</a></h2>
<p>Cho đến nay, cách chúng ta mô tả việc <strong>replacement</strong> xảy ra giả định rằng OS sẽ chờ cho đến khi bộ nhớ đầy hoàn toàn, và chỉ khi đó mới <strong>replace</strong> (hoặc <strong>evict</strong>) một page để tạo chỗ cho page khác. Tuy nhiên, như bạn có thể hình dung, điều này hơi thiếu thực tế, và có nhiều lý do để OS chủ động giữ một phần nhỏ bộ nhớ trống sẵn sàng.</p>
<p>Để giữ một lượng nhỏ bộ nhớ trống, hầu hết các <strong>operating system</strong> (hệ điều hành) đều có một cơ chế <strong>high watermark</strong> (HW — ngưỡng cao) và <strong>low watermark</strong> (LW — ngưỡng thấp) để quyết định khi nào bắt đầu <strong>evicting pages</strong> (loại bỏ các trang) khỏi bộ nhớ. Cách hoạt động như sau: khi OS phát hiện số lượng page trống ít hơn LW, một <strong>background thread</strong> (luồng nền) chịu trách nhiệm giải phóng bộ nhớ sẽ chạy. Luồng này sẽ loại bỏ các page cho đến khi số lượng page trống đạt HW. Background thread này, đôi khi được gọi là <strong>swap daemon</strong> hoặc <strong>page daemon</strong><sup class="footnote-reference"><a href="#1">1</a></sup>, sau đó sẽ chuyển sang trạng thái ngủ, hài lòng vì đã giải phóng được một lượng bộ nhớ để các process đang chạy và OS có thể sử dụng.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Từ “daemon”, thường được phát âm là “demon”, là một thuật ngữ cũ chỉ một background thread hoặc process thực hiện một công việc hữu ích. Nguồn gốc của thuật ngữ này (một lần nữa!) xuất phát từ hệ thống <strong>Multics</strong> [CS94].</p>
</div>
<blockquote>
<p><strong>TIP: DO WORK IN THE BACKGROUND</strong><br />
(Thực hiện công việc ở chế độ nền)<br />
Khi bạn có một số công việc cần làm, thường là một ý tưởng hay nếu thực hiện chúng ở chế độ nền để tăng hiệu quả và cho phép gom nhóm các thao tác. OS thường thực hiện công việc ở chế độ nền; ví dụ, nhiều hệ thống <strong>buffer</strong> (đệm) các thao tác ghi file trong bộ nhớ trước khi thực sự ghi dữ liệu ra đĩa. Cách làm này có nhiều lợi ích tiềm năng: tăng hiệu quả của đĩa, vì đĩa có thể nhận nhiều yêu cầu ghi cùng lúc và do đó lập lịch tốt hơn; cải thiện độ trễ ghi, vì ứng dụng nghĩ rằng thao tác ghi đã hoàn tất rất nhanh; khả năng giảm khối lượng công việc, vì có thể các thao tác ghi này sẽ không bao giờ cần ghi ra đĩa (ví dụ: nếu file bị xóa); và tận dụng tốt hơn thời gian nhàn rỗi, vì công việc nền có thể được thực hiện khi hệ thống đang rảnh, từ đó khai thác phần cứng hiệu quả hơn [G+95].</p>
</blockquote>
<p>Bằng cách thực hiện nhiều thao tác thay thế (replacement) cùng lúc, các tối ưu hiệu năng mới trở nên khả thi. Ví dụ, nhiều hệ thống sẽ <strong>cluster</strong> hoặc nhóm một số page và ghi chúng ra <strong>swap partition</strong> (phân vùng hoán đổi) cùng lúc, từ đó tăng hiệu quả của đĩa [LL82]; như chúng ta sẽ thấy sau khi bàn chi tiết về đĩa, việc clustering như vậy giúp giảm <strong>seek</strong> và <strong>rotational overheads</strong> (chi phí tìm kiếm và quay) của đĩa, từ đó cải thiện hiệu năng đáng kể.</p>
<p>Để phối hợp với background paging thread, luồng điều khiển trong <em>Figure 21.3</em> nên được điều chỉnh một chút; thay vì thực hiện replacement trực tiếp, thuật toán sẽ chỉ cần kiểm tra xem có page trống nào không. Nếu không, nó sẽ thông báo cho background paging thread rằng cần có page trống; khi luồng này giải phóng được một số page, nó sẽ đánh thức lại luồng ban đầu, luồng này sau đó có thể <strong>page in</strong> (nạp vào) page mong muốn và tiếp tục công việc.</p>
<h2 id="217-summary"><a class="header" href="#217-summary">21.7 Summary</a></h2>
<p>(Tóm tắt)</p>
<p>Trong chương ngắn này, chúng ta đã giới thiệu khái niệm truy cập nhiều bộ nhớ hơn mức hiện diện vật lý trong hệ thống. Để làm được điều đó đòi hỏi cấu trúc page table phức tạp hơn, vì cần có một <strong>present bit</strong> (bit hiện diện) để cho biết page có đang ở trong bộ nhớ hay không. Khi page không hiện diện, <strong>page-fault handler</strong> (trình xử lý lỗi trang) của OS sẽ chạy để xử lý page fault, và sắp xếp việc chuyển page mong muốn từ đĩa vào bộ nhớ, có thể trước tiên phải thay thế một số page trong bộ nhớ để tạo chỗ cho các page sắp được nạp vào.</p>
<p>Điều quan trọng (và thật đáng kinh ngạc!) cần nhớ là tất cả các hành động này diễn ra <strong>một cách trong suốt</strong> đối với process. Đối với process, nó chỉ đang truy cập vào virtual memory riêng, liên tục của mình. Ở phía sau, các page được đặt ở những vị trí tùy ý (không liên tục) trong physical memory, và đôi khi chúng thậm chí không có trong bộ nhớ, buộc phải nạp từ đĩa. Mặc dù chúng ta hy vọng rằng trong trường hợp phổ biến, truy cập bộ nhớ sẽ nhanh, nhưng trong một số trường hợp, sẽ cần nhiều thao tác đĩa để xử lý; một việc đơn giản như thực hiện một lệnh đơn có thể, trong trường hợp xấu nhất, mất nhiều mili-giây để hoàn tất.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-vượt-ra-ngoài-physical-memory-các-chính-sách"><a class="header" href="#22-vượt-ra-ngoài-physical-memory-các-chính-sách">22. Vượt ra ngoài Physical Memory: Các chính sách</a></h1>
<p>Trong một <strong>virtual memory manager</strong> (bộ quản lý bộ nhớ ảo), mọi thứ trở nên đơn giản khi hệ thống có nhiều bộ nhớ trống. Khi xảy ra <strong>page fault</strong> (lỗi trang), hệ điều hành tìm một <strong>free page</strong> (trang trống) trong danh sách các trang trống và gán nó cho trang gây lỗi. Chúc mừng nhé, <strong>Operating System</strong> (hệ điều hành), bạn lại xử lý thành công rồi.</p>
<p>Tuy nhiên, mọi thứ trở nên thú vị hơn khi bộ nhớ trống còn rất ít. Trong trường hợp này, áp lực bộ nhớ (<strong>memory pressure</strong>) buộc <strong>OS</strong> phải bắt đầu <strong>paging out</strong> (ghi ra đĩa) một số trang để giải phóng chỗ cho các trang đang được sử dụng tích cực. Việc quyết định trang nào (hoặc các trang nào) sẽ bị loại bỏ (<strong>evict</strong>) được gói gọn trong <strong>replacement policy</strong> (chính sách thay thế) của OS; về mặt lịch sử, đây là một trong những quyết định quan trọng nhất mà các hệ thống virtual memory đời đầu phải đưa ra, vì các hệ thống cũ thường có rất ít <strong>physical memory</strong> (bộ nhớ vật lý). Ít nhất, đây là một tập hợp các chính sách thú vị mà chúng ta nên tìm hiểu kỹ hơn. Và do đó, vấn đề đặt ra là:</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ QUYẾT ĐỊNH TRANG NÀO SẼ BỊ LOẠI BỎ</strong></p>
<p>Làm thế nào để OS quyết định trang nào (hoặc các trang nào) sẽ bị loại khỏi bộ nhớ? Quyết định này được thực hiện bởi <strong>replacement policy</strong> của hệ thống, thường tuân theo một số nguyên tắc chung (sẽ được thảo luận bên dưới) nhưng cũng bao gồm một số tinh chỉnh để tránh các hành vi bất thường trong các trường hợp đặc biệt (<strong>corner-case behaviors</strong>).</p>
</blockquote>
<h2 id="221-quản-lý-cache"><a class="header" href="#221-quản-lý-cache">22.1 Quản lý Cache</a></h2>
<p>Trước khi đi sâu vào các chính sách, chúng ta cần mô tả chi tiết hơn vấn đề cần giải quyết. Vì <strong>main memory</strong> (bộ nhớ chính) chỉ chứa một tập con của tất cả các trang trong hệ thống, nên có thể coi nó như một <strong>cache</strong> cho các trang của virtual memory. Do đó, mục tiêu của chúng ta khi chọn một <strong>replacement policy</strong> cho cache này là <strong>giảm thiểu số lượng cache miss</strong>, tức là giảm số lần phải nạp một trang từ đĩa. Ngược lại, cũng có thể coi mục tiêu là <strong>tối đa hóa số lượng cache hit</strong>, tức là số lần một trang được truy cập và tìm thấy ngay trong bộ nhớ.</p>
<p>Biết được số lượng <strong>cache hit</strong> và <strong>cache miss</strong> cho phép chúng ta tính <strong>average memory access time (AMAT)</strong> — thời gian truy cập bộ nhớ trung bình — cho một chương trình (một chỉ số mà các kiến trúc sư máy tính thường tính cho <strong>hardware cache</strong> [HP06]). Cụ thể, với các giá trị này, ta có thể tính AMAT của một chương trình như sau:</p>
<p>$$ \text{AMAT} = T_M + (P_{Miss} \cdot T_D) $$</p>
<p>(22.1)</p>
<p>Trong đó:</p>
<ul>
<li>$T_M$ là chi phí truy cập bộ nhớ</li>
<li>$T_D$ là chi phí truy cập đĩa</li>
<li>$P_{Miss}$ là xác suất không tìm thấy dữ liệu trong cache (<strong>miss</strong>).</li>
</ul>
<p>Giá trị $P_{Miss}$ nằm trong khoảng từ 0.0 đến 1.0, và đôi khi chúng ta dùng tỷ lệ phần trăm miss thay vì xác suất (ví dụ: tỷ lệ miss 10% nghĩa là $P_{Miss} = 0.10$). Lưu ý rằng bạn <strong>luôn</strong> phải trả chi phí truy cập dữ liệu trong bộ nhớ; tuy nhiên, khi bị miss, bạn phải trả thêm chi phí nạp dữ liệu từ đĩa.</p>
<p><strong>Ví dụ:</strong><br />
Giả sử chúng ta có một máy với <strong>address space</strong> (không gian địa chỉ) rất nhỏ: 4KB, với kích thước trang (<strong>page size</strong>) là 256 byte. Khi đó, một <strong>virtual address</strong> (địa chỉ ảo) sẽ có hai thành phần:</p>
<ul>
<li><strong>VPN</strong> (Virtual Page Number – số trang ảo) 4 bit (các bit có trọng số cao nhất)</li>
<li><strong>Offset</strong> 8 bit (các bit có trọng số thấp nhất).</li>
</ul>
<p>Như vậy, một <strong>process</strong> (tiến trình) trong ví dụ này có thể truy cập $2^4 = 16$ trang ảo. Giả sử tiến trình này tạo ra chuỗi các truy cập bộ nhớ (<strong>memory references</strong>) như sau (theo dạng địa chỉ ảo):</p>
<pre><code>0x000, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 0x900
</code></pre>
<p>Các địa chỉ ảo này trỏ đến byte đầu tiên của mỗi trang trong 10 trang đầu tiên của không gian địa chỉ (số trang chính là chữ số hex đầu tiên của địa chỉ ảo).</p>
<p>Giả sử thêm rằng mọi trang ngoại trừ <strong>virtual page 3</strong> đã có sẵn trong bộ nhớ. Khi đó, chuỗi truy cập bộ nhớ sẽ có hành vi:</p>
<pre><code>hit, hit, hit, miss, hit, hit, hit, hit, hit, hit
</code></pre>
<p>Ta có thể tính <strong>hit rate</strong> (tỷ lệ hit) là 90%, vì 9 trên 10 lần truy cập tìm thấy dữ liệu trong bộ nhớ. <strong>Miss rate</strong> do đó là 10% ($P_{Miss} = 0.1$). Nói chung, $P_{Hit} + P_{Miss} = 1.0$; tỷ lệ hit cộng tỷ lệ miss luôn bằng 100%.</p>
<p><strong>Tính AMAT:</strong><br />
Giả sử chi phí truy cập bộ nhớ ($T_M$) là khoảng 100 nanosecond, và chi phí truy cập đĩa ($T_D$) là khoảng 10 millisecond. Khi đó:</p>
<p>$$
\text{AMAT} = 100\text{ns} + 0.1 \cdot 10\text{ms}<br />
= 100\text{ns} + 1\text{ms}<br />
= 1.0001\ \text{ms} \ (\approx 1\ \text{millisecond})
$$</p>
<p>Nếu tỷ lệ hit là 99.9% ($P_{Miss} = 0.001$), kết quả sẽ khác hẳn:</p>
<p>$$
\text{AMAT} = 100\text{ns} + 0.001 \cdot 10\text{ms}<br />
= 100\text{ns} + 10\ \mu\text{s}<br />
\approx 10.1\ \mu\text{s}
$$</p>
<p>Tức là nhanh hơn khoảng 100 lần. Khi tỷ lệ hit tiến gần 100%, AMAT tiến gần đến 100 nanosecond.</p>
<p>Rõ ràng, như bạn thấy trong ví dụ này, chi phí truy cập đĩa trong các hệ thống hiện đại là rất lớn, đến mức chỉ cần một tỷ lệ miss rất nhỏ cũng sẽ nhanh chóng chi phối toàn bộ AMAT của chương trình. Vì vậy, chúng ta cần tránh càng nhiều miss càng tốt, nếu không tốc độ sẽ bị giới hạn bởi tốc độ của đĩa. Một cách để cải thiện là phát triển một <strong>replacement policy</strong> thông minh — và đó chính là điều chúng ta sẽ làm tiếp theo.</p>
<h2 id="222-chính-sách-thay-thế-tối-ưu-optimal-replacement-policy"><a class="header" href="#222-chính-sách-thay-thế-tối-ưu-optimal-replacement-policy">22.2 Chính sách thay thế tối ưu (Optimal Replacement Policy)</a></h2>
<p>Để hiểu rõ hơn cách một <strong>replacement policy</strong> (chính sách thay thế) cụ thể hoạt động, sẽ rất hữu ích nếu so sánh nó với <strong>replacement policy</strong> tốt nhất có thể. Thật vậy, một chính sách tối ưu như vậy đã được Belady phát triển từ nhiều năm trước [B66] (ông ban đầu gọi nó là <strong>MIN</strong>). <strong>Optimal replacement policy</strong> (chính sách thay thế tối ưu) dẫn đến số lượng <strong>miss</strong> (lỗi cache) ít nhất có thể. Belady đã chỉ ra rằng một cách tiếp cận đơn giản (nhưng thật không may là rất khó triển khai!) — thay thế trang sẽ được truy cập xa nhất trong tương lai — chính là chính sách tối ưu, giúp giảm thiểu tối đa số lượng cache miss.</p>
<blockquote>
<p><strong>TIP: SO SÁNH VỚI CHÍNH SÁCH TỐI ƯU LÀ HỮU ÍCH</strong></p>
<p>Mặc dù chính sách tối ưu không thực tế để áp dụng trực tiếp trong hệ thống thật, nhưng nó cực kỳ hữu ích như một điểm tham chiếu trong mô phỏng hoặc các nghiên cứu khác. Việc nói rằng thuật toán mới của bạn đạt <strong>hit rate</strong> (tỷ lệ hit) 80% sẽ không có nhiều ý nghĩa nếu đứng riêng lẻ; nhưng nếu nói rằng chính sách tối ưu đạt 82% hit rate (và do đó cách tiếp cận mới của bạn khá gần với tối ưu) thì kết quả sẽ có ý nghĩa hơn và có ngữ cảnh rõ ràng. Vì vậy, trong bất kỳ nghiên cứu nào, việc biết được giá trị tối ưu cho phép bạn so sánh tốt hơn, chỉ ra mức cải thiện vẫn còn khả thi, và cũng giúp bạn biết khi nào nên dừng tối ưu hóa chính sách của mình vì nó đã đủ gần với lý tưởng [AD03].</p>
</blockquote>
<p>Hy vọng rằng trực giác đằng sau chính sách tối ưu là dễ hiểu. Hãy nghĩ như thế này: nếu bạn buộc phải loại bỏ một trang, tại sao không loại bỏ trang mà bạn sẽ cần đến muộn nhất trong tương lai? Bằng cách làm như vậy, bạn đang ngầm khẳng định rằng tất cả các trang khác trong cache đều quan trọng hơn trang ở xa nhất đó. Lý do điều này đúng rất đơn giản: bạn sẽ truy cập các trang khác trước khi truy cập trang ở xa nhất.</p>
<p>Hãy cùng theo dõi một ví dụ đơn giản để hiểu các quyết định mà chính sách tối ưu đưa ra. Giả sử một chương trình truy cập chuỗi các <strong>virtual page</strong> (trang ảo) như sau:</p>
<pre><code>0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1
</code></pre>
<p><strong>Figure 22.1</strong> dưới đây minh họa hành vi của chính sách tối ưu, giả sử cache có thể chứa tối đa 3 trang.</p>
<div class="table-wrapper"><table><thead><tr><th>Access</th><th>Hit/Miss?</th><th>Evict</th><th>Resulting Cache State</th></tr></thead><tbody>
<tr><td>0</td><td>Miss</td><td></td><td>0</td></tr>
<tr><td>1</td><td>Miss</td><td></td><td>0, 1</td></tr>
<tr><td>2</td><td>Miss</td><td></td><td>0, 1, 2</td></tr>
<tr><td>0</td><td>Hit</td><td></td><td>0, 1, 2</td></tr>
<tr><td>1</td><td>Hit</td><td></td><td>0, 1, 2</td></tr>
<tr><td>3</td><td>Miss</td><td>2</td><td>0, 1, 3</td></tr>
<tr><td>0</td><td>Hit</td><td></td><td>0, 1, 3</td></tr>
<tr><td>3</td><td>Hit</td><td></td><td>0, 1, 3</td></tr>
<tr><td>1</td><td>Hit</td><td></td><td>0, 1, 3</td></tr>
<tr><td>2</td><td>Miss</td><td>3</td><td>0, 1, 2</td></tr>
<tr><td>1</td><td>Hit</td><td></td><td>0, 1, 2</td></tr>
</tbody></table>
</div>
<p><strong>Hình 22.1: Truy vết thuật toán thay thế tối ưu (Tracing The Optimal Policy)</strong></p>
<p>Trong hình, bạn có thể thấy các hành động sau. Không có gì ngạc nhiên, ba lần truy cập đầu tiên đều là <strong>miss</strong> (trượt), vì cache bắt đầu ở trạng thái rỗng; loại miss này đôi khi được gọi là <strong>cold-start miss</strong> (miss khởi động lạnh) hoặc <strong>compulsory miss</strong> (miss bắt buộc). Sau đó, chúng ta lại truy cập các page 0 và 1, cả hai đều <strong>hit</strong> (trúng) trong cache. Cuối cùng, chúng ta gặp một miss khác (với page 3), nhưng lần này cache đã đầy; cần phải thay thế một page! Câu hỏi đặt ra: nên thay thế page nào?</p>
<p>Với <strong>optimal policy</strong> (chính sách tối ưu), ta sẽ xem xét tương lai của từng page hiện có trong cache (0, 1 và 2), và thấy rằng page 0 sẽ được truy cập gần như ngay lập tức, page 1 được truy cập muộn hơn một chút, và page 2 được truy cập xa nhất trong tương lai. Do đó, optimal policy có lựa chọn dễ dàng: <strong>evict</strong> (loại bỏ) page 2, dẫn đến cache chứa các page 0, 1 và 3. Ba lần truy cập tiếp theo đều là hit, nhưng sau đó chúng ta truy cập page 2 (đã bị loại bỏ từ lâu) và gặp một miss khác.</p>
<p>Tại đây, optimal policy lại xem xét tương lai của từng page trong cache (0, 1 và 3), và nhận thấy rằng miễn là không loại bỏ page 1 (sắp được truy cập), thì sẽ ổn. Ví dụ minh họa cho thấy page 3 bị loại bỏ, mặc dù page 0 cũng là một lựa chọn hợp lý. Cuối cùng, ta hit vào page 1 và kết thúc chuỗi truy vết.</p>
<blockquote>
<p><strong>ASIDE: TYPES OF CACHE MISSES</strong><br />
(Các loại cache miss)<br />
Trong lĩnh vực <strong>computer architecture</strong> (kiến trúc máy tính), các kiến trúc sư đôi khi phân loại miss thành ba loại: <strong>compulsory</strong>, <strong>capacity</strong>, và <strong>conflict misses</strong>, đôi khi gọi là <strong>Three C’s</strong> [H87].</p>
<ul>
<li><strong>Compulsory miss</strong> (hoặc <strong>cold-start miss</strong> [EF78]) xảy ra vì cache ban đầu rỗng và đây là lần truy cập đầu tiên tới mục dữ liệu.</li>
<li><strong>Capacity miss</strong> xảy ra vì cache hết chỗ và phải loại bỏ một mục để đưa mục mới vào.</li>
<li><strong>Conflict miss</strong> xuất hiện trong phần cứng do giới hạn về vị trí một mục có thể được đặt trong cache phần cứng, nguyên nhân từ <strong>set-associativity</strong>; loại miss này không xảy ra trong <strong>OS page cache</strong> vì cache này luôn <strong>fully-associative</strong> (hoàn toàn kết hợp), tức là không có giới hạn về vị trí đặt một page trong bộ nhớ. Xem H&amp;P [HP06] để biết chi tiết.</li>
</ul>
</blockquote>
<p>Chúng ta cũng có thể tính <strong>hit rate</strong> (tỉ lệ trúng) cho cache: với 6 hit và 5 miss, hit rate là:</p>
<p>$$ \frac{\text{Hits}}{\text{Hits} + \text{Misses}} = \frac{6}{6+5} $$</p>
<p>tức là 54,5%. Bạn cũng có thể tính hit rate <strong>modulo compulsory misses</strong> (tức là bỏ qua miss đầu tiên đối với một page nhất định), kết quả là 85,7%.</p>
<p>Tuy nhiên, như chúng ta đã thấy trong việc phát triển các <strong>scheduling policy</strong> (chính sách lập lịch), tương lai thường không thể biết trước; bạn không thể xây dựng optimal policy cho một <strong>general-purpose operating system</strong> (hệ điều hành đa dụng)<sup class="footnote-reference"><a href="#1">1</a></sup>. Do đó, khi phát triển một chính sách thực tế, có thể triển khai, chúng ta sẽ tập trung vào các phương pháp khác để quyết định page nào cần loại bỏ. Optimal policy sẽ chỉ đóng vai trò là điểm so sánh, để biết chúng ta đang tiến gần đến “hoàn hảo” đến mức nào.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Nếu bạn làm được, hãy cho chúng tôi biết! Chúng ta có thể cùng nhau trở nên giàu có. Hoặc, giống như các nhà khoa học “phát hiện” ra <strong>cold fusion</strong> (nhiệt hạch lạnh), sẽ bị chế giễu và mỉa mai rộng rãi [FP89].</p>
</div>
<h2 id="223-a-simple-policy-fifo"><a class="header" href="#223-a-simple-policy-fifo">22.3 A Simple Policy: FIFO</a></h2>
<p>(Một chính sách đơn giản: FIFO)</p>
<p>Nhiều hệ thống đời đầu đã tránh sự phức tạp của việc cố gắng tiếp cận optimal và sử dụng các <strong>replacement policy</strong> (chính sách thay thế) rất đơn giản. Ví dụ, một số hệ thống sử dụng <strong>FIFO</strong> (first-in, first-out — vào trước, ra trước), trong đó các page được đưa vào một <strong>queue</strong> (hàng đợi) khi chúng vào hệ thống; khi cần thay thế, page ở <strong>đuôi hàng đợi</strong> (page “first-in”) sẽ bị loại bỏ. FIFO có một ưu điểm lớn: rất dễ triển khai.</p>
<p>Hãy xem FIFO hoạt động thế nào với chuỗi truy cập ví dụ của chúng ta (<em>Figure 22.2</em>, trang 5). Chúng ta lại bắt đầu với ba compulsory miss cho các page 0, 1 và 2, sau đó hit vào cả 0 và 1. Tiếp theo, page 3 được truy cập, gây ra một miss; quyết định thay thế với FIFO rất dễ: chọn page “first-in” (trạng thái cache trong hình được giữ theo thứ tự FIFO, với page vào trước nằm bên trái), đó là page 0.</p>
<p>Không may, lần truy cập tiếp theo là page 0, gây ra một miss khác và thay thế (loại bỏ page 1). Sau đó, chúng ta hit vào page 3, nhưng miss ở page 1 và 2, và cuối cùng hit vào page 1.</p>
<p><img src="22/img/fig22_2.PNG" alt="" /></p>
<p><strong>Hình 22.2: Truy vết chính sách FIFO (Tracing The FIFO Policy)</strong></p>
<p>So sánh FIFO với <strong>optimal</strong>, FIFO hoạt động kém hơn đáng kể: <strong>hit rate</strong> (tỉ lệ trúng) chỉ đạt 36,4% (hoặc 57,1% nếu loại trừ <strong>compulsory misses</strong> — các miss bắt buộc). FIFO hoàn toàn không thể xác định tầm quan trọng của các block: ngay cả khi page 0 đã được truy cập nhiều lần, FIFO vẫn loại bỏ nó, chỉ vì đó là page được đưa vào bộ nhớ đầu tiên.</p>
<blockquote>
<p><strong>ASIDE: BELADY’S ANOMALY</strong><br />
(Hiện tượng bất thường của Belady)<br />
Belady (tác giả của optimal policy) và các đồng nghiệp đã tìm ra một chuỗi tham chiếu bộ nhớ có hành vi khá bất ngờ [BNS69]. Chuỗi <strong>memory-reference</strong> (tham chiếu bộ nhớ) là:<br />
<code>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</code>.<br />
<strong>Replacement policy</strong> (chính sách thay thế) mà họ nghiên cứu là FIFO. Điều thú vị: tỉ lệ hit của cache thay đổi thế nào khi tăng kích thước cache từ 3 lên 4 page.</p>
<p>Thông thường, bạn sẽ mong tỉ lệ hit của cache tăng (cải thiện) khi cache lớn hơn. Nhưng trong trường hợp này, với FIFO, nó lại giảm! Hãy tự tính số hit và miss để kiểm chứng. Hành vi kỳ lạ này thường được gọi là <strong>Belady’s Anomaly</strong> (điều này khiến các đồng tác giả của ông khá bối rối).</p>
<p>Một số chính sách khác, như <strong>LRU</strong>, không gặp vấn đề này. Bạn đoán được tại sao không? Thực tế, LRU có một đặc tính gọi là <strong>stack property</strong> [M+70]. Với các thuật toán có đặc tính này, một cache kích thước N+1 tự nhiên sẽ bao gồm toàn bộ nội dung của cache kích thước N. Do đó, khi tăng kích thước cache, tỉ lệ hit sẽ giữ nguyên hoặc tăng. FIFO và <strong>Random</strong> (cùng một số chính sách khác) rõ ràng không tuân theo stack property, và do đó dễ gặp hành vi bất thường.</p>
</blockquote>
<h2 id="224-another-simple-policy-random"><a class="header" href="#224-another-simple-policy-random">22.4 Another Simple Policy: Random</a></h2>
<p>(Một chính sách đơn giản khác: Random)</p>
<p>Một chính sách thay thế tương tự là <strong>Random</strong>, chính sách này đơn giản chọn ngẫu nhiên một page để thay thế khi bộ nhớ bị áp lực. Random có các đặc điểm tương tự FIFO: dễ triển khai, nhưng không thực sự cố gắng thông minh trong việc chọn block để loại bỏ. Hãy xem Random hoạt động thế nào với chuỗi tham chiếu ví dụ nổi tiếng của chúng ta (<em>Figure 22.3</em>).</p>
<p><img src="22/img/fig22_3.PNG" alt="" /></p>
<p><strong>Hình 22.3: Truy vết chính sách Random (Tracing The Random Policy)</strong></p>
<p>Tất nhiên, hiệu quả của Random phụ thuộc hoàn toàn vào việc nó may mắn (hoặc xui xẻo) thế nào khi chọn. Trong ví dụ trên, Random hoạt động tốt hơn một chút so với FIFO, và kém hơn một chút so với optimal. Thực tế, chúng ta có thể chạy thử nghiệm Random hàng nghìn lần và xác định hiệu quả trung bình của nó.</p>
<p><img src="22/img/fig22_4.PNG" alt="" /></p>
<p><strong>Hình 22.4: Hiệu năng của Random qua 10.000 lần thử (Random Performance Over 10,000 Trials)</strong></p>
<p>Như bạn thấy, đôi khi (hơn 40% số lần), Random tốt ngang optimal, đạt 6 hit trên chuỗi truy vết ví dụ; đôi khi nó tệ hơn nhiều, chỉ đạt 2 hit hoặc ít hơn. Hiệu quả của Random phụ thuộc vào “vận may” khi chọn.</p>
<h2 id="225-using-history-lru"><a class="header" href="#225-using-history-lru">22.5 Using History: LRU</a></h2>
<p>(Sử dụng lịch sử: LRU)</p>
<p>Thật không may, bất kỳ chính sách nào đơn giản như FIFO hoặc Random đều có khả năng gặp một vấn đề chung: nó có thể loại bỏ một page quan trọng, page này sắp được truy cập lại. FIFO loại bỏ page được đưa vào đầu tiên; nếu đó là page chứa code hoặc <strong>data structure</strong> (cấu trúc dữ liệu) quan trọng, nó vẫn bị loại bỏ, mặc dù sắp được nạp lại. Do đó, FIFO, Random và các chính sách tương tự khó có thể tiệm cận optimal; cần một cách tiếp cận thông minh hơn.</p>
<p>Giống như khi xây dựng <strong>scheduling policy</strong> (chính sách lập lịch), để cải thiện khả năng dự đoán tương lai, chúng ta lại dựa vào quá khứ và sử dụng lịch sử làm hướng dẫn. Ví dụ, nếu một chương trình đã truy cập một page gần đây, nhiều khả năng nó sẽ truy cập lại page đó trong tương lai gần.</p>
<p>Một loại thông tin lịch sử mà <strong>page-replacement policy</strong> (chính sách thay thế trang) có thể sử dụng là <strong>frequency</strong> (tần suất); nếu một page đã được truy cập nhiều lần, có lẽ không nên thay thế nó vì rõ ràng nó có giá trị. Một thuộc tính thường được sử dụng hơn là <strong>recency of access</strong> (độ gần đây của lần truy cập); page được truy cập càng gần đây thì càng có khả năng sẽ được truy cập lại.</p>
<p>Nhóm chính sách này dựa trên cái gọi là <strong>principle of locality</strong> (nguyên lý địa phương) [D70], về cơ bản là một quan sát về chương trình và hành vi của chúng. Nguyên lý này nói một cách đơn giản rằng các chương trình có xu hướng truy cập một số đoạn code nhất định (ví dụ: trong vòng lặp) và các cấu trúc dữ liệu (ví dụ: mảng được truy cập trong vòng lặp) khá thường xuyên; do đó, chúng ta nên sử dụng lịch sử để xác định page nào quan trọng và giữ chúng trong bộ nhớ khi cần loại bỏ page khác.</p>
<p>Từ đó, một nhóm các thuật toán đơn giản dựa trên lịch sử ra đời:</p>
<ul>
<li><strong>Least-Frequently-Used (LFU)</strong>: thay thế page được sử dụng ít thường xuyên nhất khi cần loại bỏ.</li>
<li><strong>Least-Recently-Used (LRU)</strong>: thay thế page được sử dụng ít gần đây nhất.</li>
</ul>
<p>Các thuật toán này rất dễ nhớ: chỉ cần biết tên là bạn biết ngay nó làm gì — một đặc điểm tuyệt vời cho tên gọi.</p>
<p>Để hiểu rõ hơn về LRU, hãy xem LRU hoạt động thế nào với chuỗi tham chiếu ví dụ của chúng ta. <em>Figure 22.5</em> (trang 7) cho thấy kết quả. Từ hình, bạn có thể thấy LRU sử dụng lịch sử để hoạt động tốt hơn các chính sách <strong>stateless</strong> (không lưu trạng thái) như Random hoặc FIFO. Trong ví dụ, LRU loại bỏ page 2 khi lần đầu cần thay thế, vì page 0 và 1 đã được truy cập gần đây hơn. Sau đó, nó thay thế page 0 vì page 1 và 3 đã được truy cập gần đây hơn. Trong cả hai trường hợp, quyết định của LRU — dựa trên lịch sử — hóa ra là chính xác, và các lần truy cập tiếp theo đều là hit. Do đó, trong ví dụ của chúng ta, LRU hoạt động tốt nhất có thể, đạt hiệu năng ngang với optimal<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Trong trường hợp này, LRU đạt hiệu năng tối đa vì chuỗi truy cập phù hợp với giả định của nguyên lý địa phương.</p>
</div>
<p><img src="22/img/fig22_5.PNG" alt="" /></p>
<p><strong>Hình 22.5: Truy vết chính sách LRU (Tracing The LRU Policy)</strong></p>
<blockquote>
<p><strong>ASIDE: TYPES OF LOCALITY</strong><br />
(Các loại tính cục bộ)<br />
Có hai loại <strong>locality</strong> (tính cục bộ) mà các chương trình thường thể hiện:</p>
<ul>
<li>Loại thứ nhất gọi là <strong>spatial locality</strong> (tính cục bộ không gian), phát biểu rằng nếu một page P được truy cập, nhiều khả năng các page xung quanh nó (ví dụ P − 1 hoặc P + 1) cũng sẽ được truy cập.</li>
<li>Loại thứ hai là <strong>temporal locality</strong> (tính cục bộ thời gian), phát biểu rằng các page đã được truy cập gần đây nhiều khả năng sẽ được truy cập lại trong tương lai gần.</li>
</ul>
<p>Giả định về sự tồn tại của các loại locality này đóng vai trò lớn trong các hệ thống phân cấp cache của phần cứng, vốn triển khai nhiều cấp độ cache cho lệnh, dữ liệu và dịch địa chỉ để giúp chương trình chạy nhanh khi locality tồn tại.</p>
<p>Tất nhiên, <strong>principle of locality</strong> (nguyên lý cục bộ) — như thường được gọi — không phải là một quy tắc cứng nhắc mà mọi chương trình đều phải tuân theo. Thực tế, một số chương trình truy cập bộ nhớ (hoặc đĩa) theo cách khá ngẫu nhiên và hầu như không thể hiện locality trong luồng truy cập của chúng. Do đó, mặc dù locality là điều tốt cần ghi nhớ khi thiết kế cache (dù là phần cứng hay phần mềm), nó không đảm bảo thành công. Thay vào đó, đây là một <strong>heuristic</strong> (kinh nghiệm) thường tỏ ra hữu ích trong thiết kế hệ thống máy tính.</p>
</blockquote>
<p>Chúng ta cũng nên lưu ý rằng tồn tại các thuật toán đối nghịch với các thuật toán này: <strong>Most-Frequently-Used (MFU)</strong> và <strong>Most-Recently-Used (MRU)</strong>. Trong hầu hết các trường hợp (không phải tất cả!), các chính sách này hoạt động không tốt, vì chúng bỏ qua thay vì tận dụng locality mà hầu hết các chương trình thể hiện.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Đúng vậy, chúng tôi đã “nấu” kết quả. Nhưng đôi khi việc “nấu” là cần thiết để chứng minh một luận điểm.</p>
</div>
<h2 id="226-workload-examples"><a class="header" href="#226-workload-examples">22.6 Workload Examples</a></h2>
<p>(Các ví dụ về khối lượng công việc)</p>
<p>Hãy xem một vài ví dụ nữa để hiểu rõ hơn cách một số chính sách này hoạt động. Ở đây, chúng ta sẽ xem xét các <strong>workload</strong> (khối lượng công việc) phức tạp hơn thay vì các chuỗi truy vết nhỏ. Tuy nhiên, ngay cả các workload này cũng đã được đơn giản hóa rất nhiều; một nghiên cứu tốt hơn sẽ bao gồm các <strong>application trace</strong> (truy vết ứng dụng) thực tế.</p>
<p><strong>Workload</strong> đầu tiên của chúng ta <strong>không có locality</strong>, nghĩa là mỗi tham chiếu là tới một page ngẫu nhiên trong tập các page được truy cập. Trong ví dụ đơn giản này, workload truy cập 100 page duy nhất theo thời gian, chọn page tiếp theo để tham chiếu một cách ngẫu nhiên; tổng cộng có 10.000 lượt truy cập page. Trong thí nghiệm, chúng ta thay đổi kích thước cache từ rất nhỏ (1 page) đến đủ để chứa tất cả các page duy nhất (100 page), nhằm xem mỗi chính sách hoạt động thế nào trên dải kích thước cache này.</p>
<p><img src="22/img/fig22_6.PNG" alt="" /></p>
<p><strong>Hình 22.6: Workload không có locality (The No-Locality Workload)</strong></p>
<p>Hình 22.6 biểu diễn kết quả thí nghiệm cho <strong>optimal</strong>, <strong>LRU</strong>, <strong>Random</strong>, và <strong>FIFO</strong>. Trục y của hình cho thấy hit rate mà mỗi chính sách đạt được; trục x thay đổi kích thước cache như mô tả ở trên.</p>
<p>Từ biểu đồ, chúng ta có thể rút ra một số kết luận:</p>
<ol>
<li>Khi workload không có locality, việc bạn dùng chính sách thực tế nào cũng không quan trọng; LRU, FIFO và Random đều hoạt động giống nhau, với hit rate được xác định chính xác bởi kích thước cache.</li>
<li>Khi cache đủ lớn để chứa toàn bộ workload, chính sách nào bạn dùng cũng không quan trọng; tất cả các chính sách (kể cả Random) đều hội tụ về hit rate 100% khi tất cả các block được tham chiếu đều nằm trong cache.</li>
<li>Cuối cùng, bạn có thể thấy optimal hoạt động tốt hơn đáng kể so với các chính sách thực tế; nếu có thể “nhìn trước tương lai”, việc thay thế sẽ hiệu quả hơn nhiều.</li>
</ol>
<p>Workload tiếp theo được gọi là <strong>“80-20” workload</strong>, thể hiện locality: 80% số lần tham chiếu là tới 20% số page (“hot” pages — page nóng); 20% số lần tham chiếu còn lại là tới 80% số page còn lại (“cold” pages — page lạnh). Trong workload này, tổng số page duy nhất vẫn là 100; do đó, hot pages được tham chiếu hầu hết thời gian, và cold pages chiếm phần còn lại. <strong>Hình 22.7</strong> (trang 10) cho thấy các chính sách hoạt động thế nào với workload này.</p>
<p><img src="22/img/fig22_7.PNG" alt="" /></p>
<p><strong>Hình 22.7: Workload 80-20 (The 80-20 Workload)</strong></p>
<p>Như bạn thấy từ hình, mặc dù cả Random và FIFO đều hoạt động khá tốt, LRU làm tốt hơn, vì nó có xu hướng giữ lại các hot pages; do các page này đã được tham chiếu thường xuyên trong quá khứ, chúng có khả năng sẽ được tham chiếu lại trong tương lai gần. Optimal một lần nữa hoạt động tốt hơn, cho thấy thông tin lịch sử của LRU không hoàn hảo.</p>
<p>Lúc này, bạn có thể tự hỏi: liệu sự cải thiện của LRU so với Random và FIFO có thực sự đáng kể? Câu trả lời, như thường lệ, là “còn tùy”. Nếu mỗi miss là rất tốn kém (điều này không hiếm), thì ngay cả một mức tăng nhỏ trong hit rate (giảm miss rate) cũng có thể tạo ra sự khác biệt lớn về hiệu năng. Nếu miss không quá tốn kém, thì lợi ích tiềm năng của LRU tất nhiên sẽ không quan trọng đến vậy.</p>
<p>Hãy xem một workload cuối cùng. Chúng tôi gọi nó là <strong>“looping sequential” workload</strong> (workload tuần tự lặp), trong đó chúng ta tham chiếu 50 page theo thứ tự, bắt đầu từ 0, sau đó 1, ..., đến page 49, rồi lặp lại, lặp đi lặp lại các truy cập này, tổng cộng 10.000 lượt truy cập tới 50 page duy nhất. Biểu đồ cuối trong <strong>Hình 22.8</strong> cho thấy hành vi của các chính sách với workload này.</p>
<p><img src="22/img/fig22_8.PNG" alt="" /></p>
<p><strong>Hình 22.8: Workload tuần tự lặp (The Looping Workload)</strong></p>
<p>Workload này, phổ biến trong nhiều ứng dụng (bao gồm cả các ứng dụng thương mại quan trọng như <strong>database</strong> [CD85]), là trường hợp xấu nhất cho cả LRU và FIFO. Các thuật toán này, dưới workload tuần tự lặp, loại bỏ các page cũ hơn; không may, do tính chất lặp của workload, các page cũ này sẽ được truy cập sớm hơn so với các page mà chính sách ưu tiên giữ lại trong cache. Thực tế, ngay cả với cache kích thước 49, một workload tuần tự lặp gồm 50 page vẫn dẫn đến hit rate 0%.</p>
<p>Điều thú vị là Random hoạt động tốt hơn đáng kể, dù không đạt tới optimal, nhưng ít nhất đạt được hit rate khác 0. Hóa ra Random có một số đặc tính thú vị; một trong số đó là không gặp các hành vi bất thường ở các trường hợp đặc biệt (corner-case) khó chịu.</p>
<h2 id="227-implementing-historical-algorithms"><a class="header" href="#227-implementing-historical-algorithms">22.7 Implementing Historical Algorithms</a></h2>
<p>(Triển khai các thuật toán dựa trên lịch sử)</p>
<p>Như bạn thấy, một thuật toán như <strong>LRU</strong> (Least Recently Used — loại bỏ trang ít được sử dụng gần đây nhất) thường có thể làm tốt hơn các chính sách đơn giản như <strong>FIFO</strong> hoặc <strong>Random</strong>, vốn có thể loại bỏ các page quan trọng. Tuy nhiên, các chính sách dựa trên lịch sử lại đặt ra một thách thức mới: <strong>làm thế nào để triển khai chúng?</strong></p>
<p>Lấy ví dụ LRU. Để triển khai hoàn hảo, chúng ta cần làm khá nhiều việc. Cụ thể, với mỗi lần truy cập page (tức là mỗi lần truy cập bộ nhớ, dù là nạp lệnh hay đọc/ghi dữ liệu), chúng ta phải cập nhật một <strong>data structure</strong> (cấu trúc dữ liệu) để di chuyển page này lên đầu danh sách (tức là phía <strong>MRU</strong> — Most Recently Used). So sánh với FIFO, danh sách FIFO của các page chỉ được truy cập khi một page bị loại bỏ (bằng cách xóa page vào trước) hoặc khi một page mới được thêm vào danh sách (ở phía vào sau). Để theo dõi page nào được sử dụng gần nhất và xa nhất, hệ thống phải thực hiện một số công việc ghi nhận (accounting) trên <strong>mỗi</strong> lần tham chiếu bộ nhớ. Rõ ràng, nếu không cẩn thận, việc ghi nhận này có thể làm giảm hiệu năng đáng kể.</p>
<p>Một phương pháp có thể giúp tăng tốc là bổ sung một chút hỗ trợ từ phần cứng. Ví dụ, máy có thể cập nhật, với mỗi lần truy cập page, một trường thời gian trong bộ nhớ (có thể nằm trong page table của từng process, hoặc trong một mảng riêng trong bộ nhớ, mỗi entry ứng với một physical page của hệ thống). Khi một page được truy cập, trường thời gian này sẽ được phần cứng đặt thành thời gian hiện tại. Sau đó, khi cần thay thế một page, OS chỉ cần quét tất cả các trường thời gian trong hệ thống để tìm page ít được sử dụng gần đây nhất.</p>
<p>Tuy nhiên, khi số lượng page trong hệ thống tăng, việc quét một mảng thời gian khổng lồ chỉ để tìm page cũ nhất tuyệt đối là cực kỳ tốn kém. Hãy tưởng tượng một máy hiện đại với 4GB bộ nhớ, chia thành các page 4KB. Máy này có 1 triệu page, và việc tìm page LRU sẽ mất rất nhiều thời gian, ngay cả với tốc độ CPU hiện đại. Điều này đặt ra câu hỏi: <strong>chúng ta có thực sự cần tìm page cũ nhất tuyệt đối để thay thế không?</strong> Liệu chúng ta có thể chấp nhận một <strong>xấp xỉ</strong>?</p>
<blockquote>
<p><strong>CRUX: HOW TO IMPLEMENT AN LRU REPLACEMENT POLICY</strong><br />
(Làm thế nào để triển khai chính sách thay thế LRU)<br />
Vì việc triển khai LRU hoàn hảo là tốn kém, liệu chúng ta có thể xấp xỉ nó theo cách nào đó mà vẫn đạt được hành vi mong muốn?</p>
</blockquote>
<h2 id="228-approximating-lru"><a class="header" href="#228-approximating-lru">22.8 Approximating LRU</a></h2>
<p>(Xấp xỉ LRU)</p>
<p>Câu trả lời là <strong>có</strong>: việc xấp xỉ LRU khả thi hơn nhiều về mặt chi phí tính toán, và thực tế đây là cách mà nhiều hệ thống hiện đại áp dụng. Ý tưởng này cần một chút hỗ trợ phần cứng, dưới dạng <strong>use bit</strong> (bit sử dụng, đôi khi gọi là <strong>reference bit</strong> — bit tham chiếu), lần đầu được triển khai trong hệ thống có phân trang đầu tiên, <strong>Atlas one-level store</strong> [KE+62]. Mỗi page trong hệ thống có một use bit, và các bit này được lưu ở đâu đó trong bộ nhớ (có thể trong page table của từng process, hoặc trong một mảng riêng). Mỗi khi một page được tham chiếu (đọc hoặc ghi), use bit sẽ được phần cứng đặt thành 1. Phần cứng <strong>không bao giờ</strong> tự xóa bit này (đặt về 0); đó là trách nhiệm của OS.</p>
<p>OS sử dụng use bit để xấp xỉ LRU như thế nào? Có nhiều cách, nhưng <strong>clock algorithm</strong> [C69] là một cách tiếp cận đơn giản. Hãy tưởng tượng tất cả các page của hệ thống được sắp xếp thành một danh sách vòng tròn. Một “kim đồng hồ” trỏ tới một page bất kỳ để bắt đầu (không quan trọng là page nào). Khi cần thay thế, OS kiểm tra page P mà kim đang trỏ có use bit bằng 1 hay 0. Nếu bằng 1, điều này nghĩa là page P vừa được sử dụng gần đây và không phải ứng viên tốt để thay thế. OS sẽ xóa use bit của P (đặt về 0) và di chuyển kim sang page tiếp theo (P+1). Thuật toán tiếp tục cho đến khi tìm thấy một page có use bit bằng 0, nghĩa là page này không được sử dụng gần đây (hoặc, trong trường hợp xấu nhất, tất cả page đều đã được sử dụng và chúng ta đã quét hết, xóa tất cả bit).</p>
<p>Lưu ý rằng đây không phải là cách duy nhất dùng use bit để xấp xỉ LRU. Bất kỳ cách nào định kỳ xóa use bit và phân biệt page có use bit = 1 và = 0 để quyết định thay thế đều được. Thuật toán clock của Corbató chỉ là một cách tiếp cận sớm và thành công, với ưu điểm là không phải quét toàn bộ bộ nhớ nhiều lần để tìm page không sử dụng.</p>
<p><img src="22/img/fig22_9.PNG" alt="" /></p>
<p><strong>Hình 22.9: Workload 80-20 với Clock</strong></p>
<p>Biểu đồ trong Hình 22.9 cho thấy hành vi của một biến thể clock algorithm. Biến thể này quét ngẫu nhiên các page khi thay thế; khi gặp page có reference bit = 1, nó xóa bit (đặt về 0); khi gặp page có reference bit = 0, nó chọn page đó làm <strong>victim</strong> (nạn nhân). Như bạn thấy, mặc dù không tốt bằng LRU hoàn hảo, nó vẫn tốt hơn các cách không xét đến lịch sử.</p>
<h2 id="229-considering-dirty-pages"><a class="header" href="#229-considering-dirty-pages">22.9 Considering Dirty Pages</a></h2>
<p>(Xem xét các trang bẩn)</p>
<p>Một sửa đổi nhỏ cho clock algorithm (cũng do Corbató [C69] đề xuất) thường được áp dụng là xem xét thêm việc page có bị <strong>modified</strong> (sửa đổi) khi ở trong bộ nhớ hay không. Lý do: nếu page đã bị sửa đổi (<strong>dirty</strong>), nó phải được ghi lại ra đĩa khi bị loại bỏ, điều này tốn kém. Nếu page chưa bị sửa đổi (<strong>clean</strong>), việc loại bỏ là miễn phí; <strong>physical frame</strong> (khung trang vật lý) có thể được tái sử dụng ngay mà không cần I/O bổ sung. Do đó, một số hệ thống VM ưu tiên loại bỏ page sạch hơn page bẩn.</p>
<p>Để hỗ trợ điều này, phần cứng cần có <strong>modified bit</strong> (còn gọi là <strong>dirty bit</strong>). Bit này được đặt mỗi khi page bị ghi, và có thể được tích hợp vào thuật toán thay thế trang. Ví dụ, clock algorithm có thể được sửa để ưu tiên quét tìm page vừa <strong>unused</strong> (không dùng) vừa <strong>clean</strong> để loại bỏ trước; nếu không tìm thấy, mới tìm page unused nhưng dirty, v.v.</p>
<h2 id="2210-other-vm-policies"><a class="header" href="#2210-other-vm-policies">22.10 Other VM Policies</a></h2>
<p>(Các chính sách VM khác)</p>
<p><strong>Page replacement</strong> không phải là chính sách duy nhất mà <strong>VM subsystem</strong> (hệ thống con bộ nhớ ảo) áp dụng (mặc dù có thể là quan trọng nhất). Ví dụ, OS cũng phải quyết định <strong>khi nào</strong> đưa một page vào bộ nhớ. Chính sách này, đôi khi gọi là <strong>page selection policy</strong> (chính sách chọn trang) [D70], đưa ra cho OS một số lựa chọn khác nhau.</p>
<p>Với hầu hết các page, OS sử dụng <strong>demand paging</strong> — nghĩa là OS chỉ đưa page vào bộ nhớ khi nó được truy cập, “on demand” (theo yêu cầu). Tất nhiên, OS có thể đoán rằng một page sắp được dùng và đưa nó vào trước; hành vi này gọi là <strong>prefetching</strong> và chỉ nên thực hiện khi có khả năng thành công hợp lý. Ví dụ, một số hệ thống giả định rằng nếu page mã P được đưa vào bộ nhớ, thì page mã P+1 cũng sẽ sớm được truy cập và nên được đưa vào luôn.</p>
<p>Một chính sách khác xác định cách OS ghi page ra đĩa. Tất nhiên, có thể ghi từng page một; tuy nhiên, nhiều hệ thống gom nhiều thao tác ghi đang chờ trong bộ nhớ và ghi chúng ra đĩa trong một lần (hiệu quả hơn). Hành vi này thường được gọi là <strong>clustering</strong> hoặc <strong>grouping of writes</strong> (gom nhóm ghi), và hiệu quả vì đặc tính của ổ đĩa: thực hiện một lần ghi lớn hiệu quả hơn nhiều lần ghi nhỏ.</p>
<h2 id="2211-thrashing"><a class="header" href="#2211-thrashing">22.11 Thrashing</a></h2>
<p>(Hiện tượng quá tải phân trang)</p>
<p>Trước khi kết thúc, chúng ta bàn đến một câu hỏi cuối cùng: <strong>OS nên làm gì khi bộ nhớ bị oversubscribed</strong> (quá tải), tức là nhu cầu bộ nhớ của tập hợp các <strong>process</strong> (tiến trình) đang chạy vượt quá dung lượng <strong>physical memory</strong> (bộ nhớ vật lý) sẵn có? Trong trường hợp này, hệ thống sẽ liên tục thực hiện phân trang (paging), một trạng thái đôi khi được gọi là <strong>thrashing</strong> [D70].</p>
<p>Một số hệ điều hành đời trước có một tập hợp cơ chế khá tinh vi để vừa phát hiện vừa xử lý thrashing khi nó xảy ra. Ví dụ, với một tập hợp process, hệ thống có thể quyết định <strong>không chạy</strong> một số process, với hy vọng rằng <strong>working set</strong> (tập trang đang được sử dụng tích cực) của tập process còn lại sẽ vừa với bộ nhớ và do đó có thể tiếp tục tiến triển. Cách tiếp cận này, thường được gọi là <strong>admission control</strong> (kiểm soát tiếp nhận), dựa trên nguyên tắc: đôi khi <strong>làm ít việc nhưng làm tốt</strong> sẽ tốt hơn là cố gắng làm tất cả mọi thứ cùng lúc nhưng kém hiệu quả — một tình huống mà chúng ta thường gặp cả trong đời sống lẫn trong các hệ thống máy tính hiện đại (đáng tiếc là vậy).</p>
<p>Một số hệ thống hiện nay áp dụng cách tiếp cận “mạnh tay” hơn đối với tình trạng quá tải bộ nhớ. Ví dụ, một số phiên bản Linux chạy <strong>out-of-memory killer</strong> khi bộ nhớ bị oversubscribed; <strong>daemon</strong> này sẽ chọn một process tiêu tốn nhiều bộ nhớ và <strong>kill</strong> (chấm dứt) nó, từ đó giảm áp lực bộ nhớ theo cách không mấy tinh tế. Mặc dù cách này thành công trong việc giảm áp lực bộ nhớ, nhưng nó có thể gây ra vấn đề, chẳng hạn nếu nó kill <strong>X server</strong>, khiến mọi ứng dụng yêu cầu hiển thị trở nên không thể sử dụng.</p>
<h2 id="2212-summary"><a class="header" href="#2212-summary">22.12 Summary</a></h2>
<p>(Tóm tắt)</p>
<p>Chúng ta đã thấy sự xuất hiện của nhiều <strong>page-replacement policy</strong> (chính sách thay thế trang) và các chính sách khác, vốn là một phần của <strong>VM subsystem</strong> (hệ thống con bộ nhớ ảo) trong tất cả các hệ điều hành hiện đại. Các hệ thống hiện đại bổ sung một số tinh chỉnh cho các xấp xỉ LRU đơn giản như <strong>clock</strong>; ví dụ, <strong>scan resistance</strong> (kháng quét) là một thành phần quan trọng của nhiều thuật toán hiện đại, như <strong>ARC</strong> [MM03]. Các thuật toán scan-resistant thường giống LRU nhưng cố gắng tránh hành vi tệ nhất của LRU, như chúng ta đã thấy với <strong>looping-sequential workload</strong> (khối lượng công việc tuần tự lặp). Do đó, sự tiến hóa của các thuật toán thay thế trang vẫn tiếp tục.</p>
<p>Trong nhiều năm, tầm quan trọng của các thuật toán thay thế đã giảm, do sự chênh lệch quá lớn giữa thời gian truy cập bộ nhớ và thời gian truy cập đĩa. Cụ thể, vì việc paging ra đĩa quá tốn kém, chi phí của việc phân trang thường xuyên là không thể chấp nhận; nói đơn giản, <strong>dù thuật toán thay thế của bạn tốt đến đâu</strong>, nếu bạn phải thay thế thường xuyên, hệ thống của bạn sẽ trở nên chậm không thể chịu nổi. Do đó, giải pháp tốt nhất khi đó là một giải pháp đơn giản (dù không thỏa mãn về mặt học thuật): <strong>mua thêm bộ nhớ</strong>.</p>
<p>Tuy nhiên, những đổi mới gần đây trong các thiết bị lưu trữ nhanh hơn nhiều (ví dụ: <strong>Flash-based SSDs</strong>) đã thay đổi tỷ lệ hiệu năng này một lần nữa, dẫn đến một “thời kỳ phục hưng” của các thuật toán thay thế trang. Xem [SS10, W+21] để biết các nghiên cứu gần đây trong lĩnh vực này.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-hệ-thống-bộ-nhớ-ảo-hoàn-chỉnh-complete-virtual-memory-systems"><a class="header" href="#23-hệ-thống-bộ-nhớ-ảo-hoàn-chỉnh-complete-virtual-memory-systems">23. Hệ thống bộ nhớ ảo hoàn chỉnh (Complete Virtual Memory Systems)</a></h1>
<p>Trước khi kết thúc việc nghiên cứu về <strong>virtualizing memory</strong> (ảo hóa bộ nhớ), chúng ta hãy xem xét kỹ hơn cách mà toàn bộ một hệ thống <strong>virtual memory</strong> (bộ nhớ ảo) được xây dựng. Chúng ta đã thấy các thành phần then chốt của những hệ thống như vậy, bao gồm nhiều thiết kế <strong>page table</strong> (bảng trang), sự tương tác với <strong>TLB</strong> (đôi khi còn được OS xử lý trực tiếp), và các chiến lược quyết định page nào giữ lại trong bộ nhớ và page nào loại bỏ. Tuy nhiên, còn nhiều tính năng khác tạo nên một hệ thống bộ nhớ ảo hoàn chỉnh, bao gồm nhiều đặc tính về hiệu năng, chức năng và bảo mật. Và đây là vấn đề mấu chốt:</p>
<blockquote>
<p><strong>THE CRUX: HOW TO BUILD A COMPLETE VM SYSTEM</strong><br />
(Làm thế nào để xây dựng một hệ thống bộ nhớ ảo hoàn chỉnh)<br />
Những tính năng nào là cần thiết để hiện thực hóa một hệ thống bộ nhớ ảo hoàn chỉnh? Chúng cải thiện hiệu năng, tăng cường bảo mật hoặc cải thiện hệ thống theo những cách nào?</p>
</blockquote>
<p>Chúng ta sẽ tìm hiểu điều này thông qua hai hệ thống. Hệ thống đầu tiên là một trong những ví dụ sớm nhất của một <strong>virtual memory manager</strong> (bộ quản lý bộ nhớ ảo) “hiện đại” — đó là hệ điều hành <strong>VAX/VMS</strong> [LL82], được phát triển trong những năm 1970 và đầu 1980; một số lượng đáng ngạc nhiên các kỹ thuật và phương pháp từ hệ thống này vẫn tồn tại đến ngày nay, vì vậy rất đáng để nghiên cứu. Một số ý tưởng, dù đã 50 năm tuổi, vẫn đáng để biết — điều này vốn quen thuộc trong nhiều lĩnh vực khác (ví dụ: Vật lý), nhưng lại cần được nhấn mạnh trong các ngành dựa trên công nghệ (ví dụ: Khoa học Máy tính). Hệ thống thứ hai là <strong>Linux</strong>, vì lý do hiển nhiên: Linux là một hệ thống được sử dụng rộng rãi, chạy hiệu quả từ các thiết bị nhỏ và yếu như điện thoại cho đến các hệ thống đa lõi có khả năng mở rộng cao trong các trung tâm dữ liệu hiện đại. Do đó, hệ thống VM của nó phải đủ linh hoạt để hoạt động thành công trong tất cả các kịch bản này. Chúng ta sẽ thảo luận từng hệ thống để minh họa cách các khái niệm đã trình bày ở các chương trước kết hợp lại thành một <strong>memory manager</strong> (bộ quản lý bộ nhớ) hoàn chỉnh.</p>
<h2 id="231-vaxvms-virtual-memory"><a class="header" href="#231-vaxvms-virtual-memory">23.1 VAX/VMS Virtual Memory</a></h2>
<p><strong>Kiến trúc VAX-11</strong> thuộc dòng <strong>minicomputer</strong> được giới thiệu vào cuối những năm 1970 bởi <strong>Digital Equipment Corporation (DEC)</strong>. DEC từng là một “ông lớn” trong ngành công nghiệp máy tính thời kỳ minicomputer; đáng tiếc là một loạt quyết định sai lầm cùng với sự xuất hiện của PC đã từ từ (nhưng chắc chắn) dẫn đến sự sụp đổ của họ [C03]. Kiến trúc này được hiện thực trong nhiều phiên bản, bao gồm <strong>VAX-11/780</strong> và phiên bản yếu hơn là <strong>VAX-11/750</strong>.</p>
<p>Hệ điều hành cho hệ thống này được gọi là <strong>VAX/VMS</strong> (hoặc đơn giản là <strong>VMS</strong>), với một trong những kiến trúc sư chính là <strong>Dave Cutler</strong>, người sau này dẫn dắt việc phát triển <strong>Microsoft Windows NT</strong> [C93]. VMS phải đối mặt với vấn đề chung là nó sẽ chạy trên một dải rộng các loại máy, từ những máy VAX rất rẻ (vâng, “VAXen” là dạng số nhiều đúng) cho đến những máy cực kỳ mạnh mẽ trong cùng họ kiến trúc. Do đó, OS phải có các cơ chế và chính sách hoạt động tốt trên toàn bộ dải hệ thống này. Ngoài ra, VMS là một ví dụ điển hình về các cải tiến phần mềm được dùng để che giấu một số nhược điểm vốn có của kiến trúc phần cứng. Mặc dù OS thường dựa vào phần cứng để xây dựng các <strong>abstraction</strong> (trừu tượng) và <strong>illusion</strong> (ảo tưởng) hiệu quả, đôi khi các nhà thiết kế phần cứng không làm mọi thứ hoàn hảo; trong phần cứng VAX, chúng ta sẽ thấy một vài ví dụ về điều này, và cách mà VMS khắc phục để xây dựng một hệ thống hiệu quả, hoạt động tốt bất chấp các nhược điểm phần cứng.</p>
<h3 id="memory-management-hardware"><a class="header" href="#memory-management-hardware">Memory Management Hardware</a></h3>
<p>VAX-11 cung cấp <strong>virtual address space</strong> 32-bit cho mỗi <strong>process</strong> (tiến trình), được chia thành các <strong>page</strong> 512 byte. Do đó, một <strong>virtual address</strong> bao gồm <strong>VPN</strong> (virtual page number) 23-bit và <strong>offset</strong> 9-bit. Hơn nữa, 2 bit cao nhất của VPN được dùng để phân biệt <strong>segment</strong> (đoạn) mà page thuộc về; do đó, hệ thống này là một dạng <strong>hybrid</strong> (lai) giữa <strong>paging</strong> và <strong>segmentation</strong>, như chúng ta đã thấy trước đây.</p>
<p>Nửa dưới của address space được gọi là <strong>process space</strong> và là duy nhất cho mỗi process. Trong nửa đầu của process space (gọi là <strong>P0</strong>), chứa chương trình người dùng và <strong>heap</strong> (vùng nhớ động) — heap này phát triển xuống dưới. Trong nửa sau của process space (<strong>P1</strong>), chứa <strong>stack</strong> (ngăn xếp) — stack này phát triển lên trên. Nửa trên của address space được gọi là <strong>system space</strong> (<strong>S</strong>), mặc dù chỉ một nửa của nó được sử dụng. <strong>OS code</strong> và dữ liệu được bảo vệ nằm ở đây, và theo cách này OS được chia sẻ giữa các process.</p>
<p>Một mối quan tâm lớn của các nhà thiết kế VMS là kích thước page cực kỳ nhỏ trong phần cứng VAX (512 byte). Kích thước này, được chọn vì lý do lịch sử, dẫn đến vấn đề cơ bản là làm cho <strong>linear page table</strong> (bảng trang tuyến tính) trở nên quá lớn. Do đó, một trong những mục tiêu đầu tiên của các nhà thiết kế VMS là đảm bảo rằng VMS sẽ không làm tràn bộ nhớ với page table. Hệ thống giảm áp lực của page table lên bộ nhớ theo hai cách.</p>
<p>Thứ nhất, bằng cách chia address space của người dùng thành hai phần, VAX-11 cung cấp một page table riêng cho mỗi vùng này (P0 và P1) trên mỗi process.</p>
<blockquote>
<p><strong>ASIDE: THE CURSE OF GENERALITY</strong><br />
(Lời nguyền của tính tổng quát)<br />
Hệ điều hành thường gặp một vấn đề gọi là <strong>curse of generality</strong> (lời nguyền của tính tổng quát), khi chúng phải hỗ trợ chung cho một lớp ứng dụng và hệ thống rất rộng. Kết quả cơ bản của lời nguyền này là OS khó có thể hỗ trợ tốt cho bất kỳ cài đặt cụ thể nào. Trong trường hợp của VMS, lời nguyền này là rất thực tế, vì kiến trúc VAX-11 được hiện thực trong nhiều phiên bản khác nhau. Điều này cũng đúng cho đến ngày nay, khi Linux được kỳ vọng chạy tốt trên điện thoại, TV set-top box, laptop, desktop, và cả máy chủ cao cấp chạy hàng nghìn process trong một <strong>cloud-based datacenter</strong> (trung tâm dữ liệu dựa trên đám mây).</p>
</blockquote>
<p>Nhờ vậy, không cần cấp phát không gian page table cho phần không sử dụng của address space giữa stack và heap. <strong>Base register</strong> (thanh ghi cơ sở) và <strong>bounds register</strong> (thanh ghi giới hạn) được sử dụng như mong đợi; base register giữ địa chỉ của page table cho segment đó, và bounds register giữ kích thước của nó (tức là số lượng <strong>page-table entry</strong>).</p>
<p>Thứ hai, OS giảm áp lực bộ nhớ hơn nữa bằng cách đặt <strong>user page table</strong> (cho P0 và P1, tức là hai bảng trên mỗi process) vào <strong>kernel virtual memory</strong> (bộ nhớ ảo của nhân). Do đó, khi cấp phát hoặc mở rộng page table, kernel sẽ cấp phát không gian từ chính virtual memory của nó, trong segment S. Nếu bộ nhớ bị áp lực nghiêm trọng, kernel có thể <strong>swap</strong> (hoán đổi) các page của page table này ra đĩa, giải phóng physical memory cho các mục đích khác.</p>
<p>Việc đặt page table vào kernel virtual memory khiến quá trình <strong>address translation</strong> (dịch địa chỉ) trở nên phức tạp hơn. Ví dụ, để dịch một virtual address trong P0 hoặc P1, phần cứng phải trước tiên tra cứu <strong>page-table entry</strong> cho page đó trong page table tương ứng (P0 hoặc P1 của process đó); tuy nhiên, để làm điều này, phần cứng có thể phải tham khảo <strong>system page table</strong> (nằm trong physical memory); sau khi dịch xong, phần cứng mới biết địa chỉ của page trong page table, và cuối cùng mới biết địa chỉ của dữ liệu cần truy cập. Tất cả những điều này, may mắn thay, is made faster by the VAX’s hardware-managed TLBs, which usually (hopefully) circumvent this laborious lookup.</p>
<h3 id="một-không-gian-địa-chỉ-thực-tế-a-real-address-space"><a class="header" href="#một-không-gian-địa-chỉ-thực-tế-a-real-address-space">Một không gian địa chỉ thực tế (A Real Address Space)</a></h3>
<p>Một điểm thú vị khi nghiên cứu <strong>VMS</strong> là chúng ta có thể thấy cách một <strong>address space</strong> (không gian địa chỉ) thực tế được xây dựng (<em>Figure 23.1</em>). Cho đến nay, chúng ta giả định một address space đơn giản chỉ gồm <strong>user code</strong> (mã người dùng), <strong>user data</strong> (dữ liệu người dùng) và <strong>user heap</strong> (vùng nhớ động của người dùng), nhưng như có thể thấy, một address space thực tế phức tạp hơn đáng kể.</p>
<p>Ví dụ, <strong>code segment</strong> (đoạn code) không bao giờ bắt đầu tại <strong>page</strong> 0. Thay vào đó, page này được đánh dấu <strong>inaccessible</strong> (không thể truy cập), nhằm hỗ trợ việc phát hiện các truy cập <strong>null pointer</strong> (con trỏ null). Do đó, một mối quan tâm khi thiết kế address space là hỗ trợ <strong>debugging</strong> (gỡ lỗi), và page 0 không thể truy cập ở đây cung cấp một dạng hỗ trợ như vậy.</p>
<p>Quan trọng hơn, <strong>kernel virtual address space</strong> (không gian địa chỉ ảo của nhân — bao gồm cấu trúc dữ liệu và mã của kernel) là một phần của mỗi user address space. Khi <strong>context switch</strong> (chuyển ngữ cảnh), OS thay đổi các thanh ghi <strong>P0</strong> và <strong>P1</strong> để trỏ tới page table thích hợp của process sắp chạy; tuy nhiên, nó <strong>không</strong> thay đổi các thanh ghi <strong>S base</strong> và <strong>S bound</strong>, và do đó các cấu trúc kernel “giống nhau” được ánh xạ vào mỗi user address space.</p>
<p><img src="23/img/fig23_1.PNG" alt="" /></p>
<p><strong>Figure 23.1: The VAX/VMS Address Space</strong><br />
<em>(Không gian địa chỉ của VAX/VMS)</em></p>
<p>Kernel được ánh xạ vào mỗi address space vì nhiều lý do. Cách xây dựng này giúp kernel dễ dàng hơn; ví dụ, khi OS nhận một <strong>pointer</strong> từ chương trình người dùng (ví dụ trong <strong>system call</strong> <code>write()</code>), việc sao chép dữ liệu từ con trỏ đó sang cấu trúc của kernel trở nên đơn giản. OS được viết và biên dịch một cách tự nhiên, không cần lo lắng dữ liệu nó truy cập đến từ đâu. Ngược lại, nếu kernel nằm hoàn toàn trong <strong>physical memory</strong> (bộ nhớ vật lý), sẽ rất khó thực hiện các thao tác như <strong>swap</strong> (hoán đổi) các page của page table ra đĩa; nếu kernel có address space riêng, việc di chuyển dữ liệu giữa ứng dụng người dùng và kernel sẽ lại phức tạp và tốn công. Với cách xây dựng này (hiện được sử dụng rộng rãi), kernel gần như xuất hiện như một thư viện đối với ứng dụng, dù là một thư viện được bảo vệ.</p>
<blockquote>
<p><strong>ASIDE: TẠI SAO TRUY CẬP NULL POINTER GÂY SEG FAULT</strong><br />
Giờ bạn nên hiểu rõ điều gì xảy ra khi <strong>dereference</strong> (giải tham chiếu) một null pointer. Một process tạo ra virtual address bằng 0, bằng cách làm như sau:</p>
<pre><code class="language-c">int *p = NULL; // gán p = 0
// thử ghi giá trị 10 vào địa chỉ ảo 0
*p = 10;
</code></pre>
<p>Phần cứng cố gắng tra VPN (cũng là 0) trong TLB, và gặp <strong>TLB miss</strong>. Page table được tra cứu, và entry cho VPN 0 được đánh dấu <strong>invalid</strong> (không hợp lệ). Do đó, đây là một truy cập không hợp lệ, dẫn đến việc chuyển quyền điều khiển cho OS, và OS có thể sẽ chấm dứt process (trên hệ thống UNIX, process sẽ nhận một <strong>signal</strong> cho phép nó phản ứng với lỗi này; nếu không bắt được signal, process sẽ bị kill).</p>
</blockquote>
<p>Một điểm cuối cùng về address space này liên quan đến <strong>protection</strong> (bảo vệ). Rõ ràng, OS không muốn ứng dụng người dùng đọc hoặc ghi dữ liệu/mã của OS. Do đó, phần cứng phải hỗ trợ các mức bảo vệ khác nhau cho page để thực hiện điều này. VAX làm điều đó bằng cách chỉ định, trong các <strong>protection bit</strong> của page table, mức đặc quyền (<strong>privilege level</strong>) mà CPU phải có để truy cập một page cụ thể. Nhờ vậy, dữ liệu và mã hệ thống được đặt ở mức bảo vệ cao hơn dữ liệu và mã người dùng; mọi nỗ lực truy cập thông tin như vậy từ mã người dùng sẽ tạo ra một <strong>trap</strong> vào OS, và (bạn đoán đúng) khả năng cao là process vi phạm sẽ bị chấm dứt.</p>
<h3 id="page-replacement-thay-thế-trang"><a class="header" href="#page-replacement-thay-thế-trang">Page Replacement (Thay thế trang)</a></h3>
<p><strong>Page table entry</strong> (PTE) trong VAX chứa các bit sau:</p>
<ul>
<li><strong>valid bit</strong> (bit hợp lệ)</li>
<li><strong>protection field</strong> (trường bảo vệ, 4 bit)</li>
<li><strong>modify bit</strong> (hoặc <strong>dirty bit</strong>)</li>
<li>một trường dành riêng cho OS (5 bit)</li>
<li>và cuối cùng là <strong>physical frame number</strong> (PFN) để lưu vị trí của page trong physical memory.</li>
</ul>
<p>Người đọc tinh ý sẽ nhận ra: <strong>không có reference bit</strong>! Do đó, thuật toán thay thế của VMS phải hoạt động mà không có hỗ trợ phần cứng để xác định page nào đang hoạt động.</p>
<p>Các nhà phát triển cũng lo ngại về <strong>memory hogs</strong> — các chương trình sử dụng nhiều bộ nhớ và khiến các chương trình khác khó chạy. Hầu hết các chính sách chúng ta đã xem đều dễ bị ảnh hưởng bởi hiện tượng này; ví dụ, <strong>LRU</strong> là một chính sách toàn cục, không chia sẻ bộ nhớ công bằng giữa các process.</p>
<blockquote>
<p><strong>ASIDE: MÔ PHỎNG REFERENCE BIT</strong><br />
Thực tế, bạn không cần reference bit phần cứng để biết page nào đang được sử dụng trong hệ thống. Vào đầu những năm 1980, <strong>Babaoglu</strong> và <strong>Joy</strong> đã chỉ ra rằng <strong>protection bit</strong> trên VAX có thể được dùng để mô phỏng reference bit [BJ81]. Ý tưởng cơ bản: nếu muốn biết page nào đang được sử dụng, hãy đánh dấu tất cả page trong page table là <strong>inaccessible</strong> (không thể truy cập) (nhưng vẫn lưu thông tin về page nào thực sự có thể truy cập bởi process, có thể trong trường “reserved OS field” của PTE). Khi process truy cập một page, nó sẽ tạo ra một <strong>trap</strong> vào OS; OS sẽ kiểm tra xem page đó thực sự có thể truy cập không, và nếu có, khôi phục lại quyền bảo vệ bình thường (ví dụ: read-only hoặc read-write). Khi thay thế, OS có thể kiểm tra page nào vẫn bị đánh dấu inaccessible, từ đó biết page nào không được sử dụng gần đây.<br />
Mấu chốt của việc “mô phỏng” reference bit là giảm overhead nhưng vẫn thu được thông tin tốt về việc sử dụng page. OS không được quá tích cực trong việc đánh dấu inaccessible (overhead sẽ cao), cũng không được quá thụ động (mọi page sẽ bị truy cập và OS lại không biết page nào nên loại bỏ).</p>
</blockquote>
<p>Để giải quyết hai vấn đề này, các nhà phát triển đã đưa ra <strong>segmented FIFO replacement policy</strong> [RL81]. Ý tưởng đơn giản: mỗi process có một số lượng page tối đa có thể giữ trong bộ nhớ, gọi là <strong>resident set size</strong> (RSS). Mỗi page này được giữ trong một danh sách FIFO; khi process vượt quá RSS, page “first-in” sẽ bị loại bỏ. FIFO rõ ràng không cần hỗ trợ phần cứng, nên dễ triển khai.</p>
<p>Tất nhiên, <strong>pure FIFO</strong> không hoạt động quá tốt, như chúng ta đã thấy. Để cải thiện hiệu năng của FIFO, VMS giới thiệu hai <strong>second-chance list</strong> (danh sách cơ hội thứ hai) toàn cục, nơi page được đặt trước khi bị loại bỏ khỏi bộ nhớ: một <strong>global clean-page free list</strong> và một <strong>dirty-page list</strong>. Khi process P vượt quá RSS, một page bị loại khỏi FIFO của process; nếu <strong>clean</strong> (không bị sửa đổi), nó được đặt vào cuối clean-page list; nếu <strong>dirty</strong> (bị sửa đổi), nó được đặt vào cuối dirty-page list.</p>
<p>Nếu process Q khác cần một page trống, nó lấy page đầu tiên từ global clean list. Tuy nhiên, nếu process P ban đầu bị <strong>page fault</strong> trên page đó trước khi nó bị thu hồi, P sẽ lấy lại page từ clean (hoặc dirty) list, tránh được một lần truy cập đĩa tốn kém. Các second-chance list toàn cục càng lớn, thuật toán segmented FIFO càng tiệm cận hiệu năng của LRU [RL81].</p>
<p>Một tối ưu hóa khác trong VMS cũng giúp khắc phục kích thước page nhỏ. Với page nhỏ như vậy, <strong>disk I/O</strong> trong quá trình swapping có thể kém hiệu quả, vì đĩa hoạt động tốt hơn với các lần truyền lớn. Để làm I/O swapping hiệu quả hơn, VMS bổ sung một số tối ưu hóa, quan trọng nhất là <strong>clustering</strong>. Với clustering, VMS nhóm các lô page lớn từ global dirty list và ghi chúng ra đĩa trong một lần (biến chúng thành clean). Clustering được sử dụng trong hầu hết các hệ thống hiện đại, vì khả năng đặt page ở bất kỳ đâu trong swap space để cho OS có thể nhóm các pages, perform những lần write lớn hơn với số lượng ít hơn, và từ đó cải thiện performance.</p>
<h3 id="các-thủ-thuật-thú-vị-khác-other-neat-tricks"><a class="header" href="#các-thủ-thuật-thú-vị-khác-other-neat-tricks">Các thủ thuật thú vị khác (Other Neat Tricks)</a></h3>
<p>VMS có hai thủ thuật khác, nay đã trở thành tiêu chuẩn: <strong>demand zeroing</strong> (khởi tạo trang bằng 0 khi cần) và <strong>copy-on-write</strong> (COW). Đây là những tối ưu hóa dạng “lười biếng” (lazy optimizations).</p>
<p>Một dạng “lười biếng” trong VMS (và hầu hết các hệ thống hiện đại) là <strong>demand zeroing</strong> các page. Để hiểu rõ hơn, hãy xét ví dụ thêm một page vào <strong>address space</strong> (không gian địa chỉ) của bạn, chẳng hạn trong <strong>heap</strong>. Trong một triển khai ngây thơ, OS sẽ đáp ứng yêu cầu thêm page vào heap bằng cách tìm một page trong <strong>physical memory</strong> (bộ nhớ vật lý), ghi toàn bộ bằng số 0 (yêu cầu này nhằm đảm bảo bảo mật; nếu không, bạn có thể thấy dữ liệu còn sót lại từ process khác đã dùng page này trước đó!), rồi ánh xạ nó vào address space của bạn (tức là thiết lập page table để trỏ tới physical page đó). Nhưng cách triển khai ngây thơ này có thể tốn kém, đặc biệt nếu page đó không bao giờ được process sử dụng.</p>
<p>Với <strong>demand zeroing</strong>, OS thay vào đó làm rất ít khi page được thêm vào address space; nó chỉ đặt một entry trong page table đánh dấu page là <strong>inaccessible</strong> (không thể truy cập). Nếu process sau đó đọc hoặc ghi vào page, một <strong>trap</strong> sẽ xảy ra và chuyển quyền điều khiển vào OS. Khi xử lý trap, OS nhận ra (thường thông qua một số bit được đánh dấu trong phần “reserved for OS” của page table entry) rằng đây thực chất là một demand-zero page; lúc này, OS mới thực hiện công việc cần thiết: tìm một physical page, ghi toàn bộ bằng 0, và ánh xạ nó vào address space của process. Nếu process không bao giờ truy cập page, toàn bộ công việc này được tránh, và đó chính là lợi ích của demand zeroing.</p>
<p>Một tối ưu hóa thú vị khác trong VMS (và gần như mọi OS hiện đại) là <strong>copy-on-write</strong> (COW). Ý tưởng, vốn xuất hiện ít nhất từ hệ điều hành <strong>TENEX</strong> [BB+72], rất đơn giản: khi OS cần sao chép một page từ address space này sang address space khác, thay vì sao chép, nó có thể ánh xạ page đó vào address space đích và đánh dấu <strong>read-only</strong> trong cả hai address space. Nếu cả hai chỉ đọc page này, không cần hành động gì thêm, và OS đã thực hiện một bản sao “nhanh” mà không di chuyển dữ liệu.</p>
<p>Tuy nhiên, nếu một trong hai address space thực sự cố ghi vào page, sẽ xảy ra trap vào OS. OS sẽ nhận ra đây là một COW page, và do đó (một cách lười biếng) cấp phát một page mới, sao chép dữ liệu vào đó, và ánh xạ page mới này vào address space của process gây fault. Process sau đó tiếp tục chạy và giờ có bản sao riêng của page.</p>
<p>COW hữu ích vì nhiều lý do. Bất kỳ dạng <strong>shared library</strong> (thư viện dùng chung) nào cũng có thể được ánh xạ copy-on-write vào address space của nhiều process, tiết kiệm bộ nhớ quý giá. Trong hệ thống UNIX, COW còn quan trọng hơn do ngữ nghĩa của <code>fork()</code> và <code>exec()</code>. Như bạn nhớ, <code>fork()</code> tạo một bản sao chính xác của address space của process gọi; với address space lớn, việc sao chép này chậm và tốn dữ liệu. Tệ hơn, hầu hết address space này sẽ bị ghi đè ngay sau đó bởi lệnh <code>exec()</code>, vốn thay thế address space của process gọi bằng address space của chương trình mới. Bằng cách thực hiện <code>fork()</code> theo kiểu copy-on-write, OS tránh được phần lớn việc sao chép không cần thiết, vẫn giữ đúng ngữ nghĩa và cải thiện hiệu năng.</p>
<blockquote>
<p><strong>TIP: BE LAZY</strong><br />
(Hãy “lười biếng”)<br />
Sự “lười biếng” có thể là một đức tính, cả trong cuộc sống lẫn trong hệ điều hành. Lười biếng có thể trì hoãn công việc đến sau, điều này có lợi trong OS vì nhiều lý do. Thứ nhất, trì hoãn công việc có thể giảm độ trễ của thao tác hiện tại, cải thiện khả năng phản hồi; ví dụ, OS thường báo rằng thao tác ghi file đã thành công ngay lập tức, và chỉ thực sự ghi ra đĩa sau đó ở chế độ nền. Thứ hai, quan trọng hơn, lười biếng đôi khi loại bỏ hoàn toàn nhu cầu làm việc đó; ví dụ, trì hoãn ghi cho đến khi file bị xóa sẽ loại bỏ luôn việc ghi. Lười biếng cũng tốt trong đời sống: ví dụ, trì hoãn làm bài tập OS có thể giúp bạn tránh lỗi trong đề bài nhờ bạn học phát hiện; tuy nhiên, dự án khó mà bị hủy, nên quá lười có thể gây rắc rối, dẫn đến nộp muộn, điểm kém, và một giảng viên buồn. Đừng làm giảng viên buồn!</p>
</blockquote>
<h2 id="232-the-linux-virtual-memory-system"><a class="header" href="#232-the-linux-virtual-memory-system">23.2 The Linux Virtual Memory System</a></h2>
<p>(Hệ thống bộ nhớ ảo của Linux)</p>
<p>Giờ chúng ta sẽ thảo luận một số khía cạnh thú vị của hệ thống VM của Linux. Việc phát triển Linux được thúc đẩy bởi các kỹ sư thực sự giải quyết các vấn đề thực tế gặp phải trong môi trường sản xuất, và do đó nhiều tính năng đã dần được tích hợp, tạo thành một hệ thống bộ nhớ ảo đầy đủ chức năng và giàu tính năng.</p>
<p>Chúng ta sẽ không thể bàn hết mọi khía cạnh của Linux VM, nhưng sẽ đề cập đến những điểm quan trọng nhất, đặc biệt là những nơi nó vượt xa các hệ thống VM cổ điển như VAX/VMS. Chúng ta cũng sẽ cố gắng chỉ ra những điểm chung giữa Linux và các hệ thống cũ.</p>
<p>Trong phần này, chúng ta sẽ tập trung vào Linux cho <strong>Intel x86</strong>. Mặc dù Linux có thể và thực sự chạy trên nhiều kiến trúc bộ xử lý khác nhau, Linux trên x86 là triển khai phổ biến và quan trọng nhất, và do đó là trọng tâm của chúng ta.</p>
<h3 id="the-linux-address-space"><a class="header" href="#the-linux-address-space">The Linux Address Space</a></h3>
<p>(Không gian địa chỉ của Linux)</p>
<p>Giống như các hệ điều hành hiện đại khác, và cũng giống VAX/VMS, một <strong>Linux virtual address space</strong><sup class="footnote-reference"><a href="#1">1</a></sup> gồm hai phần: <strong>user portion</strong> (phần người dùng — nơi chứa mã chương trình người dùng, stack, heap và các phần khác) và <strong>kernel portion</strong> (phần nhân — nơi chứa mã kernel, stack, heap và các phần khác). Giống các hệ thống khác, khi <strong>context switch</strong>, phần user của address space hiện tại sẽ thay đổi; phần kernel thì giống nhau giữa các process. Giống các hệ thống khác, một chương trình chạy ở <strong>user mode</strong> không thể truy cập các <strong>kernel virtual page</strong>; chỉ bằng cách trap vào kernel và chuyển sang <strong>privileged mode</strong> mới có thể truy cập bộ nhớ này.</p>
<p><img src="23/img/fig23_2.PNG" alt="" />
<strong>Figure 23.2: The Linux Address Space</strong><br />
<em>(Không gian địa chỉ của Linux)</em></p>
<p>Trong Linux 32-bit cổ điển (tức là Linux với virtual address space 32-bit), ranh giới giữa phần user và kernel nằm tại địa chỉ <code>0xC0000000</code>, tức là ở vị trí ba phần tư của address space. Do đó, các địa chỉ ảo từ <code>0</code> đến <code>0xBFFFFFFF</code> là <strong>user virtual address</strong>; các địa chỉ còn lại (<code>0xC0000000</code> đến <code>0xFFFFFFFF</code>) thuộc <strong>kernel virtual address space</strong>. Linux 64-bit có cách chia tương tự nhưng tại các điểm hơi khác. <em>Figure 23.2</em> minh họa một address space điển hình (đã giản lược).</p>
<p>Một điểm thú vị ở Linux là nó có hai loại <strong>kernel virtual address</strong>. Loại đầu tiên gọi là <strong>kernel logical addresses</strong> [O16]. Đây là phần bạn có thể coi là virtual address space “bình thường” của kernel; để có thêm bộ nhớ loại này, mã kernel chỉ cần gọi <code>kmalloc</code>. Hầu hết các cấu trúc dữ liệu của kernel nằm ở đây, như page table, <strong>per-process kernel stack</strong>, v.v. Không giống hầu hết bộ nhớ khác trong hệ thống, <strong>kernel logical memory</strong> không thể bị swap ra đĩa.</p>
<p>Điểm thú vị nhất của kernel logical addresses là mối liên hệ của chúng với physical memory. Cụ thể, có một ánh xạ trực tiếp giữa kernel logical addresses và phần đầu của physical memory. Ví dụ, kernel logical address <code>0xC0000000</code> ánh xạ tới physical address <code>0x00000000</code>, <code>0xC0000FFF</code> tới <code>0x00000FFF</code>, v.v. Ánh xạ trực tiếp này có hai hệ quả:</p>
<ol>
<li>Dễ dàng dịch qua lại giữa kernel logical address và physical address; do đó, các địa chỉ này thường được coi như địa chỉ vật lý.</li>
<li>Nếu một vùng bộ nhớ liên tục trong kernel logical address space, nó cũng liên tục trong physical memory. Điều này khiến bộ nhớ được cấp phát ở phần này của kernel address space phù hợp cho các thao tác cần physical memory liên tục để hoạt động đúng, chẳng hạn như truyền/nhận dữ liệu I/O giữa các thiết bị thông qua direct memory access (DMA) (Sẽ học trong phần 3 của cuốn sách này).</li>
</ol>
<p>Loại địa chỉ kernel còn lại là <strong>kernel virtual address</strong> (địa chỉ ảo của nhân). Để cấp phát bộ nhớ kiểu này, mã trong kernel sẽ gọi một bộ cấp phát khác, <code>vmalloc</code>, hàm này trả về một con trỏ tới một vùng bộ nhớ <strong>virtually contiguous</strong> (liên tục về mặt địa chỉ ảo) với kích thước mong muốn. Không giống như <strong>kernel logical memory</strong> (bộ nhớ logic của nhân), <strong>kernel virtual memory</strong> thường <strong>không liên tục</strong> trong bộ nhớ vật lý; mỗi <strong>kernel virtual page</strong> có thể ánh xạ tới các <strong>physical page</strong> không liền kề (và do đó không phù hợp cho <strong>DMA</strong> — Direct Memory Access). Tuy nhiên, chính vì vậy mà loại bộ nhớ này dễ cấp phát hơn, và thường được dùng cho các <strong>buffer</strong> lớn, nơi việc tìm một khối bộ nhớ vật lý lớn, liên tục là rất khó khăn.</p>
<p>Trong Linux 32-bit, một lý do khác cho sự tồn tại của kernel virtual address là nó cho phép kernel truy cập nhiều hơn (xấp xỉ) 1 GB bộ nhớ. Trước đây, máy tính có ít bộ nhớ hơn nhiều, nên việc truy cập quá 1 GB không phải là vấn đề. Tuy nhiên, công nghệ phát triển và sớm xuất hiện nhu cầu cho phép kernel sử dụng lượng bộ nhớ lớn hơn. Kernel virtual address, nhờ không bị ràng buộc bởi ánh xạ một-một nghiêm ngặt tới physical memory, đã giúp điều này khả thi. Tuy nhiên, với sự chuyển dịch sang Linux 64-bit, nhu cầu này ít cấp bách hơn, vì kernel không còn bị giới hạn chỉ trong 1 GB cuối của virtual address space.</p>
<h3 id="page-table-structure-cấu-trúc-bảng-trang"><a class="header" href="#page-table-structure-cấu-trúc-bảng-trang">Page Table Structure (Cấu trúc bảng trang)</a></h3>
<p>Vì chúng ta đang tập trung vào Linux trên kiến trúc x86, phần thảo luận sẽ xoay quanh loại cấu trúc <strong>page table</strong> mà x86 cung cấp, vì nó quyết định Linux có thể và không thể làm gì. Như đã đề cập, x86 cung cấp một cấu trúc page table nhiều cấp (<strong>multi-level page table</strong>) được phần cứng quản lý (<strong>hardware-managed</strong>), với một page table cho mỗi <strong>process</strong> (tiến trình); OS chỉ cần thiết lập các ánh xạ trong bộ nhớ, trỏ một thanh ghi đặc quyền (<strong>privileged register</strong>) tới đầu <strong>page directory</strong>, và phần cứng sẽ xử lý phần còn lại. OS tham gia, như mong đợi, khi tạo hoặc xóa process, và khi <strong>context switch</strong>, đảm bảo trong mỗi trường hợp rằng <strong>hardware MMU</strong> đang sử dụng đúng page table để thực hiện dịch địa chỉ.</p>
<p>Có lẽ thay đổi lớn nhất trong những năm gần đây là chuyển từ x86 32-bit sang x86 64-bit, như đã đề cập ngắn gọn ở trên. Giống như trong hệ thống VAX/VMS, <strong>32-bit address space</strong> đã tồn tại từ lâu, và khi công nghệ thay đổi, nó bắt đầu trở thành giới hạn thực sự cho các chương trình. <strong>Virtual memory</strong> giúp việc lập trình hệ thống trở nên dễ dàng, nhưng với các hệ thống hiện đại chứa nhiều GB bộ nhớ, 32 bit không còn đủ để tham chiếu tới tất cả. Do đó, bước nhảy tiếp theo là cần thiết.</p>
<p>Việc chuyển sang <strong>64-bit address</strong> ảnh hưởng đến cấu trúc page table trong x86 theo cách dễ đoán. Vì x86 sử dụng page table nhiều cấp, các hệ thống 64-bit hiện nay dùng <strong>bảng bốn cấp</strong> (four-level table). Tuy nhiên, toàn bộ không gian địa chỉ 64-bit chưa được sử dụng; mới chỉ dùng <strong>48 bit thấp</strong>. Do đó, một <strong>virtual address</strong> có thể được hình dung như sau:</p>
<p>...</p>
<p>Như có thể thấy trong hình minh họa, <strong>16 bit cao</strong> của virtual address không được sử dụng (và do đó không tham gia vào quá trình dịch địa chỉ), <strong>12 bit thấp</strong> (do kích thước page 4 KB) được dùng làm <strong>offset</strong> (vì vậy được sử dụng trực tiếp, không cần dịch), để lại <strong>36 bit ở giữa</strong> của virtual address tham gia vào quá trình dịch. Phần <strong>P1</strong> của địa chỉ được dùng để đánh chỉ số vào <strong>page directory</strong> cao nhất, và quá trình dịch tiếp tục từ đó, từng cấp một, cho đến khi page table thực sự được đánh chỉ số bởi <strong>P4</strong>, trả về <strong>page table entry</strong> mong muốn.</p>
<p>Khi dung lượng bộ nhớ hệ thống tiếp tục tăng, nhiều phần hơn của không gian địa chỉ khổng lồ này sẽ được kích hoạt, dẫn đến cấu trúc page table năm cấp, và cuối cùng là sáu cấp. Hãy tưởng tượng: một lần tra cứu page table đơn giản có thể cần tới sáu cấp dịch địa chỉ, chỉ để tìm vị trí của một dữ liệu nào đó trong bộ nhớ.</p>
<h3 id="large-page-support-hỗ-trợ-trang-lớn"><a class="header" href="#large-page-support-hỗ-trợ-trang-lớn">Large Page Support (Hỗ trợ trang lớn)</a></h3>
<p><strong>Intel x86</strong> cho phép sử dụng nhiều kích thước page, không chỉ page chuẩn 4 KB. Cụ thể, các thiết kế gần đây hỗ trợ page 2 MB và thậm chí 1 GB trong phần cứng. Do đó, theo thời gian, Linux đã phát triển để cho phép ứng dụng sử dụng các <strong>huge page</strong> (trang lớn, theo cách gọi trong thế giới Linux).</p>
<p>Việc sử dụng huge page, như đã gợi ý trước đó, mang lại nhiều lợi ích. Giống như trong VAX/VMS, điều này giúp giảm số lượng ánh xạ cần có trong page table; page càng lớn, số ánh xạ càng ít. Tuy nhiên, việc giảm số lượng <strong>page-table entry</strong> không phải là động lực chính của huge page; thay vào đó, lợi ích lớn nhất là <strong>cải thiện hành vi của TLB</strong> và hiệu năng liên quan. Khi một process sử dụng tích cực một lượng lớn bộ nhớ, nó nhanh chóng làm đầy TLB với các bản dịch địa chỉ. Nếu các bản dịch này là cho page 4 KB, chỉ một lượng nhỏ bộ nhớ tổng thể có thể được truy cập mà không gây ra <strong>TLB miss</strong>. Kết quả là, với các workload “big memory” hiện đại chạy trên máy có nhiều GB bộ nhớ, chi phí hiệu năng là đáng kể; nghiên cứu gần đây cho thấy một số ứng dụng tiêu tốn tới 10% chu kỳ CPU để xử lý TLB miss [B+13].</p>
<p>Huge page cho phép một process truy cập một vùng bộ nhớ lớn mà không gặp TLB miss, bằng cách sử dụng ít slot hơn trong TLB — đây là lợi ích chính. Ngoài ra, huge page còn có các lợi ích khác: đường xử lý khi TLB miss ngắn hơn, nghĩa là khi TLB miss xảy ra, nó được xử lý nhanh hơn. Thêm vào đó, việc cấp phát có thể khá nhanh (trong một số kịch bản), một lợi ích nhỏ nhưng đôi khi quan trọng.</p>
<blockquote>
<p><strong>TIP: CONSIDER INCREMENTALISM</strong><br />
(Hãy cân nhắc cách tiếp cận gia tăng)<br />
Nhiều khi trong cuộc sống, bạn được khuyến khích trở thành một nhà cách mạng. “Hãy nghĩ lớn!”, họ nói. “Hãy thay đổi thế giới!”, họ hô hào. Và bạn có thể thấy tại sao điều đó hấp dẫn; trong một số trường hợp, những thay đổi lớn là cần thiết, và vì vậy việc thúc đẩy mạnh mẽ cho chúng là hợp lý. Và nếu bạn thử theo cách này, ít nhất họ có thể sẽ ngừng la hét vào bạn.</p>
<p>Tuy nhiên, trong nhiều trường hợp, một cách tiếp cận chậm hơn, mang tính gia tăng có thể là điều đúng đắn nên làm. Ví dụ về <strong>Linux huge page</strong> trong chương này là một minh họa cho <strong>engineering incrementalism</strong> (cách tiếp cận kỹ thuật theo hướng gia tăng); thay vì giữ lập trường cứng nhắc và khẳng định rằng large page là tương lai, các nhà phát triển đã chọn cách tiếp cận thận trọng: trước tiên giới thiệu hỗ trợ chuyên biệt cho nó, tìm hiểu thêm về ưu và nhược điểm, và chỉ khi có lý do thực sự mới bổ sung hỗ trợ tổng quát cho tất cả ứng dụng.</p>
<p>Incrementalism, dù đôi khi bị coi thường, thường dẫn đến tiến bộ chậm rãi, có suy nghĩ và hợp lý. Khi xây dựng hệ thống, cách tiếp cận này có thể chính là điều bạn cần. Thực tế, điều này cũng có thể đúng trong cuộc sống.</p>
</blockquote>
<p>Một khía cạnh thú vị trong việc Linux hỗ trợ huge page là cách nó được triển khai theo hướng gia tăng. Ban đầu, các nhà phát triển Linux biết rằng hỗ trợ này chỉ quan trọng với một số ít ứng dụng, chẳng hạn như các <strong>large database</strong> (cơ sở dữ liệu lớn) có yêu cầu hiệu năng nghiêm ngặt. Do đó, quyết định được đưa ra là cho phép ứng dụng <strong>explicitly request</strong> (yêu cầu rõ ràng) cấp phát bộ nhớ với large page (thông qua call <code>mmap()</code> hoặc <code>shmget()</code>). Bằng cách này, hầu hết ứng dụng sẽ không bị ảnh hưởng (và tiếp tục chỉ sử dụng page 4 KB); một số ít ứng dụng đòi hỏi cao sẽ phải thay đổi để dùng các giao diện này, nhưng với chúng thì điều đó là xứng đáng.</p>
<p>Gần đây hơn, khi nhu cầu cải thiện hành vi của <strong>TLB</strong> trở nên phổ biến hơn ở nhiều ứng dụng, các nhà phát triển Linux đã bổ sung <strong>transparent huge page support</strong> (hỗ trợ large page trong suốt). Khi tính năng này được bật, hệ điều hành sẽ tự động tìm cơ hội để cấp phát huge page (thường là 2 MB, nhưng trên một số hệ thống là 1 GB) mà không cần sửa đổi ứng dụng.</p>
<p>Huge page không phải không có chi phí. Chi phí tiềm ẩn lớn nhất là <strong>internal fragmentation</strong> (phân mảnh bên trong), tức là một page lớn nhưng chỉ được sử dụng thưa thớt. Dạng lãng phí này có thể làm đầy bộ nhớ với các page lớn nhưng ít được dùng. <strong>Swapping</strong>, nếu được bật, cũng hoạt động không tốt với huge page, đôi khi làm tăng đáng kể lượng I/O mà hệ thống thực hiện. <strong>Overhead</strong> của việc cấp phát cũng có thể tệ (trong một số trường hợp khác). Nhìn chung, một điều rõ ràng: kích thước page 4 KB, vốn phục vụ hệ thống rất tốt trong nhiều năm, không còn là giải pháp phổ quát như trước; dung lượng bộ nhớ ngày càng tăng đòi hỏi chúng ta phải cân nhắc large page và các giải pháp khác như một phần của sự tiến hóa tất yếu của hệ thống <strong>VM</strong> (virtual memory). Việc Linux chậm rãi áp dụng công nghệ dựa trên phần cứng này là bằng chứng cho sự thay đổi sắp tới.</p>
<h3 id="the-page-cache"><a class="header" href="#the-page-cache">The Page Cache</a></h3>
<p>(Bộ nhớ đệm trang)</p>
<p>Để giảm chi phí truy cập <strong>persistent storage</strong> (lưu trữ lâu dài — nội dung trọng tâm của phần ba cuốn sách này), hầu hết các hệ thống sử dụng các <strong>caching subsystem</strong> (hệ thống con bộ nhớ đệm) mạnh mẽ để giữ các mục dữ liệu phổ biến trong bộ nhớ. Linux, về mặt này, không khác gì các hệ điều hành truyền thống.</p>
<p><strong>Linux page cache</strong> là thống nhất, giữ các page trong bộ nhớ từ ba nguồn chính:</p>
<ul>
<li><strong>Memory-mapped files</strong> (các tệp được ánh xạ vào bộ nhớ)</li>
<li><strong>File data</strong> và <strong>metadata</strong> từ thiết bị (thường được truy cập thông qua các call <code>read()</code> và <code>write()</code> tới <strong>file system</strong>)</li>
<li><strong>Heap</strong> và <strong>stack page</strong> tạo thành mỗi process (đôi khi gọi là <strong>anonymous memory</strong>, vì không có tệp được đặt tên bên dưới, mà thay vào đó là <strong>swap space</strong>).</li>
</ul>
<p>Các thực thể này được lưu trong một <strong>page cache hash table</strong>, cho phép tra cứu nhanh khi cần dữ liệu.</p>
<p>Page cache theo dõi xem các entry là <strong>clean</strong> (đã đọc nhưng chưa cập nhật) hay <strong>dirty</strong> (hay còn gọi là <strong>modified</strong> — đã sửa đổi). Dữ liệu dirty được ghi định kỳ ra <strong>backing store</strong> (tức là ra tệp cụ thể đối với dữ liệu tệp, hoặc ra swap space đối với vùng anonymous) bởi các <strong>background thread</strong> (luồng nền) gọi là <code>pdflush</code>, đảm bảo rằng dữ liệu đã sửa đổi cuối cùng sẽ được ghi trở lại lưu trữ lâu dài. Hoạt động nền này diễn ra sau một khoảng thời gian nhất định hoặc khi có quá nhiều page bị coi là dirty (cả hai đều là tham số cấu hình được).</p>
<p>Trong một số trường hợp, hệ thống bị thiếu bộ nhớ, và Linux phải quyết định page nào cần loại bỏ khỏi bộ nhớ để giải phóng không gian. Để làm điều này, Linux sử dụng một dạng sửa đổi của <strong>2Q replacement</strong> [JS94], được mô tả dưới đây.</p>
<p>Ý tưởng cơ bản rất đơn giản: <strong>standard LRU replacement</strong> (thay thế LRU tiêu chuẩn) hiệu quả, nhưng có thể bị phá vỡ bởi một số mẫu truy cập phổ biến. Ví dụ, nếu một process liên tục truy cập một tệp lớn (đặc biệt là tệp gần bằng hoặc lớn hơn kích thước bộ nhớ), LRU sẽ loại bỏ mọi tệp khác khỏi bộ nhớ. Tệ hơn: giữ lại một phần của tệp này trong bộ nhớ cũng không hữu ích, vì chúng không bao giờ được truy cập lại trước khi bị loại bỏ.</p>
<p>Phiên bản 2Q replacement của Linux giải quyết vấn đề này bằng cách giữ hai danh sách và chia bộ nhớ giữa chúng. Khi được truy cập lần đầu, một page được đặt vào một hàng đợi (gọi là <strong>A1</strong> trong bài báo gốc, nhưng là <strong>inactive list</strong> trong Linux); khi được truy cập lại, page được <strong>promote</strong> (thăng hạng) sang hàng đợi khác (gọi là <strong>Aq</strong> trong bài báo gốc, nhưng là <strong>active list</strong> trong Linux). Khi cần thay thế, ứng viên bị loại bỏ được lấy từ inactive list. Linux cũng định kỳ di chuyển các page từ cuối active list sang inactive list, giữ active list ở mức khoảng hai phần ba tổng kích thước page cache [G04].</p>
<p>Lý tưởng nhất, Linux sẽ quản lý các danh sách này theo thứ tự LRU hoàn hảo, nhưng như đã thảo luận ở các chương trước, làm như vậy là tốn kém. Do đó, giống như nhiều OS khác, một <strong>approximation of LRU</strong> (xấp xỉ LRU) — tương tự như <strong>clock replacement</strong> — được sử dụng.</p>
<p>Cách tiếp cận 2Q này nhìn chung hoạt động khá giống LRU, nhưng đặc biệt xử lý tốt trường hợp truy cập tuần hoàn một tệp lớn bằng cách giới hạn các page của truy cập tuần hoàn đó trong inactive list. Vì các page này không bao giờ được truy cập lại trước khi bị loại bỏ, chúng không làm “trôi” các page hữu ích khác trong active list ra khỏi bộ nhớ.</p>
<blockquote>
<p><strong>ASIDE: THE UBIQUITY OF MEMORY-MAPPING</strong><br />
(Tính phổ biến của kỹ thuật ánh xạ bộ nhớ)<br />
Kỹ thuật <strong>memory mapping</strong> (ánh xạ bộ nhớ) đã xuất hiện trước Linux nhiều năm, và được sử dụng ở nhiều nơi trong Linux cũng như các hệ thống hiện đại khác. Ý tưởng rất đơn giản: bằng cách gọi <code>mmap()</code> trên một <strong>file descriptor</strong> (bộ mô tả tệp) đã được mở, một <strong>process</strong> (tiến trình) sẽ nhận về một con trỏ trỏ tới phần đầu của một vùng <strong>virtual memory</strong> (bộ nhớ ảo) nơi nội dung của tệp được “đặt” vào. Sau đó, bằng cách sử dụng con trỏ này, process có thể truy cập bất kỳ phần nào của tệp chỉ bằng một thao tác <strong>pointer dereference</strong> (giải tham chiếu con trỏ).</p>
<p>Các truy cập tới những phần của tệp được ánh xạ bộ nhớ nhưng chưa được nạp vào bộ nhớ sẽ kích hoạt <strong>page fault</strong> (lỗi trang), tại thời điểm đó OS sẽ nạp (page in) dữ liệu liên quan và làm cho nó khả dụng bằng cách cập nhật <strong>page table</strong> (bảng trang) của process tương ứng (tức là <strong>demand paging</strong> — phân trang theo yêu cầu).</p>
<p>Mọi process Linux thông thường đều sử dụng memory-mapped file, ngay cả khi mã trong <code>main()</code> không trực tiếp gọi <code>mmap()</code>, bởi vì cách Linux nạp mã từ tệp thực thi và mã từ <strong>shared library</strong> (thư viện dùng chung) vào bộ nhớ. Dưới đây là kết quả (đã rút gọn nhiều) của công cụ dòng lệnh <code>pmap</code>, cho thấy các ánh xạ khác nhau tạo thành virtual address space của một chương trình đang chạy (trong ví dụ này là shell <code>tcsh</code>). Kết quả hiển thị bốn cột: địa chỉ ảo của ánh xạ, kích thước của nó, các <strong>protection bit</strong> (bit bảo vệ) của vùng, và nguồn của ánh xạ:</p>
<pre><code>0000000000400000     372K r-x-- tcsh
00000000019d5000    1780K rw-- [anon ]
00007f4e7cf06000    1792K r-x-- libc-2.23.so
00007f4e7d2d0000      36K r-x-- libcrypt-2.23.so
00007f4e7d508000     148K r-x-- libtinfo.so.5.9
00007f4e7d731000     152K r-x-- ld-2.23.so
00007f4e7d932000      16K rw-- [stack ]
</code></pre>
<p>Như bạn thấy từ kết quả này, mã từ tệp thực thi <code>tcsh</code>, cũng như mã từ <code>libc</code>, <code>libcrypt</code>, <code>libtinfo</code>, và mã từ <strong>dynamic linker</strong> (<code>ld.so</code>) đều được ánh xạ vào address space. Ngoài ra còn có hai vùng <strong>anonymous</strong> (ẩn danh): <strong>heap</strong> (mục thứ hai, được gắn nhãn <code>anon</code>) và <strong>stack</strong> (được gắn nhãn <code>stack</code>). Memory-mapped file cung cấp cho OS một cách đơn giản và hiệu quả để xây dựng một address space hiện đại.</p>
</blockquote>
<h3 id="security-and-buffer-overflows"><a class="header" href="#security-and-buffer-overflows">Security And Buffer Overflows</a></h3>
<p>(Bảo mật và tràn bộ đệm)</p>
<p>Có lẽ sự khác biệt lớn nhất giữa các hệ thống <strong>VM</strong> (virtual memory) hiện đại (Linux, Solaris, hoặc một trong các biến thể BSD) và các hệ thống cũ (VAX/VMS) là sự nhấn mạnh vào <strong>security</strong> (bảo mật) trong thời đại ngày nay. <strong>Protection</strong> (bảo vệ) luôn là một mối quan tâm nghiêm túc đối với hệ điều hành, nhưng với việc các máy tính ngày càng kết nối nhiều hơn, không có gì ngạc nhiên khi các nhà phát triển đã triển khai nhiều biện pháp phòng thủ để ngăn chặn những hacker tinh vi chiếm quyền điều khiển hệ thống.</p>
<p>Một mối đe dọa lớn là <strong>buffer overflow attack</strong> (tấn công tràn bộ đệm)<sup class="footnote-reference"><a href="#2">2</a></sup>, có thể được sử dụng chống lại các chương trình người dùng thông thường và thậm chí cả kernel. Ý tưởng của các cuộc tấn công này là tìm một lỗi trong hệ thống mục tiêu cho phép kẻ tấn công chèn dữ liệu tùy ý vào address space của mục tiêu. Những lỗ hổng như vậy đôi khi xuất hiện vì lập trình viên <strong>giả định sai</strong> rằng một đầu vào sẽ không quá dài, và do đó (một cách tin tưởng) sao chép đầu vào vào một buffer; vì đầu vào thực tế quá dài, nó tràn ra ngoài buffer, ghi đè lên vùng nhớ của mục tiêu. Đoạn code tưởng chừng vô hại dưới đây có thể là nguồn gốc của vấn đề:</p>
<pre><code class="language-c">int some_function(char *input) {
    char dest_buffer[100];
    strcpy(dest_buffer, input); // oops, unbounded copy!
}
</code></pre>
<p>Trong nhiều trường hợp, một tràn bộ đệm như vậy không gây hậu quả nghiêm trọng, ví dụ: dữ liệu đầu vào xấu được đưa vào một chương trình người dùng hoặc thậm chí OS có thể chỉ khiến nó bị crash, nhưng không tệ hơn. Tuy nhiên, các lập trình viên độc hại có thể cẩn thận tạo ra dữ liệu đầu vào tràn bộ đệm để chèn mã của riêng họ vào hệ thống mục tiêu, về cơ bản cho phép họ chiếm quyền điều khiển và thực thi ý đồ riêng. Nếu tấn công thành công vào một chương trình người dùng có kết nối mạng, kẻ tấn công có thể chạy các tính toán tùy ý hoặc thậm chí “cho thuê” chu kỳ CPU của hệ thống bị xâm nhập; nếu tấn công thành công vào chính hệ điều hành, cuộc tấn công có thể truy cập nhiều tài nguyên hơn nữa, và đây là một dạng <strong>privilege escalation</strong> (leo thang đặc quyền — tức là mã người dùng giành được quyền truy cập của kernel). Như bạn có thể đoán, đây đều là những điều <strong>rất tệ</strong>.</p>
<p>Biện pháp phòng thủ đầu tiên và đơn giản nhất chống lại buffer overflow là ngăn chặn việc thực thi bất kỳ mã nào nằm trong một số vùng nhất định của address space (ví dụ: trong stack). <strong>NX bit</strong> (No-eXecute), được AMD giới thiệu vào phiên bản x86 của họ (Intel cũng có bit tương tự gọi là <strong>XD bit</strong>), là một biện pháp như vậy; nó chỉ đơn giản ngăn việc thực thi từ bất kỳ page nào có bit này được đặt trong page table entry tương ứng. Cách tiếp cận này ngăn mã được kẻ tấn công chèn vào stack của mục tiêu khỏi bị thực thi, và do đó giảm thiểu vấn đề.</p>
<p>Tuy nhiên, kẻ tấn công thông minh thì… rất thông minh, và ngay cả khi mã chèn vào không thể được thêm trực tiếp, các chuỗi lệnh tùy ý vẫn có thể được thực thi bởi mã độc. Ý tưởng này, ở dạng tổng quát nhất, được gọi là <strong>return-oriented programming</strong> (ROP) [S07], và thực sự là một kỹ thuật rất tinh vi. Quan sát đằng sau ROP là trong bất kỳ address space của chương trình nào cũng có rất nhiều đoạn code nhỏ (gọi là <strong>gadget</strong> trong thuật ngữ ROP), đặc biệt là các chương trình C liên kết với thư viện C khổng lồ. Do đó, kẻ tấn công có thể ghi đè stack sao cho <strong>return address</strong> trong hàm đang thực thi trỏ tới một lệnh độc hại mong muốn (hoặc một chuỗi lệnh), theo sau là một lệnh <code>return</code>. Bằng cách xâu chuỗi một số lượng lớn gadget (tức là đảm bảo mỗi lệnh <code>return</code> nhảy tới gadget tiếp theo), kẻ tấn công có thể thực thi mã tùy ý. Thật đáng kinh ngạc!</p>
<p>Để phòng chống ROP (bao gồm cả dạng trước đó là <strong>return-to-libc attack</strong> [S+04]), Linux (và các hệ thống khác) bổ sung một biện pháp phòng thủ khác, gọi là <strong>address space layout randomization</strong> (ASLR). Thay vì đặt code, stack và heap ở các vị trí cố định trong virtual address space, OS sẽ <strong>randomize</strong> (ngẫu nhiên hóa) vị trí của chúng, khiến việc tạo ra chuỗi mã phức tạp cần thiết để thực hiện loại tấn công này trở nên khó khăn hơn nhiều. Hầu hết các cuộc tấn công vào chương trình người dùng dễ bị tổn thương sẽ chỉ gây crash, nhưng không thể chiếm quyền điều khiển chương trình đang chạy.</p>
<p>Điều thú vị là bạn có thể quan sát sự ngẫu nhiên này trong thực tế khá dễ dàng. Dưới đây là một đoạn code minh họa điều đó trên một hệ thống Linux hiện đại:</p>
<p>Đoạn code này chỉ đơn giản in ra địa chỉ (ảo) của một biến trên <strong>stack</strong>. Trong các hệ thống cũ không có <strong>ASLR</strong> (Address Space Layout Randomization — ngẫu nhiên hóa bố cục không gian địa chỉ), giá trị này sẽ giống nhau mỗi lần chạy. Nhưng như bạn thấy bên dưới, giá trị thay đổi theo từng lần chạy:</p>
<pre><code>prompt&gt; ./random
0x7ffd3e55d2b4
prompt&gt; ./random
0x7ffe1033b8f4
prompt&gt; ./random
0x7ffe45522e94
</code></pre>
<p><strong>ASLR</strong> là một cơ chế phòng thủ hữu ích đến mức nó đã được tích hợp cả vào <strong>kernel</strong>, trong một tính năng có tên khá trực diện là <strong>kernel address space layout randomization</strong> (<strong>KASLR</strong>). Tuy nhiên, hóa ra kernel còn có những vấn đề bảo mật lớn hơn cần xử lý, như chúng ta sẽ bàn tiếp theo.</p>
<h3 id="other-security-problems-meltdown-and-spectre"><a class="header" href="#other-security-problems-meltdown-and-spectre">Other Security Problems: Meltdown And Spectre</a></h3>
<p>(Các vấn đề bảo mật khác: Meltdown và Spectre)</p>
<p>Tại thời điểm viết những dòng này (tháng 8 năm 2018), thế giới <strong>systems security</strong> (bảo mật hệ thống) đã bị đảo lộn bởi hai cuộc tấn công mới và có liên quan đến nhau. Cuộc tấn công đầu tiên được gọi là <strong>Meltdown</strong>, và cuộc thứ hai là <strong>Spectre</strong>. Chúng được phát hiện gần như cùng lúc bởi bốn nhóm nhà nghiên cứu/kỹ sư khác nhau, và đã dẫn đến những nghi vấn sâu sắc về các cơ chế bảo vệ cơ bản mà phần cứng máy tính và hệ điều hành cung cấp. Xem <code>spectreattack.com</code> để đọc các bài báo mô tả chi tiết từng cuộc tấn công; <strong>Spectre</strong> được xem là vấn đề nghiêm trọng hơn trong hai cái.</p>
<p>Điểm yếu chung bị khai thác trong cả hai cuộc tấn công này là việc các <strong>CPU</strong> trong hệ thống hiện đại thực hiện nhiều kỹ thuật “hậu trường” phức tạp để cải thiện hiệu năng. Một lớp kỹ thuật nằm ở trung tâm của vấn đề được gọi là <strong>speculative execution</strong> (thực thi dự đoán), trong đó CPU đoán các lệnh nào sẽ được thực thi trong tương lai gần và bắt đầu thực thi chúng trước. Nếu dự đoán đúng, chương trình chạy nhanh hơn; nếu sai, CPU sẽ hoàn tác các tác động của chúng lên <strong>architectural state</strong> (trạng thái kiến trúc — ví dụ: các thanh ghi) và thử lại, lần này đi theo nhánh đúng.</p>
<p>Vấn đề với speculative execution là nó thường để lại dấu vết của quá trình thực thi trong nhiều thành phần của hệ thống, như <strong>processor cache</strong>, <strong>branch predictor</strong>, v.v. Và đây chính là vấn đề: như các tác giả của các cuộc tấn công đã chỉ ra, trạng thái này có thể khiến nội dung bộ nhớ bị lộ, ngay cả những vùng bộ nhớ mà chúng ta nghĩ rằng đã được <strong>MMU</strong> bảo vệ.</p>
<p>Một hướng tiếp cận để tăng cường bảo vệ kernel là loại bỏ càng nhiều càng tốt phần kernel address space khỏi mỗi user process và thay vào đó sử dụng một <strong>kernel page table</strong> riêng cho hầu hết dữ liệu của kernel (gọi là <strong>kernel page-table isolation</strong>, hay <strong>KPTI</strong>) [G+17]. Như vậy, thay vì ánh xạ mã và cấu trúc dữ liệu của kernel vào mỗi process, chỉ giữ lại phần tối thiểu cần thiết; khi chuyển vào kernel, hệ thống sẽ chuyển sang kernel page table. Cách làm này cải thiện bảo mật và tránh được một số hướng tấn công, nhưng phải trả giá: hiệu năng. Việc chuyển đổi page table là tốn kém. Đó chính là cái giá của bảo mật: sự tiện lợi và hiệu suất.</p>
<p>Đáng tiếc, KPTI không giải quyết được tất cả các vấn đề bảo mật đã nêu ở trên, chỉ một phần trong số đó. Và các giải pháp đơn giản như tắt speculative execution sẽ không hợp lý, vì hệ thống sẽ chạy chậm hơn hàng nghìn lần. Vì vậy, đây là một thời điểm thú vị để sống, nếu bạn quan tâm đến bảo mật hệ thống.</p>
<p>Để thực sự hiểu các cuộc tấn công này, bạn (có lẽ) sẽ phải học thêm nhiều điều trước tiên. Hãy bắt đầu bằng việc tìm hiểu <strong>kiến trúc máy tính hiện đại</strong>, như được trình bày trong các sách nâng cao về chủ đề này, tập trung vào speculative execution và tất cả các cơ chế cần thiết để triển khai nó. Chắc chắn hãy đọc về các cuộc tấn công Meltdown và Spectre tại các trang web đã đề cập ở trên; chúng cũng bao gồm phần giới thiệu hữu ích về speculative execution, vì vậy có thể là điểm khởi đầu không tồi. Và hãy nghiên cứu hệ điều hành để tìm thêm các lỗ hổng tiềm ẩn. Ai biết được còn những vấn đề gì đang tồn tại?</p>
<h2 id="233-summary"><a class="header" href="#233-summary">23.3 Summary</a></h2>
<p>(Tóm tắt)</p>
<p>Bạn vừa xem một cái nhìn tổng quan từ trên xuống dưới về hai hệ thống <strong>virtual memory</strong> (bộ nhớ ảo). Hy vọng rằng hầu hết các chi tiết đều dễ theo dõi, vì bạn đã có hiểu biết tốt về các cơ chế và chính sách cơ bản. Thông tin chi tiết hơn về VAX/VMS có trong bài báo xuất sắc (và ngắn gọn) của <strong>Levy</strong> và <strong>Lipman</strong> [LL82]. Chúng tôi khuyến khích bạn đọc nó, vì đây là cách tuyệt vời để thấy được nguồn tài liệu gốc đằng sau các chương này.</p>
<p>Bạn cũng đã tìm hiểu đôi chút về Linux. Dù là một hệ thống lớn và phức tạp, nó kế thừa nhiều ý tưởng hay từ quá khứ, nhiều ý tưởng trong số đó chúng tôi chưa có dịp bàn chi tiết. Ví dụ, Linux thực hiện <strong>lazy copy-on-write</strong> khi sao chép page trong <code>fork()</code>, nhờ đó giảm overhead bằng cách tránh sao chép không cần thiết. Linux cũng <strong>demand zero</strong> các page (sử dụng memory-mapping của thiết bị <code>/dev/zero</code>), và có một <strong>background swap daemon</strong> (<code>swapd</code>) để hoán đổi page ra đĩa nhằm giảm áp lực bộ nhớ. Thật vậy, hệ thống VM chứa đầy những ý tưởng hay được lấy từ quá khứ, đồng thời cũng bao gồm nhiều cải tiến riêng.</p>
<p>Để tìm hiểu thêm, hãy tham khảo những cuốn sách hợp lý (nhưng tiếc là đã lỗi thời) [BC05, G04]. Chúng tôi khuyến khích bạn tự đọc, vì chúng tôi chỉ có thể cung cấp một giọt nước trong đại dương phức tạp này. Nhưng, bạn phải bắt đầu từ đâu đó. Và, “một đại dương chẳng qua cũng chỉ là tập hợp của vô số giọt nước” [M04].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="26-tính-đồng-thời-giới-thiệu-concurrency-an-introduction"><a class="header" href="#26-tính-đồng-thời-giới-thiệu-concurrency-an-introduction">26 Tính đồng thời: Giới thiệu (Concurrency: An Introduction)</a></h1>
<p>Cho đến nay, chúng ta đã tìm hiểu sự phát triển của các <strong>abstraction</strong> (trừu tượng hóa) cơ bản mà <strong>OS</strong> (hệ điều hành) thực hiện. Chúng ta đã thấy cách biến một <strong>physical CPU</strong> (CPU vật lý) thành nhiều <strong>virtual CPU</strong> (CPU ảo), từ đó tạo ra ảo tưởng rằng nhiều chương trình đang chạy đồng thời. Chúng ta cũng đã thấy cách tạo ra ảo tưởng về một <strong>virtual memory</strong> (bộ nhớ ảo) lớn và riêng tư cho mỗi <strong>process</strong> (tiến trình); abstraction của <strong>address space</strong> (không gian địa chỉ) này cho phép mỗi chương trình hoạt động như thể nó có bộ nhớ riêng, trong khi thực tế OS đang bí mật <strong>multiplexing</strong> (đa hợp) các address space trên physical memory (và đôi khi cả đĩa).</p>
<p>Trong chương này, chúng ta giới thiệu một abstraction mới cho một process đang chạy: <strong>thread</strong> (luồng). Thay vì cách nhìn cổ điển về một <strong>điểm thực thi duy nhất</strong> trong chương trình (tức là một <strong>PC</strong> — program counter — nơi các lệnh được nạp và thực thi), một chương trình <strong>multi-threaded</strong> (đa luồng) có nhiều điểm thực thi (tức là nhiều PC, mỗi PC đang được nạp và thực thi). Một cách khác để hình dung là: mỗi thread gần giống như một process riêng biệt, ngoại trừ một điểm khác biệt: chúng <strong>chia sẻ cùng một address space</strong> và do đó có thể truy cập cùng dữ liệu.</p>
<p><strong>Trạng thái</strong> của một thread đơn lẻ rất giống với trạng thái của một process. Nó có một <strong>program counter (PC)</strong> để theo dõi vị trí chương trình đang nạp lệnh. Mỗi thread có tập <strong>register</strong> (thanh ghi) riêng để thực hiện tính toán; do đó, nếu có hai thread chạy trên một CPU, khi chuyển từ thread này (T1) sang thread kia (T2), cần thực hiện <strong>context switch</strong> (chuyển ngữ cảnh). Context switch giữa các thread khá giống với context switch giữa các process, vì trạng thái register của T1 phải được lưu và trạng thái register của T2 phải được khôi phục trước khi chạy T2. Với process, chúng ta lưu trạng thái vào <strong>process control block (PCB)</strong>; bây giờ, chúng ta cần một hoặc nhiều <strong>thread control block (TCB)</strong> để lưu trạng thái của từng thread trong một process. Tuy nhiên, có một điểm khác biệt lớn trong context switch giữa thread so với process: <strong>address space vẫn giữ nguyên</strong> (tức là không cần chuyển đổi page table đang sử dụng).</p>
<p>Một khác biệt lớn khác giữa thread và process liên quan đến <strong>stack</strong>. Trong mô hình đơn giản về address space của một process cổ điển (mà giờ ta có thể gọi là <strong>single-threaded process</strong> — tiến trình đơn luồng), chỉ có một stack, thường nằm ở cuối address space (<em>Figure 26.1</em>, bên trái). Tuy nhiên, trong một <strong>multi-threaded process</strong>, mỗi thread chạy độc lập và tất nhiên có thể gọi vào nhiều <strong>routine</strong> (hàm con) khác nhau để thực hiện công việc. Thay vì một stack duy nhất trong address space, sẽ có <strong>một stack cho mỗi thread</strong>. Giả sử chúng ta có một multi-threaded process với hai thread; address space kết quả sẽ khác (<em>Figure 26.1</em>, bên phải).</p>
<p><img src="26/img/fig26_1.PNG" alt="" />
<strong>Figure 26.1: Single-Threaded And Multi-Threaded Address Spaces</strong><br />
<em>(Không gian địa chỉ của tiến trình đơn luồng và đa luồng)</em></p>
<p>Trong hình này, bạn có thể thấy hai stack nằm rải rác trong address space của process. Do đó, bất kỳ biến cấp phát trên stack, tham số, giá trị trả về, và các dữ liệu khác mà ta đặt trên stack sẽ được lưu trong cái gọi là <strong>thread-local storage</strong> (bộ nhớ cục bộ của luồng), tức là stack của thread tương ứng.</p>
<p>Bạn cũng có thể nhận thấy điều này phá vỡ bố cục address space “đẹp đẽ” trước đây. Trước kia, stack và heap có thể phát triển độc lập và chỉ gặp vấn đề khi hết không gian trong address space. Giờ đây, chúng ta không còn tình huống thuận lợi như vậy. May mắn thay, điều này thường không sao, vì stack thường không cần quá lớn (ngoại lệ là các chương trình sử dụng đệ quy sâu).</p>
<h2 id="261-tại-sao-sử-dụng-thread-why-use-threads"><a class="header" href="#261-tại-sao-sử-dụng-thread-why-use-threads">26.1 Tại sao sử dụng Thread? (Why Use Threads?)</a></h2>
<p>Trước khi đi sâu vào chi tiết về thread và một số vấn đề có thể gặp khi lập trình đa luồng, hãy trả lời một câu hỏi đơn giản hơn: <strong>Tại sao lại dùng thread?</strong></p>
<p>Hóa ra, có ít nhất <strong>hai lý do chính</strong> để bạn nên dùng thread.</p>
<p><strong>Lý do thứ nhất</strong> rất đơn giản: <strong>parallelism</strong> (tính song song). Hãy tưởng tượng bạn đang viết một chương trình thực hiện các phép toán trên các mảng rất lớn, ví dụ: cộng hai mảng lớn với nhau, hoặc tăng giá trị của mỗi phần tử trong mảng lên một lượng nào đó. Nếu bạn chạy trên một CPU duy nhất, nhiệm vụ khá đơn giản: chỉ cần thực hiện từng phép toán và xong. Tuy nhiên, nếu bạn chạy chương trình trên một hệ thống có nhiều CPU, bạn có khả năng tăng tốc quá trình này đáng kể bằng cách để mỗi CPU thực hiện một phần công việc. Việc biến một chương trình đơn luồng tiêu chuẩn thành một chương trình thực hiện công việc này trên nhiều CPU được gọi là <strong>parallelization</strong> (song song hóa), và sử dụng một thread cho mỗi CPU để làm việc là cách tự nhiên và phổ biến để tăng tốc chương trình trên phần cứng hiện đại.</p>
<p><strong>Lý do thứ hai</strong> tinh tế hơn: <strong>tránh chặn tiến trình của chương trình do I/O chậm</strong>. Hãy tưởng tượng bạn đang viết một chương trình thực hiện nhiều loại I/O khác nhau: chờ gửi hoặc nhận tin nhắn, chờ một thao tác <strong>disk I/O</strong> (I/O đĩa) hoàn tất, hoặc thậm chí (ngầm) chờ một <strong>page fault</strong> được xử lý xong. Thay vì chờ đợi, chương trình của bạn có thể muốn làm việc khác, bao gồm tận dụng CPU để tính toán, hoặc thậm chí gửi thêm yêu cầu I/O khác. Sử dụng thread là cách tự nhiên để tránh bị “mắc kẹt”; khi một thread trong chương trình chờ (tức là bị <strong>blocked</strong> do I/O), <strong>CPU scheduler</strong> (bộ lập lịch CPU) có thể chuyển sang các thread khác đang sẵn sàng chạy và làm việc hữu ích. Threading cho phép <strong>overlap</strong> (chồng lấp) giữa I/O và các hoạt động khác trong cùng một chương trình, tương tự như <strong>multiprogramming</strong> (đa chương trình) đã làm cho các process giữa các chương trình; kết quả là nhiều ứng dụng server hiện đại (web server, hệ quản trị cơ sở dữ liệu, v.v.) sử dụng thread trong triển khai của chúng.</p>
<p>Tất nhiên, trong cả hai trường hợp trên, bạn <strong>có thể</strong> dùng nhiều process thay vì thread. Tuy nhiên, thread <strong>chia sẻ cùng một address space</strong> và do đó dễ dàng chia sẻ dữ liệu, vì vậy là lựa chọn tự nhiên khi xây dựng các loại chương trình này. Process là lựa chọn hợp lý hơn cho các tác vụ tách biệt về mặt logic, nơi ít cần chia sẻ cấu trúc dữ liệu trong bộ nhớ.</p>
<h2 id="262-ví-dụ-tạo-thread-an-example-thread-creation"><a class="header" href="#262-ví-dụ-tạo-thread-an-example-thread-creation">26.2 Ví dụ: Tạo Thread (An Example: Thread Creation)</a></h2>
<p>Bây giờ chúng ta đi vào một số chi tiết. Giả sử chúng ta muốn chạy một chương trình tạo ra hai <strong>thread</strong> (luồng), mỗi thread thực hiện một công việc độc lập, trong trường hợp này là in ra “A” hoặc “B”. Mã nguồn được thể hiện trong <em>Figure 26.2</em> (trang 4).</p>
<p><img src="26/img/fig26_2.PNG" alt="" />
<strong>Figure 26.2: Simple Thread Creation Code (t0.c)</strong></p>
<p>Chương trình <strong>main</strong> tạo ra hai thread (gọi là T1 và T2), mỗi thread sẽ chạy hàm <code>mythread()</code>, nhưng với các đối số khác nhau (chuỗi “A” hoặc “B”). Ngay khi một thread được tạo, nó có thể bắt đầu chạy ngay lập tức (tùy thuộc vào quyết định của <strong>scheduler</strong> — bộ lập lịch); hoặc nó có thể được đưa vào trạng thái “ready” (sẵn sàng) nhưng chưa “running” (đang chạy) và do đó chưa thực thi. Tất nhiên, trên một hệ thống <strong>multiprocessor</strong> (đa bộ xử lý), các thread thậm chí có thể chạy đồng thời, nhưng tạm thời chúng ta chưa xét đến khả năng này.</p>
<p>Sau khi tạo hai thread, <strong>main thread</strong> gọi <code>pthread_join()</code>, hàm này sẽ chờ một thread cụ thể hoàn thành. Lệnh này được gọi hai lần, đảm bảo T1 và T2 sẽ chạy và hoàn tất trước khi cho phép main thread chạy tiếp; khi đó, nó sẽ in ra “main: end” và thoát. Tổng cộng, ba thread được sử dụng trong lần chạy này: main thread, T1 và T2.</p>
<p>Hãy xem xét các khả năng sắp xếp thứ tự thực thi của chương trình nhỏ này. Trong sơ đồ thực thi (<em>Figure 26.3</em>, trang 5), thời gian tăng dần theo chiều từ trên xuống, và mỗi cột thể hiện thời điểm một thread khác nhau (main, Thread 1 hoặc Thread 2) đang chạy.</p>
<p><img src="26/img/fig26_3.PNG" alt="" />
<strong>Figure 26.3: Thread Trace (1)</strong></p>
<p>Tuy nhiên, cần lưu ý rằng thứ tự này không phải là thứ tự duy nhất có thể xảy ra. Thực tế, với một chuỗi lệnh, có khá nhiều khả năng, tùy thuộc vào việc scheduler quyết định chạy thread nào tại một thời điểm nhất định. Ví dụ, ngay khi một thread được tạo, nó có thể chạy ngay lập tức, dẫn đến thứ tự thực thi như trong <em>Figure 26.4</em> (trang 5).</p>
<p><img src="26/img/fig26_4.PNG" alt="" />
<strong>Figure 26.4: Thread Trace (2)</strong></p>
<p>Chúng ta thậm chí có thể thấy “B” được in trước “A”, nếu scheduler quyết định chạy Thread 2 trước, mặc dù Thread 1 được tạo trước; không có lý do gì để giả định rằng thread được tạo trước sẽ chạy trước. <em>Figure 26.5</em> (trang 6) cho thấy thứ tự thực thi này, với việc Thread 2 chạy trước Thread 1.</p>
<p><img src="26/img/fig26_5.PNG" alt="" />
<strong>Figure 26.5: Thread Trace (3)</strong></p>
<p>Như bạn có thể thấy, một cách để hình dung việc tạo thread là nó giống như gọi một hàm; tuy nhiên, thay vì thực thi hàm trước rồi mới quay lại hàm gọi, hệ thống sẽ tạo ra một <strong>thread of execution</strong> (luồng thực thi) mới cho routine được gọi, và nó chạy độc lập với hàm gọi, có thể trước khi <code>create</code> trả về, hoặc có thể muộn hơn nhiều. Thread nào chạy tiếp theo được quyết định bởi OS scheduler, và mặc dù scheduler có thể triển khai một thuật toán hợp lý, nhưng rất khó để biết chính xác thread nào sẽ chạy tại một thời điểm bất kỳ.</p>
<p>Bạn cũng có thể nhận ra từ ví dụ này rằng thread làm mọi thứ trở nên phức tạp: ngay cả việc xác định cái gì sẽ chạy khi nào cũng đã khó! Máy tính vốn đã khó hiểu nếu không có concurrency (tính đồng thời). Đáng tiếc là với concurrency, mọi thứ còn tệ hơn. Nhiều hơn thế nữa.</p>
<h2 id="263-tại-sao-mọi-thứ-tệ-hơn-dữ-liệu-chia-sẻ-why-it-gets-worse-shared-data"><a class="header" href="#263-tại-sao-mọi-thứ-tệ-hơn-dữ-liệu-chia-sẻ-why-it-gets-worse-shared-data">26.3 Tại sao mọi thứ tệ hơn: Dữ liệu chia sẻ (Why It Gets Worse: Shared Data)</a></h2>
<p>Ví dụ thread đơn giản ở trên hữu ích để minh họa cách tạo thread và cách chúng có thể chạy theo các thứ tự khác nhau tùy vào scheduler. Tuy nhiên, nó chưa cho thấy cách các thread tương tác khi truy cập <strong>shared data</strong> (dữ liệu chia sẻ).</p>
<p>Hãy tưởng tượng một ví dụ đơn giản, nơi hai thread muốn cập nhật một biến toàn cục dùng chung. Mã nguồn được nghiên cứu nằm trong <em>Figure 26.6</em> (trang 7).</p>
<p><img src="26/img/fig26_6.PNG" alt="" />
<strong>Figure 26.6: Sharing Data: Uh Oh (t1.c)</strong></p>
<p>Một vài ghi chú về mã nguồn:</p>
<ul>
<li>Thứ nhất, như Stevens gợi ý [SR05], chúng ta <strong>wrap</strong> (bao bọc) các routine tạo và join thread để thoát ngay khi gặp lỗi; với một chương trình đơn giản như thế này, chúng ta ít nhất muốn phát hiện lỗi (nếu có), nhưng không cần xử lý phức tạp (ví dụ: chỉ cần thoát). Do đó, <code>Pthread_create()</code> chỉ đơn giản gọi <code>pthread_create()</code> và đảm bảo mã trả về là 0; nếu không, <code>Pthread_create()</code> sẽ in thông báo và thoát.</li>
<li>Thứ hai, thay vì dùng hai hàm riêng cho các worker thread, chúng ta chỉ dùng một đoạn code và truyền đối số (ở đây là một chuỗi) để mỗi thread in ra một ký tự khác nhau trước thông điệp của nó.</li>
<li>Cuối cùng, và quan trọng nhất, chúng ta xem mỗi worker đang làm gì: cộng một số vào biến chia sẻ <code>counter</code>, và làm điều đó 10 triệu lần (1e7) trong vòng lặp. Kết quả mong muốn: <strong>20.000.000</strong>.</li>
</ul>
<p>Bây giờ, chúng ta biên dịch và chạy chương trình để xem hành vi:</p>
<p>Trường hợp mọi thứ diễn ra như mong đợi:</p>
<pre><code>prompt&gt; gcc -o main main.c -Wall -pthread; ./main
main: begin (counter = 0)
A: begin
B: begin
A: done
B: done
main: done with both (counter = 20000000)
</code></pre>
<p>Đáng tiếc, khi chạy chương trình này, ngay cả trên một CPU đơn, chúng ta <strong>không nhất thiết</strong> nhận được kết quả mong muốn. Đôi khi, kết quả là:</p>
<pre><code>prompt&gt; ./main
main: begin (counter = 0)
A: begin
B: begin
A: done
B: done
main: done with both (counter = 19345221)
</code></pre>
<p>Thử lại một lần nữa, chỉ để chắc rằng chúng ta không bị “ảo giác”. Rốt cuộc, chẳng phải máy tính được dạy là phải cho kết quả <strong>deterministic</strong> (xác định) sao?! Hay các giáo sư đã lừa chúng ta? (há hốc mồm)</p>
<pre><code>prompt&gt; ./main
main: begin (counter = 0)
A: begin
B: begin
A: done
B: done
main: done with both (counter = 19221041)
</code></pre>
<p>Không chỉ mỗi lần chạy đều <strong>sai</strong>, mà kết quả còn <strong>khác nhau</strong>! Câu hỏi lớn còn lại: <strong>Tại sao điều này xảy ra?</strong></p>
<blockquote>
<p><strong>TIP: KNOW AND USE YOUR TOOLS</strong><br />
(Biết và sử dụng thành thạo công cụ của bạn)<br />
Bạn nên luôn học các công cụ mới giúp viết, gỡ lỗi và hiểu hệ thống máy tính. Ở đây, chúng ta sử dụng một công cụ hữu ích gọi là <strong>disassembler</strong> (trình dịch ngược mã máy sang assembly). Khi bạn chạy một disassembler trên một tệp thực thi (<strong>executable</strong>), nó sẽ hiển thị các lệnh <strong>assembly</strong> tạo nên chương trình. Ví dụ, nếu chúng ta muốn hiểu đoạn code cấp thấp dùng để cập nhật biến <code>counter</code> (như trong ví dụ), ta chạy <code>objdump</code> (trên Linux) để xem mã assembly:</p>
<pre><code>prompt&gt; objdump -d main
</code></pre>
<p>Thao tác này sẽ tạo ra một danh sách dài tất cả các lệnh trong chương trình, được gắn nhãn rõ ràng (đặc biệt nếu bạn biên dịch với cờ <code>-g</code>), bao gồm cả thông tin <strong>symbol</strong> (ký hiệu) trong chương trình. Chương trình <code>objdump</code> chỉ là một trong nhiều công cụ bạn nên học cách sử dụng; một <strong>debugger</strong> như <code>gdb</code>, các <strong>memory profiler</strong> như <code>valgrind</code> hoặc <code>purify</code>, và tất nhiên là cả trình biên dịch (<strong>compiler</strong>) cũng là những công cụ khác mà bạn nên dành thời gian tìm hiểu thêm; bạn càng thành thạo công cụ, bạn càng có thể xây dựng được những hệ thống tốt hơn.</p>
</blockquote>
<h2 id="264-trọng-tâm-của-vấn-đề-lập-lịch-không-kiểm-soát-the-heart-of-the-problem-uncontrolled-scheduling"><a class="header" href="#264-trọng-tâm-của-vấn-đề-lập-lịch-không-kiểm-soát-the-heart-of-the-problem-uncontrolled-scheduling">26.4 Trọng tâm của vấn đề: Lập lịch không kiểm soát (The Heart Of The Problem: Uncontrolled Scheduling)</a></h2>
<p>Để hiểu tại sao điều này xảy ra, chúng ta phải hiểu chuỗi lệnh mà <strong>compiler</strong> (trình biên dịch) sinh ra để cập nhật <code>counter</code>. Trong trường hợp này, chúng ta chỉ muốn cộng thêm một số (1) vào <code>counter</code>. Do đó, chuỗi lệnh để thực hiện có thể trông như sau (trên kiến trúc x86):</p>
<pre><code class="language-assembly">mov 0x8049a1c, %eax
add $0x1, %eax
mov %eax, 0x8049a1c
</code></pre>
<p>Ví dụ này giả định rằng biến <code>counter</code> nằm tại địa chỉ <code>0x8049a1c</code>. Trong chuỗi ba lệnh này:</p>
<ul>
<li>Lệnh <code>mov</code> của x86 được dùng trước tiên để lấy giá trị từ bộ nhớ tại địa chỉ đó và đưa vào thanh ghi <code>eax</code>.</li>
<li>Sau đó, lệnh <code>add</code> được thực hiện, cộng 1 (<code>0x1</code>) vào nội dung của thanh ghi <code>eax</code>.</li>
<li>Cuối cùng, nội dung của <code>eax</code> được lưu trở lại bộ nhớ tại cùng địa chỉ.</li>
</ul>
<p>Hãy tưởng tượng một trong hai thread (Thread 1) đi vào đoạn code này, và chuẩn bị tăng <code>counter</code> lên một. Nó nạp giá trị của <code>counter</code> (giả sử ban đầu là 50) vào thanh ghi <code>eax</code>. Do đó, <code>eax = 50</code> đối với Thread 1. Sau đó, nó cộng thêm 1 vào thanh ghi; do đó <code>eax = 51</code>.</p>
<p>Bây giờ, một điều không may xảy ra: một <strong>timer interrupt</strong> (ngắt định thời) được kích hoạt; do đó, OS lưu trạng thái của thread đang chạy (PC, các thanh ghi bao gồm <code>eax</code>, v.v.) vào <strong>TCB</strong> (thread control block) của thread đó.</p>
<p>Tiếp theo, một điều tệ hơn xảy ra: Thread 2 được chọn để chạy, và nó cũng đi vào cùng đoạn code này. Nó cũng thực hiện lệnh đầu tiên, lấy giá trị của <code>counter</code> và đưa vào <code>eax</code> của nó (lưu ý: mỗi thread khi chạy có tập thanh ghi riêng; các thanh ghi này được “ảo hóa” bởi mã context switch lưu và khôi phục chúng). Giá trị của <code>counter</code> lúc này vẫn là 50, do đó Thread 2 có <code>eax = 50</code>. Giả sử Thread 2 thực hiện hai lệnh tiếp theo, tăng <code>eax</code> lên 1 (<code>eax = 51</code>), rồi lưu nội dung của <code>eax</code> vào <code>counter</code> (địa chỉ <code>0x8049a1c</code>). Như vậy, biến toàn cục <code>counter</code> giờ có giá trị 51.</p>
<p>Cuối cùng, một <strong>context switch</strong> khác xảy ra, và Thread 1 tiếp tục chạy. Nhớ rằng nó vừa thực hiện xong lệnh <code>mov</code> và <code>add</code>, và giờ chuẩn bị thực hiện lệnh <code>mov</code> cuối cùng. Cũng nhớ rằng <code>eax = 51</code>. Do đó, lệnh <code>mov</code> cuối cùng được thực thi, lưu giá trị vào bộ nhớ; <code>counter</code> được đặt thành 51 một lần nữa.</p>
<p>Nói ngắn gọn, điều đã xảy ra là: đoạn code tăng <code>counter</code> đã được chạy <strong>hai lần</strong>, nhưng <code>counter</code>, vốn bắt đầu ở 50, giờ chỉ bằng 51. Một phiên bản “đúng” của chương trình này lẽ ra phải khiến <code>counter</code> bằng 52.</p>
<p>Hãy xem một <strong>execution trace</strong> (vết thực thi) chi tiết để hiểu rõ hơn vấn đề. Giả sử, trong ví dụ này, đoạn code trên được nạp tại địa chỉ 100 trong bộ nhớ, như chuỗi sau (lưu ý cho những ai quen với các tập lệnh dạng RISC: x86 có lệnh độ dài biến đổi; lệnh <code>mov</code> này chiếm 5 byte bộ nhớ, và lệnh <code>add</code> chỉ chiếm 3 byte):</p>
<pre><code>100 mov 0x8049a1c, %eax
105 add $0x1, %eax
108 mov %eax, 0x8049a1c
</code></pre>
<p><img src="26/img/fig26_7.PNG" alt="" />
<strong>Figure 26.7: The Problem: Up Close and Personal</strong><br />
<em>(Vấn đề: Cận cảnh và chi tiết)</em></p>
<p>Với các giả định này, những gì xảy ra được minh họa trong <strong>Hình 26.7</strong> (trang 10). Giả sử biến <code>counter</code> bắt đầu với giá trị 50, và hãy lần theo ví dụ này để đảm bảo bạn hiểu điều gì đang diễn ra.</p>
<p>Những gì chúng ta vừa minh họa được gọi là <strong>race condition</strong> (điều kiện tranh chấp) — cụ thể hơn là <strong>data race</strong> (tranh chấp dữ liệu): kết quả phụ thuộc vào thời điểm thực thi của đoạn code. Với một chút “xui xẻo” (tức là <strong>context switch</strong> xảy ra tại những điểm không thuận lợi trong quá trình thực thi), chúng ta sẽ nhận kết quả sai. Thực tế, mỗi lần chạy có thể cho ra kết quả khác nhau; do đó, thay vì một phép tính <strong>deterministic</strong> (xác định) như chúng ta thường mong đợi từ máy tính, ta gọi kết quả này là <strong>indeterminate</strong> (không xác định), tức là không biết trước đầu ra sẽ là gì và rất có thể sẽ khác nhau giữa các lần chạy.</p>
<p>Bởi vì nhiều <strong>thread</strong> cùng thực thi đoạn code này có thể dẫn đến race condition, chúng ta gọi đoạn code này là một <strong>critical section</strong> (vùng tới hạn). Critical section là một đoạn code truy cập một biến chia sẻ (hoặc nói chung hơn là một tài nguyên chia sẻ) và <strong>không được phép</strong> thực thi đồng thời bởi nhiều hơn một thread.</p>
<p>Điều chúng ta thực sự muốn cho đoạn code này là <strong>mutual exclusion</strong> (loại trừ lẫn nhau). Tính chất này đảm bảo rằng nếu một thread đang thực thi bên trong critical section, các thread khác sẽ bị ngăn không cho làm điều đó.</p>
<p>Hầu như tất cả các thuật ngữ này, nhân tiện, đều được đặt ra bởi <strong>Edsger Dijkstra</strong>, một nhà tiên phong trong lĩnh vực này và đã giành giải <strong>Turing Award</strong> nhờ công trình này và các công trình khác; hãy xem bài báo năm 1968 của ông “Cooperating Sequential Processes” [D68] để có một mô tả cực kỳ rõ ràng về vấn đề. Chúng ta sẽ còn nhắc đến Dijkstra nhiều hơn trong phần này của sách.</p>
<blockquote>
<p><strong>TIP: USE ATOMIC OPERATIONS</strong><br />
(Sử dụng các thao tác nguyên tử)<br />
<strong>Atomic operations</strong> (các thao tác nguyên tử) là một trong những kỹ thuật nền tảng mạnh mẽ nhất trong việc xây dựng hệ thống máy tính, từ <strong>computer architecture</strong> (kiến trúc máy tính), đến <strong>concurrent code</strong> (mã đồng thời — như chúng ta đang học ở đây), đến <strong>file system</strong> (hệ thống tệp — mà chúng ta sẽ học sớm thôi), <strong>database management system</strong> (hệ quản trị cơ sở dữ liệu), và thậm chí cả <strong>distributed system</strong> (hệ thống phân tán) [L+93].</p>
<p>Ý tưởng đằng sau việc biến một chuỗi hành động thành nguyên tử có thể được diễn đạt đơn giản bằng cụm “tất cả hoặc không gì cả” (<strong>all or nothing</strong>); nghĩa là hoặc tất cả các hành động bạn muốn nhóm lại đều xảy ra, hoặc không hành động nào xảy ra, và không tồn tại trạng thái trung gian có thể nhìn thấy. Đôi khi, việc nhóm nhiều hành động thành một hành động nguyên tử duy nhất được gọi là <strong>transaction</strong> (giao dịch), một khái niệm được phát triển rất chi tiết trong lĩnh vực cơ sở dữ liệu và xử lý giao dịch [GR92].</p>
<p>Trong chủ đề nghiên cứu <strong>concurrency</strong> (tính đồng thời) của chúng ta, chúng ta sẽ sử dụng các <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa) để biến các chuỗi lệnh ngắn thành các <strong>atomic block</strong> (khối nguyên tử) khi thực thi, nhưng ý tưởng về tính nguyên tử còn rộng hơn nhiều, như chúng ta sẽ thấy. Ví dụ, file system sử dụng các kỹ thuật như <strong>journaling</strong> hoặc <strong>copy-on-write</strong> để chuyển đổi trạng thái trên đĩa một cách nguyên tử, điều này rất quan trọng để hệ thống hoạt động đúng khi gặp sự cố. Nếu điều này chưa rõ ràng, đừng lo — bạn sẽ hiểu ở các chương sau.</p>
</blockquote>
<h2 id="265-mong-muốn-về-tính-nguyên-tử-the-wish-for-atomicity"><a class="header" href="#265-mong-muốn-về-tính-nguyên-tử-the-wish-for-atomicity">26.5 Mong muốn về tính nguyên tử (The Wish For Atomicity)</a></h2>
<p>Một cách để giải quyết vấn đề này là có những lệnh mạnh mẽ hơn, có thể trong một bước duy nhất thực hiện chính xác những gì chúng ta cần và loại bỏ khả năng bị ngắt tại thời điểm không thích hợp. Ví dụ, giả sử chúng ta có một <strong>super instruction</strong> (siêu lệnh) như sau:</p>
<pre><code>memory-add 0x8049a1c, $0x1
</code></pre>
<p>Giả sử lệnh này cộng một giá trị vào một vị trí bộ nhớ, và phần cứng đảm bảo rằng nó được thực thi <strong>atomically</strong> (nguyên tử); khi lệnh được thực thi, nó sẽ thực hiện cập nhật như mong muốn. Nó không thể bị ngắt giữa chừng, bởi vì đó chính là đảm bảo mà phần cứng cung cấp: khi một ngắt xảy ra, hoặc lệnh chưa chạy chút nào, hoặc nó đã chạy xong hoàn toàn; không tồn tại trạng thái trung gian. Phần cứng thật tuyệt vời, đúng không?</p>
<p><strong>Atomically</strong> trong ngữ cảnh này nghĩa là “như một đơn vị” (<strong>as a unit</strong>), đôi khi được hiểu là “tất cả hoặc không gì cả” (<strong>all or none</strong>). Điều chúng ta muốn là thực thi nguyên tử chuỗi ba lệnh sau:</p>
<pre><code class="language-assembly">mov 0x8049a1c, %eax
add $0x1, %eax
mov %eax, 0x8049a1c
</code></pre>
<p>Như đã nói, nếu chúng ta có một lệnh duy nhất để làm điều này, ta chỉ cần phát lệnh đó và xong. Nhưng trong trường hợp tổng quát, chúng ta sẽ <strong>không</strong> có một lệnh như vậy. Hãy tưởng tượng chúng ta đang xây dựng một <strong>concurrent B-tree</strong> (cây B đồng thời) và muốn cập nhật nó; liệu chúng ta có thực sự muốn phần cứng hỗ trợ một lệnh “atomic update of B-tree” (cập nhật nguyên tử cây B) không? Có lẽ là không, ít nhất là trong một <strong>instruction set</strong> (tập lệnh) hợp lý.</p>
<p>Do đó, thay vào đó, chúng ta sẽ yêu cầu phần cứng cung cấp một vài lệnh hữu ích mà trên đó chúng ta có thể xây dựng một tập hợp tổng quát các <strong>synchronization primitive</strong>. Bằng cách sử dụng hỗ trợ phần cứng này, kết hợp với sự hỗ trợ từ hệ điều hành, chúng ta sẽ có thể xây dựng mã đa luồng truy cập các critical section một cách đồng bộ và có kiểm soát, từ đó tạo ra kết quả đúng một cách đáng tin cậy bất chấp bản chất đầy thách thức của thực thi đồng thời. Thật tuyệt vời, đúng không? Đây chính là vấn đề mà chúng ta sẽ nghiên cứu trong phần này của sách. Đây là một vấn đề vừa thú vị vừa khó, và sẽ khiến bạn “đau đầu” (một chút). Nếu không thấy “đau đầu”, nghĩa là bạn chưa hiểu! Hãy tiếp tục làm việc cho đến khi đầu bạn “đau”; khi đó, bạn biết mình đang đi đúng hướng. Và lúc đó, hãy nghỉ ngơi; chúng ta không muốn bạn đau đầu quá mức.</p>
<blockquote>
<p><strong>THE CRUX: HOW TO SUPPORT SYNCHRONIZATION</strong><br />
(Vấn đề cốt lõi: Làm thế nào để hỗ trợ đồng bộ hóa)<br />
Chúng ta cần sự hỗ trợ gì từ <strong>hardware</strong> (phần cứng) để xây dựng các <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa) hữu ích? Chúng ta cần sự hỗ trợ gì từ <strong>OS</strong> (hệ điều hành)? Làm thế nào để xây dựng các primitive này một cách đúng đắn và hiệu quả? Các chương trình có thể sử dụng chúng như thế nào để đạt được kết quả mong muốn?</p>
</blockquote>
<h2 id="266-một-vấn-đề-khác-chờ-đợi-luồng-khác-one-more-problem-waiting-for-another"><a class="header" href="#266-một-vấn-đề-khác-chờ-đợi-luồng-khác-one-more-problem-waiting-for-another">26.6 Một vấn đề khác: Chờ đợi luồng khác (One More Problem: Waiting For Another)</a></h2>
<p>Chương này đã thiết lập vấn đề <strong>concurrency</strong> (tính đồng thời) như thể chỉ có một loại tương tác xảy ra giữa các <strong>thread</strong> (luồng): đó là truy cập các biến chia sẻ và nhu cầu hỗ trợ <strong>atomicity</strong> (tính nguyên tử) cho các <strong>critical section</strong> (vùng tới hạn). Tuy nhiên, thực tế còn có một dạng tương tác phổ biến khác, khi một thread phải <strong>chờ</strong> một thread khác hoàn thành một hành động nào đó trước khi nó có thể tiếp tục.</p>
<p>Tương tác này xuất hiện, ví dụ, khi một <strong>process</strong> (tiến trình) thực hiện một thao tác <strong>disk I/O</strong> (I/O đĩa) và bị đưa vào trạng thái ngủ (<strong>sleep</strong>); khi I/O hoàn tất, process cần được đánh thức (<strong>wake up</strong>) để có thể tiếp tục.</p>
<p>Do đó, trong các chương tiếp theo, chúng ta sẽ không chỉ nghiên cứu cách xây dựng hỗ trợ cho synchronization primitive để đảm bảo atomicity, mà còn cả các cơ chế hỗ trợ dạng tương tác <strong>sleeping/waking</strong> (ngủ/thức) này — vốn rất phổ biến trong các chương trình đa luồng. Nếu hiện tại điều này chưa rõ ràng, cũng không sao! Bạn sẽ hiểu ngay khi đọc chương về <strong>condition variable</strong> (biến điều kiện). Nếu đến lúc đó vẫn chưa hiểu, thì… không ổn lắm, và bạn nên đọc lại chương đó (và đọc lại nhiều lần) cho đến khi hiểu.</p>
<blockquote>
<p><strong>ASIDE: KEY CONCURRENCY TERMS</strong><br />
(Các thuật ngữ then chốt về tính đồng thời)<br />
<strong>CRITICAL SECTION, RACE CONDITION, INDETERMINATE, MUTUAL EXCLUSION</strong></p>
<p>Bốn thuật ngữ này quan trọng đến mức chúng tôi muốn nêu rõ chúng ở đây. Xem một số công trình ban đầu của <strong>Dijkstra</strong> [D65, D68] để biết thêm chi tiết.</p>
<ul>
<li><strong>Critical section</strong>: một đoạn code truy cập một tài nguyên chia sẻ, thường là một biến hoặc cấu trúc dữ liệu.</li>
<li><strong>Race condition</strong> (hay <strong>data race</strong> [NM92]): xảy ra nếu nhiều thread cùng đi vào critical section gần như cùng lúc; cả hai đều cố gắng cập nhật cấu trúc dữ liệu chia sẻ, dẫn đến kết quả bất ngờ (và có thể không mong muốn).</li>
<li><strong>Indeterminate program</strong>: chương trình chứa một hoặc nhiều race condition; đầu ra của chương trình thay đổi giữa các lần chạy, tùy thuộc vào thread nào chạy khi nào. Kết quả vì thế không <strong>deterministic</strong> (xác định), điều mà chúng ta thường kỳ vọng ở hệ thống máy tính.</li>
<li>Để tránh các vấn đề này, thread nên sử dụng một dạng <strong>mutual exclusion primitive</strong>; điều này đảm bảo rằng chỉ một thread duy nhất được vào critical section tại một thời điểm, tránh race condition và tạo ra kết quả xác định.</li>
</ul>
</blockquote>
<h2 id="267-tóm-tắt-tại-sao-học-trong-môn-hệ-điều-hành-summary-why-in-os-class"><a class="header" href="#267-tóm-tắt-tại-sao-học-trong-môn-hệ-điều-hành-summary-why-in-os-class">26.7 Tóm tắt: Tại sao học trong môn Hệ điều hành? (Summary: Why in OS Class?)</a></h2>
<p>Trước khi kết thúc, có thể bạn sẽ hỏi: tại sao chúng ta lại học nội dung này trong môn Hệ điều hành? Câu trả lời ngắn gọn: <strong>“History”</strong> (lịch sử); OS là chương trình đồng thời đầu tiên, và nhiều kỹ thuật đã được tạo ra để sử dụng bên trong OS. Sau này, với sự xuất hiện của <strong>multi-threaded process</strong> (tiến trình đa luồng), lập trình viên ứng dụng cũng phải quan tâm đến những vấn đề này.</p>
<p>Ví dụ, hãy tưởng tượng trường hợp có hai process đang chạy. Giả sử cả hai đều gọi <code>write()</code> để ghi vào một tệp, và cả hai đều muốn <strong>append</strong> (nối thêm) dữ liệu vào tệp (tức là thêm dữ liệu vào cuối tệp, làm tăng kích thước của nó). Để làm được điều đó, cả hai phải:</p>
<ul>
<li>Cấp phát một <strong>block</strong> mới</li>
<li>Ghi vào <strong>inode</strong> của tệp vị trí block này</li>
<li>Thay đổi kích thước tệp để phản ánh kích thước mới lớn hơn<br />
(và một số thao tác khác; chúng ta sẽ tìm hiểu thêm về tệp trong phần ba của sách).</li>
</ul>
<p>Vì <strong>interrupt</strong> (ngắt) có thể xảy ra bất kỳ lúc nào, đoạn code cập nhật các cấu trúc chia sẻ này (ví dụ: <strong>bitmap</strong> cho việc cấp phát, hoặc inode của tệp) là <strong>critical section</strong>; do đó, các nhà thiết kế OS, ngay từ khi khái niệm interrupt được giới thiệu, đã phải lo lắng về cách OS cập nhật các cấu trúc nội bộ. Một interrupt xảy ra không đúng lúc sẽ gây ra tất cả các vấn đề đã mô tả ở trên.</p>
<p>Không có gì ngạc nhiên khi <strong>page table</strong>, <strong>process list</strong>, cấu trúc của file system, và hầu như mọi <strong>kernel data structure</strong> (cấu trúc dữ liệu của nhân) đều phải được truy cập một cách cẩn thận, với các synchronization primitive phù hợp, để hoạt động chính xác.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="27-phần-xen-kẽ-thread-api-interlude-thread-api"><a class="header" href="#27-phần-xen-kẽ-thread-api-interlude-thread-api">27 Phần xen kẽ: Thread API (Interlude: Thread API)</a></h1>
<p>Chương này trình bày ngắn gọn các phần chính của <strong>thread API</strong> (giao diện lập trình ứng dụng cho luồng). Mỗi phần sẽ được giải thích chi tiết hơn trong các chương tiếp theo, khi chúng ta minh họa cách sử dụng API. Thông tin chi tiết hơn có thể tìm thấy trong nhiều sách và nguồn trực tuyến [B89, B97, B+96, K+96]. Cần lưu ý rằng các chương tiếp theo sẽ giới thiệu các khái niệm về <strong>lock</strong> (khóa) và <strong>condition variable</strong> (biến điều kiện) một cách chậm rãi hơn, kèm nhiều ví dụ; do đó, chương này phù hợp hơn để dùng như tài liệu tham khảo.</p>
<blockquote>
<p><strong>CRUX: HOW TO CREATE AND CONTROL THREADS</strong><br />
(Vấn đề cốt lõi: Làm thế nào để tạo và điều khiển thread)<br />
OS nên cung cấp những <strong>interface</strong> (giao diện) nào để tạo và điều khiển thread? Các interface này nên được thiết kế như thế nào để vừa dễ sử dụng vừa hữu ích?</p>
</blockquote>
<h2 id="271-thread-creation-tạo-thread"><a class="header" href="#271-thread-creation-tạo-thread">27.1 Thread Creation (Tạo thread)</a></h2>
<p>Điều đầu tiên bạn cần làm để viết một chương trình <strong>multi-threaded</strong> (đa luồng) là tạo ra các thread mới, và do đó phải tồn tại một <strong>thread creation interface</strong> (giao diện tạo luồng). Trong <strong>POSIX</strong>, điều này khá đơn giản:</p>
<pre><code class="language-c">#include &lt;pthread.h&gt;
int pthread_create(pthread_t        *thread,
                   const pthread_attr_t *attr,
                   void             *(*start_routine)(void*),
                   void             *arg);
</code></pre>
<p>Khai báo này có thể trông hơi phức tạp (đặc biệt nếu bạn chưa từng dùng <strong>function pointer</strong> — con trỏ hàm — trong C), nhưng thực tế không quá khó. Có bốn tham số: <code>thread</code>, <code>attr</code>, <code>start_routine</code>, và <code>arg</code>.</p>
<ul>
<li>
<p>Tham số thứ nhất, <code>thread</code>, là một con trỏ tới cấu trúc kiểu <code>pthread_t</code>; chúng ta sẽ dùng cấu trúc này để tương tác với thread, và do đó cần truyền nó vào <code>pthread_create()</code> để khởi tạo.</p>
</li>
<li>
<p>Tham số thứ hai, <code>attr</code>, được dùng để chỉ định các <strong>attribute</strong> (thuộc tính) mà thread này có thể có. Ví dụ: thiết lập kích thước stack hoặc thông tin về <strong>scheduling priority</strong> (độ ưu tiên lập lịch) của thread. Một attribute được khởi tạo bằng một call riêng tới <code>pthread_attr_init()</code>; xem trang <strong>manual</strong> để biết chi tiết. Tuy nhiên, trong hầu hết các trường hợp, giá trị mặc định là đủ; trong trường hợp này, chúng ta chỉ cần truyền giá trị <code>NULL</code>.</p>
</li>
<li>
<p>Tham số thứ ba là phức tạp nhất, nhưng thực chất chỉ là câu hỏi: <strong>thread này sẽ bắt đầu chạy ở hàm nào?</strong> Trong C, đây là một function pointer, và ở đây nó cho biết điều sau: một tên hàm (<code>start_routine</code>), hàm này nhận một đối số duy nhất kiểu <code>void *</code> (như được chỉ ra trong dấu ngoặc đơn sau <code>start_routine</code>), và trả về một giá trị kiểu <code>void *</code> (tức là một con trỏ void).</p>
</li>
</ul>
<p>Nếu routine này thay vào đó yêu cầu một đối số kiểu <strong>integer</strong> thay vì void pointer, khai báo sẽ trông như sau:</p>
<pre><code class="language-c">int pthread_create(..., // hai tham số đầu giống nhau
                   void *(*start_routine)(int),
                   int arg);
</code></pre>
<p>Nếu routine nhận một void pointer làm đối số, nhưng trả về một integer, nó sẽ trông như sau:</p>
<pre><code class="language-c">int pthread_create(..., // hai tham số đầu giống nhau
                   int (*start_routine)(void *),
                   void *arg);
</code></pre>
<ul>
<li>Cuối cùng, tham số thứ tư, <code>arg</code>, chính là đối số sẽ được truyền vào hàm nơi thread bắt đầu thực thi. Bạn có thể hỏi: tại sao chúng ta cần các void pointer này? Câu trả lời khá đơn giản: việc có một void pointer làm đối số của hàm <code>start_routine</code> cho phép chúng ta truyền vào bất kỳ kiểu dữ liệu nào; việc có nó làm giá trị trả về cho phép thread trả về bất kỳ kiểu kết quả nào.</li>
</ul>
<p>Hãy xem một ví dụ trong <strong>Hình 27.1</strong>. Ở đây, chúng ta chỉ tạo một thread được truyền hai đối số, được đóng gói vào một kiểu dữ liệu do chúng ta tự định nghĩa (<code>myarg_t</code>). Thread, khi được tạo, có thể đơn giản <strong>cast</strong> (ép kiểu) đối số của nó sang kiểu mong đợi và giải nén các đối số theo ý muốn.</p>
<p><img src="27/img/fig27_1.PNG" alt="" /></p>
<p><strong>Hình 27.1: Tạo một Thread</strong></p>
<p>Và đó là nó! Khi bạn tạo một thread, bạn thực sự đã có thêm một thực thể đang thực thi độc lập, với <strong>call stack</strong> (ngăn xếp call hàm) riêng của nó, chạy trong cùng <strong>address space</strong> (không gian địa chỉ) với tất cả các thread hiện có trong chương trình. Và từ đây, “cuộc vui” bắt đầu!</p>
<h2 id="272-hoàn-thành-thread-thread-completion"><a class="header" href="#272-hoàn-thành-thread-thread-completion">27.2 Hoàn thành Thread (Thread Completion)</a></h2>
<p>Ví dụ ở trên cho thấy cách tạo một thread. Tuy nhiên, điều gì sẽ xảy ra nếu bạn muốn <strong>chờ</strong> một thread hoàn thành? Bạn cần làm một việc đặc biệt để chờ hoàn tất; cụ thể, bạn phải gọi hàm <code>pthread_join()</code>.</p>
<pre><code class="language-c">int pthread_join(pthread_t thread, void **value_ptr);
</code></pre>
<p>Hàm này nhận hai tham số:</p>
<ul>
<li>
<p>Tham số thứ nhất có kiểu <code>pthread_t</code>, được dùng để chỉ định <strong>thread</strong> mà bạn muốn chờ. Biến này được khởi tạo bởi hàm tạo thread (khi bạn truyền con trỏ tới nó làm đối số cho <code>pthread_create()</code>); nếu bạn giữ lại biến này, bạn có thể dùng nó để chờ thread đó kết thúc.</p>
</li>
<li>
<p>Tham số thứ hai là một con trỏ tới giá trị trả về mà bạn muốn nhận lại. Vì hàm này có thể trả về bất kỳ thứ gì, nó được định nghĩa để trả về một con trỏ kiểu <code>void</code>; và vì <code>pthread_join()</code> sẽ thay đổi giá trị của đối số được truyền vào, bạn cần truyền vào <strong>con trỏ tới giá trị đó</strong>, chứ không chỉ giá trị.</p>
</li>
</ul>
<p>Hãy xem một ví dụ khác (<strong>Hình 27.2</strong>, trang 4). Trong đoạn code này, một thread được tạo, và được truyền một vài đối số thông qua cấu trúc <code>myarg_t</code>. Để trả về giá trị, kiểu <code>myret_t</code> được sử dụng. Khi thread kết thúc, <strong>main thread</strong>, vốn đang chờ bên trong <code>pthread_join()</code><sup class="footnote-reference"><a href="#1">1</a></sup>, sẽ tiếp tục chạy, và chúng ta có thể truy cập các giá trị trả về từ thread, cụ thể là những gì nằm trong <code>myret_t</code>.</p>
<pre><code class="language-c">typedef struct { int a; int b; } myarg_t;
typedef struct { int x; int y; } myret_t;

void *mythread(void *arg) {
  myret_t *rvals = Malloc(sizeof(myret_t));
  rvals-&gt;x = 1;
  rvals-&gt;y = 2;
  return (void *) rvals;
}

int main(int argc, char *argv[]) {
  pthread_t p;
  myret_t *rvals;
  myarg_t args = { 10, 20 };
  Pthread_create(&amp;p, NULL, mythread, &amp;args);
  Pthread_join(p, (void **) &amp;rvals);
  printf(&quot;returned %d %d\n&quot;, rvals-&gt;x, rvals-&gt;y);
  free(rvals);
  return 0;
}
</code></pre>
<p><img src="27/img/fig27_2.PNG" alt="" /></p>
<p><strong>Hình 27.2: Chờ Thread hoàn thành</strong></p>
<p>Một vài điểm cần lưu ý về ví dụ này:</p>
<ul>
<li>Thứ nhất, nhiều khi chúng ta không cần phải đóng gói và giải nén đối số phức tạp như vậy. Ví dụ, nếu chỉ tạo một thread <strong>không có đối số</strong>, ta có thể truyền <code>NULL</code> khi tạo thread. Tương tự, ta có thể truyền <code>NULL</code> vào <code>pthread_join()</code> nếu không quan tâm đến giá trị trả về.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Lưu ý rằng chúng ta sử dụng <strong>wrapper function</strong> ở đây; cụ thể, chúng ta gọi <code>Malloc()</code>, <code>Pthread_join()</code>, và <code>Pthread_create()</code>, vốn chỉ gọi các phiên bản chữ thường tương ứng và đảm bảo các hàm này không trả về giá trị bất thường.</p>
</div>
<ul>
<li>Thứ hai, nếu chỉ truyền một giá trị duy nhất (ví dụ: một <code>long long int</code>), ta không cần đóng gói nó thành cấu trúc. <strong>Hình 27.3</strong> (trang 5) cho thấy ví dụ. Trong trường hợp này, mọi thứ đơn giản hơn, vì ta không cần đóng gói đối số và giá trị trả về vào cấu trúc.</li>
</ul>
<pre><code class="language-c">void *mythread(void *arg) {
  long long int value = (long long int) arg;
  printf(&quot;%lld\n&quot;, value);
  return (void *) (value + 1);
}
int main(int argc, char *argv[]) {
  pthread_t p;
  long long int rvalue;
  Pthread_create(&amp;p, NULL, mythread, (void *) 100);
  Pthread_join(p, (void **) &amp;rvalue);
  printf(&quot;returned %lld\n&quot;, rvalue);
  return 0;
}
</code></pre>
<p><img src="27/img/fig27_3.PNG" alt="" /></p>
<p><strong>Hình 27.3: Truyền đối số đơn giản hơn cho Thread</strong></p>
<ul>
<li>Thứ ba, cần <strong>cực kỳ cẩn thận</strong> với cách trả về giá trị từ một thread. Cụ thể, <strong>không bao giờ</strong> trả về một con trỏ trỏ tới vùng nhớ được cấp phát trên <strong>call stack</strong> của thread. Nếu làm vậy, điều gì sẽ xảy ra? (hãy suy nghĩ!). Đây là một ví dụ nguy hiểm, được sửa đổi từ ví dụ trong <strong>Hình 27.2</strong>:</li>
</ul>
<pre><code class="language-c">void *mythread(void *arg) {
  myarg_t *args = (myarg_t *) arg;
  printf(&quot;%d %d\n&quot;, args-&gt;a, args-&gt;b);
  myret_t oops; // ALLOCATED ON STACK: BAD!
  oops.x = 1;
  oops.y = 2;
  return (void *) &amp;oops;
}
</code></pre>
<p>Trong trường hợp này, biến <code>oops</code> được cấp phát trên stack của <code>mythread</code>. Tuy nhiên, khi hàm trả về, giá trị này sẽ bị <strong>tự động giải phóng</strong> (đó là lý do stack dễ sử dụng!), và việc trả về một con trỏ trỏ tới biến đã bị giải phóng sẽ dẫn đến nhiều hậu quả xấu. Khi in ra giá trị mà bạn nghĩ là đã trả về, bạn có thể (nhưng không chắc chắn) sẽ bất ngờ. Hãy thử và tự kiểm chứng<sup class="footnote-reference"><a href="#2">2</a></sup>!</p>
<ul>
<li>Cuối cùng, bạn có thể nhận thấy việc dùng <code>pthread_create()</code> để tạo một thread, rồi ngay lập tức gọi <code>pthread_join()</code> là một cách khá kỳ lạ để tạo thread. Thực tế, có một cách dễ hơn để làm đúng việc này: <strong>gọi hàm trực tiếp</strong>. Rõ ràng, chúng ta thường sẽ tạo nhiều hơn một thread và chờ chúng hoàn thành, nếu không thì việc dùng thread cũng chẳng có nhiều ý nghĩa.</li>
</ul>
<p>Cũng cần lưu ý rằng không phải mọi chương trình đa luồng đều sử dụng hàm join. Ví dụ, một <strong>multi-threaded web server</strong> có thể tạo nhiều <strong>worker thread</strong> và dùng main thread để nhận yêu cầu và phân phát cho các worker, chạy vô thời hạn. Những chương trình chạy lâu như vậy có thể không cần join. Tuy nhiên, một chương trình song song tạo thread để thực hiện một tác vụ cụ thể (theo kiểu song song) thường sẽ dùng join để đảm bảo tất cả công việc hoàn tất trước khi thoát hoặc chuyển sang giai đoạn tính toán tiếp theo.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>May mắn là trình biên dịch <code>gcc</code> thường sẽ cảnh báo khi bạn viết code như thế này, và đó là một lý do nữa để chú ý đến cảnh báo của trình biên dịch.</p>
</div>
<h2 id="273-locks-khóa"><a class="header" href="#273-locks-khóa">27.3 Locks (Khóa)</a></h2>
<p>Bên cạnh việc tạo và join thread, có lẽ nhóm hàm hữu ích tiếp theo mà thư viện <strong>POSIX threads</strong> cung cấp là các hàm hỗ trợ <strong>mutual exclusion</strong> (loại trừ lẫn nhau) cho <strong>critical section</strong> (vùng tới hạn) thông qua <strong>lock</strong> (khóa). Cặp hàm cơ bản nhất để sử dụng cho mục đích này được định nghĩa như sau:</p>
<pre><code class="language-c">int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
</code></pre>
<p>Các hàm này khá dễ hiểu và sử dụng. Khi bạn có một đoạn code là critical section, và do đó cần được bảo vệ để đảm bảo hoạt động đúng, lock là công cụ rất hữu ích. Bạn có thể hình dung đoạn code như sau:</p>
<pre><code class="language-c">pthread_mutex_t lock;
pthread_mutex_lock(&amp;lock);
x = x + 1; // hoặc bất kỳ đoạn code nào thuộc critical section
pthread_mutex_unlock(&amp;lock);
</code></pre>
<p>Ý tưởng của đoạn code này như sau: nếu không có thread nào khác đang giữ lock khi <code>pthread_mutex_lock()</code> được gọi, thread sẽ <strong>acquire</strong> (giành) được lock và đi vào critical section. Nếu một thread khác đang giữ lock, thread đang cố lấy lock sẽ <strong>không trả về</strong> từ call hàm cho đến khi nó giành được lock (ngụ ý rằng thread đang giữ lock đã <strong>release</strong> nó thông qua call <code>unlock</code>). Tất nhiên, có thể có nhiều thread bị kẹt chờ bên trong hàm lấy lock tại cùng một thời điểm; tuy nhiên, chỉ thread đang giữ lock mới được phép gọi <code>unlock</code>.</p>
<p>Đáng tiếc, đoạn code trên <strong>bị lỗi</strong> ở hai điểm quan trọng.</p>
<p><strong>Vấn đề thứ nhất</strong> là <strong>không khởi tạo đúng cách</strong>. Tất cả các lock phải được khởi tạo đúng để đảm bảo chúng có giá trị ban đầu chính xác và hoạt động như mong muốn khi gọi lock và unlock.</p>
<p>Với POSIX threads, có hai cách để khởi tạo lock:</p>
<ul>
<li><strong>Cách 1:</strong> Sử dụng hằng <code>PTHREAD_MUTEX_INITIALIZER</code>, như sau:</li>
</ul>
<pre><code class="language-c">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
</code></pre>
<p>Cách này sẽ đặt lock về giá trị mặc định và làm cho lock có thể sử dụng được.</p>
<ul>
<li><strong>Cách 2:</strong> Khởi tạo động (tức là tại <strong>run time</strong>) bằng cách gọi <code>pthread_mutex_init()</code>, như sau:</li>
</ul>
<pre><code class="language-c">int rc = pthread_mutex_init(&amp;lock, NULL);
assert(rc == 0); // luôn kiểm tra thành công!
</code></pre>
<p>Tham số thứ nhất của hàm này là địa chỉ của lock, tham số thứ hai là một tập <strong>attribute</strong> (thuộc tính) tùy chọn. Bạn có thể tự tìm hiểu thêm về các thuộc tính này; truyền <code>NULL</code> sẽ dùng giá trị mặc định. Cả hai cách đều hoạt động, nhưng thông thường chúng ta dùng cách khởi tạo động (cách thứ hai). Lưu ý rằng khi không còn dùng lock, bạn nên gọi hàm <code>pthread_mutex_destroy()</code> để giải phóng; xem trang manual để biết chi tiết.</p>
<p><strong>Vấn đề thứ hai</strong> là <strong>không kiểm tra mã lỗi</strong> khi gọi <code>lock</code> và <code>unlock</code>. Giống như hầu hết các hàm thư viện trong hệ thống UNIX, các hàm này <strong>có thể thất bại</strong>! Nếu code của bạn không kiểm tra mã lỗi, lỗi sẽ xảy ra một cách âm thầm, và trong trường hợp này có thể cho phép nhiều thread cùng vào critical section. Tối thiểu, hãy dùng <strong>wrapper</strong> để đảm bảo hàm thực thi thành công, như minh họa trong <strong>Hình 27.4</strong> (trang 7); các chương trình phức tạp hơn (không phải chương trình minh họa đơn giản) — vốn không thể chỉ đơn giản thoát khi có lỗi — nên kiểm tra thất bại và xử lý phù hợp khi call không thành công.</p>
<pre><code class="language-c">// Giữ code gọn gàng; chỉ dùng nếu exit() là chấp nhận được khi lỗi
void Pthread_mutex_lock(pthread_mutex_t *mutex) {
  int rc = pthread_mutex_lock(mutex);
  assert(rc == 0);
}
</code></pre>
<p><img src="27/img/fig27_4.PNG" alt="" /></p>
<p><strong>Hình 27.4: Ví dụ về Wrapper</strong></p>
<p>Các hàm <code>lock</code> và <code>unlock</code> không phải là những hàm duy nhất trong thư viện pthreads tương tác với lock. Còn hai hàm khác cũng đáng chú ý:</p>
<pre><code class="language-c">int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_timedlock(pthread_mutex_t *mutex,
                            struct timespec *abs_timeout);
</code></pre>
<p>Hai call này được dùng để <strong>acquire lock</strong> (lấy khóa):</p>
<ul>
<li>Phiên bản <code>trylock</code> sẽ trả về lỗi nếu lock đang được giữ.</li>
<li>Phiên bản <code>timedlock</code> sẽ trả về sau khi hết thời gian chờ (<strong>timeout</strong>) hoặc sau khi lấy được lock, tùy điều kiện nào xảy ra trước. Do đó, <code>timedlock</code> với thời gian chờ bằng 0 sẽ tương đương với <code>trylock</code>.</li>
</ul>
<p>Cả hai phiên bản này nhìn chung nên tránh sử dụng; tuy nhiên, vẫn có một số trường hợp việc tránh bị kẹt (có thể là vô thời hạn) trong hàm lấy lock là hữu ích, như chúng ta sẽ thấy trong các chương sau (ví dụ: khi nghiên cứu <strong>deadlock</strong> — bế tắc).</p>
<h2 id="274-condition-variables-biến-điều-kiện"><a class="header" href="#274-condition-variables-biến-điều-kiện">27.4 Condition Variables (Biến điều kiện)</a></h2>
<p>Thành phần quan trọng khác của bất kỳ thư viện <strong>thread</strong> (luồng) nào, và chắc chắn đúng với <strong>POSIX threads</strong>, là <strong>condition variable</strong> (biến điều kiện). Condition variable hữu ích khi cần thực hiện một dạng <strong>signaling</strong> (báo hiệu) giữa các thread, trong trường hợp một thread phải chờ thread khác làm xong một việc nào đó trước khi nó có thể tiếp tục. Hai hàm chính được các chương trình sử dụng khi muốn tương tác theo cách này là:</p>
<pre><code class="language-c">int pthread_cond_wait(pthread_cond_t *cond,
                      pthread_mutex_t *mutex);
int pthread_cond_signal(pthread_cond_t *cond);
</code></pre>
<p>Để sử dụng condition variable, ta cần có thêm một <strong>lock</strong> (khóa) được liên kết với biến điều kiện này. Khi gọi một trong hai hàm trên, lock này phải đang được giữ.</p>
<p>Hàm đầu tiên, <code>pthread_cond_wait()</code>, sẽ đưa <strong>calling thread</strong> (thread gọi hàm) vào trạng thái ngủ (<strong>sleep</strong>), và chờ cho đến khi một thread khác <strong>signal</strong> (báo hiệu) nó, thường là khi có điều gì đó trong chương trình thay đổi mà thread đang ngủ quan tâm. Một ví dụ sử dụng điển hình như sau:</p>
<pre><code class="language-c">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
Pthread_mutex_lock(&amp;lock);
while (ready == 0)
  Pthread_cond_wait(&amp;cond, &amp;lock);
Pthread_mutex_unlock(&amp;lock);
</code></pre>
<p>Trong đoạn code này, sau khi khởi tạo lock và condition liên quan<sup class="footnote-reference"><a href="#3">3</a></sup>, một thread sẽ kiểm tra xem biến <code>ready</code> đã được đặt thành giá trị khác 0 hay chưa. Nếu chưa, thread sẽ gọi hàm <code>wait</code> để ngủ cho đến khi một thread khác đánh thức nó.</p>
<p>Code để đánh thức một thread, chạy trong một thread khác, sẽ như sau:</p>
<pre><code class="language-c">Pthread_mutex_lock(&amp;lock);
ready = 1;
Pthread_cond_signal(&amp;cond);
Pthread_mutex_unlock(&amp;lock);
</code></pre>
<p>Một vài điểm cần lưu ý về trình tự code này:</p>
<ul>
<li>
<p><strong>Thứ nhất</strong>, khi <strong>signal</strong> (báo hiệu) — cũng như khi thay đổi biến toàn cục <code>ready</code> — ta luôn đảm bảo lock đang được giữ. Điều này giúp tránh vô tình tạo ra <strong>race condition</strong> (điều kiện tranh chấp) trong code.</p>
</li>
<li>
<p><strong>Thứ hai</strong>, bạn có thể nhận thấy rằng hàm <code>wait</code> nhận lock làm tham số thứ hai, trong khi hàm <code>signal</code> chỉ nhận condition. Lý do cho sự khác biệt này là: hàm <code>wait</code>, ngoài việc đưa thread gọi vào trạng thái ngủ, còn <strong>release</strong> (nhả) lock khi đưa thread đó vào ngủ. Hãy tưởng tượng nếu nó không làm vậy: thread khác sẽ không thể acquire lock và signal để đánh thức nó. Tuy nhiên, trước khi trả về sau khi được đánh thức, <code>pthread_cond_wait()</code> sẽ <strong>re-acquire</strong> (lấy lại) lock, đảm bảo rằng bất cứ khi nào thread đang chờ chạy giữa lúc acquire lock ở đầu vòng chờ và release lock ở cuối, nó luôn giữ lock.</p>
</li>
<li>
<p><strong>Thứ ba</strong>, một điểm đặc biệt: thread đang chờ sẽ <strong>kiểm tra lại</strong> điều kiện trong vòng lặp <code>while</code>, thay vì chỉ dùng câu lệnh <code>if</code>. Chúng ta sẽ bàn chi tiết hơn về vấn đề này khi học condition variable ở chương sau, nhưng nói chung, dùng <code>while</code> là cách đơn giản và an toàn. Mặc dù việc kiểm tra lại điều kiện có thể thêm một chút overhead, nhưng một số bản cài đặt pthread có thể <strong>spurious wakeup</strong> (đánh thức giả) một thread đang chờ; trong trường hợp đó, nếu không kiểm tra lại, thread sẽ tiếp tục chạy với giả định rằng điều kiện đã thay đổi, dù thực tế không phải vậy. An toàn hơn là coi việc được đánh thức chỉ là một <strong>gợi ý</strong> rằng có thể đã có thay đổi, chứ không phải một sự thật tuyệt đối.</p>
</li>
</ul>
<p>Lưu ý rằng đôi khi người ta có thể bị cám dỗ sử dụng một <strong>flag</strong> (cờ) đơn giản để báo hiệu giữa hai thread, thay vì dùng condition variable và lock đi kèm. Ví dụ, ta có thể viết lại code chờ ở trên thành:</p>
<pre><code class="language-c">while (ready == 0)
  ; // spin
</code></pre>
<p>Và code báo hiệu tương ứng sẽ là:</p>
<pre><code class="language-c">ready = 1;
</code></pre>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Có thể dùng <code>pthread_cond_init()</code> (và <code>pthread_cond_destroy()</code>) thay cho cách khởi tạo tĩnh <code>PTHREAD_COND_INITIALIZER</code>. Nghe có vẻ tốn công hơn? Đúng vậy.</p>
</div>
<p><strong>Đừng bao giờ làm như vậy</strong>, vì các lý do sau:</p>
<ul>
<li><strong>Thứ nhất</strong>, cách này hoạt động kém hiệu quả trong nhiều trường hợp (việc <strong>spin</strong> lâu chỉ lãng phí chu kỳ CPU).</li>
<li><strong>Thứ hai</strong>, nó dễ gây lỗi. Nghiên cứu gần đây [X+10] cho thấy, thật đáng ngạc nhiên là việc dùng flag (như trên) để đồng bộ giữa các thread rất dễ mắc lỗi; trong nghiên cứu đó, khoảng <strong>một nửa</strong> số trường hợp đồng bộ kiểu “tự chế” này là <strong>buggy</strong> (có lỗi)!</li>
</ul>
<p>Đừng lười biếng; hãy dùng condition variable ngay cả khi bạn nghĩ rằng có thể bỏ qua.</p>
<p>Nếu condition variable nghe có vẻ khó hiểu, đừng quá lo (ít nhất là bây giờ) — chúng ta sẽ học rất chi tiết về chúng trong một chương sau. Cho đến lúc đó, chỉ cần biết rằng chúng tồn tại và hiểu sơ qua cách cũng như lý do sử dụng chúng là đủ.</p>
<h2 id="275-biên-dịch-và-chạy"><a class="header" href="#275-biên-dịch-và-chạy">27.5 Biên dịch và chạy</a></h2>
<p>Tất cả các ví dụ mã trong chương này đều tương đối dễ thiết lập và chạy. Để biên dịch, bạn phải include header <code>pthread.h</code> trong mã nguồn. Trên dòng liên kết (link), bạn cũng phải liên kết tường minh với thư viện pthreads bằng cách thêm cờ <code>-pthread</code>. Ví dụ, để biên dịch một chương trình multi-threaded (đa luồng) đơn giản, bạn chỉ cần làm như sau:</p>
<pre><code>prompt&gt; gcc -o main main.c -Wall -pthread
</code></pre>
<p>Chỉ cần <code>main.c</code> include header của pthreads, bạn đã biên dịch thành công một chương trình concurrent (đồng thời). Còn nó có chạy đúng hay không thì, như thường lệ, là một chuyện hoàn toàn khác.<br />
Lưu ý: thread (luồng) là đơn vị thực thi nhẹ trong cùng một process (tiến trình), chia sẻ không gian địa chỉ; lập trình multi-threaded đòi hỏi quản lý đồng bộ chặt chẽ để tránh lỗi tinh vi.</p>
<h2 id="276-tóm-tắt"><a class="header" href="#276-tóm-tắt">27.6 Tóm tắt</a></h2>
<p>Chúng ta đã giới thiệu những kiến thức cơ bản về thư viện pthread, bao gồm tạo thread (luồng), xây dựng mutual exclusion (loại trừ lẫn nhau) thông qua locks (khóa), và cơ chế signaling/waiting (phát tín hiệu/chờ đợi) thông qua condition variables (biến điều kiện). Bạn không cần nhiều hơn thế để viết mã multi-threaded vững chắc và hiệu quả, ngoài sự kiên nhẫn và rất nhiều cẩn trọng!<br />
Giải thích ngắn: lock bảo đảm chỉ một thread truy cập vùng dữ liệu tới hạn tại một thời điểm; condition variable cho phép thread ngủ và được đánh thức khi một điều kiện trở nên đúng.</p>
<p>Chúng ta kết thúc chương bằng một tập hợp các mẹo có thể hữu ích khi bạn viết mã multi-threaded (xem phần aside ở trang sau để biết chi tiết). Còn có nhiều khía cạnh khác của API cũng thú vị; nếu muốn biết thêm, hãy gõ <code>man -k pthread</code> trên hệ thống Linux để xem hơn một trăm API cấu thành toàn bộ giao diện. Tuy nhiên, các phần cơ bản đã thảo luận ở đây sẽ giúp bạn xây dựng các chương trình multi-threaded tinh vi (và hy vọng là đúng đắn và hiệu năng). Phần khó với threads không nằm ở API, mà ở logic tinh vi của cách bạn xây dựng các chương trình concurrent. Hãy đọc tiếp để tìm hiểu thêm.<br />
Lưu ý: API là tập hợp hàm/giao ước của thư viện; hiểu đúng semantics (ngữ nghĩa) của từng primitive đồng bộ mới là chìa khóa.</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: THREAD API GUIDELINES</strong></p>
<p>Có một số điều nhỏ nhưng quan trọng cần ghi nhớ khi bạn dùng POSIX thread library (thư viện POSIX threads/Pthreads) — hoặc thực ra là bất kỳ thread library nào — để xây dựng chương trình multi-threaded. Chúng bao gồm:</p>
<ul>
<li><strong>Keep it simple:</strong> Trên hết, mọi đoạn code để lock hoặc signal giữa các thread nên càng đơn giản càng tốt. Các tương tác luồng rắc rối thường dẫn đến lỗi.</li>
<li><strong>Minimize thread interactions:</strong> Cố gắng giảm thiểu số cách mà các thread tương tác với nhau. Mỗi tương tác nên được suy xét cẩn thận và xây dựng bằng các cách tiếp cận đã được kiểm nghiệm (nhiều trong số đó chúng ta sẽ học ở các chương sau).</li>
<li><strong>Initialize locks and condition variables:</strong> Không khởi tạo sẽ dẫn đến mã có lúc chạy được, có lúc thất bại theo những cách rất kỳ quặc.</li>
<li><strong>Check your return codes:</strong> Trong mọi lập trình C và UNIX, bạn nên kiểm tra mọi giá trị trả về; ở đây cũng vậy. Không làm vậy sẽ dẫn đến hành vi khó hiểu, khiến bạn có thể (a) hét lên, (b) bứt tóc, hoặc (c) cả hai.</li>
<li><strong>Be careful with how you pass arguments to, and return values from, threads:</strong> Đặc biệt, bất cứ khi nào bạn truyền tham chiếu đến biến được cấp phát trên stack (ngăn xếp), rất có thể bạn đang làm sai.</li>
<li><strong>Each thread has its own stack:</strong> Liên quan đến ý trên, hãy nhớ mỗi thread có stack riêng. Vì thế, nếu bạn có biến cục bộ trong một hàm mà thread đang thực thi, biến đó về bản chất là riêng tư với thread đó; thread khác không thể (dễ dàng) truy cập. Để chia sẻ dữ liệu giữa các thread, giá trị phải nằm trên heap (bộ nhớ heap) hoặc ở một vùng có thể truy cập toàn cục.</li>
<li><strong>Always use condition variables to signal between threads:</strong> Dù đôi khi hấp dẫn khi dùng một cờ (flag) đơn giản, đừng làm vậy.</li>
<li><strong>Use the manual pages:</strong> Trên Linux, các trang <code>pthread</code> trong man rất nhiều thông tin và bàn về nhiều sắc thái được trình bày ở đây, thường còn chi tiết hơn. Hãy đọc kỹ!</li>
</ul>
<p>Giải thích ngắn: stack là vùng nhớ cho biến cục bộ và khung hàm của mỗi thread; heap là vùng nhớ cấp phát động dùng để chia sẻ an toàn hơn giữa các thread khi kết hợp với đồng bộ hóa phù hợp.</p>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="28-locks-khóa"><a class="header" href="#28-locks-khóa">28 Locks (Khóa)</a></h1>
<p>Từ phần giới thiệu về <strong>concurrency</strong> (tính đồng thời), chúng ta đã thấy một trong những vấn đề cơ bản của lập trình đồng thời: chúng ta muốn thực thi một chuỗi lệnh một cách <strong>atomically</strong> (nguyên tử), nhưng do sự tồn tại của <strong>interrupt</strong> (ngắt) trên một bộ xử lý đơn (hoặc nhiều <strong>thread</strong> chạy đồng thời trên nhiều bộ xử lý), chúng ta không thể làm được. Trong chương này, chúng ta sẽ giải quyết trực tiếp vấn đề này bằng cách giới thiệu một cơ chế gọi là <strong>lock</strong> (khóa). Lập trình viên sẽ chú thích mã nguồn bằng các lock, đặt chúng bao quanh các <strong>critical section</strong> (vùng tới hạn), từ đó đảm bảo rằng bất kỳ critical section nào cũng được thực thi như thể nó là một lệnh nguyên tử duy nhất.</p>
<h2 id="281-locks-Ý-tưởng-cơ-bản-locks-the-basic-idea"><a class="header" href="#281-locks-Ý-tưởng-cơ-bản-locks-the-basic-idea">28.1 Locks: Ý tưởng cơ bản (Locks: The Basic Idea)</a></h2>
<p>Ví dụ, giả sử critical section của chúng ta trông như sau — đây là dạng cập nhật kinh điển của một biến chia sẻ:</p>
<pre><code>balance = balance + 1;
</code></pre>
<p>Tất nhiên, các critical section khác cũng có thể xảy ra, chẳng hạn như thêm một phần tử vào <strong>linked list</strong> (danh sách liên kết) hoặc các cập nhật phức tạp hơn đối với các cấu trúc dữ liệu chia sẻ, nhưng ở đây chúng ta sẽ giữ ví dụ đơn giản này. Để sử dụng lock, ta thêm một số đoạn code bao quanh critical section như sau:</p>
<pre><code class="language-c">lock_t mutex; // một lock 'mutex' được cấp phát toàn cục
...
lock(&amp;mutex);
balance = balance + 1;
unlock(&amp;mutex);
</code></pre>
<p>Một lock chỉ là một biến, do đó để sử dụng, bạn phải khai báo một biến lock nào đó (như <code>mutex</code> ở trên). Biến lock này (hoặc gọi tắt là “lock”) lưu trạng thái của khóa tại mọi thời điểm. Nó có thể ở trạng thái <strong>available</strong> (có sẵn / unlocked / free) — nghĩa là không có thread nào giữ lock, hoặc ở trạng thái <strong>acquired</strong> (đã được giữ / locked / held) — nghĩa là đúng một thread đang giữ lock và giả định rằng nó đang ở trong critical section. Ta cũng có thể lưu trữ thêm thông tin khác trong kiểu dữ liệu này, chẳng hạn như thread nào đang giữ lock, hoặc một hàng đợi để sắp xếp thứ tự lấy lock, nhưng những thông tin như vậy thường được ẩn khỏi người dùng lock.</p>
<p><strong>Ngữ nghĩa</strong> của các hàm <code>lock()</code> và <code>unlock()</code> khá đơn giản:</p>
<ul>
<li>Gọi hàm <code>lock()</code> sẽ cố gắng <strong>acquire</strong> (lấy) lock; nếu không có thread nào khác đang giữ lock (tức là lock đang free), thread sẽ lấy được lock và vào critical section; thread này đôi khi được gọi là <strong>owner</strong> (chủ sở hữu) của lock.</li>
<li>Nếu một thread khác gọi <code>lock()</code> trên cùng biến lock đó (<code>mutex</code> trong ví dụ này) khi lock đang bị giữ, call sẽ <strong>không trả về</strong> cho đến khi lock được thread đang giữ <strong>release</strong> (nhả) ra; theo cách này, các thread khác bị ngăn không cho vào critical section khi thread đầu tiên vẫn đang ở trong đó.</li>
</ul>
<p>Khi <strong>owner</strong> của lock gọi <code>unlock()</code>, lock sẽ trở lại trạng thái free. Nếu không có thread nào khác đang chờ lock (tức là không có thread nào gọi <code>lock()</code> và bị kẹt ở đó), trạng thái lock đơn giản được chuyển sang free. Nếu có các thread đang chờ (bị kẹt trong <code>lock()</code>), một trong số chúng sẽ (cuối cùng) nhận ra (hoặc được thông báo) về sự thay đổi trạng thái này, lấy lock và vào critical section.</p>
<p>Lock cung cấp cho lập trình viên một mức độ kiểm soát tối thiểu đối với <strong>scheduling</strong> (lập lịch). Thông thường, chúng ta coi thread là các thực thể được lập trình viên tạo ra nhưng được OS lập lịch theo bất kỳ cách nào OS muốn. Lock trả lại một phần quyền kiểm soát đó cho lập trình viên; bằng cách đặt lock quanh một đoạn code, lập trình viên có thể đảm bảo rằng không bao giờ có nhiều hơn một thread hoạt động trong đoạn code đó. Nhờ vậy, lock giúp biến sự hỗn loạn của lập lịch truyền thống trong OS thành một hoạt động có kiểm soát hơn.</p>
<h2 id="282-pthread-locks"><a class="header" href="#282-pthread-locks">28.2 Pthread Locks</a></h2>
<p>Tên mà thư viện <strong>POSIX</strong> dùng cho lock là <strong>mutex</strong> (viết tắt của <em>mutual exclusion</em> — loại trừ lẫn nhau), vì nó được dùng để đảm bảo rằng nếu một thread đang ở trong critical section, nó sẽ <strong>ngăn</strong> các thread khác vào cho đến khi hoàn tất. Do đó, khi bạn thấy đoạn code POSIX threads sau, bạn nên hiểu rằng nó thực hiện cùng chức năng như ví dụ ở trên (ở đây chúng ta lại dùng <strong>wrapper</strong> để kiểm tra lỗi khi lock và unlock):</p>
<pre><code class="language-c">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
Pthread_mutex_lock(&amp;lock); // wrapper; thoát nếu lỗi
balance = balance + 1;
Pthread_mutex_unlock(&amp;lock);
</code></pre>
<p>Bạn cũng có thể nhận thấy rằng phiên bản POSIX truyền một biến vào hàm lock và unlock, vì chúng ta có thể dùng các lock khác nhau để bảo vệ các biến khác nhau. Cách làm này có thể <strong>tăng concurrency</strong> (tính đồng thời): thay vì dùng <strong>một big lock</strong> (khóa lớn) cho mọi critical section (chiến lược <strong>coarse-grained locking</strong> — khóa thô), người ta thường bảo vệ các dữ liệu và cấu trúc dữ liệu khác nhau bằng các lock khác nhau, cho phép nhiều thread cùng ở trong các đoạn code đã khóa cùng lúc (<strong>fine-grained locking</strong> — khóa tinh).</p>
<h2 id="283-xây-dựng-một-lock-building-a-lock"><a class="header" href="#283-xây-dựng-một-lock-building-a-lock">28.3 Xây dựng một Lock (Building A Lock)</a></h2>
<p>Đến thời điểm này, bạn hẳn đã có một số hiểu biết về cách một <strong>lock</strong> (khóa) hoạt động, từ góc nhìn của lập trình viên. Nhưng làm thế nào để <strong>xây dựng</strong> một lock? Cần hỗ trợ gì từ <strong>hardware</strong> (phần cứng)? Cần hỗ trợ gì từ <strong>OS</strong> (hệ điều hành)? Đây chính là tập hợp các câu hỏi mà phần còn lại của chương này sẽ giải đáp.</p>
<blockquote>
<p><strong>THE CRUX: HOW TO BUILD A LOCK</strong><br />
(Vấn đề cốt lõi: Làm thế nào để xây dựng một lock)<br />
Làm thế nào để xây dựng một lock hiệu quả? Một lock hiệu quả phải cung cấp <strong>mutual exclusion</strong> (loại trừ lẫn nhau) với chi phí thấp, và có thể đạt được một số đặc tính khác mà chúng ta sẽ thảo luận bên dưới. Cần hỗ trợ gì từ phần cứng? Cần hỗ trợ gì từ hệ điều hành?</p>
</blockquote>
<p>Để xây dựng một lock hoạt động đúng, chúng ta sẽ cần sự trợ giúp từ “người bạn cũ” là phần cứng, cũng như “người bạn tốt” là hệ điều hành. Qua nhiều năm, một số <strong>hardware primitive</strong> (nguyên thủy phần cứng) khác nhau đã được bổ sung vào <strong>instruction set</strong> (tập lệnh) của nhiều kiến trúc máy tính; mặc dù chúng ta sẽ không nghiên cứu cách các lệnh này được triển khai (đó là chủ đề của môn kiến trúc máy tính), nhưng chúng ta sẽ nghiên cứu cách sử dụng chúng để xây dựng một <strong>mutual exclusion primitive</strong> như lock. Chúng ta cũng sẽ tìm hiểu cách hệ điều hành tham gia để hoàn thiện bức tranh và cho phép xây dựng một thư viện lock tinh vi.</p>
<h2 id="284-Đánh-giá-lock-evaluating-locks"><a class="header" href="#284-Đánh-giá-lock-evaluating-locks">28.4 Đánh giá Lock (Evaluating Locks)</a></h2>
<p>Trước khi xây dựng bất kỳ lock nào, chúng ta cần hiểu rõ mục tiêu, và do đó cần đặt câu hỏi: <strong>đánh giá hiệu quả của một lock như thế nào</strong>? Để đánh giá một lock có hoạt động (và hoạt động tốt) hay không, chúng ta cần thiết lập một số tiêu chí cơ bản.</p>
<ul>
<li>
<p><strong>Tiêu chí đầu tiên</strong>: lock có thực hiện đúng nhiệm vụ cơ bản là cung cấp <strong>mutual exclusion</strong> hay không? Nói cách khác, lock có ngăn chặn nhiều thread cùng vào một critical section hay không?</p>
</li>
<li>
<p><strong>Tiêu chí thứ hai</strong>: <strong>fairness</strong> (tính công bằng). Mỗi thread cạnh tranh lock có cơ hội công bằng để lấy lock khi nó được giải phóng hay không? Xét ở trường hợp cực đoan: có thread nào bị <strong>starvation</strong> (đói tài nguyên) khi cạnh tranh lock, dẫn đến không bao giờ lấy được lock hay không?</p>
</li>
<li>
<p><strong>Tiêu chí cuối cùng</strong>: <strong>performance</strong> (hiệu năng), cụ thể là <strong>time overhead</strong> (độ trễ thời gian) do việc sử dụng lock gây ra. Có một số trường hợp đáng xem xét:</p>
<ol>
<li><strong>No contention</strong> (không tranh chấp): khi chỉ có một thread chạy và thực hiện lấy và nhả lock, chi phí của việc này là bao nhiêu?</li>
<li><strong>Single CPU, multiple threads contending</strong> (một CPU, nhiều thread tranh chấp): trong trường hợp này, có vấn đề hiệu năng nào không?</li>
<li><strong>Multiple CPUs contending</strong> (nhiều CPU, mỗi CPU có thread tranh chấp lock): lock hoạt động thế nào?</li>
</ol>
</li>
</ul>
<p>Bằng cách so sánh các kịch bản này, chúng ta có thể hiểu rõ hơn tác động hiệu năng của các kỹ thuật lock khác nhau.</p>
<h2 id="285-kiểm-soát-interrupt-controlling-interrupts"><a class="header" href="#285-kiểm-soát-interrupt-controlling-interrupts">28.5 Kiểm soát Interrupt (Controlling Interrupts)</a></h2>
<p>Một trong những giải pháp sớm nhất để cung cấp <strong>mutual exclusion</strong> là <strong>tắt interrupt</strong> cho critical section; giải pháp này được phát minh cho hệ thống <strong>single-processor</strong> (đơn xử lý). Mã nguồn sẽ như sau:</p>
<pre><code class="language-c">void lock() {
  DisableInterrupts();
}
void unlock() {
  EnableInterrupts();
}
</code></pre>
<p>Giả sử chúng ta đang chạy trên một hệ thống đơn xử lý như vậy. Bằng cách tắt interrupt (sử dụng một lệnh phần cứng đặc biệt) trước khi vào critical section, chúng ta đảm bảo rằng mã bên trong critical section sẽ không bị ngắt, và do đó sẽ thực thi như thể nó là nguyên tử. Khi xong, chúng ta bật lại interrupt (cũng bằng lệnh phần cứng) và chương trình tiếp tục như bình thường.</p>
<p><strong>Ưu điểm chính</strong> của cách tiếp cận này là <strong>đơn giản</strong>. Bạn không cần phải suy nghĩ nhiều để hiểu tại sao nó hoạt động. Không có ngắt, một thread có thể chắc chắn rằng đoạn code nó thực thi sẽ chạy trọn vẹn và không bị thread khác can thiệp.</p>
<p><strong>Nhược điểm</strong>, đáng tiếc, lại nhiều:</p>
<ol>
<li>
<p><strong>Vấn đề tin cậy</strong>: Cách này yêu cầu cho phép bất kỳ thread nào gọi hàm cũng có thể thực hiện một thao tác đặc quyền (bật/tắt interrupt), và do đó phải tin rằng khả năng này không bị lạm dụng. Như bạn đã biết, bất cứ khi nào phải tin tưởng một chương trình tùy ý, chúng ta có thể gặp rắc rối. Ví dụ:</p>
<ul>
<li>Một chương trình “tham lam” có thể gọi <code>lock()</code> ngay khi bắt đầu và chiếm dụng CPU.</li>
<li>Tệ hơn, một chương trình lỗi hoặc độc hại có thể gọi <code>lock()</code> rồi chạy vòng lặp vô hạn. Trong trường hợp này, OS sẽ <strong>mất quyền kiểm soát</strong> hệ thống, và cách duy nhất để khắc phục là <strong>khởi động lại</strong>.<br />
Việc dùng tắt interrupt như một giải pháp đồng bộ hóa tổng quát đòi hỏi quá nhiều sự tin tưởng vào ứng dụng.</li>
</ul>
</li>
<li>
<p><strong>Không hoạt động trên multiprocessor</strong>: Nếu nhiều thread chạy trên các CPU khác nhau và cùng cố vào một critical section, việc tắt interrupt không giúp ích gì; các thread vẫn có thể chạy trên CPU khác và vào critical section. Vì multiprocessor hiện nay rất phổ biến, giải pháp tổng quát của chúng ta phải tốt hơn.</p>
</li>
<li>
<p><strong>Mất interrupt</strong>: Tắt interrupt trong thời gian dài có thể dẫn đến mất interrupt, gây ra các vấn đề nghiêm trọng cho hệ thống. Ví dụ: nếu CPU bỏ lỡ tín hiệu rằng một thiết bị đĩa đã hoàn tất yêu cầu đọc, OS sẽ không biết để đánh thức process đang chờ.</p>
</li>
</ol>
<p>Vì những lý do này, việc tắt interrupt chỉ được dùng trong <strong>ngữ cảnh hạn chế</strong> như một primitive đảm bảo mutual exclusion. Ví dụ, trong một số trường hợp, chính hệ điều hành sẽ dùng <strong>interrupt masking</strong> (che ngắt) để đảm bảo tính nguyên tử khi truy cập các cấu trúc dữ liệu nội bộ, hoặc ít nhất để tránh một số tình huống xử lý ngắt phức tạp. Cách dùng này hợp lý, vì vấn đề tin cậy không tồn tại bên trong OS — vốn luôn tin tưởng chính nó để thực hiện các thao tác đặc quyền.</p>
<h2 id="286-một-nỗ-lực-thất-bại-chỉ-sử-dụng-loadstore"><a class="header" href="#286-một-nỗ-lực-thất-bại-chỉ-sử-dụng-loadstore">28.6 Một nỗ lực thất bại: Chỉ sử dụng Load/Store</a></h2>
<p>Để vượt ra khỏi các kỹ thuật dựa trên <strong>interrupt</strong> (ngắt), chúng ta sẽ phải dựa vào <strong>CPU hardware</strong> (phần cứng CPU) và các <strong>instruction</strong> (lệnh) mà nó cung cấp để xây dựng một <strong>lock</strong> (khóa) đúng nghĩa. Trước tiên, hãy thử xây dựng một lock đơn giản bằng cách sử dụng một biến cờ (<strong>flag</strong>) duy nhất. Trong nỗ lực thất bại này, chúng ta sẽ thấy một số ý tưởng cơ bản cần thiết để xây dựng lock, và (hy vọng) sẽ thấy lý do tại sao chỉ dùng một biến duy nhất và truy cập nó thông qua các thao tác load/store thông thường là <strong>không đủ</strong>.</p>
<p>Trong nỗ lực đầu tiên này (<strong>Hình 28.1</strong>), ý tưởng khá đơn giản: sử dụng một biến (<code>flag</code>) để biểu thị việc một thread nào đó đang giữ lock. Thread đầu tiên vào <strong>critical section</strong> (vùng tới hạn) sẽ gọi <code>lock()</code>, hàm này sẽ kiểm tra xem <code>flag</code> có bằng 1 hay không (trong trường hợp này là không), và sau đó đặt <code>flag</code> thành 1 để biểu thị rằng thread hiện đang giữ lock. Khi hoàn tất critical section, thread sẽ gọi <code>unlock()</code> và xóa <code>flag</code>, cho biết lock không còn bị giữ nữa.</p>
<pre><code class="language-c">typedef struct __lock_t { int flag; } lock_t;

void init(lock_t *mutex) {
  // 0 -&gt; lock đang rảnh, 1 -&gt; lock đang bị giữ
  mutex-&gt;flag = 0;
}

void lock(lock_t *mutex) {
  while (mutex-&gt;flag == 1) // KIỂM TRA flag
    ; // spin-wait (không làm gì)
  mutex-&gt;flag = 1;         // BÂY GIỜ đặt flag!
}

void unlock(lock_t *mutex) {
  mutex-&gt;flag = 0;
}
</code></pre>
<p><img src="28/img/fig28_1.PNG" alt="" /></p>
<p><strong>Hình 28.1: Nỗ lực đầu tiên: Một biến cờ đơn giản</strong></p>
<p>Nếu một thread khác gọi <code>lock()</code> trong khi thread đầu tiên đang ở trong critical section, nó sẽ chỉ đơn giản <strong>spin-wait</strong> (chờ bận) trong vòng lặp <code>while</code> cho đến khi thread kia gọi <code>unlock()</code> và xóa <code>flag</code>. Khi thread đầu tiên làm vậy, thread đang chờ sẽ thoát khỏi vòng lặp <code>while</code>, đặt <code>flag</code> thành 1 cho chính nó, và tiếp tục vào critical section.</p>
<p>Đáng tiếc, đoạn code này có <strong>hai vấn đề</strong>: một về <strong>tính đúng đắn</strong> (correctness), và một về <strong>hiệu năng</strong> (performance).</p>
<ul>
<li><strong>Vấn đề tính đúng đắn</strong> rất dễ thấy khi bạn quen với tư duy lập trình đồng thời. Hãy tưởng tượng sự xen kẽ lệnh như trong <strong>Hình 28.2</strong>; giả sử ban đầu <code>flag = 0</code>:</li>
</ul>
<pre><code>Thread 1                  Thread 2
call lock()
while (flag == 1)
interrupt: switch to Thread 2

                          call lock()
                          while (flag == 1)
                          flag = 1;
                          interrupt: switch to Thread 1
flag = 1; // cũng đặt flag thành 1!
</code></pre>
<p><img src="28/img/fig28_2.PNG" alt="" /></p>
<p><strong>Hình 28.2: Trace: Không có Mutual Exclusion</strong></p>
<p>Như bạn thấy từ sự xen kẽ này, chỉ với một <strong>interrupt</strong> xảy ra “đúng lúc” (hay “sai lúc”), ta dễ dàng tạo ra tình huống cả hai thread đều đặt <code>flag</code> thành 1 và cả hai cùng vào critical section. Đây là hành vi mà dân chuyên gọi là “tệ” — rõ ràng chúng ta đã thất bại trong việc cung cấp yêu cầu cơ bản nhất: <strong>mutual exclusion</strong>.</p>
<ul>
<li><strong>Vấn đề hiệu năng</strong> (sẽ được bàn kỹ hơn sau) nằm ở cách một thread chờ để lấy lock đang bị giữ: nó liên tục kiểm tra giá trị của <code>flag</code>, kỹ thuật này gọi là <strong>spin-waiting</strong>. Spin-waiting lãng phí thời gian CPU để chờ thread khác nhả lock. Sự lãng phí này đặc biệt nghiêm trọng trên <strong>uniprocessor</strong> (bộ xử lý đơn), nơi thread mà thread chờ đang đợi thậm chí <strong>không thể chạy</strong> (ít nhất là cho đến khi xảy ra context switch)! Do đó, khi phát triển các giải pháp tinh vi hơn, chúng ta cũng nên xem xét cách tránh loại lãng phí này.</li>
</ul>
<h2 id="287-xây-dựng-spin-lock-hoạt-động-với-test-and-set"><a class="header" href="#287-xây-dựng-spin-lock-hoạt-động-với-test-and-set">28.7 Xây dựng Spin Lock hoạt động với Test-And-Set</a></h2>
<p>Vì việc tắt interrupt không hoạt động trên <strong>multiprocessor</strong> (đa xử lý), và vì các cách tiếp cận đơn giản chỉ dùng load/store (như ở trên) không hiệu quả, các nhà thiết kế hệ thống đã bắt đầu phát minh ra <strong>hardware support</strong> (hỗ trợ phần cứng) cho việc khóa. Những hệ thống multiprocessor đầu tiên, như <strong>Burroughs B5000</strong> vào đầu những năm 1960 [M82], đã có hỗ trợ này; ngày nay, tất cả các hệ thống đều cung cấp loại hỗ trợ này, ngay cả với hệ thống chỉ có một CPU.</p>
<p>Phần hỗ trợ phần cứng đơn giản nhất để hiểu được gọi là <strong>test-and-set</strong> (hoặc <strong>atomic exchange</strong><sup class="footnote-reference"><a href="#1">1</a></sup>). Chúng ta định nghĩa chức năng của lệnh test-and-set thông qua đoạn code C sau:</p>
<pre><code class="language-c">int TestAndSet(int *old_ptr, int new) {
  int old = *old_ptr; // lấy giá trị cũ tại old_ptr
  // ghi 'new' vào old_ptr
  *old_ptr = new;
  return old;         // trả về giá trị cũ
}
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Mỗi kiến trúc hỗ trợ test-and-set lại gọi nó bằng tên khác nhau. Trên SPARC, nó được gọi là lệnh load/store unsigned byte (<code>ldstub</code>); trên x86, nó là phiên bản có khóa (<strong>locked</strong>) của lệnh atomic exchange (<code>xchg</code>).</p>
</div>
<blockquote>
<p><strong>ASIDE: THUẬT TOÁN DEKKER VÀ PETERSON</strong></p>
<p>Vào những năm 1960, <strong>Dijkstra</strong> đã nêu ra bài toán <strong>concurrency</strong> (tính đồng thời) cho bạn bè của mình, và một trong số họ — nhà toán học <strong>Theodorus Jozef Dekker</strong> — đã đưa ra một lời giải [D68]. Không giống như các giải pháp mà chúng ta thảo luận ở đây, vốn sử dụng các <strong>hardware instruction</strong> (lệnh phần cứng) đặc biệt và thậm chí cả sự hỗ trợ từ <strong>OS</strong> (hệ điều hành), thuật toán của Dekker chỉ dùng các thao tác <strong>load</strong> và <strong>store</strong> (giả định rằng chúng nguyên tử với nhau, điều này đúng trên phần cứng đời đầu).</p>
<p>Cách tiếp cận của Dekker sau đó được <strong>Peterson</strong> cải tiến [P81]. Một lần nữa, chỉ dùng load và store, và ý tưởng là đảm bảo rằng hai <strong>thread</strong> (luồng) không bao giờ cùng vào <strong>critical section</strong> (vùng tới hạn) cùng lúc. Dưới đây là thuật toán Peterson (cho hai thread); hãy thử xem bạn có hiểu đoạn code này không. Các biến <code>flag</code> và <code>turn</code> được dùng để làm gì?</p>
<pre><code class="language-c">int flag[2];
int turn;

void init() {
  // biểu thị ý định giữ lock bằng 'flag'
  flag[0] = flag[1] = 0;
  // lượt của ai? (thread 0 hoặc 1)
  turn = 0;
}

void lock() {
  // 'self' là ID của thread gọi hàm
  flag[self] = 1;
  // nhường lượt cho thread kia
  turn = 1 - self;
  while ((flag[1-self] == 1) &amp;&amp; (turn == 1 - self))
    ; // spin-wait khi chưa đến lượt
}

void unlock() {
  // hủy ý định giữ lock
  flag[self] = 0;
}
</code></pre>
<p>Vì một lý do nào đó, việc phát triển các lock hoạt động mà không cần hỗ trợ phần cứng đặc biệt đã trở thành trào lưu một thời, mang lại cho giới nghiên cứu lý thuyết nhiều vấn đề để giải quyết. Tất nhiên, hướng nghiên cứu này trở nên khá vô dụng khi người ta nhận ra rằng dễ dàng hơn nhiều nếu giả định có một chút hỗ trợ phần cứng (và thực tế là hỗ trợ này đã tồn tại từ những ngày đầu của <strong>multiprocessing</strong>). Hơn nữa, các thuật toán như trên không hoạt động trên phần cứng hiện đại (do <strong>relaxed memory consistency model</strong> — mô hình nhất quán bộ nhớ lỏng), khiến chúng còn ít hữu ích hơn trước đây. Thêm một hướng nghiên cứu nữa bị xếp vào “ngăn lưu trữ lịch sử”...</p>
</blockquote>
<p>Lệnh <code>test-and-set</code> hoạt động như sau: nó trả về giá trị cũ tại địa chỉ mà <code>old_ptr</code> trỏ tới, đồng thời cập nhật giá trị đó thành <code>new</code>. Điểm mấu chốt là chuỗi thao tác này được thực hiện <strong>atomically</strong> (nguyên tử). Sở dĩ gọi là “test and set” là vì nó cho phép bạn “kiểm tra” (test) giá trị cũ (giá trị được trả về) đồng thời “đặt” (set) vị trí bộ nhớ đó thành giá trị mới; hóa ra, lệnh mạnh hơn một chút này là đủ để xây dựng một <strong>spin lock</strong> đơn giản, như chúng ta sẽ xem trong <strong>Hình 28.3</strong>. Hoặc tốt hơn: hãy thử tự mình suy luận trước!</p>
<pre><code class="language-c">typedef struct __lock_t {
  int flag;
} lock_t;

void init(lock_t *lock) {
  // 0: lock đang rảnh, 1: lock đang bị giữ
  lock-&gt;flag = 0;
}

void lock(lock_t *lock) {
  while (TestAndSet(&amp;lock-&gt;flag, 1) == 1)
    ; // spin-wait (không làm gì)
}

void unlock(lock_t *lock) {
  lock-&gt;flag = 0;
}
</code></pre>
<p><img src="28/img/fig28_3.PNG" alt="" /></p>
<p><strong>Hình 28.3: Một Spin Lock đơn giản sử dụng Test-and-Set</strong></p>
<p>Hãy đảm bảo rằng chúng ta hiểu tại sao lock này hoạt động. Trước hết, tưởng tượng trường hợp một thread gọi <code>lock()</code> và không có thread nào khác đang giữ lock; khi đó, <code>flag</code> sẽ bằng 0. Khi thread gọi <code>TestAndSet(flag, 1)</code>, hàm sẽ trả về giá trị cũ của <code>flag</code> (0); do đó, thread gọi hàm — khi kiểm tra giá trị <code>flag</code> — sẽ không bị kẹt trong vòng lặp <code>while</code> và sẽ lấy được lock. Thread này cũng đồng thời đặt giá trị <code>flag</code> thành 1 một cách nguyên tử, biểu thị rằng lock hiện đang bị giữ. Khi thread hoàn tất critical section, nó gọi <code>unlock()</code> để đặt lại <code>flag</code> về 0.</p>
<p>Trường hợp thứ hai xảy ra khi một thread khác đã giữ lock (tức là <code>flag</code> = 1). Khi đó, thread này gọi <code>lock()</code> và tiếp tục gọi <code>TestAndSet(flag, 1)</code>. Lần này, <code>TestAndSet()</code> sẽ trả về giá trị cũ tại <code>flag</code> là 1 (vì lock đang bị giữ), đồng thời đặt lại nó thành 1. Chừng nào lock còn bị giữ bởi thread khác, <code>TestAndSet()</code> sẽ liên tục trả về 1, và thread này sẽ tiếp tục <strong>spin</strong> cho đến khi lock được nhả. Khi <code>flag</code> cuối cùng được đặt về 0 bởi thread khác, thread này sẽ gọi <code>TestAndSet()</code> lần nữa, lúc này trả về 0 đồng thời đặt giá trị thành 1, và do đó lấy được lock để vào critical section.</p>
<blockquote>
<p><strong>TIP: HÃY NGHĨ VỀ CONCURRENCY NHƯ MỘT BỘ LẬP LỊCH “XẤU TÍNH”</strong><br />
Từ ví dụ này, bạn có thể hình dung cách tiếp cận cần có để hiểu việc thực thi đồng thời. Hãy thử tưởng tượng bạn là một <strong>scheduler</strong> (bộ lập lịch) “xấu tính”, người sẽ ngắt các thread vào những thời điểm tệ hại nhất để phá hỏng nỗ lực yếu ớt của chúng trong việc xây dựng các <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa). Bạn thật là một scheduler độc ác! Mặc dù chuỗi ngắt chính xác có thể khó xảy ra, nhưng nó <strong>có thể</strong> xảy ra, và đó là tất cả những gì cần để chứng minh một cách tiếp cận nào đó là không hoạt động. Đôi khi, suy nghĩ theo hướng “xấu tính” lại hữu ích!</p>
</blockquote>
<p>Bằng cách biến cả thao tác kiểm tra (giá trị cũ của lock) và đặt (giá trị mới) thành một <strong>atomic operation</strong> (thao tác nguyên tử) duy nhất, chúng ta đảm bảo rằng chỉ một thread có thể lấy được lock. Và đó chính là cách xây dựng một <strong>mutual exclusion primitive</strong> hoạt động! Giờ đây, bạn cũng có thể hiểu tại sao loại lock này thường được gọi là <strong>spin lock</strong>. Đây là loại lock đơn giản nhất để xây dựng, và chỉ đơn giản là “quay vòng” (spin), tiêu tốn chu kỳ CPU, cho đến khi lock sẵn sàng. Để hoạt động đúng trên <strong>single processor</strong> (bộ xử lý đơn), nó cần một <strong>preemptive scheduler</strong> (bộ lập lịch ưu tiên ngắt) — tức là một bộ lập lịch sẽ ngắt một thread thông qua <strong>timer</strong> (bộ định thời) để chạy thread khác theo định kỳ. Nếu không có preemption, spin lock không có nhiều ý nghĩa trên một CPU đơn, vì một thread đang spin trên CPU sẽ không bao giờ tự nhường CPU.</p>
<h2 id="288-Đánh-giá-spin-lock-evaluating-spin-locks"><a class="header" href="#288-Đánh-giá-spin-lock-evaluating-spin-locks">28.8 Đánh giá Spin Lock (Evaluating Spin Locks)</a></h2>
<p>Với <strong>spin lock</strong> cơ bản mà chúng ta đã xây dựng, giờ đây ta có thể đánh giá mức độ hiệu quả của nó dựa trên các tiêu chí đã mô tả trước đó.</p>
<p>Tiêu chí quan trọng nhất của một <strong>lock</strong> là <strong>correctness</strong> (tính đúng đắn): nó có cung cấp <strong>mutual exclusion</strong> (loại trừ lẫn nhau) hay không? Ở đây, câu trả lời là <strong>có</strong>: spin lock chỉ cho phép một <strong>thread</strong> (luồng) duy nhất vào <strong>critical section</strong> (vùng tới hạn) tại một thời điểm. Do đó, chúng ta có một lock đúng đắn.</p>
<p>Tiêu chí tiếp theo là <strong>fairness</strong> (tính công bằng). Spin lock có công bằng với thread đang chờ hay không? Bạn có thể đảm bảo rằng một thread đang chờ sẽ <strong>luôn</strong> được vào critical section không? Đáng tiếc, câu trả lời là <strong>không</strong>: spin lock không cung cấp bất kỳ đảm bảo nào về tính công bằng. Thực tế, một thread có thể <strong>spin</strong> (quay vòng chờ) mãi mãi khi có tranh chấp. Spin lock đơn giản (như đã thảo luận) là <strong>không công bằng</strong> và có thể dẫn đến <strong>starvation</strong> (đói tài nguyên).</p>
<p>Tiêu chí cuối cùng là <strong>performance</strong> (hiệu năng). Chi phí của việc sử dụng spin lock là gì? Để phân tích kỹ hơn, hãy xem xét một vài trường hợp khác nhau.</p>
<ul>
<li><strong>Trường hợp 1</strong>: Các thread cạnh tranh lock trên <strong>single processor</strong> (bộ xử lý đơn).</li>
<li><strong>Trường hợp 2</strong>: Các thread phân bố trên nhiều CPU.</li>
</ul>
<p>Với spin lock, trong trường hợp <strong>single CPU</strong>, chi phí hiệu năng có thể rất tệ; hãy tưởng tượng khi thread đang giữ lock bị <strong>preempted</strong> (tạm dừng) ngay trong critical section. <strong>Scheduler</strong> (bộ lập lịch) có thể sẽ chạy tất cả các thread khác (giả sử có N − 1 thread khác), mỗi thread đều cố gắng lấy lock. Trong trường hợp này, mỗi thread sẽ spin trong suốt <strong>time slice</strong> (lượng thời gian CPU cấp cho một thread) trước khi nhường CPU, gây lãng phí chu kỳ CPU.</p>
<p>Tuy nhiên, trên <strong>multiple CPUs</strong> (đa xử lý), spin lock hoạt động khá tốt (nếu số lượng thread xấp xỉ số lượng CPU). Lý do như sau: giả sử Thread A chạy trên CPU 1 và Thread B chạy trên CPU 2, cả hai cùng tranh chấp lock. Nếu Thread A (CPU 1) lấy được lock, và Thread B cố lấy, B sẽ spin (trên CPU 2). Tuy nhiên, giả định rằng critical section ngắn, lock sẽ sớm được nhả và Thread B sẽ lấy được. Trong trường hợp này, việc spin để chờ lock giữ trên CPU khác không lãng phí nhiều chu kỳ CPU, và do đó có thể hiệu quả.</p>
<h2 id="289-compare-and-swap"><a class="header" href="#289-compare-and-swap">28.9 Compare-And-Swap</a></h2>
<p>Một <strong>hardware primitive</strong> (nguyên thủy phần cứng) khác mà một số hệ thống cung cấp được gọi là <strong>compare-and-swap</strong> (trên SPARC) hoặc <strong>compare-and-exchange</strong> (trên x86). Mã giả C cho lệnh này được thể hiện trong <strong>Hình 28.4</strong>.</p>
<pre><code class="language-c">int CompareAndSwap(int *ptr, int expected, int new) {
  int original = *ptr;
  if (original == expected)
    *ptr = new;
  return original;
}
</code></pre>
<p><img src="28/img/fig28_4.PNG" alt="" /></p>
<p><strong>Hình 28.4: Compare-and-swap</strong></p>
<p>Ý tưởng cơ bản của <code>compare-and-swap</code> là kiểm tra xem giá trị tại địa chỉ <code>ptr</code> có bằng <code>expected</code> hay không; nếu có, cập nhật vị trí bộ nhớ đó thành giá trị <code>new</code>. Nếu không, không làm gì cả. Trong cả hai trường hợp, trả về giá trị gốc tại vị trí bộ nhớ đó, cho phép đoạn code gọi <code>compare-and-swap</code> biết được thao tác có thành công hay không.</p>
<p>Với lệnh <code>compare-and-swap</code>, ta có thể xây dựng lock tương tự như với <code>test-and-set</code>. Ví dụ, ta chỉ cần thay hàm <code>lock()</code> ở trên bằng:</p>
<pre><code class="language-c">void lock(lock_t *lock) {
  while (CompareAndSwap(&amp;lock-&gt;flag, 0, 1) == 1)
    ; // spin
}
</code></pre>
<p>Phần còn lại của code giống như ví dụ <code>test-and-set</code> ở trên. Code này hoạt động tương tự: nó kiểm tra nếu <code>flag</code> bằng 0 thì nguyên tử thay bằng 1 để lấy lock. Các thread cố lấy lock khi nó đang bị giữ sẽ bị kẹt spin cho đến khi lock được nhả.</p>
<p>Nếu bạn muốn xem cách triển khai <code>compare-and-swap</code> phiên bản x86 có thể gọi từ C, đoạn code (từ [S05]) có thể hữu ích<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<p>Cuối cùng, như bạn có thể nhận ra, <code>compare-and-swap</code> là một lệnh mạnh hơn <code>test-and-set</code>. Chúng ta sẽ tận dụng sức mạnh này trong tương lai khi tìm hiểu về <strong>lock-free synchronization</strong> (đồng bộ hóa không khóa) [H91]. Tuy nhiên, nếu chỉ xây dựng spin lock đơn giản với nó, hành vi sẽ giống hệt spin lock đã phân tích ở trên.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>github.com/remzi-arpacidusseau/ostep-code/tree/master/threads-locks</p>
</div>
<h2 id="2810-load-linked-và-store-conditional"><a class="header" href="#2810-load-linked-và-store-conditional">28.10 Load-Linked và Store-Conditional</a></h2>
<p>Một số nền tảng cung cấp cặp lệnh hoạt động cùng nhau để giúp xây dựng critical section. Trên kiến trúc <strong>MIPS</strong> [H93], ví dụ, lệnh <strong>load-linked</strong> và <strong>store-conditional</strong> có thể được dùng kết hợp để xây dựng lock và các cấu trúc đồng thời khác. Mã giả C cho các lệnh này được thể hiện trong <strong>Hình 28.5</strong>. Alpha, PowerPC và ARM cũng cung cấp các lệnh tương tự [W09].</p>
<pre><code class="language-c">int LoadLinked(int *ptr) {
  return *ptr;
}

int StoreConditional(int *ptr, int value) {
  if (no update to *ptr since LL to this addr) {
    *ptr = value;
    return 1; // thành công!
  } else {
    return 0; // thất bại
  }
}
</code></pre>
<p><img src="28/img/fig28_5.PNG" alt="" /></p>
<p><strong>Hình 28.5: Load-linked và Store-conditional</strong></p>
<p><code>Load-linked</code> hoạt động gần giống như lệnh load thông thường, chỉ đơn giản là lấy giá trị từ bộ nhớ và đặt vào thanh ghi. Sự khác biệt chính nằm ở <code>store-conditional</code>, lệnh này chỉ thành công (và cập nhật giá trị tại địa chỉ vừa được load-linked) nếu <strong>không có</strong> thao tác store nào khác tới địa chỉ đó diễn ra trong khoảng thời gian từ lúc load-linked. Nếu thành công, <code>store-conditional</code> trả về 1 và cập nhật giá trị tại <code>ptr</code> thành <code>value</code>; nếu thất bại, giá trị tại <code>ptr</code> không thay đổi và trả về 0.</p>
<p><strong>Thử thách</strong>: hãy tự nghĩ cách xây dựng lock bằng load-linked và store-conditional. Sau đó, so sánh với đoạn code dưới đây — một giải pháp đơn giản. Giải pháp được thể hiện trong <strong>Hình 28.6</strong>.</p>
<pre><code class="language-c">void lock(lock_t *lock) {
  while (1) {
    while (LoadLinked(&amp;lock-&gt;flag) == 1)
      ; // spin cho đến khi flag = 0
    if (StoreConditional(&amp;lock-&gt;flag, 1) == 1)
      return; // nếu đặt thành 1 thành công: xong
    // nếu thất bại: thử lại
  }
}

void unlock(lock_t *lock) {
  lock-&gt;flag = 0;
}
</code></pre>
<p><img src="28/img/fig28_6.PNG" alt="" /></p>
<p><strong>Hình 28.6: Sử dụng LL/SC để xây dựng một Lock</strong></p>
<p>Phần code <code>lock()</code> là phần thú vị nhất. Đầu tiên, một <strong>thread</strong> sẽ <strong>spin</strong> (quay vòng chờ) cho đến khi <code>flag</code> được đặt về 0 (biểu thị rằng lock đang không bị giữ). Khi điều kiện này thỏa mãn, thread sẽ cố gắng lấy lock thông qua lệnh <strong>store-conditional</strong>; nếu thành công, thread đã thay đổi giá trị của <code>flag</code> thành 1 một cách <strong>atomic</strong> (nguyên tử) và do đó có thể tiếp tục vào <strong>critical section</strong> (vùng tới hạn).</p>
<p>Hãy lưu ý cách mà việc <strong>store-conditional</strong> có thể thất bại. Một thread gọi <code>lock()</code> và thực hiện <strong>load-linked</strong>, trả về 0 vì lock chưa bị giữ. Trước khi nó có thể thực hiện <strong>store-conditional</strong>, nó bị <strong>interrupt</strong> (ngắt) và một thread khác đi vào code lock, cũng thực hiện lệnh <strong>load-linked</strong>, cũng nhận được giá trị 0 và tiếp tục. Tại thời điểm này, cả hai thread đều đã thực hiện load-linked và đều chuẩn bị thực hiện store-conditional. Điểm mấu chốt của cặp lệnh này là <strong>chỉ một</strong> trong hai thread sẽ thành công trong việc cập nhật <code>flag</code> thành 1 và do đó lấy được lock; thread thứ hai khi thực hiện store-conditional sẽ thất bại (vì thread kia đã cập nhật giá trị của <code>flag</code> giữa thời điểm load-linked và store-conditional của nó) và do đó phải thử lấy lock lại từ đầu.</p>
<p>Trong một buổi học vài năm trước, sinh viên đại học David Capel đã gợi ý một dạng rút gọn hơn của đoạn code trên, dành cho những ai thích <strong>short-circuiting boolean conditionals</strong> (rút gọn điều kiện logic). Hãy thử xem bạn có hiểu tại sao nó tương đương không. Rõ ràng là nó ngắn hơn!</p>
<pre><code class="language-c">void lock(lock_t *lock) {
  while (LoadLinked(&amp;lock-&gt;flag) ||
         !StoreConditional(&amp;lock-&gt;flag, 1))
    ; // spin
}
</code></pre>
<h2 id="2811-fetch-and-add"><a class="header" href="#2811-fetch-and-add">28.11 Fetch-And-Add</a></h2>
<p>Một <strong>hardware primitive</strong> (nguyên thủy phần cứng) cuối cùng là lệnh <strong>fetch-and-add</strong>, lệnh này sẽ <strong>tăng</strong> một giá trị một cách nguyên tử đồng thời trả về giá trị cũ tại một địa chỉ nhất định. Mã giả C cho lệnh fetch-and-add như sau:</p>
<pre><code class="language-c">int FetchAndAdd(int *ptr) {
  int old = *ptr;
  *ptr = old + 1;
  return old;
}
</code></pre>
<blockquote>
<p><strong>TIP: ÍT CODE HƠN LÀ CODE TỐT HƠN (LUẬT CỦA LAUER)</strong><br />
Lập trình viên thường hay khoe khoang về việc họ đã viết bao nhiêu code để làm một việc gì đó. Cách nghĩ này là sai lầm cơ bản. Điều đáng khoe khoang hơn là bạn đã viết <strong>ít</strong> code như thế nào để hoàn thành một nhiệm vụ. Code ngắn gọn, súc tích luôn được ưu tiên; nó thường dễ hiểu hơn và ít lỗi hơn. Như Hugh Lauer đã nói khi bàn về việc xây dựng hệ điều hành Pilot: “Nếu cùng một nhóm người có gấp đôi thời gian, họ có thể tạo ra một hệ thống tốt tương đương chỉ với một nửa số dòng code.” [L81] Chúng ta sẽ gọi đây là <strong>Luật của Lauer</strong>, và nó rất đáng để ghi nhớ. Vì vậy, lần tới khi bạn định khoe về việc đã viết bao nhiêu code để hoàn thành bài tập, hãy suy nghĩ lại, hoặc tốt hơn, hãy quay lại, viết lại và làm cho code rõ ràng và ngắn gọn nhất có thể.</p>
</blockquote>
<p>Trong ví dụ này, chúng ta sẽ sử dụng <code>fetch-and-add</code> để xây dựng một <strong>ticket lock</strong> thú vị hơn, được giới thiệu bởi Mellor-Crummey và Scott [MS91]. Code cho lock và unlock được thể hiện trong <strong>Hình 28.7</strong> (trang 14).</p>
<pre><code class="language-c">typedef struct __lock_t {
  int ticket;
  int turn;
} lock_t;

void lock_init(lock_t *lock) {
  lock-&gt;ticket = 0;
  lock-&gt;turn   = 0;
}

void lock(lock_t *lock) {
  int myturn = FetchAndAdd(&amp;lock-&gt;ticket);
  while (lock-&gt;turn != myturn)
    ; // spin
}

void unlock(lock_t *lock) {
  lock-&gt;turn = lock-&gt;turn + 1;
}
</code></pre>
<p><img src="28/img/fig28_7.PNG" alt="" /></p>
<p><strong>Hình 28.7: Ticket Locks</strong></p>
<p>Thay vì chỉ dùng một giá trị, giải pháp này sử dụng kết hợp hai biến <code>ticket</code> và <code>turn</code> để xây dựng lock. Cách hoạt động cơ bản khá đơn giản: khi một thread muốn lấy lock, nó thực hiện một thao tác <code>fetch-and-add</code> nguyên tử trên giá trị <code>ticket</code>; giá trị trả về được coi là “lượt” (<code>myturn</code>) của thread đó. Biến <code>lock-&gt;turn</code> dùng chung toàn cục sẽ xác định lượt của thread nào; khi (<code>myturn == turn</code>) đối với một thread, đó là lượt của thread đó để vào critical section. Việc unlock chỉ đơn giản là tăng <code>turn</code> để thread đang chờ tiếp theo (nếu có) có thể vào critical section.</p>
<p>Hãy lưu ý một điểm khác biệt quan trọng của giải pháp này so với các nỗ lực trước: nó đảm bảo <strong>progress</strong> (tiến triển) cho tất cả các thread. Một khi thread được gán giá trị ticket, nó sẽ được chạy vào một thời điểm nào đó trong tương lai (sau khi các thread trước nó đã đi qua critical section và nhả lock). Trong các nỗ lực trước, không có đảm bảo như vậy; một thread spin trên <code>test-and-set</code> (ví dụ) có thể spin mãi ngay cả khi các thread khác liên tục lấy và nhả lock.</p>
<h2 id="2812-quá-nhiều-spinning-làm-gì-tiếp"><a class="header" href="#2812-quá-nhiều-spinning-làm-gì-tiếp">28.12 Quá nhiều spinning: Làm gì tiếp?</a></h2>
<p>Các lock dựa trên phần cứng của chúng ta rất đơn giản (chỉ vài dòng code) và chúng hoạt động (bạn thậm chí có thể chứng minh điều đó nếu muốn, bằng cách viết code), đây là hai đặc tính tuyệt vời của bất kỳ hệ thống hoặc đoạn code nào. Tuy nhiên, trong một số trường hợp, các giải pháp này có thể khá <strong>kém hiệu quả</strong>. Hãy tưởng tượng bạn đang chạy hai thread trên một <strong>single processor</strong>. Giờ giả sử một thread (thread 0) đang ở trong critical section và giữ lock, và không may bị <strong>interrupt</strong>. Thread thứ hai (thread 1) lúc này cố gắng lấy lock, nhưng phát hiện nó đang bị giữ. Do đó, nó bắt đầu spin. Và spin. Rồi spin tiếp. Cuối cùng, một <strong>timer interrupt</strong> xảy ra, thread 0 được chạy lại, nhả lock, và cuối cùng (ở lần chạy tiếp theo chẳng hạn), thread 1 sẽ không phải spin nhiều nữa và có thể lấy được lock. Như vậy, bất cứ khi nào một thread bị kẹt spin trong tình huống như thế này, nó sẽ lãng phí <strong>toàn bộ time slice</strong> chỉ để kiểm tra một giá trị mà sẽ không thay đổi! Vấn đề còn tệ hơn khi có N thread tranh chấp lock; <strong>N − 1</strong> time slice có thể bị lãng phí theo cách tương tự, chỉ để spin và chờ một thread duy nhất nhả lock. Và do đó, chúng ta có vấn đề tiếp theo:</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ TRÁNH SPINNING</strong><br />
Làm thế nào để phát triển một lock mà không lãng phí thời gian CPU vào việc spin vô ích?</p>
</blockquote>
<p>Chỉ hỗ trợ phần cứng thôi là <strong>không đủ</strong> để giải quyết vấn đề này. Chúng ta sẽ cần cả sự hỗ trợ từ <strong>OS</strong>! Hãy cùng tìm hiểu cách mà điều đó có thể hoạt động.</p>
<h2 id="2813-một-cách-tiếp-cận-đơn-giản-just-yield-baby"><a class="header" href="#2813-một-cách-tiếp-cận-đơn-giản-just-yield-baby">28.13 Một cách tiếp cận đơn giản: <strong>Just Yield, Baby</strong></a></h2>
<p><strong>Hardware support</strong> (hỗ trợ phần cứng) đã giúp chúng ta tiến khá xa: có được các <strong>lock</strong> (khóa) hoạt động, và thậm chí (như trong trường hợp <strong>ticket lock</strong>) còn đảm bảo <strong>fairness</strong> (tính công bằng) trong việc giành lock. Tuy nhiên, chúng ta vẫn còn một vấn đề: phải làm gì khi một <strong>context switch</strong> (chuyển ngữ cảnh) xảy ra trong <strong>critical section</strong> (vùng tới hạn), và các <strong>thread</strong> (luồng) bắt đầu <strong>spin</strong> (quay vòng chờ) vô tận, đợi thread đang giữ lock (và bị ngắt) được chạy lại?</p>
<p>Cách thử đầu tiên của chúng ta là một phương pháp đơn giản và “thân thiện”: khi bạn sắp spin, hãy nhường CPU cho thread khác. Như Al Davis có thể nói: <em>“just yield, baby!”</em> [D91]. <strong>Hình 28.8</strong> (trang 15) minh họa cách tiếp cận này.</p>
<pre><code class="language-c">void init() {
  flag = 0;
}

void lock() {
  while (TestAndSet(&amp;flag, 1) == 1)
    yield(); // nhường CPU
}

void unlock() {
  flag = 0;
}
</code></pre>
<p><img src="28/img/fig28_8.PNG" alt="" /></p>
<p><strong>Hình 28.8: Lock với Test-and-set và Yield</strong></p>
<p>Trong cách tiếp cận này, chúng ta giả định có một <strong>OS primitive</strong> (nguyên thủy hệ điều hành) <code>yield()</code> mà một thread có thể gọi khi muốn nhường CPU và cho phép thread khác chạy. Một thread có thể ở một trong ba trạng thái (<strong>running</strong>, <strong>ready</strong>, hoặc <strong>blocked</strong>); <code>yield</code> đơn giản là một <strong>system call</strong> (call hệ thống) chuyển thread gọi hàm từ trạng thái running sang trạng thái ready, và do đó đưa một thread khác lên trạng thái running. Nói cách khác, thread gọi <code>yield</code> tự loại mình khỏi lịch chạy.</p>
<p>Hãy nghĩ về ví dụ với hai thread trên một CPU; trong trường hợp này, cách tiếp cận dựa trên yield hoạt động khá tốt. Nếu một thread gọi <code>lock()</code> và phát hiện lock đang bị giữ, nó sẽ đơn giản nhường CPU, và do đó thread còn lại sẽ chạy và hoàn tất critical section của nó. Trong trường hợp đơn giản này, cách tiếp cận yield hoạt động hiệu quả.</p>
<p>Bây giờ hãy xét trường hợp có nhiều thread (giả sử 100) liên tục tranh chấp lock. Trong trường hợp này, nếu một thread lấy được lock và bị <strong>preempted</strong> (tạm dừng) trước khi nhả lock, 99 thread còn lại sẽ lần lượt gọi <code>lock()</code>, phát hiện lock đang bị giữ, và nhường CPU. Giả sử <strong>scheduler</strong> (bộ lập lịch) dùng kiểu <strong>round-robin</strong>, cả 99 thread này sẽ thực hiện mô hình “chạy rồi yield” trước khi thread giữ lock được chạy lại. Mặc dù tốt hơn so với cách spin (vốn sẽ lãng phí 99 <strong>time slice</strong> chỉ để quay vòng chờ), cách này vẫn tốn kém; chi phí của một <strong>context switch</strong> có thể đáng kể, và do đó vẫn có nhiều lãng phí.</p>
<p>Tệ hơn, cách này không giải quyết được <strong>starvation</strong> (đói tài nguyên). Một thread có thể bị kẹt trong vòng lặp yield vô tận trong khi các thread khác liên tục vào và ra khỏi critical section. Rõ ràng, chúng ta cần một cách tiếp cận giải quyết starvation một cách trực tiếp.</p>
<h2 id="2814-sử-dụng-hàng-đợi-sleeping-thay-vì-spinning"><a class="header" href="#2814-sử-dụng-hàng-đợi-sleeping-thay-vì-spinning">28.14 Sử dụng hàng đợi: <strong>Sleeping thay vì Spinning</strong></a></h2>
<p>Vấn đề thực sự với một số cách tiếp cận trước đây (ngoại trừ ticket lock) là chúng để quá nhiều thứ cho <strong>may rủi</strong>. <strong>Scheduler</strong> quyết định thread nào sẽ chạy tiếp theo; nếu scheduler chọn sai, một thread được chạy sẽ hoặc là spin chờ lock (cách tiếp cận đầu tiên của chúng ta), hoặc là yield CPU ngay lập tức (cách tiếp cận thứ hai). Dù theo cách nào, vẫn có khả năng lãng phí và không có cơ chế ngăn chặn starvation.</p>
<p><img src="28/img/fig28_9.PNG" alt="" /></p>
<p><strong>Hình 28.9: Lock với Queue, Test-and-set, Yield và Wakeup</strong></p>
<p>Do đó, chúng ta phải <strong>chủ động kiểm soát</strong> thread nào sẽ được lấy lock tiếp theo sau khi thread hiện tại nhả lock. Để làm điều này, chúng ta cần thêm một chút hỗ trợ từ <strong>OS</strong> (hệ điều hành), cũng như một <strong>queue</strong> (hàng đợi) để theo dõi các thread đang chờ lấy lock.</p>
<p>Để đơn giản, chúng ta sẽ sử dụng hỗ trợ do <strong>Solaris</strong> cung cấp, thông qua hai call:</p>
<ul>
<li><code>park()</code> để đưa thread gọi hàm vào trạng thái ngủ (<strong>sleep</strong>),</li>
<li><code>unpark(threadID)</code> để đánh thức một thread cụ thể được chỉ định bởi <code>threadID</code>.</li>
</ul>
<p>Hai hàm này có thể được dùng kết hợp để xây dựng một lock mà sẽ đưa thread gọi hàm vào ngủ nếu nó cố lấy một lock đang bị giữ, và đánh thức nó khi lock được giải phóng. Hãy xem code trong <strong>Hình 28.9</strong> để hiểu một cách sử dụng các primitive này.</p>
<blockquote>
<p><strong>ASIDE: LÝ DO KHÁC ĐỂ TRÁNH SPINNING – PRIORITY INVERSION</strong><br />
Một lý do tốt để tránh <strong>spin lock</strong> là hiệu năng: như đã mô tả trong phần chính, nếu một thread bị ngắt khi đang giữ lock, các thread khác dùng spin lock sẽ tiêu tốn rất nhiều thời gian CPU chỉ để chờ lock được giải phóng. Tuy nhiên, còn một lý do thú vị khác để tránh spin lock trên một số hệ thống: <strong>tính đúng đắn</strong>. Vấn đề cần cảnh giác được gọi là <strong>priority inversion</strong> (đảo ngược độ ưu tiên), một “tai họa liên hành tinh” đã xảy ra cả trên Trái Đất [M15] và Sao Hỏa [R97]!</p>
<p>Giả sử có hai thread trong hệ thống. Thread 2 (T2) có <strong>scheduling priority</strong> (độ ưu tiên lập lịch) cao, và Thread 1 (T1) có độ ưu tiên thấp hơn. Giả sử <strong>CPU scheduler</strong> luôn chạy T2 thay vì T1 nếu cả hai đều sẵn sàng chạy; T1 chỉ chạy khi T2 không thể (ví dụ: khi T2 bị block do I/O).</p>
<p>Bây giờ, vấn đề xảy ra: giả sử T2 bị block vì lý do nào đó. T1 chạy, lấy một spin lock và vào critical section. T2 được <strong>unblock</strong> (có thể vì một I/O hoàn tất), và scheduler lập tức chạy T2 (loại T1 ra). T2 cố lấy lock, nhưng không được (vì T1 đang giữ lock), nên nó cứ spin mãi. Vì lock là spin lock, T2 spin vô tận và hệ thống bị treo.</p>
<p>Chỉ tránh dùng spin lock thôi thì đáng tiếc là <strong>không</strong> tránh được vấn đề inversion. Hãy tưởng tượng có ba thread: T1, T2, và T3, với T3 có độ ưu tiên cao nhất, T1 thấp nhất. Giả sử T1 lấy lock. T3 bắt đầu chạy và vì có độ ưu tiên cao hơn T1, nó lập tức chạy (preempt T1). T3 cố lấy lock mà T1 giữ, nhưng bị kẹt chờ. Nếu T2 bắt đầu chạy, nó có độ ưu tiên cao hơn T1, nên sẽ chạy. T3, dù có độ ưu tiên cao hơn T2, vẫn bị kẹt chờ T1, và T1 có thể không bao giờ chạy nếu T2 vẫn chạy. Thật trớ trêu khi T3 “hùng mạnh” không thể chạy, trong khi T2 “thấp kém” lại chiếm CPU.</p>
<p>Có nhiều cách để xử lý vấn đề priority inversion. Trong trường hợp spin lock gây ra vấn đề, có thể tránh dùng spin lock (sẽ được mô tả bên dưới). Tổng quát hơn, một thread có độ ưu tiên cao đang chờ một thread có độ ưu tiên thấp có thể <strong>tạm thời nâng độ ưu tiên</strong> của thread thấp hơn, cho phép nó chạy và giải quyết inversion — kỹ thuật này gọi là <strong>priority inheritance</strong> (kế thừa độ ưu tiên). Giải pháp đơn giản nhất: đảm bảo tất cả thread có cùng độ ưu tiên.</p>
</blockquote>
<p>Trong ví dụ này, chúng ta làm hai việc thú vị:</p>
<ol>
<li>Kết hợp ý tưởng <code>test-and-set</code> cũ với một <strong>queue</strong> chứa các thread chờ lock để tạo ra một lock hiệu quả hơn.</li>
<li>Sử dụng queue để kiểm soát thread nào sẽ lấy lock tiếp theo, từ đó tránh <strong>starvation</strong> (đói tài nguyên).</li>
</ol>
<p>Bạn có thể để ý cách <code>guard</code> được sử dụng (Hình 28.9, trang 16), về cơ bản là một spin lock bao quanh các thao tác trên <code>flag</code> và queue mà lock sử dụng. Cách này không loại bỏ hoàn toàn spin-waiting; một thread có thể bị ngắt khi đang acquire hoặc release lock, khiến các thread khác phải spin chờ nó chạy lại. Tuy nhiên, thời gian spin là rất ngắn (chỉ vài lệnh bên trong code <code>lock</code> và <code>unlock</code>, thay vì toàn bộ critical section do người dùng định nghĩa), nên cách này có thể chấp nhận được.</p>
<p>Bạn cũng có thể thấy rằng trong <code>lock()</code>, khi một thread không thể lấy lock (lock đang bị giữ), chúng ta cẩn thận thêm thread đó vào queue (bằng cách gọi <code>gettid()</code> để lấy thread ID của thread hiện tại), đặt <code>guard</code> về 0, và nhường CPU. Một câu hỏi cho bạn: điều gì sẽ xảy ra nếu việc nhả guard lock diễn ra <strong>sau</strong> <code>park()</code> thay vì trước? Gợi ý: điều gì đó tệ sẽ xảy ra.</p>
<p>Bạn cũng có thể nhận thấy rằng <code>flag</code> <strong>không</strong> được đặt lại về 0 khi một thread khác được đánh thức. Tại sao? Đây không phải lỗi, mà là <strong>bắt buộc</strong>! Khi một thread được đánh thức, nó sẽ như thể đang quay lại từ <code>park()</code>; tuy nhiên, tại thời điểm đó nó <strong>không giữ</strong> <code>guard</code> và do đó không thể đặt <code>flag</code> thành 1. Vì vậy, chúng ta chỉ đơn giản <strong>chuyển lock trực tiếp</strong> từ thread nhả lock sang thread tiếp theo lấy lock; <code>flag</code> không được đặt về 0 ở giữa.</p>
<p>Cuối cùng, bạn có thể nhận thấy một race condition tiềm ẩn trong giải pháp, ngay trước call <code>park()</code>. Nếu thời điểm không may, một thread chuẩn bị park, giả định rằng nó sẽ ngủ cho đến khi lock được nhả. Nếu lúc đó chuyển sang một thread khác (ví dụ: thread đang giữ lock) và thread này nhả lock, thì lần park tiếp theo của thread đầu tiên có thể ngủ mãi mãi — vấn đề này gọi là <strong>wakeup/waiting race</strong>.</p>
<p>Solaris giải quyết vấn đề này bằng cách thêm một system call thứ ba: <code>setpark()</code>. Khi gọi hàm này, thread báo rằng nó sắp park. Nếu sau đó nó bị ngắt và một thread khác gọi <code>unpark</code> trước khi <code>park</code> thực sự được gọi, thì lần <code>park</code> tiếp theo sẽ trả về ngay lập tức thay vì ngủ. Việc sửa code trong <code>lock()</code> là rất nhỏ:</p>
<pre><code class="language-c">queue_add(m-&gt;q, gettid());
setpark(); // code mới
m-&gt;guard = 0;
</code></pre>
<p>Một giải pháp khác là truyền <code>guard</code> vào kernel. Khi đó, kernel có thể đảm bảo việc nhả lock và đưa thread ra khỏi hàng đợi diễn ra một cách nguyên tử.</p>
<h2 id="2815-hệ-điều-hành-khác-hỗ-trợ-khác-nhau"><a class="header" href="#2815-hệ-điều-hành-khác-hỗ-trợ-khác-nhau">28.15 Hệ điều hành khác, hỗ trợ khác nhau</a></h2>
<p>Cho đến giờ, chúng ta đã thấy một dạng hỗ trợ mà OS có thể cung cấp để xây dựng một lock hiệu quả hơn trong thư viện thread. Các OS khác cũng cung cấp hỗ trợ tương tự; chi tiết có thể khác nhau.</p>
<p>Ví dụ, <strong>Linux</strong> cung cấp một cơ chế gọi là <strong>futex</strong> (fast userspace mutex), tương tự như giao diện của Solaris nhưng cung cấp nhiều chức năng hơn trong kernel. Cụ thể, mỗi futex gắn với một vị trí bộ nhớ vật lý cụ thể, cũng như một hàng đợi trong kernel cho mỗi futex. Các thread có thể dùng các call futex (mô tả bên dưới) để ngủ và thức khi cần.</p>
<p>Cụ thể, có hai call:</p>
<ul>
<li><code>futex_wait(address, expected)</code> đưa thread gọi hàm vào trạng thái ngủ, giả sử giá trị tại địa chỉ <code>address</code> bằng <code>expected</code>. Nếu không bằng, call trả về ngay lập tức.</li>
<li><code>futex_wake(address)</code> đánh thức một thread đang chờ trong hàng đợi.</li>
</ul>
<p>Cách sử dụng các call này trong một <strong>Linux mutex</strong> được minh họa trong <strong>Hình 28.10</strong> (trang 19).</p>
<p><img src="28/img/fig28_10.PNG" alt="" /></p>
<p><strong>Hình 28.10: Linux-based Futex Locks</strong></p>
<p>Đoạn code này trích từ tệp <code>lowlevellock.h</code> trong thư viện <strong>nptl</strong> (một phần của thư viện <strong>gnu libc</strong>) [L09] thú vị ở một vài điểm.</p>
<p>Thứ nhất, nó sử dụng <strong>một số nguyên duy nhất</strong> để theo dõi cả việc lock đang bị giữ hay không (<strong>bit cao</strong> của số nguyên) và số lượng <strong>waiter</strong> (thread đang chờ lock) (<strong>các bit còn lại</strong>). Do đó, nếu giá trị của lock là <strong>số âm</strong>, điều đó có nghĩa là lock đang bị giữ (vì bit cao được đặt và bit này quyết định dấu của số nguyên).</p>
<p>Thứ hai, đoạn code này cho thấy cách <strong>tối ưu hóa cho trường hợp phổ biến</strong>, cụ thể là khi <strong>không có tranh chấp</strong> lock; với chỉ một thread thực hiện acquire và release lock, lượng công việc thực hiện là rất ít (một thao tác nguyên tử <code>test-and-set</code> để lock và một phép cộng nguyên tử để release lock).</p>
<p>Hãy thử tự phân tích phần còn lại của lock “thực tế” này để hiểu cách nó hoạt động. Hãy làm điều đó và trở thành <strong>bậc thầy về Linux locking</strong>, hoặc ít nhất là một người biết lắng nghe khi sách bảo bạn làm gì<sup class="footnote-reference"><a href="#3">3</a></sup>.</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Giống như việc mua một bản in của OSTEP! Dù cuốn sách có sẵn miễn phí trên mạng, nhưng chẳng phải bạn sẽ rất thích có một bản bìa cứng để trên bàn làm việc sao? Hoặc tốt hơn, mười bản để chia sẻ với bạn bè và gia đình? Và có thể thêm một bản nữa để… ném vào kẻ thù? (cuốn sách khá nặng, và do đó ném nó lại khá hiệu quả)</p>
</div>
<h2 id="2816-two-phase-locks"><a class="header" href="#2816-two-phase-locks">28.16 Two-Phase Locks</a></h2>
<p>Một ghi chú cuối: cách tiếp cận của Linux mang hơi hướng của một phương pháp cũ đã được sử dụng không liên tục trong nhiều năm, ít nhất là từ thời <strong>Dahm Locks</strong> vào đầu những năm 1960 [M82], và hiện được gọi là <strong>two-phase lock</strong> (khóa hai pha).</p>
<p>Một two-phase lock nhận ra rằng <strong>spinning</strong> (quay vòng chờ) có thể hữu ích, đặc biệt nếu lock sắp được nhả. Vì vậy, ở <strong>pha đầu tiên</strong>, lock sẽ spin trong một khoảng thời gian, hy vọng có thể acquire lock.</p>
<p>Tuy nhiên, nếu lock không được acquire trong pha spin đầu tiên, sẽ chuyển sang <strong>pha thứ hai</strong>, trong đó thread gọi hàm sẽ được đưa vào trạng thái <strong>sleep</strong> (ngủ) và chỉ được đánh thức khi lock trở nên rảnh. Lock của Linux ở trên là một dạng của loại lock này, nhưng nó chỉ spin <strong>một lần</strong>; một phiên bản tổng quát hơn có thể spin trong vòng lặp một khoảng thời gian cố định trước khi sử dụng hỗ trợ <code>futex</code> để sleep.</p>
<p>Two-phase lock là một ví dụ khác của <strong>hybrid approach</strong> (cách tiếp cận lai), nơi việc kết hợp hai ý tưởng tốt có thể tạo ra một ý tưởng tốt hơn. Tất nhiên, việc này phụ thuộc rất nhiều vào nhiều yếu tố, bao gồm môi trường phần cứng, số lượng thread, và đặc điểm tải công việc. Như thường lệ, việc tạo ra một loại lock <strong>general-purpose</strong> (dùng chung) tốt cho mọi trường hợp sử dụng là một thách thức lớn.</p>
<h2 id="2817-tóm-tắt-summary"><a class="header" href="#2817-tóm-tắt-summary">28.17 Tóm tắt (Summary)</a></h2>
<p>Cách tiếp cận ở trên cho thấy cách mà các <strong>real lock</strong> (lock thực tế) được xây dựng ngày nay: một phần <strong>hardware support</strong> (hỗ trợ phần cứng) (dưới dạng các lệnh mạnh hơn) kết hợp với một phần <strong>OS support</strong> (hỗ trợ từ hệ điều hành) (ví dụ: dưới dạng các primitive <code>park()</code> và <code>unpark()</code> trên Solaris, hoặc <code>futex</code> trên Linux).</p>
<p>Tất nhiên, chi tiết sẽ khác nhau, và đoạn code chính xác để thực hiện việc locking như vậy thường được <strong>tinh chỉnh rất kỹ</strong>. Hãy xem mã nguồn của Solaris hoặc Linux nếu bạn muốn biết thêm chi tiết; chúng là những tài liệu rất thú vị để đọc [L09, S09]. Ngoài ra, hãy xem công trình xuất sắc của David và cộng sự để so sánh các chiến lược locking trên các hệ thống <strong>multiprocessor</strong> (đa xử lý) hiện đại [D+13].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="29-cấu-trúc-dữ-liệu-đồng-thời-dựa-trên-khóa-lock-based-concurrent-data-structures"><a class="header" href="#29-cấu-trúc-dữ-liệu-đồng-thời-dựa-trên-khóa-lock-based-concurrent-data-structures">29 Cấu trúc dữ liệu đồng thời dựa trên khóa (Lock-based Concurrent Data Structures)</a></h1>
<p>Trước khi đi xa hơn khỏi chủ đề <strong>lock</strong> (khóa), chúng ta sẽ mô tả cách sử dụng khóa trong một số cấu trúc dữ liệu phổ biến. Việc thêm khóa vào một cấu trúc dữ liệu để cho phép <strong>thread</strong> (luồng) sử dụng sẽ khiến cấu trúc đó trở nên <strong>thread safe</strong> (an toàn luồng). Tất nhiên, cách thức chính xác mà các khóa này được thêm vào sẽ quyết định cả <strong>tính đúng đắn</strong> (correctness) và <strong>hiệu năng</strong> (performance) của cấu trúc dữ liệu. Và đây chính là thách thức của chúng ta:</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ THÊM KHÓA VÀO CẤU TRÚC DỮ LIỆU</strong><br />
Khi được giao một cấu trúc dữ liệu cụ thể, chúng ta nên thêm khóa vào như thế nào để nó hoạt động đúng? Hơn nữa, làm thế nào để thêm khóa sao cho cấu trúc dữ liệu đạt hiệu năng cao, cho phép nhiều thread truy cập đồng thời (concurrently) cùng lúc?</p>
</blockquote>
<p>Tất nhiên, chúng ta khó có thể bao quát tất cả các cấu trúc dữ liệu hoặc mọi phương pháp thêm tính đồng thời, vì đây là một chủ đề đã được nghiên cứu trong nhiều năm, với (thực sự) hàng ngàn bài báo khoa học được công bố. Do đó, chúng tôi hy vọng sẽ cung cấp một phần giới thiệu đủ để bạn nắm được cách tư duy cần thiết, và giới thiệu một số nguồn tài liệu tốt để bạn tự tìm hiểu thêm. Chúng tôi nhận thấy khảo sát của Moir và Shavit là một nguồn thông tin tuyệt vời [MS04].</p>
<h2 id="291-bộ-đếm-đồng-thời-concurrent-counters"><a class="header" href="#291-bộ-đếm-đồng-thời-concurrent-counters">29.1 Bộ đếm đồng thời (Concurrent Counters)</a></h2>
<p>Một trong những cấu trúc dữ liệu đơn giản nhất là <strong>counter</strong> (bộ đếm). Đây là một cấu trúc thường được sử dụng và có giao diện đơn giản. Chúng ta định nghĩa một bộ đếm đơn giản <strong>không đồng thời</strong> trong <strong>Hình 29.1</strong>.</p>
<h3 id="Đơn-giản-nhưng-không-mở-rộng-được-simple-but-not-scalable"><a class="header" href="#Đơn-giản-nhưng-không-mở-rộng-được-simple-but-not-scalable">Đơn giản nhưng không mở rộng được (Simple But Not Scalable)</a></h3>
<p>Như bạn thấy, bộ đếm <strong>non-synchronized</strong> (không đồng bộ) là một cấu trúc dữ liệu rất đơn giản, chỉ cần một lượng mã nhỏ để triển khai. Giờ chúng ta có thách thức tiếp theo: làm thế nào để khiến đoạn code này <strong>thread safe</strong>? <strong>Hình 29.2</strong> cho thấy cách chúng ta thực hiện điều đó.</p>
<p><img src="29/img/fig29_1.PNG" alt="" /></p>
<p><strong>Hình 29.1:</strong> Bộ đếm không có khóa</p>
<p>Bộ đếm đồng thời này đơn giản và hoạt động đúng. Thực tế, nó tuân theo một <strong>mẫu thiết kế</strong> (design pattern) phổ biến đối với các cấu trúc dữ liệu đồng thời cơ bản nhất: chỉ cần thêm một <strong>lock duy nhất</strong>, được <strong>acquire</strong> (chiếm giữ) khi gọi một hàm thao tác trên cấu trúc dữ liệu, và <strong>release</strong> (giải phóng) khi trả về từ call hàm. Theo cách này, nó tương tự như một cấu trúc dữ liệu được xây dựng với <strong>monitor</strong> [BH73], nơi khóa được tự động chiếm giữ và giải phóng khi bạn gọi và trả về từ các phương thức của đối tượng.</p>
<p>Tại thời điểm này, bạn đã có một cấu trúc dữ liệu đồng thời hoạt động được. Vấn đề bạn có thể gặp phải là <strong>hiệu năng</strong>. Nếu cấu trúc dữ liệu của bạn quá chậm, bạn sẽ phải làm nhiều hơn là chỉ thêm một khóa duy nhất; các tối ưu hóa như vậy, nếu cần, sẽ là chủ đề của phần còn lại của chương này. Lưu ý rằng nếu cấu trúc dữ liệu không quá chậm, bạn đã xong! Không cần làm gì phức tạp nếu giải pháp đơn giản đã hiệu quả.</p>
<p>Để hiểu chi phí hiệu năng của cách tiếp cận đơn giản này, chúng tôi chạy một <strong>benchmark</strong> (bài kiểm thử hiệu năng) trong đó mỗi thread cập nhật một bộ đếm dùng chung một số lần cố định; sau đó chúng tôi thay đổi số lượng thread. <strong>Hình 29.5</strong> cho thấy tổng thời gian thực hiện, với từ một đến bốn thread hoạt động; mỗi thread cập nhật bộ đếm một triệu lần. Thí nghiệm này được chạy trên một máy iMac với bốn CPU Intel i5 2.7 GHz; với nhiều CPU hoạt động hơn, chúng tôi kỳ vọng sẽ hoàn thành nhiều công việc hơn trong cùng một đơn vị thời gian.</p>
<p>Từ đường trên cùng trong hình (được gắn nhãn “Precise”), bạn có thể thấy hiệu năng của bộ đếm <strong>synchronized</strong> (đồng bộ hóa) mở rộng rất kém. Trong khi một thread có thể hoàn thành một triệu lần cập nhật bộ đếm trong thời gian rất ngắn (khoảng 0,03 giây), thì khi có hai thread cùng cập nhật bộ đếm một triệu lần mỗi thread <strong>đồng thời</strong>, thời gian thực hiện tăng vọt (lên hơn 5 giây!). Và tình hình chỉ tệ hơn khi có nhiều thread hơn.</p>
<p><img src="29/img/fig29_2.PNG" alt="" /></p>
<p><strong>Hình 29.2:</strong> Bộ đếm có khóa</p>
<p>Lý tưởng nhất, bạn muốn các thread hoàn thành nhanh như trên nhiều bộ xử lý cũng giống như một thread trên một bộ xử lý. Đạt được điều này được gọi là <strong>perfect scaling</strong> (mở rộng hoàn hảo); mặc dù có nhiều công việc hơn, nhưng nó được thực hiện song song, và do đó thời gian hoàn thành nhiệm vụ không tăng lên.</p>
<h3 id="Đếm-có-khả-năng-mở-rộng-scalable-counting"><a class="header" href="#Đếm-có-khả-năng-mở-rộng-scalable-counting">Đếm có khả năng mở rộng (Scalable Counting)</a></h3>
<p>Thật đáng kinh ngạc, các nhà nghiên cứu đã nghiên cứu cách xây dựng các <strong>counter</strong> (bộ đếm) có khả năng mở rộng tốt hơn trong nhiều năm [MS04]. Càng đáng kinh ngạc hơn là việc các bộ đếm có khả năng mở rộng thực sự quan trọng, như các nghiên cứu gần đây về phân tích hiệu năng hệ điều hành đã chỉ ra [B+10]; nếu không có khả năng đếm mở rộng, một số <strong>workload</strong> (tải công việc) chạy trên Linux sẽ gặp vấn đề nghiêm trọng về khả năng mở rộng trên các máy đa lõi (<strong>multicore</strong>). Nhiều kỹ thuật đã được phát triển để giải quyết vấn đề này. Chúng ta sẽ mô tả một phương pháp được gọi là <strong>approximate counter</strong> (bộ đếm xấp xỉ) [C06].</p>
<p><strong>Approximate counter</strong> hoạt động bằng cách biểu diễn một bộ đếm logic duy nhất thông qua nhiều bộ đếm vật lý cục bộ (<strong>local counter</strong>), mỗi CPU core một bộ đếm, cùng với một bộ đếm toàn cục (<strong>global counter</strong>). Cụ thể, trên một máy có bốn CPU, sẽ có bốn local counter và một global counter. Ngoài các bộ đếm này, còn có các <strong>lock</strong> (khóa): một khóa cho mỗi local counter^[1], và một khóa cho global counter.</p>
<p>Ý tưởng cơ bản của approximate counting như sau: khi một <strong>thread</strong> (luồng) chạy trên một core nhất định muốn tăng giá trị bộ đếm, nó sẽ tăng local counter của core đó; việc truy cập local counter này được đồng bộ hóa thông qua local lock tương ứng. Vì mỗi CPU có local counter riêng, các thread trên các CPU khác nhau có thể cập nhật local counter mà không tranh chấp (<strong>contention</strong>), và do đó việc cập nhật bộ đếm có khả năng mở rộng.</p>
<p>Tuy nhiên, để giữ cho global counter luôn được cập nhật (trong trường hợp một thread muốn đọc giá trị của nó), các giá trị local sẽ được định kỳ chuyển sang global counter, bằng cách chiếm giữ (<strong>acquire</strong>) global lock và tăng nó thêm giá trị của local counter; sau đó local counter được đặt lại về 0.</p>
<p>Tần suất thực hiện việc chuyển từ local sang global này được xác định bởi một <strong>ngưỡng</strong> (<strong>threshold</strong>) S. S càng nhỏ, bộ đếm càng hoạt động giống bộ đếm không mở rộng ở trên; S càng lớn, bộ đếm càng có khả năng mở rộng, nhưng giá trị global có thể lệch xa hơn so với giá trị thực tế. Người ta có thể đơn giản là chiếm giữ tất cả local lock và global lock (theo một thứ tự xác định để tránh <strong>deadlock</strong>) để lấy giá trị chính xác, nhưng cách này không mở rộng được.</p>
<p>Để làm rõ, hãy xem một ví dụ (<strong>Hình 29.3</strong>). Trong ví dụ này, ngưỡng S được đặt là 5, và có các thread trên mỗi trong bốn CPU đang cập nhật local counter L1 ... L4. Giá trị của global counter (G) cũng được hiển thị trong <strong>trace</strong>, với thời gian tăng dần từ trên xuống. Ở mỗi bước thời gian, một local counter có thể được tăng; nếu giá trị local đạt ngưỡng S, giá trị local sẽ được chuyển sang global counter và local counter được đặt lại.</p>
<p><img src="29/img/fig29_3.PNG" alt="" /></p>
<p><strong>Hình 29.3:</strong> Theo dõi hoạt động của approximate counter</p>
<p>^[1]: Chúng ta cần local lock vì giả định rằng có thể có nhiều hơn một thread trên mỗi core. Nếu chỉ có một thread chạy trên mỗi core, sẽ không cần local lock.</p>
<p>Đường dưới trong <strong>Hình 29.5</strong> (được gắn nhãn “Approximate”, ở trang 6) cho thấy hiệu năng của approximate counter với ngưỡng S = 1024. Hiệu năng rất tốt; thời gian để cập nhật bộ đếm bốn triệu lần trên bốn bộ xử lý hầu như không cao hơn thời gian để cập nhật một triệu lần trên một bộ xử lý.</p>
<p><img src="29/img/fig29_4.PNG" alt="" /></p>
<p><strong>Hình 29.4:</strong> Triển khai approximate counter</p>
<p><img src="29/img/fig29_5.PNG" alt="" /></p>
<p><strong>Hình 29.5:</strong> Hiệu năng của bộ đếm truyền thống so với approximate counter</p>
<p><img src="29/img/fig29_6.PNG" alt="" /></p>
<p><strong>Hình 29.6:</strong> Khả năng mở rộng của approximate counter</p>
<p><strong>Hình 29.6</strong> cho thấy tầm quan trọng của giá trị ngưỡng S, với bốn thread mỗi thread tăng bộ đếm 1 triệu lần trên bốn CPU. Nếu S thấp, hiệu năng kém (nhưng giá trị global luôn khá chính xác); nếu S cao, hiệu năng rất tốt, nhưng giá trị global bị trễ (tối đa bằng số CPU nhân với S). Đây chính là sự đánh đổi giữa <strong>độ chính xác</strong> và <strong>hiệu năng</strong> mà approximate counter mang lại.</p>
<p>Một phiên bản sơ khai của approximate counter được thể hiện trong <strong>Hình 29.4</strong> (trang 5). Hãy đọc nó, hoặc tốt hơn, tự chạy thử nghiệm để hiểu rõ hơn cách nó hoạt động.</p>
<blockquote>
<p><strong>TIP: NHIỀU TÍNH ĐỒNG THỜI HƠN KHÔNG PHẢI LÚC NÀO CŨNG NHANH HƠN</strong><br />
Nếu thiết kế của bạn thêm quá nhiều chi phí phụ (ví dụ: liên tục acquire và release lock thay vì chỉ một lần), thì việc nó đồng thời hơn có thể không quan trọng. Các giải pháp đơn giản thường hoạt động tốt, đặc biệt nếu chúng hiếm khi sử dụng các thao tác tốn kém. Thêm nhiều khóa và sự phức tạp có thể là nguyên nhân khiến bạn thất bại. Tất cả những điều đó để nói rằng: chỉ có một cách thực sự để biết — hãy xây dựng cả hai phương án (đơn giản nhưng ít đồng thời hơn, và phức tạp nhưng đồng thời hơn) và đo lường hiệu năng. Cuối cùng, bạn không thể “ăn gian” hiệu năng; ý tưởng của bạn hoặc là nhanh hơn, hoặc là không.</p>
</blockquote>
<h2 id="292-danh-sách-liên-kết-đồng-thời-concurrent-linked-lists"><a class="header" href="#292-danh-sách-liên-kết-đồng-thời-concurrent-linked-lists">29.2 Danh sách liên kết đồng thời (Concurrent Linked Lists)</a></h2>
<p>Tiếp theo, chúng ta sẽ xem xét một cấu trúc phức tạp hơn: <strong>linked list</strong> (danh sách liên kết). Hãy bắt đầu lại với một cách tiếp cận cơ bản. Để đơn giản, chúng ta sẽ bỏ qua một số hàm hiển nhiên mà một danh sách như vậy thường có, và chỉ tập trung vào thao tác <strong>insert</strong> (chèn) và <strong>lookup</strong> (tìm kiếm) đồng thời; phần <strong>delete</strong> (xóa) và các thao tác khác sẽ để bạn đọc tự suy nghĩ. <strong>Hình 29.7</strong> cho thấy mã nguồn của cấu trúc dữ liệu sơ khai này.</p>
<p><img src="29/img/fig29_7.PNG" alt="" /></p>
<p><strong>Hình 29.7:</strong> Danh sách liên kết đồng thời</p>
<p>Như bạn thấy trong mã nguồn, hàm <code>insert</code> đơn giản là <strong>acquire</strong> (chiếm giữ) một <strong>lock</strong> khi bắt đầu, và <strong>release</strong> (giải phóng) nó khi kết thúc. Một vấn đề nhỏ nhưng tinh vi có thể xảy ra nếu <code>malloc()</code> thất bại (một trường hợp hiếm); trong tình huống này, mã nguồn cũng phải giải phóng khóa trước khi kết thúc thao tác chèn.</p>
<p>Kiểu <strong>luồng điều khiển ngoại lệ</strong> (exceptional control flow) này đã được chứng minh là rất dễ gây lỗi; một nghiên cứu gần đây về các bản vá của <strong>Linux kernel</strong> cho thấy một tỷ lệ lớn lỗi (gần 40%) xuất hiện ở những nhánh mã hiếm khi được thực thi như vậy (thực tế, quan sát này đã khơi nguồn cho một số nghiên cứu của chính chúng tôi, trong đó chúng tôi loại bỏ tất cả các nhánh xử lý lỗi cấp phát bộ nhớ trong một hệ thống file của Linux, giúp hệ thống trở nên ổn định hơn [S+11]).</p>
<p>Vậy, thách thức đặt ra: liệu chúng ta có thể viết lại các hàm <code>insert</code> và <code>lookup</code> sao cho vẫn đúng khi có chèn đồng thời, nhưng tránh được trường hợp nhánh lỗi cũng phải thêm lệnh <code>unlock</code>?</p>
<p>Câu trả lời, trong trường hợp này, là <strong>có</strong>. Cụ thể, chúng ta có thể sắp xếp lại mã nguồn một chút để việc <strong>lock</strong> và <strong>release</strong> chỉ bao quanh <strong>critical section</strong> (vùng tới hạn) thực sự trong hàm <code>insert</code>, và để hàm <code>lookup</code> sử dụng một đường thoát chung (common exit path). Cách thứ nhất hoạt động vì một phần của thao tác chèn thực tế không cần khóa; giả sử <code>malloc()</code> tự nó là <strong>thread-safe</strong>, mỗi thread có thể gọi nó mà không lo điều kiện tranh chấp (<strong>race condition</strong>) hoặc lỗi đồng thời khác. Chỉ khi cập nhật danh sách dùng chung mới cần giữ khóa. Xem <strong>Hình 29.8</strong> để biết chi tiết các chỉnh sửa này.</p>
<p>Đối với hàm <code>lookup</code>, đây là một phép biến đổi mã đơn giản: thoát khỏi vòng lặp tìm kiếm chính và đi đến một đường trả về duy nhất. Làm như vậy giúp giảm số lần acquire/release lock trong mã, và do đó giảm khả năng vô tình tạo ra lỗi (chẳng hạn quên <code>unlock</code> trước khi <code>return</code>).</p>
<p><img src="29/img/fig29_8.PNG" alt="" /></p>
<p><strong>Hình 29.8:</strong> Danh sách liên kết đồng thời: Phiên bản viết lại</p>
<h3 id="mở-rộng-khả-năng-của-linked-list-scaling-linked-lists"><a class="header" href="#mở-rộng-khả-năng-của-linked-list-scaling-linked-lists">Mở rộng khả năng của linked list (Scaling Linked Lists)</a></h3>
<p>Mặc dù chúng ta lại có một linked list đồng thời cơ bản, nhưng một lần nữa, nó không mở rộng hiệu quả. Một kỹ thuật mà các nhà nghiên cứu đã khám phá để cho phép nhiều tính đồng thời hơn trong danh sách được gọi là <strong>hand-over-hand locking</strong> (hay còn gọi là <strong>lock coupling</strong>) [MS04].</p>
<p>Ý tưởng khá đơn giản: thay vì có một khóa duy nhất cho toàn bộ danh sách, bạn thêm một khóa cho <strong>mỗi node</strong> của danh sách. Khi duyệt danh sách, mã nguồn sẽ <strong>acquire</strong> khóa của node kế tiếp trước, rồi mới <strong>release</strong> khóa của node hiện tại (điều này tạo cảm giác như “chuyền tay” khóa, do đó có tên gọi hand-over-hand).</p>
<blockquote>
<p><strong>TIP: CẨN TRỌNG VỚI KHÓA VÀ LUỒNG ĐIỀU KHIỂN</strong><br />
Một mẹo thiết kế tổng quát, hữu ích cả trong lập trình đồng thời lẫn các lĩnh vực khác, là hãy cẩn trọng với các thay đổi luồng điều khiển dẫn đến việc hàm kết thúc sớm (return), thoát (exit), hoặc các điều kiện lỗi tương tự khiến hàm dừng thực thi. Bởi vì nhiều hàm sẽ bắt đầu bằng việc acquire một khóa, cấp phát bộ nhớ, hoặc thực hiện các thao tác thay đổi trạng thái khác, khi lỗi xảy ra, mã nguồn phải hoàn tác tất cả các thay đổi trạng thái trước khi trả về — điều này rất dễ gây lỗi. Do đó, tốt nhất là cấu trúc mã để giảm thiểu mô hình này.</p>
</blockquote>
<p>Về mặt ý tưởng, một linked list kiểu hand-over-hand có vẻ hợp lý; nó cho phép mức độ đồng thời cao trong các thao tác trên danh sách. Tuy nhiên, trên thực tế, rất khó để làm cho cấu trúc này nhanh hơn cách tiếp cận dùng một khóa duy nhất, vì chi phí acquire và release khóa cho mỗi node trong quá trình duyệt là quá lớn. Ngay cả với danh sách rất dài và số lượng thread lớn, mức độ đồng thời đạt được nhờ cho phép nhiều lượt duyệt song song cũng khó có thể nhanh hơn việc chỉ cần acquire một khóa, thực hiện thao tác, rồi release nó. Có lẽ một dạng <strong>lai</strong> (hybrid) — nơi bạn acquire một khóa mới sau mỗi một số node nhất định — sẽ đáng để nghiên cứu.</p>
<h2 id="293-hàng-đợi-đồng-thời-concurrent-queues"><a class="header" href="#293-hàng-đợi-đồng-thời-concurrent-queues">29.3 Hàng đợi đồng thời (Concurrent Queues)</a></h2>
<p>Như bạn đã biết, luôn có một phương pháp tiêu chuẩn để biến một cấu trúc dữ liệu thành <strong>concurrent data structure</strong> (cấu trúc dữ liệu đồng thời): thêm một <strong>big lock</strong> (khóa lớn). Đối với <strong>queue</strong> (hàng đợi), chúng ta sẽ bỏ qua cách tiếp cận này, giả định rằng bạn có thể tự hình dung ra.</p>
<p>Thay vào đó, chúng ta sẽ xem xét một hàng đợi đồng thời hơn một chút, được thiết kế bởi Michael và Scott [MS98]. Cấu trúc dữ liệu và mã nguồn được sử dụng cho hàng đợi này được thể hiện trong <strong>Hình 29.9</strong> (trang 11).</p>
<p><img src="29/img/fig29_9.PNG" alt="" /></p>
<p><strong>Hình 29.9:</strong> Hàng đợi đồng thời của Michael và Scott</p>
<p>Nếu bạn nghiên cứu kỹ đoạn code này, bạn sẽ nhận thấy có <strong>hai khóa</strong>: một cho <strong>head</strong> (đầu hàng đợi) và một cho <strong>tail</strong> (đuôi hàng đợi). Mục tiêu của hai khóa này là cho phép các thao tác <strong>enqueue</strong> (thêm phần tử vào đuôi) và <strong>dequeue</strong> (lấy phần tử từ đầu) diễn ra đồng thời. Trong trường hợp phổ biến, hàm <code>enqueue</code> chỉ truy cập <strong>tail lock</strong>, và <code>dequeue</code> chỉ truy cập <strong>head lock</strong>.</p>
<p>Một thủ thuật được Michael và Scott sử dụng là thêm một <strong>dummy node</strong> (nút giả, được cấp phát trong mã khởi tạo hàng đợi); nút giả này cho phép tách biệt các thao tác ở head và tail. Hãy nghiên cứu mã nguồn, hoặc tốt hơn, gõ lại, chạy thử và đo đạc để hiểu sâu hơn cách nó hoạt động.</p>
<p>Hàng đợi được sử dụng phổ biến trong các ứng dụng <strong>multi-threaded</strong> (đa luồng). Tuy nhiên, loại hàng đợi được sử dụng ở đây (chỉ với khóa) thường không hoàn toàn đáp ứng nhu cầu của các chương trình như vậy. Một <strong>bounded queue</strong> (hàng đợi giới hạn) được phát triển đầy đủ hơn, cho phép một thread chờ nếu hàng đợi rỗng hoặc quá đầy, sẽ là chủ đề nghiên cứu chuyên sâu của chúng ta trong chương tiếp theo về <strong>condition variables</strong> (biến điều kiện). Hãy đón xem!</p>
<h2 id="294-bảng-băm-đồng-thời-concurrent-hash-table"><a class="header" href="#294-bảng-băm-đồng-thời-concurrent-hash-table">29.4 Bảng băm đồng thời (Concurrent Hash Table)</a></h2>
<p>Chúng ta kết thúc phần thảo luận với một cấu trúc dữ liệu đồng thời đơn giản và có tính ứng dụng rộng rãi: <strong>hash table</strong> (bảng băm). Chúng ta sẽ tập trung vào một bảng băm đơn giản <strong>không thay đổi kích thước</strong>; việc xử lý thay đổi kích thước cần thêm một chút công việc, và chúng tôi để lại như một bài tập cho bạn đọc.</p>
<p><img src="29/img/fig29_10.PNG" alt="" /></p>
<p><strong>Hình 29.10:</strong> Bảng băm đồng thời</p>
<p>Bảng băm đồng thời này (<strong>Hình 29.10</strong>) khá trực quan, được xây dựng bằng cách sử dụng các <strong>concurrent list</strong> (danh sách đồng thời) mà chúng ta đã phát triển trước đó, và hoạt động rất hiệu quả. Lý do cho hiệu năng tốt của nó là thay vì có một khóa duy nhất cho toàn bộ cấu trúc, nó sử dụng <strong>một khóa cho mỗi hash bucket</strong> (mỗi bucket được biểu diễn bởi một danh sách). Cách làm này cho phép nhiều thao tác đồng thời diễn ra.</p>
<p><strong>Hình 29.11</strong> (trang 13) cho thấy hiệu năng của bảng băm khi thực hiện các cập nhật đồng thời (từ 10.000 đến 50.000 cập nhật đồng thời từ mỗi trong bốn thread, trên cùng một máy iMac với bốn CPU). Cũng được hiển thị, để so sánh, là hiệu năng của một linked list (với một khóa duy nhất).</p>
<p><img src="29/img/fig29_11.PNG" alt="" /></p>
<p><strong>Hình 29.11:</strong> Khả năng mở rộng của bảng băm</p>
<p>Như bạn thấy từ biểu đồ, bảng băm đồng thời đơn giản này mở rộng rất tốt; ngược lại, linked list thì không.</p>
<h2 id="295-tóm-tắt-summary"><a class="header" href="#295-tóm-tắt-summary">29.5 Tóm tắt (Summary)</a></h2>
<p>Chúng ta đã giới thiệu một số ví dụ về <strong>concurrent data structure</strong> (cấu trúc dữ liệu đồng thời), từ <strong>counter</strong> (bộ đếm), đến <strong>list</strong> (danh sách) và <strong>queue</strong> (hàng đợi), và cuối cùng là <strong>hash table</strong> (bảng băm) — một cấu trúc phổ biến và được sử dụng rộng rãi. Trên đường đi, chúng ta đã học được một số bài học quan trọng:</p>
<ul>
<li>Cần cẩn trọng khi <strong>acquire</strong> (chiếm giữ) và <strong>release</strong> (giải phóng) khóa xung quanh các thay đổi luồng điều khiển (<strong>control flow changes</strong>).</li>
<li>Việc tăng tính đồng thời không nhất thiết sẽ tăng hiệu năng.</li>
<li>Chỉ nên khắc phục các vấn đề hiệu năng khi chúng thực sự tồn tại.</li>
</ul>
<p>Điểm cuối cùng này — tránh <strong>premature optimization</strong> (tối ưu hóa sớm) — là nguyên tắc cốt lõi đối với bất kỳ lập trình viên nào quan tâm đến hiệu năng; không có giá trị gì khi làm một thứ nhanh hơn nếu điều đó không cải thiện hiệu năng tổng thể của ứng dụng.</p>
<p>Tất nhiên, chúng ta mới chỉ chạm tới bề mặt của các cấu trúc hiệu năng cao. Hãy xem khảo sát xuất sắc của Moir và Shavit để biết thêm thông tin, cũng như các liên kết đến những nguồn khác [MS04]. Đặc biệt, bạn có thể quan tâm đến các cấu trúc khác (như <strong>B-tree</strong>); để học về chúng, một khóa học cơ sở dữ liệu sẽ là lựa chọn tốt nhất. Bạn cũng có thể tò mò về các kỹ thuật <strong>không sử dụng khóa truyền thống</strong>; các <strong>non-blocking data structure</strong> (cấu trúc dữ liệu không chặn) là thứ mà chúng ta sẽ tìm hiểu sơ qua trong chương về các lỗi đồng thời phổ biến, nhưng thực tế đây là một lĩnh vực kiến thức riêng biệt, đòi hỏi nhiều nghiên cứu hơn khả năng của cuốn sách này. Nếu muốn, bạn hãy tự tìm hiểu thêm.</p>
<blockquote>
<p><strong>TIP: TRÁNH TỐI ƯU HÓA SỚM (ĐỊNH LUẬT CỦA KNUTH)</strong><br />
Khi xây dựng một cấu trúc dữ liệu đồng thời, hãy bắt đầu với cách tiếp cận cơ bản nhất: thêm một <strong>big lock</strong> duy nhất để cung cấp quyền truy cập đồng bộ. Bằng cách này, bạn có khả năng xây dựng một cơ chế khóa đúng; nếu sau đó bạn thấy nó gặp vấn đề về hiệu năng, bạn có thể tinh chỉnh, chỉ làm cho nó nhanh hơn khi cần. Như Knuth đã nói nổi tiếng: <em>“Premature optimization is the root of all evil.”</em><br />
Nhiều hệ điều hành đã sử dụng một khóa duy nhất khi lần đầu chuyển sang <strong>multiprocessor</strong> (đa bộ xử lý), bao gồm Sun OS và Linux. Trong Linux, khóa này thậm chí còn có tên: <strong>big kernel lock</strong> (BKL). Trong nhiều năm, cách tiếp cận đơn giản này là một lựa chọn tốt, nhưng khi hệ thống đa CPU trở thành tiêu chuẩn, việc chỉ cho phép một thread hoạt động trong kernel tại một thời điểm đã trở thành nút thắt cổ chai về hiệu năng. Do đó, đã đến lúc bổ sung tối ưu hóa để cải thiện tính đồng thời cho các hệ thống này. Trong Linux, cách tiếp cận trực tiếp hơn đã được áp dụng: thay thế một khóa bằng nhiều khóa. Trong Sun, một quyết định táo bạo hơn đã được đưa ra: xây dựng một hệ điều hành hoàn toàn mới, gọi là <strong>Solaris</strong>, tích hợp tính đồng thời một cách cơ bản ngay từ đầu. Hãy đọc các sách về kernel của Linux và Solaris để biết thêm thông tin về những hệ thống thú vị này [BC05, MM00].</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="30-condition-variables-biến-điều-kiện"><a class="header" href="#30-condition-variables-biến-điều-kiện">30 Condition Variables (Biến điều kiện)</a></h1>
<p>Cho đến nay, chúng ta đã phát triển khái niệm <strong>lock</strong> (khóa) và thấy cách xây dựng một lock đúng đắn với sự kết hợp hợp lý giữa hỗ trợ từ <strong>hardware</strong> (phần cứng) và <strong>OS</strong> (hệ điều hành). Tuy nhiên, lock không phải là <strong>primitive</strong> (nguyên thủy) duy nhất cần thiết để xây dựng các chương trình <strong>concurrent</strong> (đồng thời).</p>
<p>Đặc biệt, có nhiều trường hợp một <strong>thread</strong> (luồng) muốn kiểm tra xem một <strong>condition</strong> (điều kiện) nào đó có đúng hay không trước khi tiếp tục thực thi. Ví dụ, một <strong>parent thread</strong> (luồng cha) có thể muốn kiểm tra xem <strong>child thread</strong> (luồng con) đã hoàn thành hay chưa trước khi tiếp tục (thường được gọi là <code>join()</code>); vậy việc chờ này nên được triển khai như thế nào? Hãy xem <strong>Hình 30.1</strong>.</p>
<pre><code class="language-c">void *child(void *arg) {
  printf(&quot;child\n&quot;);
  // XXX làm sao để báo là đã xong?
  return NULL;
}

int main(int argc, char *argv[]) {
  printf(&quot;parent: begin\n&quot;);
  pthread_t c;
  Pthread_create(&amp;c, NULL, child, NULL); // child
  // XXX làm sao để chờ child?
  printf(&quot;parent: end\n&quot;);
  return 0;
}
</code></pre>
<p><img src="30/img/fig30_1.PNG" alt="" /></p>
<p><strong>Hình 30.1: Parent chờ Child</strong></p>
<p>Điều chúng ta muốn thấy ở đây là kết quả sau:</p>
<pre><code>parent: begin
child
parent: end
</code></pre>
<p>Chúng ta có thể thử dùng một biến chia sẻ, như trong <strong>Hình 30.2</strong>. Giải pháp này nhìn chung sẽ hoạt động, nhưng cực kỳ <strong>kém hiệu quả</strong> vì parent sẽ <strong>spin</strong> (quay vòng chờ) và lãng phí thời gian CPU. Điều chúng ta muốn ở đây là một cách để đưa parent vào trạng thái <strong>sleep</strong> (ngủ) cho đến khi điều kiện mà ta đang chờ (ví dụ: child đã hoàn thành) trở thành đúng.</p>
<pre><code class="language-c">volatile int done = 0;

void *child(void *arg) {
  printf(&quot;child\n&quot;);
  done = 1;
  return NULL;
}

int main(int argc, char *argv[]) {
  printf(&quot;parent: begin\n&quot;);
  pthread_t c;
  Pthread_create(&amp;c, NULL, child, NULL); // child
  while (done == 0)
    ; // spin
  printf(&quot;parent: end\n&quot;);
  return 0;
}
</code></pre>
<p><img src="30/img/fig30_2.PNG" alt="" /></p>
<p><strong>Hình 30.2: Parent chờ Child – Cách tiếp cận Spin-based</strong></p>
<blockquote>
<p><strong>THE CRUX: HOW TO WAIT FOR A CONDITION</strong><br />
Trong các chương trình đa luồng, việc một thread chờ cho đến khi một điều kiện trở thành đúng trước khi tiếp tục là rất hữu ích. Cách tiếp cận đơn giản là spin cho đến khi điều kiện đúng, nhưng điều này cực kỳ kém hiệu quả và lãng phí chu kỳ CPU, và trong một số trường hợp có thể không chính xác. Vậy, một thread nên chờ điều kiện như thế nào?</p>
</blockquote>
<h2 id="301-Định-nghĩa-và-các-hàm-definition-and-routines"><a class="header" href="#301-Định-nghĩa-và-các-hàm-definition-and-routines">30.1 Định nghĩa và các hàm (Definition and Routines)</a></h2>
<p>Để chờ một điều kiện trở thành đúng, một thread có thể sử dụng cái gọi là <strong>condition variable</strong> (biến điều kiện). Condition variable là một <strong>explicit queue</strong> (hàng đợi tường minh) mà các thread có thể tự đưa mình vào khi một trạng thái thực thi nào đó (tức là một điều kiện) chưa như mong muốn (bằng cách <strong>wait</strong> trên condition); một thread khác, khi thay đổi trạng thái đó, có thể <strong>wake</strong> (đánh thức) một (hoặc nhiều) thread đang chờ và cho phép chúng tiếp tục (bằng cách <strong>signal</strong> trên condition).</p>
<p>Ý tưởng này bắt nguồn từ việc Dijkstra sử dụng “private semaphores” [D68]; một ý tưởng tương tự sau đó được Hoare đặt tên là “condition variable” trong công trình của ông về <strong>monitor</strong> [H74].</p>
<p>Để khai báo một condition variable, ta chỉ cần viết như sau:</p>
<pre><code class="language-c">pthread_cond_t c;
</code></pre>
<p>Điều này khai báo <code>c</code> là một condition variable (lưu ý: cần khởi tạo đúng cách). Một condition variable có hai thao tác liên quan: <code>wait()</code> và <code>signal()</code>.</p>
<ul>
<li>Lời gọi <code>wait()</code> được thực thi khi một thread muốn tự đưa mình vào trạng thái ngủ.</li>
<li>Lời gọi <code>signal()</code> được thực thi khi một thread đã thay đổi điều gì đó trong chương trình và muốn đánh thức một thread đang ngủ chờ trên condition này.</li>
</ul>
<p>Cụ thể, các call POSIX trông như sau:</p>
<pre><code class="language-c">pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);
pthread_cond_signal(pthread_cond_t *c);
</code></pre>
<p>Chúng ta thường gọi tắt là <code>wait()</code> và <code>signal</code> cho đơn giản. Một điều bạn có thể nhận thấy về <code>wait()</code> là nó cũng nhận một <strong>mutex</strong> làm tham số; nó giả định rằng mutex này đang được <strong>lock</strong> khi <code>wait()</code> được gọi.</p>
<p>Nhiệm vụ của <code>wait()</code> là <strong>release</strong> (nhả) lock và đưa thread gọi hàm vào trạng thái ngủ (<strong>atomically</strong> – nguyên tử); khi thread được đánh thức (sau khi một thread khác signal nó), nó phải <strong>re-acquire</strong> (lấy lại) lock trước khi trả quyền điều khiển về cho caller. Sự phức tạp này xuất phát từ mong muốn ngăn chặn một số <strong>race condition</strong> xảy ra khi một thread đang cố tự đưa mình vào trạng thái ngủ.</p>
<p>Hãy xem giải pháp cho bài toán join (<strong>Hình 30.3</strong>) để hiểu rõ hơn.</p>
<p><img src="30/img/fig30_3.PNG" alt="" /></p>
<p><strong>Hình 30.3: Parent chờ Child – Sử dụng Condition Variable</strong></p>
<p>Có hai trường hợp cần xem xét:</p>
<ol>
<li>
<p><strong>Trường hợp 1:</strong> Parent tạo child thread nhưng tiếp tục chạy (giả sử chỉ có một CPU) và ngay lập tức gọi <code>thr_join()</code> để chờ child hoàn thành. Trong trường hợp này, nó sẽ acquire lock, kiểm tra xem child đã xong chưa (chưa), và đưa mình vào trạng thái ngủ bằng cách gọi <code>wait()</code> (do đó nhả lock). Child sẽ chạy, in ra “child”, và gọi <code>thr_exit()</code> để đánh thức parent; đoạn code này chỉ cần acquire lock, đặt biến trạng thái <code>done</code>, và signal parent để đánh thức nó. Cuối cùng, parent sẽ chạy (trở về từ <code>wait()</code> với lock đang giữ), unlock, và in ra “parent: end”.</p>
</li>
<li>
<p><strong>Trường hợp 2:</strong> Child chạy ngay khi được tạo, đặt <code>done = 1</code>, gọi <code>signal</code> để đánh thức một thread đang ngủ (nhưng không có thread nào, nên chỉ return), và kết thúc. Parent sau đó chạy, gọi <code>thr_join()</code>, thấy <code>done = 1</code>, nên không chờ và return.</p>
</li>
</ol>
<p>Một lưu ý cuối: bạn có thể thấy parent dùng vòng lặp <code>while</code> thay vì chỉ <code>if</code> khi quyết định có chờ trên condition hay không. Mặc dù theo logic chương trình thì điều này có vẻ không bắt buộc, nhưng đây luôn là một ý tưởng tốt, như chúng ta sẽ thấy ở phần sau.</p>
<p>Để đảm bảo bạn hiểu tầm quan trọng của từng phần trong code <code>thr_exit()</code> và <code>thr_join()</code>, hãy thử một vài cách triển khai thay thế. Đầu tiên, bạn có thể tự hỏi liệu chúng ta có cần biến trạng thái <code>done</code> hay không. Điều gì sẽ xảy ra nếu code trông như ví dụ dưới đây? (<strong>Hình 30.4</strong>)</p>
<p><img src="30/img/fig30_4.PNG" alt="" /></p>
<p><strong>Hình 30.4: Parent Waiting – Không có biến trạng thái</strong></p>
<p>Đáng tiếc, cách tiếp cận này <strong>bị lỗi</strong>. Hãy tưởng tượng trường hợp child chạy ngay lập tức và gọi <code>thr_exit()</code> ngay lập tức; trong trường hợp này, child sẽ thực hiện <strong>signal</strong>, nhưng không có thread nào đang ngủ trên condition. Khi parent chạy, nó sẽ chỉ đơn giản gọi <code>wait</code> và bị kẹt; sẽ không có thread nào đánh thức nó. Từ ví dụ này, bạn có thể thấy tầm quan trọng của biến trạng thái <code>done</code>; nó lưu trữ giá trị mà các thread quan tâm. Việc ngủ, đánh thức và khóa đều được xây dựng xoay quanh biến này.</p>
<p>Dưới đây (<strong>Hình 30.5</strong>) là một cách triển khai kém khác. Trong ví dụ này, ta giả định rằng không cần giữ lock để thực hiện signal và wait. Vấn đề gì có thể xảy ra ở đây? Hãy suy nghĩ<sup class="footnote-reference"><a href="#1">1</a></sup>!</p>
<pre><code class="language-c">void thr_exit() {
  done = 1;
  Pthread_cond_signal(&amp;c);
}

void thr_join() {
  if (done == 0)
    Pthread_cond_wait(&amp;c);
}
</code></pre>
<p><img src="30/img/fig30_5.PNG" alt="" /></p>
<p><strong>Hình 30.5: Parent Waiting – Không có lock</strong></p>
<p>Vấn đề ở đây là một <strong>race condition</strong> tinh vi. Cụ thể, nếu parent gọi <code>thr_join()</code> và sau đó kiểm tra giá trị của <code>done</code>, nó sẽ thấy giá trị là 0 và do đó cố gắng đi ngủ. Nhưng ngay trước khi nó gọi <code>wait</code> để ngủ, parent bị <strong>interrupt</strong> (ngắt), và child chạy. Child thay đổi biến trạng thái <code>done</code> thành 1 và thực hiện signal, nhưng không có thread nào đang chờ nên không thread nào được đánh thức. Khi parent chạy lại, nó sẽ ngủ mãi mãi — thật đáng buồn.</p>
<p>Hy vọng rằng, từ ví dụ join đơn giản này, bạn có thể thấy một số yêu cầu cơ bản để sử dụng condition variable một cách đúng đắn. Để đảm bảo bạn hiểu, chúng ta sẽ đi qua một ví dụ phức tạp hơn: bài toán <strong>producer/consumer</strong> hoặc <strong>bounded-buffer</strong>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Lưu ý rằng ví dụ này không phải là code “thực”, vì call <code>pthread_cond_wait()</code> luôn yêu cầu một mutex cũng như một condition variable; ở đây, chúng ta chỉ giả định giao diện không yêu cầu mutex để minh họa ví dụ phản ví dụ.</p>
</div>
<blockquote>
<p><strong>TIP: LUÔN GIỮ LOCK KHI SIGNAL</strong><br />
Mặc dù không phải lúc nào cũng bắt buộc, nhưng đơn giản và tốt nhất là giữ lock khi thực hiện signal với condition variable. Ví dụ trên cho thấy một trường hợp bạn <strong>phải</strong> giữ lock để đảm bảo tính đúng đắn; tuy nhiên, cũng có một số trường hợp có thể không sao nếu không giữ, nhưng tốt nhất là nên tránh. Vì vậy, để đơn giản, hãy giữ lock khi gọi <code>signal</code>.<br />
Ngược lại, việc giữ lock khi gọi <code>wait</code> không chỉ là một mẹo, mà là <strong>bắt buộc</strong> theo ngữ nghĩa của <code>wait</code>, vì <code>wait</code> luôn: (a) giả định lock đang được giữ khi bạn gọi nó, (b) nhả lock khi đưa thread gọi vào trạng thái ngủ, và (c) lấy lại lock ngay trước khi trả về. Do đó, có thể tổng quát hóa mẹo này: <strong>giữ lock khi gọi <code>signal</code> hoặc <code>wait</code></strong>, và bạn sẽ luôn an toàn.</p>
</blockquote>
<h2 id="302-bài-toán-producerconsumer-bounded-buffer"><a class="header" href="#302-bài-toán-producerconsumer-bounded-buffer">30.2 Bài toán Producer/Consumer (Bounded Buffer)</a></h2>
<p>Bài toán đồng bộ hóa tiếp theo mà chúng ta sẽ gặp trong chương này được gọi là <strong>producer/consumer problem</strong> (bài toán nhà sản xuất/nhà tiêu thụ), hoặc đôi khi là <strong>bounded buffer problem</strong> (bài toán bộ đệm giới hạn), lần đầu được nêu ra bởi <strong>Dijkstra</strong> [D72]. Thực tế, chính bài toán producer/consumer này đã dẫn Dijkstra và các cộng sự phát minh ra <strong>generalized semaphore</strong> (semaphore tổng quát – có thể dùng như lock hoặc condition variable) [D01]; chúng ta sẽ tìm hiểu thêm về semaphore sau.</p>
<p>Hãy tưởng tượng có một hoặc nhiều <strong>producer thread</strong> (luồng sản xuất) và một hoặc nhiều <strong>consumer thread</strong> (luồng tiêu thụ). Producer tạo ra các <strong>data item</strong> (mục dữ liệu) và đặt chúng vào một <strong>buffer</strong> (bộ đệm); consumer lấy các mục này ra khỏi buffer và tiêu thụ chúng theo một cách nào đó. Mô hình này xuất hiện trong nhiều hệ thống thực tế. Ví dụ, trong một <strong>multi-threaded web server</strong> (máy chủ web đa luồng), một producer đặt các yêu cầu HTTP vào <strong>work queue</strong> (hàng đợi công việc – tức bounded buffer); các consumer thread lấy yêu cầu ra khỏi hàng đợi này và xử lý.</p>
<p>Một bounded buffer cũng được sử dụng khi bạn <strong>pipe</strong> (dùng đường ống) đầu ra của một chương trình vào chương trình khác, ví dụ:</p>
<pre><code class="language-bash">grep foo file.txt | wc -l
</code></pre>
<p>Ví dụ này chạy hai <strong>process</strong> (tiến trình) đồng thời; <code>grep</code> ghi các dòng từ <code>file.txt</code> có chứa chuỗi <code>foo</code> vào cái mà nó nghĩ là <strong>standard output</strong> (đầu ra chuẩn); <strong>UNIX shell</strong> chuyển hướng đầu ra này vào một <strong>UNIX pipe</strong> (được tạo bởi <strong>system call</strong> <code>pipe</code>). Đầu còn lại của pipe này được kết nối với <strong>standard input</strong> (đầu vào chuẩn) của tiến trình <code>wc</code>, tiến trình này chỉ đơn giản đếm số dòng trong luồng đầu vào và in ra kết quả. Như vậy, tiến trình <code>grep</code> là producer; tiến trình <code>wc</code> là consumer; giữa chúng là một bounded buffer nằm trong kernel; còn bạn, trong ví dụ này, là người dùng hạnh phúc.</p>
<p>Vì bounded buffer là một tài nguyên chia sẻ, tất nhiên chúng ta phải yêu cầu <strong>synchronized access</strong> (truy cập đồng bộ) tới nó, nếu không<sup class="footnote-reference"><a href="#2">2</a></sup> sẽ xảy ra <strong>race condition</strong>. Để bắt đầu hiểu rõ hơn vấn đề này, hãy xem một số đoạn code thực tế. Điều đầu tiên chúng ta cần là một <strong>shared buffer</strong> (bộ đệm chia sẻ), nơi producer đặt dữ liệu vào, và consumer lấy dữ liệu ra. Để đơn giản, ta chỉ dùng một số nguyên (bạn hoàn toàn có thể tưởng tượng đặt một con trỏ tới một cấu trúc dữ liệu vào đây), và hai hàm nội bộ để đặt một giá trị vào buffer chia sẻ, và lấy một giá trị ra khỏi buffer. Xem <strong>Hình 30.6</strong> (trang 6) để biết chi tiết.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Đây là lúc chúng ta dùng một chút tiếng Anh cổ điển, ở thể giả định (subjunctive form).</p>
</div>
<p><img src="30/img/fig30_6.PNG" alt="" /></p>
<p><strong>Hình 30.6: Các hàm Put và Get (phiên bản 1)</strong></p>
<p>Khá đơn giản, đúng không? Hàm <code>put()</code> giả định rằng buffer đang rỗng (và kiểm tra điều này bằng một <strong>assertion</strong>), sau đó đơn giản đặt một giá trị vào <strong>shared buffer</strong> (bộ đệm chia sẻ) và đánh dấu nó là đầy bằng cách đặt <code>count</code> thành 1. Hàm <code>get()</code> làm điều ngược lại: đặt buffer về trạng thái rỗng (tức là đặt <code>count</code> thành 0) và trả về giá trị. Đừng lo lắng việc buffer chia sẻ này chỉ có một ô; sau này, chúng ta sẽ tổng quát hóa nó thành một <strong>queue</strong> (hàng đợi) có thể chứa nhiều phần tử, và điều đó sẽ còn thú vị hơn bạn tưởng.</p>
<p>Bây giờ, chúng ta cần viết một số hàm biết khi nào thì <strong>OK</strong> để truy cập buffer — hoặc để đặt dữ liệu vào, hoặc để lấy dữ liệu ra. Điều kiện cho việc này khá rõ ràng: chỉ đặt dữ liệu vào buffer khi <code>count</code> bằng 0 (tức là buffer rỗng), và chỉ lấy dữ liệu ra khi <code>count</code> bằng 1 (tức là buffer đầy). Nếu chúng ta viết code đồng bộ hóa mà để producer đặt dữ liệu vào một buffer đã đầy, hoặc consumer lấy dữ liệu từ một buffer rỗng, thì chúng ta đã làm sai (và trong code này, một assertion sẽ kích hoạt).</p>
<p>Công việc này sẽ được thực hiện bởi hai loại <strong>thread</strong>: một nhóm gọi là <strong>producer threads</strong> (luồng sản xuất), và nhóm còn lại gọi là <strong>consumer threads</strong> (luồng tiêu thụ). <strong>Hình 30.7</strong> cho thấy code của một producer đặt một số nguyên vào buffer chia sẻ <code>loops</code> lần, và một consumer lấy dữ liệu ra khỏi buffer chia sẻ (liên tục), mỗi lần in ra giá trị mà nó lấy được.</p>
<pre><code class="language-c">void *producer(void *arg) {
  int i;
  int loops = (int) arg;
  for (i = 0; i &lt; loops; i++) {
    put(i);
  }
}

void *consumer(void *arg) {
  while (1) {
    int tmp = get();
    printf(&quot;%d\n&quot;, tmp);
  }
}
</code></pre>
<p><img src="30/img/fig30_7.PNG" alt="" /></p>
<p><strong>Hình 30.7: Producer/Consumer Threads (phiên bản 1)</strong></p>
<h3 id="một-giải-pháp-bị-lỗi-a-broken-solution"><a class="header" href="#một-giải-pháp-bị-lỗi-a-broken-solution">Một giải pháp bị lỗi (A Broken Solution)</a></h3>
<p>Bây giờ, hãy tưởng tượng rằng chúng ta chỉ có một producer và một consumer. Rõ ràng, các hàm <code>put()</code> và <code>get()</code> có <strong>critical section</strong> (vùng tới hạn) bên trong, vì <code>put()</code> cập nhật buffer, và <code>get()</code> đọc từ nó. Tuy nhiên, chỉ đặt một lock bao quanh code là <strong>không đủ</strong>; chúng ta cần thêm thứ gì đó nữa. Không ngạc nhiên, thứ đó chính là <strong>condition variables</strong> (biến điều kiện). Trong lần thử đầu tiên (bị lỗi) này (<strong>Hình 30.8</strong>), chúng ta có một condition variable duy nhất <code>cond</code> và một lock <code>mutex</code> đi kèm.</p>
<pre><code class="language-c">int loops; // phải được khởi tạo ở đâu đó...
cond_t cond;
mutex_t mutex;

void *producer(void *arg) {
  int i;
  for (i = 0; i &lt; loops; i++) {
    Pthread_mutex_lock(&amp;mutex);
    // p1
    if (count == 1)
      // p2
      Pthread_cond_wait(&amp;cond, &amp;mutex); // p3
    put(i);
    // p4
    Pthread_cond_signal(&amp;cond);
    // p5
    Pthread_mutex_unlock(&amp;mutex);
    // p6
  }
}

void *consumer(void *arg) {
  int i;
  for (i = 0; i &lt; loops; i++) {
    Pthread_mutex_lock(&amp;mutex);
    // c1
    if (count == 0)
      // c2
      Pthread_cond_wait(&amp;cond, &amp;mutex); // c3
    int tmp = get();
    // c4
    Pthread_cond_signal(&amp;cond);
    // c5
    Pthread_mutex_unlock(&amp;mutex);
    // c6
    printf(&quot;%d\n&quot;, tmp);
  }
}
</code></pre>
<p><img src="30/img/fig30_8.PNG" alt="" /></p>
<p><strong>Hình 30.8: Producer/Consumer – Một CV duy nhất và câu lệnh If</strong></p>
<p>Hãy phân tích logic <strong>signaling</strong> (báo hiệu) giữa producer và consumer. Khi một producer muốn điền dữ liệu vào buffer, nó sẽ chờ cho đến khi buffer rỗng (p1–p3). Consumer có logic tương tự, nhưng chờ một điều kiện khác: buffer đầy (c1–c3).</p>
<p>Với chỉ một producer và một consumer, code trong <strong>Hình 30.8</strong> hoạt động. Tuy nhiên, nếu có nhiều hơn một thread thuộc mỗi loại (ví dụ: hai consumer), giải pháp này có <strong>hai vấn đề nghiêm trọng</strong>. Đó là gì? … (tạm dừng để suy nghĩ) …</p>
<p>Hãy hiểu vấn đề đầu tiên, liên quan đến câu lệnh <code>if</code> trước khi gọi <code>wait</code>. Giả sử có hai consumer (Tc1 và Tc2) và một producer (Tp).</p>
<ol>
<li>Đầu tiên, một consumer (Tc1) chạy; nó acquire lock (c1), kiểm tra xem có buffer nào sẵn sàng để tiêu thụ không (c2), và thấy không có, nên gọi <code>wait</code> (c3) (thao tác này sẽ release lock).</li>
<li>Sau đó, producer (Tp) chạy. Nó acquire lock (p1), kiểm tra xem tất cả buffer đã đầy chưa (p2), và thấy chưa, nên tiếp tục điền dữ liệu vào buffer (p4). Producer sau đó signal rằng buffer đã được điền (p5). Quan trọng là, thao tác này chuyển Tc1 từ trạng thái ngủ trên condition variable sang <strong>ready queue</strong>; Tc1 giờ đã sẵn sàng chạy (nhưng chưa chạy ngay).</li>
<li>Producer tiếp tục cho đến khi nhận ra buffer đã đầy, lúc này nó ngủ (p6, p1–p3).</li>
</ol>
<p>Vấn đề xảy ra ở đây: một consumer khác (Tc2) chen vào và tiêu thụ giá trị duy nhất trong buffer (c1, c2, c4, c5, c6), bỏ qua bước chờ ở c3 vì buffer đang đầy.</p>
<p>Bây giờ, giả sử Tc1 chạy; ngay trước khi trở về từ <code>wait</code>, nó re-acquire lock và sau đó return. Nó gọi <code>get()</code> (c4), nhưng <strong>không còn dữ liệu nào trong buffer để tiêu thụ</strong>! Một assertion sẽ kích hoạt, và code không hoạt động như mong muốn.</p>
<p>Rõ ràng, chúng ta cần phải ngăn Tc1 cố gắng tiêu thụ khi Tc2 đã “lén” tiêu thụ giá trị duy nhất trong buffer mà producer vừa tạo ra. <strong>Hình 30.9</strong> sẽ minh họa hành động của từng thread, cũng như trạng thái của chúng trong scheduler (<strong>Ready</strong>, <strong>Running</strong>, hoặc <strong>Sleeping</strong>) theo thời gian.</p>
<p><img src="30/img/fig30_9.PNG" alt="" /></p>
<p><strong>Hình 30.9: Vết vạch luồng: Lời giải bị lỗi (phiên bản 1)</strong>
<img src="30/" alt="Figure 30.9: Thread Trace: Broken Solution (v1)" /></p>
<p>Vấn đề phát sinh vì một lý do đơn giản: sau khi producer đánh thức Tc1, nhưng trước khi Tc1 thực sự chạy, trạng thái của bounded buffer đã thay đổi (nhờ Tc2). Việc signal một thread chỉ đơn thuần đánh thức nó; đó là một gợi ý rằng trạng thái hệ thống đã thay đổi (trong trường hợp này là đã có một giá trị được đặt vào buffer), nhưng không có gì đảm bảo rằng khi thread được đánh thức chạy, trạng thái vẫn còn như mong muốn. Cách diễn giải ý nghĩa của signal này thường được gọi là ngữ nghĩa Mesa (Mesa semantics), theo công trình nghiên cứu đầu tiên xây dựng condition variable theo cách như vậy [LR80]; ngược lại là ngữ nghĩa Hoare (Hoare semantics), khó xây dựng hơn nhưng đưa ra bảo đảm mạnh hơn rằng thread được đánh thức sẽ chạy ngay lập tức khi được đánh thức [H74]. Hầu như mọi hệ thống từng được xây dựng đều sử dụng ngữ nghĩa Mesa.</p>
<h3 id="tốt-hơn-nhưng-vẫn-lỗi-while-không-phải-if"><a class="header" href="#tốt-hơn-nhưng-vẫn-lỗi-while-không-phải-if">Tốt hơn, nhưng vẫn lỗi: While, không phải If</a></h3>
<p>May mắn thay, cách khắc phục khá dễ (<strong>Hình 30.10</strong>): đổi <code>if</code> thành <code>while</code>. Hãy suy nghĩ vì sao điều này hoạt động; lúc này, consumer Tc1 thức dậy và (khi đang giữ lock) lập tức kiểm tra lại trạng thái biến chia sẻ (c2). Nếu tại thời điểm đó buffer rỗng, consumer đơn giản quay lại ngủ (c3). Mệnh đề <code>if</code> tương ứng trong producer (p2) cũng được đổi thành <code>while</code>.</p>
<pre><code class="language-c">int loops;
cond_t cond;
mutex_t mutex;

void *producer(void *arg) {
  int i;
  for (i = 0; i &lt; loops; i++) {
    Pthread_mutex_lock(&amp;mutex);
    // p1
    while (count == 1)
      // p2
      Pthread_cond_wait(&amp;cond, &amp;mutex); // p3
    put(i);
    // p4
    Pthread_cond_signal(&amp;cond);
    // p5
    Pthread_mutex_unlock(&amp;mutex);
    // p6
  }
}

void *consumer(void *arg) {
  int i;
  for (i = 0; i &lt; loops; i++) {
    Pthread_mutex_lock(&amp;mutex);
    // c1
    while (count == 0)
      // c2
      Pthread_cond_wait(&amp;cond, &amp;mutex); // c3
    int tmp = get();
    // c4
    Pthread_cond_signal(&amp;cond);
    // c5
    Pthread_mutex_unlock(&amp;mutex);
    // c6
    printf(&quot;%d\n&quot;, tmp);
  }
}
</code></pre>
<p><img src="30/img/fig30_10.PNG" alt="" /></p>
<p><strong>Hình 30.10: Producer/Consumer — Một CV duy nhất và dùng While</strong>
<img src="30/" alt="Figure 30.10: Producer/Consumer: Single CV And While" /></p>
<p>Nhờ ngữ nghĩa Mesa, một quy tắc đơn giản cần ghi nhớ khi dùng condition variable là luôn dùng vòng lặp <code>while</code>. Đôi khi bạn không cần kiểm tra lại điều kiện, nhưng việc kiểm tra lại luôn an toàn; cứ làm vậy và yên tâm.</p>
<p>Tuy nhiên, đoạn code này vẫn còn một lỗi — lỗi thứ hai trong hai vấn đề đã nêu. Bạn thấy được không? Nó liên quan đến việc chỉ có một condition variable. Hãy thử tìm ra vấn đề trước khi đọc tiếp. LÀM ĐI! (tạm dừng để bạn suy nghĩ, hoặc nhắm mắt lại...)</p>
<p><img src="30/img/fig30_11.PNG" alt="" /></p>
<p><strong>Hình 30.11: Vết vạch luồng: Lời giải bị lỗi (phiên bản 2)</strong>
<img src="30/" alt="Figure 30.11: Thread Trace: Broken Solution (v2)" /></p>
<p>Hãy xác nhận rằng bạn đã tìm ra đúng (hoặc ít nhất là bạn đang tỉnh táo và đọc phần này của sách). Vấn đề xảy ra khi hai consumer chạy trước (Tc1 và Tc2) và cả hai đều đi ngủ (c3). Sau đó, producer chạy, đặt một giá trị vào buffer, và đánh thức một trong các consumer (giả sử Tc1). Producer sau đó lặp lại (giải phóng và acquire lại lock trong quá trình) và cố đặt thêm dữ liệu vào buffer; vì buffer đầy, producer thay vào đó chờ trên condition (đi ngủ). Lúc này, một consumer sẵn sàng chạy (Tc1), và hai thread đang ngủ trên condition (Tc2 và Tp). Chúng ta sắp gây ra một vấn đề: mọi thứ đang trở nên “hấp dẫn”!</p>
<p>Consumer Tc1 sau đó thức dậy bằng cách trả về từ <code>wait()</code> (c3), kiểm tra lại điều kiện (c2), và thấy buffer đầy, nên tiêu thụ giá trị (c4). Consumer này sau đó, quan trọng là, thực hiện signal trên condition (c5), chỉ đánh thức một thread đang ngủ. Tuy nhiên, nó nên đánh thức thread nào? Vì consumer vừa làm rỗng buffer, rõ ràng nó nên đánh thức producer. Tuy nhiên, nếu nó lại đánh thức consumer Tc2 (điều này hoàn toàn có thể, tùy cách quản lý hàng đợi chờ), chúng ta gặp vấn đề. Cụ thể, consumer Tc2 sẽ thức dậy và thấy buffer rỗng (c2), rồi quay lại ngủ (c3). Producer Tp, vốn đang có giá trị để đặt vào buffer, thì vẫn còn ngủ. Consumer còn lại, Tc1, cũng quay lại ngủ. Cả ba thread đều rơi vào trạng thái ngủ — một lỗi hiển nhiên; xem <strong>Hình 30.11</strong> để thấy trình tự “thảm họa” này từng bước. Rõ ràng cần có signaling, nhưng phải có định hướng hơn. Một consumer không nên đánh thức consumer khác, mà chỉ đánh thức producer, và ngược lại.</p>
<h3 id="lời-giải-cho-producerconsumer-với-bộ-đệm-đơn-the-single-buffer-producerconsumer-solution"><a class="header" href="#lời-giải-cho-producerconsumer-với-bộ-đệm-đơn-the-single-buffer-producerconsumer-solution">Lời giải cho producer/consumer với bộ đệm đơn (The Single Buffer Producer/Consumer Solution)</a></h3>
<p>Lời giải ở đây một lần nữa rất nhỏ gọn: dùng hai condition variable thay vì một, để signal đúng kiểu thread cần được đánh thức khi trạng thái hệ thống thay đổi. <strong>Hình 30.12</strong> cho thấy đoạn code kết quả.
<img src="30/" alt="Figure 30.12: Single-Buffer Producer/Consumer Solution with Two Condition Variables" /></p>
<p><img src="30/img/fig30_12.PNG" alt="" /></p>
<p><strong>Hình 30.12: Producer/Consumer – Hai Condition Variable và While</strong></p>
<p>Trong đoạn code này, <strong>producer thread</strong> sẽ <strong>wait</strong> trên condition <code>empty</code> và <strong>signal</strong> <code>fill</code>. Ngược lại, <strong>consumer thread</strong> sẽ <strong>wait</strong> trên <code>fill</code> và <strong>signal</strong> <code>empty</code>. Bằng cách này, vấn đề thứ hai đã nêu ở trên được loại bỏ ngay từ thiết kế: một consumer sẽ không bao giờ vô tình đánh thức một consumer khác, và một producer cũng sẽ không bao giờ vô tình đánh thức một producer khác.</p>
<h3 id="giải-pháp-producerconsumer-đúng"><a class="header" href="#giải-pháp-producerconsumer-đúng">Giải pháp Producer/Consumer đúng</a></h3>
<p>Giờ đây, chúng ta đã có một giải pháp producer/consumer hoạt động, dù chưa phải là tổng quát hoàn toàn. Thay đổi cuối cùng chúng ta thực hiện là cho phép <strong>tăng concurrency</strong> (tính đồng thời) và <strong>hiệu suất</strong>; cụ thể, chúng ta thêm nhiều <strong>buffer slot</strong> (ô đệm) hơn, để có thể sản xuất nhiều giá trị trước khi phải ngủ, và tương tự, có thể tiêu thụ nhiều giá trị trước khi phải ngủ.</p>
<p>Với chỉ một producer và một consumer, cách tiếp cận này hiệu quả hơn vì giảm số lần <strong>context switch</strong>; với nhiều producer hoặc consumer (hoặc cả hai), nó thậm chí cho phép nhiều hoạt động sản xuất hoặc tiêu thụ diễn ra đồng thời, từ đó tăng concurrency. May mắn thay, đây chỉ là một thay đổi nhỏ so với giải pháp hiện tại.</p>
<p><img src="30/img/fig30_13.PNG" alt="" /></p>
<p><strong>Hình 30.13: Các hàm Put và Get đúng</strong></p>
<blockquote>
<p><strong>TIP: DÙNG WHILE (KHÔNG PHẢI IF) CHO CÁC ĐIỀU KIỆN</strong><br />
Khi kiểm tra một điều kiện trong chương trình đa luồng, dùng vòng lặp <code>while</code> luôn đúng; dùng câu lệnh <code>if</code> thì <strong>có thể</strong> đúng, tùy thuộc vào ngữ nghĩa của signaling. Vì vậy, hãy luôn dùng <code>while</code> và code của bạn sẽ hoạt động như mong đợi.</p>
<p>Việc dùng <code>while</code> bao quanh các kiểm tra điều kiện cũng xử lý được trường hợp <strong>spurious wakeup</strong> (đánh thức giả). Trong một số thư viện thread, do chi tiết triển khai, có thể xảy ra tình huống hai thread được đánh thức dù chỉ có một signal diễn ra [L11]. Spurious wakeup là một lý do nữa để luôn kiểm tra lại điều kiện mà thread đang chờ.</p>
</blockquote>
<p><img src="30/img/fig30_14.PNG" alt="" /></p>
<p><strong>Hình 30.14: Đồng bộ hóa Producer/Consumer đúng</strong></p>
<p>Thay đổi đầu tiên cho giải pháp đúng này nằm trong chính cấu trúc buffer và các hàm <code>put()</code> và <code>get()</code> tương ứng (<strong>Hình 30.13</strong>). Chúng ta cũng thay đổi nhẹ các điều kiện mà producer và consumer kiểm tra để quyết định có nên ngủ hay không. Đồng thời, chúng ta cũng thể hiện logic <strong>wait</strong> và <strong>signal</strong> đúng (<strong>Hình 30.14</strong>).</p>
<ul>
<li>Producer chỉ ngủ nếu <strong>tất cả</strong> buffer hiện đang đầy (p2).</li>
<li>Consumer chỉ ngủ nếu <strong>tất cả</strong> buffer hiện đang rỗng (c2).</li>
</ul>
<p>Và như vậy, chúng ta đã giải quyết xong bài toán producer/consumer; giờ là lúc ngồi xuống và thưởng thức một ly nước mát.</p>
<h2 id="303-covering-conditions"><a class="header" href="#303-covering-conditions">30.3 Covering Conditions</a></h2>
<p>Bây giờ, chúng ta sẽ xem thêm một ví dụ nữa về cách sử dụng <strong>condition variable</strong>. Nghiên cứu mã nguồn này được trích từ bài báo của <strong>Lampson và Redell</strong> về hệ điều hành <strong>Pilot</strong> [LR80], cùng nhóm tác giả đã triển khai ngữ nghĩa Mesa được mô tả ở trên (ngôn ngữ họ dùng là Mesa, do đó có tên gọi này).</p>
<p>Vấn đề họ gặp phải được minh họa rõ nhất qua một ví dụ đơn giản: một thư viện <strong>multi-threaded memory allocation</strong> (cấp phát bộ nhớ đa luồng) đơn giản. <strong>Hình 30.15</strong> cho thấy một đoạn code minh họa vấn đề.</p>
<p><img src="30/img/fig30_15.PNG" alt="" /></p>
<p><strong>Hình 30.15: Covering Conditions – Một ví dụ</strong></p>
<p>Như bạn có thể thấy trong code, khi một thread gọi vào hàm cấp phát bộ nhớ, nó có thể phải chờ cho đến khi có thêm bộ nhớ được giải phóng. Ngược lại, khi một thread giải phóng bộ nhớ, nó sẽ signal rằng đã có thêm bộ nhớ trống.</p>
<p>Tuy nhiên, code trên có một vấn đề: <strong>thread nào</strong> (trong số nhiều thread có thể đang chờ) sẽ được đánh thức?</p>
<p>Hãy xét kịch bản sau:</p>
<ul>
<li>Giả sử hiện có <strong>0 byte</strong> bộ nhớ trống; thread <strong>Ta</strong> gọi <code>allocate(100)</code>, tiếp theo là thread <strong>Tb</strong> gọi <code>allocate(10)</code> (yêu cầu ít bộ nhớ hơn).</li>
<li>Cả Ta và Tb đều phải <strong>wait</strong> trên condition và đi ngủ; hiện không đủ bộ nhớ trống để đáp ứng bất kỳ yêu cầu nào.</li>
</ul>
<p>Tại thời điểm đó, giả sử một thread thứ ba, <strong>Tc</strong>, gọi <code>free(50)</code>. Đáng tiếc, khi nó gọi <code>signal</code> để đánh thức một thread đang chờ, nó <strong>có thể không đánh thức đúng thread</strong> — cụ thể là Tb, thread chỉ cần 10 byte; trong khi Ta vẫn nên tiếp tục chờ vì chưa đủ bộ nhớ trống.</p>
<p>Do đó, code trong hình <strong>không hoạt động đúng</strong>, vì thread đánh thức các thread khác <strong>không biết</strong> thread nào (hoặc những thread nào) cần được đánh thức.</p>
<p>Giải pháp mà Lampson và Redell đề xuất khá đơn giản: thay call <code>pthread_cond_signal()</code> trong code trên bằng <code>pthread_cond_broadcast()</code>, lệnh này sẽ đánh thức <strong>tất cả</strong> các thread đang chờ. Bằng cách này, chúng ta đảm bảo rằng mọi thread cần được đánh thức sẽ được đánh thức.</p>
<p>Nhược điểm, tất nhiên, là <strong>ảnh hưởng hiệu năng tiêu cực</strong>, vì có thể chúng ta sẽ đánh thức không cần thiết nhiều thread chưa nên thức. Những thread này sẽ chỉ đơn giản thức dậy, kiểm tra lại điều kiện, rồi lập tức quay lại ngủ.</p>
<p>Lampson và Redell gọi loại condition này là <strong>covering condition</strong>, vì nó bao quát tất cả các trường hợp mà một thread cần được đánh thức (theo hướng bảo thủ); cái giá phải trả, như đã nói, là có thể đánh thức quá nhiều thread.</p>
<p>Người đọc tinh ý có thể nhận ra rằng chúng ta <strong>có thể</strong> đã dùng cách tiếp cận này trước đó (xem bài toán producer/consumer với chỉ một condition variable). Tuy nhiên, trong trường hợp đó, chúng ta có một giải pháp tốt hơn, nên đã sử dụng nó.</p>
<p>Nói chung, nếu bạn thấy chương trình của mình chỉ hoạt động khi bạn đổi các lệnh signal thành broadcast (nhưng bạn nghĩ rằng lẽ ra không cần), thì có thể bạn đang có một <strong>bug</strong>; hãy sửa nó! Nhưng trong những trường hợp như bộ cấp phát bộ nhớ ở trên, broadcast có thể là giải pháp đơn giản và hiệu quả nhất.</p>
<h2 id="304-tóm-tắt"><a class="header" href="#304-tóm-tắt">30.4 Tóm tắt</a></h2>
<p>Chúng ta đã được giới thiệu một <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa) quan trọng khác ngoài lock: <strong>condition variable</strong>.</p>
<p>Bằng cách cho phép các thread ngủ khi trạng thái chương trình chưa như mong muốn, condition variable giúp chúng ta giải quyết gọn gàng nhiều vấn đề đồng bộ hóa quan trọng, bao gồm bài toán nổi tiếng (và vẫn còn quan trọng) <strong>producer/consumer</strong>, cũng như <strong>covering condition</strong>.</p>
<p>Một câu kết ấn tượng có thể được đặt ở đây, chẳng hạn như: <em>“He loved Big Brothe…”</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-semaphores-cơ-chế-semaphore"><a class="header" href="#31-semaphores-cơ-chế-semaphore">31. Semaphores (Cơ chế Semaphore)</a></h1>
<p>Như chúng ta đã biết, để giải quyết được một loạt các vấn đề <strong>concurrency</strong> (tính đồng thời) quan trọng và thú vị, chúng ta cần cả <strong>lock</strong> (khóa) và <strong>condition variable</strong> (biến điều kiện). Một trong những người đầu tiên nhận ra điều này từ nhiều năm trước là <strong>Edsger Dijkstra</strong> (mặc dù thật khó để biết chính xác lịch sử [GR92]). Ông nổi tiếng với nhiều đóng góp, như thuật toán “<strong>shortest paths</strong>” (đường đi ngắn nhất) trong lý thuyết đồ thị [D59], bài viết gây tiếng vang về lập trình có cấu trúc mang tên “<strong>Goto Statements Considered Harmful</strong>” [D68a] (một tiêu đề tuyệt vời!), và trong trường hợp chúng ta nghiên cứu ở đây — việc giới thiệu một <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa) gọi là <strong>semaphore</strong> [D68b, D72]. Thực tế, Dijkstra và các cộng sự đã phát minh ra semaphore như một nguyên thủy duy nhất cho mọi thứ liên quan đến đồng bộ hóa; như bạn sẽ thấy, có thể dùng semaphore như cả lock và condition variable.</p>
<blockquote>
<p><strong>THE CRUX: CÁCH SỬ DỤNG SEMAPHORE</strong><br />
Làm thế nào để dùng semaphore thay cho lock và condition variable? Định nghĩa của semaphore là gì? Binary semaphore là gì? Có dễ dàng xây dựng semaphore từ lock và condition variable không? Và ngược lại, có thể xây dựng lock và condition variable từ semaphore không?</p>
</blockquote>
<h2 id="311-semaphores-Định-nghĩa"><a class="header" href="#311-semaphores-Định-nghĩa">31.1 Semaphores: Định nghĩa</a></h2>
<p><strong>Semaphore</strong> là một đối tượng có một giá trị nguyên, mà chúng ta có thể thao tác thông qua hai hàm; trong chuẩn <strong>POSIX</strong>, các hàm này là <code>sem_wait()</code> và <code>sem_post()</code><sup class="footnote-reference"><a href="#1">1</a></sup>. Vì giá trị khởi tạo của semaphore quyết định hành vi của nó, trước khi gọi bất kỳ hàm nào khác để tương tác với semaphore, chúng ta phải khởi tạo nó với một giá trị, như trong <strong>Hình 31.1</strong>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Lịch sử: <code>sem_wait()</code> ban đầu được Dijkstra gọi là <strong>P()</strong> và <code>sem_post()</code> là <strong>V()</strong>. Các dạng viết tắt này xuất phát từ tiếng Hà Lan; thú vị là các từ gốc tiếng Hà Lan này đã thay đổi theo thời gian. Ban đầu, P() đến từ “passering” (đi qua) và V() từ “vrijgave” (giải phóng); sau này, Dijkstra viết rằng P() đến từ “prolaag” (ghép của “probeer” – thử và “verlaag” – giảm), và V() từ “verhoog” – tăng. Đôi khi, người ta gọi chúng là <strong>down</strong> và <strong>up</strong>. Bạn có thể dùng các phiên bản tiếng Hà Lan này để gây ấn tượng với bạn bè, hoặc làm họ bối rối, hoặc cả hai. Xem thêm tại https://news.ycombinator.com/item?id=8761539.</p>
</div>
<pre><code class="language-c">#include &lt;semaphore.h&gt;
sem_t s;
sem_init(&amp;s, 0, 1);
</code></pre>
<p><img src="31/img/fig31_1.PNG" alt="" /></p>
<p><strong>Hình 31.1: Khởi tạo một Semaphore</strong></p>
<p>Trong hình, chúng ta khai báo một semaphore <code>s</code> và khởi tạo nó với giá trị 1 (tham số thứ ba). Tham số thứ hai của <code>sem_init()</code> sẽ được đặt là 0 trong tất cả các ví dụ chúng ta sẽ thấy; điều này cho biết semaphore được chia sẻ giữa các thread trong cùng một <strong>process</strong> (tiến trình). Xem trang <strong>man</strong> để biết chi tiết các cách sử dụng khác của semaphore (ví dụ: đồng bộ hóa giữa các process khác nhau), khi đó tham số thứ hai sẽ có giá trị khác.</p>
<p>Sau khi semaphore được khởi tạo, chúng ta có thể gọi một trong hai hàm để tương tác với nó: <code>sem_wait()</code> hoặc <code>sem_post()</code>. Hành vi của hai hàm này được mô tả trong <strong>Hình 31.2</strong>.</p>
<p>Hiện tại, chúng ta chưa quan tâm đến cách triển khai các hàm này, vốn rõ ràng cần được xử lý cẩn thận; với nhiều thread cùng gọi <code>sem_wait()</code> và <code>sem_post()</code>, cần phải quản lý các <strong>critical section</strong> (vùng tới hạn) bên trong chúng. Giờ chúng ta sẽ tập trung vào cách sử dụng các primitive này; sau đó có thể bàn về cách chúng được xây dựng.</p>
<p>Một số điểm quan trọng về giao diện này:</p>
<ul>
<li>Thứ nhất, <code>sem_wait()</code> sẽ hoặc trả về ngay (nếu giá trị của semaphore ≥ 1 khi gọi), hoặc sẽ khiến thread gọi bị <strong>suspend</strong> (tạm dừng) để chờ một lần post tiếp theo. Tất nhiên, nhiều thread có thể cùng gọi <code>sem_wait()</code> và tất cả sẽ được xếp hàng chờ được đánh thức.</li>
<li>Thứ hai, <code>sem_post()</code> không chờ một điều kiện cụ thể như <code>sem_wait()</code>; nó chỉ đơn giản tăng giá trị của semaphore và nếu có thread đang chờ, sẽ đánh thức một thread.</li>
<li>Thứ ba, giá trị của semaphore, khi âm, bằng đúng số lượng thread đang chờ [D68b]. Mặc dù giá trị này thường không được hiển thị cho người dùng semaphore, nhưng đây là một bất biến đáng biết và có thể giúp bạn nhớ cách semaphore hoạt động.</li>
</ul>
<pre><code class="language-c">int sem_wait(sem_t *s) {
  decrement the value of semaphore s by one
  wait if value of semaphore s is negative
}

int sem_post(sem_t *s) {
  increment the value of semaphore s by one
  if there are one or more threads waiting, wake one
}
</code></pre>
<p><img src="31/img/fig31_2.PNG" alt="" /></p>
<p><strong>Hình 31.2: Semaphore – Định nghĩa Wait và Post</strong></p>
<p>Đừng lo (vội) về các <strong>race condition</strong> có thể xảy ra bên trong semaphore; giả định rằng các thao tác này được thực hiện <strong>atomically</strong> (nguyên tử). Chúng ta sẽ sớm dùng lock và condition variable để đảm bảo điều này.</p>
<h2 id="312-binary-semaphores-dùng-như-lock"><a class="header" href="#312-binary-semaphores-dùng-như-lock">31.2 Binary Semaphores (Dùng như Lock)</a></h2>
<p>Giờ chúng ta sẵn sàng sử dụng semaphore. Cách dùng đầu tiên là một trường hợp quen thuộc: dùng semaphore như một <strong>lock</strong>. Xem <strong>Hình 31.3</strong>; ở đó, bạn sẽ thấy chúng ta chỉ cần bao quanh critical section cần bảo vệ bằng cặp <code>sem_wait()/sem_post()</code>. Điều quan trọng để cơ chế này hoạt động là giá trị khởi tạo của semaphore <code>m</code> (được khởi tạo với <code>X</code> trong hình). Vậy <code>X</code> nên là bao nhiêu?<br />
...(Hãy thử suy nghĩ trước khi đọc tiếp)...</p>
<pre><code class="language-c">sem_t m;
sem_init(&amp;m, 0, X); // init to X; what should X be?

sem_wait(&amp;m);
// critical section here
sem_post(&amp;m);
</code></pre>
<p><img src="31/img/fig31_3.PNG" alt="" /></p>
<p><strong>Hình 31.3: Binary Semaphore (tức là Lock)</strong></p>
<p>Nhìn lại định nghĩa của <code>sem_wait()</code> và <code>sem_post()</code> ở trên, ta thấy giá trị khởi tạo nên là <strong>1</strong>.</p>
<p>Để làm rõ, hãy tưởng tượng kịch bản với hai thread. Thread đầu tiên (Thread 0) gọi <code>sem_wait()</code>; nó sẽ giảm giá trị của semaphore xuống 0. Sau đó, nó sẽ chỉ chờ nếu giá trị nhỏ hơn 0. Vì giá trị là 0, <code>sem_wait()</code> sẽ trả về ngay và thread gọi tiếp tục; Thread 0 giờ được vào critical section. Nếu không có thread nào khác cố lấy lock khi Thread 0 đang ở trong critical section, khi nó gọi <code>sem_post()</code>, giá trị semaphore sẽ được khôi phục về 1 (và không đánh thức thread nào vì không có ai đang chờ). <strong>Hình 31.4</strong> sẽ cho thấy vết thực thi (trace) của kịch bản này.</p>
<p><img src="31/img/fig31_4.PNG" alt="" /></p>
<p><strong>Hình 31.4: Vết thực thi của luồng – Một luồng sử dụng Semaphore</strong></p>
<p>Một trường hợp thú vị hơn xảy ra khi <strong>Thread 0</strong> “giữ lock” (tức là đã gọi <code>sem_wait()</code> nhưng chưa gọi <code>sem_post()</code>), và một luồng khác (<strong>Thread 1</strong>) cố gắng vào <strong>critical section</strong> (vùng tới hạn) bằng cách gọi <code>sem_wait()</code>.</p>
<p>Trong trường hợp này, <strong>Thread 1</strong> sẽ giảm giá trị của semaphore xuống <strong>-1</strong>, và do đó sẽ phải <strong>wait</strong> (tự đưa mình vào trạng thái ngủ và nhường CPU). Khi <strong>Thread 0</strong> chạy lại, nó sẽ gọi <code>sem_post()</code>, tăng giá trị của semaphore trở lại <strong>0</strong>, và sau đó đánh thức luồng đang chờ (<strong>Thread 1</strong>). Lúc này, <strong>Thread 1</strong> sẽ có thể tự acquire lock. Khi <strong>Thread 1</strong> hoàn tất, nó sẽ lại tăng giá trị của semaphore, khôi phục nó về <strong>1</strong>.</p>
<p><img src="31/img/fig31_5.PNG" alt="" /></p>
<p><strong>Hình 31.5: Vết thực thi của luồng – Hai luồng sử dụng Semaphore</strong></p>
<p><strong>Hình 31.5</strong> minh họa vết thực thi của ví dụ này. Ngoài các hành động của luồng, hình còn cho thấy <strong>trạng thái scheduler</strong> của mỗi luồng:</p>
<ul>
<li><strong>Run</strong> (luồng đang chạy)</li>
<li><strong>Ready</strong> (có thể chạy nhưng chưa được chạy)</li>
<li><strong>Sleep</strong> (luồng đang bị block).</li>
</ul>
<p>Lưu ý rằng <strong>Thread 1</strong> sẽ chuyển sang trạng thái <strong>sleeping</strong> khi cố gắng acquire một lock đang bị giữ; chỉ khi <strong>Thread 0</strong> chạy lại thì <strong>Thread 1</strong> mới có thể được đánh thức và có khả năng chạy tiếp.</p>
<p>Nếu bạn muốn tự thực hành, hãy thử một kịch bản trong đó nhiều luồng xếp hàng chờ lock. Giá trị của semaphore sẽ là bao nhiêu trong vết thực thi như vậy?</p>
<p>Như vậy, chúng ta có thể dùng <strong>semaphore</strong> như <strong>lock</strong>. Vì lock chỉ có hai trạng thái (<strong>held</strong> – đang bị giữ và <strong>not held</strong> – không bị giữ), đôi khi chúng ta gọi semaphore dùng như lock là <strong>binary semaphore</strong>. Lưu ý rằng nếu bạn chỉ dùng semaphore theo cách nhị phân này, nó có thể được triển khai đơn giản hơn so với semaphore tổng quát mà chúng ta trình bày ở đây.</p>
<h2 id="313-semaphores-cho-việc-sắp-xếp-thứ-tự-semaphores-for-ordering"><a class="header" href="#313-semaphores-cho-việc-sắp-xếp-thứ-tự-semaphores-for-ordering">31.3 Semaphores cho việc sắp xếp thứ tự (Semaphores For Ordering)</a></h2>
<p>Semaphore cũng hữu ích để <strong>sắp xếp thứ tự các sự kiện</strong> trong một chương trình đồng thời. Ví dụ, một luồng có thể muốn chờ cho đến khi một danh sách không còn rỗng, để nó có thể xóa một phần tử khỏi danh sách.</p>
<p>Trong mô hình sử dụng này, thường có một luồng <strong>chờ</strong> một sự kiện xảy ra, và một luồng khác <strong>tạo ra</strong> sự kiện đó rồi <strong>signal</strong> rằng nó đã xảy ra, từ đó đánh thức luồng đang chờ. Chúng ta đang dùng semaphore như một <strong>ordering primitive</strong> (nguyên thủy sắp xếp thứ tự), tương tự như cách chúng ta đã dùng <strong>condition variable</strong> trước đây.</p>
<p>Một ví dụ đơn giản như sau: giả sử một luồng tạo ra một luồng khác và muốn chờ cho đến khi luồng đó hoàn tất thực thi (<strong>Hình 31.6</strong>). Khi chương trình này chạy, chúng ta muốn thấy kết quả:</p>
<pre><code>parent: begin
child
parent: end
</code></pre>
<p>Câu hỏi đặt ra là: làm thế nào để dùng semaphore đạt được hiệu ứng này? Thực tế, câu trả lời khá dễ hiểu.</p>
<p>Như bạn thấy trong code, <strong>parent</strong> chỉ cần gọi <code>sem_wait()</code> và <strong>child</strong> gọi <code>sem_post()</code> để chờ cho đến khi điều kiện “child hoàn thành” trở thành đúng.</p>
<p>Tuy nhiên, điều này dẫn đến câu hỏi: <strong>giá trị khởi tạo của semaphore này nên là bao nhiêu?</strong><br />
(Một lần nữa, hãy thử suy nghĩ trước khi đọc tiếp)</p>
<p><img src="31/img/fig31_6.PNG" alt="" /></p>
<p><strong>Hình 31.6: Parent chờ Child</strong></p>
<p>Câu trả lời, tất nhiên, là giá trị của semaphore nên được đặt là <strong>0</strong>. Có hai trường hợp cần xem xét:</p>
<ol>
<li>
<p><strong>Trường hợp 1:</strong> Parent tạo child nhưng child chưa chạy (tức là đang ở trong <strong>ready queue</strong> nhưng chưa được chạy). Trong trường hợp này (<strong>Hình 31.7</strong>, trang 6), parent sẽ gọi <code>sem_wait()</code> trước khi child gọi <code>sem_post()</code>; chúng ta muốn parent phải chờ cho đến khi child chạy. Cách duy nhất để điều này xảy ra là giá trị của semaphore <strong>không lớn hơn 0</strong>; do đó, giá trị khởi tạo phải là <strong>0</strong>.</p>
<p>Parent chạy, giảm giá trị semaphore xuống <strong>-1</strong>, rồi <strong>wait</strong> (ngủ). Khi child cuối cùng chạy, nó sẽ gọi <code>sem_post()</code>, tăng giá trị semaphore lên <strong>0</strong>, và đánh thức parent, lúc này sẽ return từ <code>sem_wait()</code> và kết thúc chương trình.</p>
</li>
</ol>
<p><img src="31/img/fig31_7.PNG" alt="" /></p>
<p><strong>Hình 31.7: Vết thực thi luồng – Parent chờ Child (Trường hợp 1)</strong></p>
<p><img src="31/img/fig31_8.PNG" alt="" /></p>
<p><strong>Hình 31.8: Vết thực thi luồng – Parent chờ Child (Trường hợp 2)</strong></p>
<p>Trường hợp thứ hai (<strong>Hình 31.8</strong>) xảy ra khi <strong>child</strong> chạy xong hoàn toàn trước khi <strong>parent</strong> có cơ hội gọi <code>sem_wait()</code>. Trong trường hợp này, child sẽ gọi <code>sem_post()</code> trước, do đó tăng giá trị của semaphore từ <strong>0</strong> lên <strong>1</strong>. Khi parent sau đó được chạy, nó sẽ gọi <code>sem_wait()</code> và thấy giá trị của semaphore là <strong>1</strong>; parent sẽ giảm giá trị này xuống <strong>0</strong> và trả về từ <code>sem_wait()</code> mà không phải chờ, vẫn đạt được hiệu ứng mong muốn.</p>
<h2 id="314-bài-toán-producerconsumer-bounded-buffer"><a class="header" href="#314-bài-toán-producerconsumer-bounded-buffer">31.4 Bài toán Producer/Consumer (Bounded Buffer)</a></h2>
<p>Vấn đề tiếp theo mà chúng ta sẽ gặp trong chương này được gọi là <strong>producer/consumer problem</strong> (bài toán nhà sản xuất/nhà tiêu thụ), hoặc đôi khi là <strong>bounded buffer problem</strong> (bài toán bộ đệm giới hạn) [D72]. Vấn đề này đã được mô tả chi tiết trong chương trước về <strong>condition variable</strong>; bạn có thể xem lại ở đó để biết chi tiết.</p>
<blockquote>
<p><strong>ASIDE: THIẾT LẬP GIÁ TRỊ CHO SEMAPHORE</strong></p>
<p>Chúng ta vừa thấy hai ví dụ về việc khởi tạo semaphore. Trong trường hợp đầu tiên, ta đặt giá trị là <strong>1</strong> để dùng semaphore như một <strong>lock</strong>; trong trường hợp thứ hai, đặt giá trị là <strong>0</strong> để dùng semaphore cho mục đích <strong>ordering</strong> (sắp xếp thứ tự). Vậy quy tắc tổng quát để khởi tạo semaphore là gì?</p>
<p>Một cách đơn giản để suy nghĩ, nhờ gợi ý của Perry Kivolowitz, là hãy xem xét số lượng <strong>tài nguyên</strong> bạn sẵn sàng “phát” ngay sau khi khởi tạo. Với lock, giá trị là <strong>1</strong>, vì bạn sẵn sàng cho phép lock được “giữ” ngay sau khi khởi tạo. Với trường hợp ordering, giá trị là <strong>0</strong>, vì ban đầu không có gì để “phát”; chỉ khi child thread hoàn thành thì tài nguyên mới được tạo ra, lúc đó giá trị mới được tăng lên <strong>1</strong>. Hãy thử áp dụng cách suy nghĩ này cho các bài toán semaphore sau này và xem nó có giúp ích không.</p>
</blockquote>
<h3 id="lần-thử-đầu-tiên"><a class="header" href="#lần-thử-đầu-tiên">Lần thử đầu tiên</a></h3>
<p>Trong lần thử đầu tiên để giải quyết vấn đề, chúng ta giới thiệu hai semaphore: <code>empty</code> và <code>full</code>, mà các thread sẽ dùng để biểu thị khi một ô trong buffer đã được làm rỗng hoặc đã được lấp đầy. Code cho các hàm <code>put</code> và <code>get</code> nằm trong <strong>Hình 31.9</strong>, và cách chúng ta thử giải quyết bài toán producer/consumer nằm trong <strong>Hình 31.10</strong> (trang 8).</p>
<p><img src="31/img/fig31_9.PNG" alt="" /></p>
<p><strong>Hình 31.10: Thêm điều kiện Full và Empty</strong></p>
<p>Trong ví dụ này, <strong>producer</strong> trước tiên sẽ chờ cho đến khi một buffer rỗng để đặt dữ liệu vào, và <strong>consumer</strong> tương tự sẽ chờ cho đến khi một buffer đầy trước khi sử dụng nó.</p>
<p>Trước hết, hãy giả sử <code>MAX=1</code> (chỉ có một buffer trong mảng), và xem điều này có hoạt động không.</p>
<p>Giả sử có hai thread: một producer và một consumer. Hãy xét một kịch bản cụ thể trên một CPU đơn. Giả sử consumer chạy trước. Khi đó, consumer sẽ đến dòng C1 trong <strong>Hình 31.10</strong>, gọi <code>sem_wait(&amp;full)</code>. Vì <code>full</code> được khởi tạo với giá trị <strong>0</strong>, call này sẽ giảm <code>full</code> xuống <strong>-1</strong>, chặn consumer lại, và chờ một thread khác gọi <code>sem_post()</code> trên <code>full</code>, đúng như mong muốn.</p>
<p>Giả sử producer sau đó chạy. Nó sẽ đến dòng P1, gọi <code>sem_wait(&amp;empty)</code>. Không giống consumer, producer sẽ tiếp tục qua dòng này, vì <code>empty</code> được khởi tạo với giá trị <code>MAX</code> (trong trường hợp này là <strong>1</strong>). Do đó, <code>empty</code> sẽ bị giảm xuống <strong>0</strong> và producer sẽ đặt một giá trị dữ liệu vào ô đầu tiên của <code>buffer</code> (dòng P2). Producer sau đó tiếp tục đến P3 và gọi <code>sem_post(&amp;full)</code>, thay đổi giá trị của semaphore <code>full</code> từ <strong>-1</strong> lên <strong>0</strong> và đánh thức consumer (ví dụ: chuyển nó từ trạng thái <strong>blocked</strong> sang <strong>ready</strong>).</p>
<p>Trong trường hợp này, có thể xảy ra một trong hai tình huống:</p>
<ul>
<li>Nếu producer tiếp tục chạy, nó sẽ lặp lại và đến dòng P1 lần nữa. Lần này, nó sẽ bị chặn, vì giá trị của <code>empty</code> là <strong>0</strong>.</li>
<li>Nếu producer bị ngắt và consumer bắt đầu chạy, consumer sẽ return từ <code>sem_wait(&amp;full)</code> (dòng C1), thấy buffer đã đầy và tiêu thụ nó.</li>
</ul>
<p>Dù theo cách nào, chúng ta cũng đạt được hành vi mong muốn.</p>
<p>Bạn có thể thử ví dụ này với nhiều thread hơn (ví dụ: nhiều producer và nhiều consumer). Nó vẫn sẽ hoạt động.</p>
<p>Bây giờ, hãy giả sử <code>MAX</code> lớn hơn 1 (ví dụ <code>MAX=10</code>). Trong ví dụ này, giả sử có nhiều producer và nhiều consumer. Lúc này, chúng ta gặp một vấn đề: <strong>race condition</strong>. Bạn có thấy nó xảy ra ở đâu không? (hãy dành thời gian quan sát) Nếu chưa thấy, gợi ý là: hãy nhìn kỹ hơn vào code của <code>put()</code> và <code>get()</code>.</p>
<p>OK, hãy phân tích vấn đề. Giả sử có hai producer (Pa và Pb) cùng gọi <code>put()</code> gần như đồng thời. Giả sử producer Pa chạy trước, và bắt đầu ghi dữ liệu vào ô đầu tiên của buffer (<code>fill=0</code> tại dòng F1). Trước khi Pa kịp tăng biến đếm <code>fill</code> lên 1, nó bị ngắt. Producer Pb bắt đầu chạy, và tại dòng F1 nó cũng ghi dữ liệu vào phần tử thứ 0 của <code>buffer</code>, nghĩa là dữ liệu cũ ở đó bị ghi đè! Đây là hành động <strong>không được phép</strong>; chúng ta không muốn dữ liệu từ producer bị mất.</p>
<h3 id="giải-pháp-thêm-mutual-exclusion"><a class="header" href="#giải-pháp-thêm-mutual-exclusion">Giải pháp: Thêm Mutual Exclusion</a></h3>
<p>Như bạn thấy, điều chúng ta quên ở đây là <strong>mutual exclusion</strong> (loại trừ lẫn nhau). Việc ghi dữ liệu vào buffer và tăng chỉ số <code>fill</code> là một <strong>critical section</strong> và do đó phải được bảo vệ cẩn thận. Vì vậy, hãy dùng <strong>binary semaphore</strong> như một <strong>lock</strong>. <strong>Hình 31.11</strong> cho thấy cách chúng ta thử áp dụng.</p>
<p><img src="31/img/fig31_10.PNG" alt="" /></p>
<p><strong>Hình 31.11: Thêm Mutual Exclusion (Sai cách)</strong></p>
<p>Giờ đây, chúng ta đã thêm một số <strong>lock</strong> bao quanh toàn bộ phần <code>put()/get()</code> của code, như được đánh dấu bởi các chú thích <strong>NEW LINE</strong>. Nghe có vẻ là một ý tưởng đúng, nhưng thực tế lại <strong>không hoạt động</strong>. Tại sao? <strong>Deadlock</strong>.</p>
<p>Vì sao deadlock xảy ra? Hãy dành chút thời gian suy nghĩ; thử tìm một tình huống mà deadlock xuất hiện. Trình tự các bước nào phải xảy ra để chương trình rơi vào deadlock?</p>
<h3 id="tránh-deadlock"><a class="header" href="#tránh-deadlock">Tránh Deadlock</a></h3>
<p>OK, bây giờ khi bạn đã tìm ra, đây là câu trả lời. Hãy tưởng tượng có hai <strong>thread</strong>, một <strong>producer</strong> và một <strong>consumer</strong>. Consumer chạy trước. Nó acquire <strong>mutex</strong> (dòng C0), sau đó gọi <code>sem_wait()</code> trên semaphore <code>full</code> (dòng C1); vì chưa có dữ liệu nào, call này khiến consumer bị block và nhường CPU; quan trọng là, consumer <strong>vẫn đang giữ lock</strong>.</p>
<p>Sau đó, producer chạy. Nó có dữ liệu để sản xuất và nếu có thể chạy, nó sẽ đánh thức consumer và mọi thứ sẽ ổn. Nhưng đáng tiếc, việc đầu tiên nó làm là gọi <code>sem_wait()</code> trên semaphore nhị phân <code>mutex</code> (dòng P0). Lock này đã bị giữ. Do đó, producer cũng bị kẹt chờ.</p>
<p>Ở đây hình thành một vòng lặp đơn giản: consumer giữ mutex và đang chờ ai đó signal <code>full</code>. Producer có thể signal <code>full</code> nhưng lại đang chờ <code>mutex</code>. Kết quả là producer và consumer đều kẹt chờ nhau: một deadlock kinh điển.</p>
<h3 id="cuối-cùng-một-giải-pháp-hoạt-động"><a class="header" href="#cuối-cùng-một-giải-pháp-hoạt-động">Cuối cùng, một giải pháp hoạt động</a></h3>
<p>Để giải quyết vấn đề này, chúng ta chỉ cần <strong>giảm phạm vi của lock</strong>. <strong>Hình 31.12</strong> (trang 10) cho thấy giải pháp đúng. Như bạn thấy, chúng ta chỉ cần di chuyển phần acquire và release mutex để bao quanh đúng <strong>critical section</strong>; phần code <code>wait</code> và <code>signal</code> trên <code>full</code> và <code>empty</code> được để bên ngoài<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<p>Kết quả là một bounded buffer đơn giản và hoạt động đúng — một mẫu thường được sử dụng trong các chương trình đa luồng. Hiểu nó ngay bây giờ; dùng nó sau này. Bạn sẽ cảm ơn chúng tôi trong nhiều năm tới. Hoặc ít nhất, bạn sẽ cảm ơn khi câu hỏi tương tự xuất hiện trong kỳ thi cuối kỳ, hoặc trong một buổi phỏng vấn xin việc.</p>
<p><img src="31/img/fig31_11.PNG" alt="" /></p>
<p><strong>Hình 31.12: Thêm Mutual Exclusion (Đúng cách)</strong></p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Thực tế, sẽ tự nhiên hơn nếu đặt phần acquire/release mutex bên trong các hàm <code>put()</code> và <code>get()</code> để đảm bảo tính mô-đun.</p>
</div>
<h2 id="315-reader-writer-locks"><a class="header" href="#315-reader-writer-locks">31.5 Reader-Writer Locks</a></h2>
<p>Một vấn đề kinh điển khác xuất phát từ nhu cầu có một <strong>locking primitive</strong> (nguyên thủy khóa) linh hoạt hơn, cho phép các thao tác truy cập cấu trúc dữ liệu khác nhau có thể yêu cầu các loại khóa khác nhau.</p>
<p>Ví dụ: hãy tưởng tượng có nhiều thao tác đồng thời trên một danh sách, bao gồm <strong>insert</strong> (chèn) và <strong>lookup</strong> (tra cứu) đơn giản. Trong khi insert thay đổi trạng thái của danh sách (vì vậy critical section truyền thống là hợp lý), lookup chỉ đọc cấu trúc dữ liệu; miễn là chúng ta đảm bảo không có insert nào đang diễn ra, ta có thể cho phép nhiều lookup chạy đồng thời.</p>
<p>Loại lock đặc biệt mà chúng ta sẽ phát triển để hỗ trợ kiểu hoạt động này được gọi là <strong>reader-writer lock</strong> [CHP71]. Code cho loại lock này được thể hiện trong <strong>Hình 31.13</strong> (trang 12).</p>
<p><img src="31/img/fig31_12.PNG" alt="" /></p>
<p><strong>Hình 31.13: Một Reader-Writer Lock đơn giản</strong></p>
<p>Code khá đơn giản. Nếu một thread muốn <strong>update</strong> (cập nhật) cấu trúc dữ liệu, nó sẽ gọi cặp hàm đồng bộ mới:</p>
<ul>
<li><code>rwlock_acquire_writelock()</code> để acquire write lock</li>
<li><code>rwlock_release_writelock()</code> để release write lock</li>
</ul>
<p>Bên trong, chúng chỉ đơn giản sử dụng semaphore <code>writelock</code> để đảm bảo chỉ một writer có thể acquire lock và do đó vào critical section để cập nhật cấu trúc dữ liệu.</p>
<p>Điều thú vị hơn là cặp hàm acquire và release <strong>read lock</strong>. Khi acquire read lock, reader trước tiên acquire <code>lock</code> và sau đó tăng biến <code>readers</code> để theo dõi số lượng reader hiện đang ở trong cấu trúc dữ liệu.</p>
<p>Bước quan trọng trong <code>rwlock_acquire_readlock()</code> xảy ra khi <strong>reader đầu tiên</strong> acquire lock; trong trường hợp đó, reader này cũng acquire write lock bằng cách gọi <code>sem_wait()</code> trên semaphore <code>writelock</code>, sau đó release <code>lock</code> bằng cách gọi <code>sem_post()</code>.</p>
<p>Như vậy, khi một reader đã acquire read lock, các reader khác cũng sẽ được phép acquire read lock; tuy nhiên, bất kỳ thread nào muốn acquire write lock sẽ phải chờ cho đến khi <strong>tất cả</strong> reader hoàn tất; reader cuối cùng rời critical section sẽ gọi <code>sem_post()</code> trên <code>writelock</code> và cho phép writer đang chờ acquire lock.</p>
<p>Cách tiếp cận này hoạt động (đúng như mong muốn), nhưng có một số nhược điểm, đặc biệt là về <strong>fairness</strong> (tính công bằng). Cụ thể, rất dễ để reader khiến writer bị <strong>starvation</strong> (đói tài nguyên). Có những giải pháp tinh vi hơn cho vấn đề này; có lẽ bạn có thể nghĩ ra một cách triển khai tốt hơn? Gợi ý: hãy nghĩ về cách ngăn không cho reader mới vào lock khi đã có writer đang chờ.</p>
<p>Cuối cùng, cần lưu ý rằng reader-writer lock nên được sử dụng một cách thận trọng. Chúng thường thêm nhiều overhead (đặc biệt với các triển khai phức tạp hơn), và do đó có thể không cải thiện hiệu năng so với việc chỉ dùng các locking primitive đơn giản và nhanh [CB08]. Dù sao, chúng cũng cho thấy một lần nữa cách chúng ta có thể dùng semaphore theo những cách thú vị và hữu ích.</p>
<blockquote>
<p><strong>TIP: ĐƠN GIẢN VÀ “NGU NGỐC” CÓ THỂ LÀ TỐT HƠN (HILL’S LAW)</strong><br />
Đừng bao giờ đánh giá thấp ý tưởng rằng cách tiếp cận đơn giản và “ngu ngốc” có thể là tốt nhất. Với locking, đôi khi một spin lock đơn giản lại hoạt động tốt nhất, vì nó dễ triển khai và nhanh. Mặc dù thứ như reader/writer lock nghe có vẻ “ngầu”, nhưng chúng phức tạp, và phức tạp có thể đồng nghĩa với chậm. Vì vậy, hãy luôn thử cách đơn giản và “ngu ngốc” trước.<br />
Ý tưởng này, hướng tới sự đơn giản, xuất hiện ở nhiều nơi. Một nguồn sớm là luận án của Mark Hill [H87], nghiên cứu cách thiết kế cache cho CPU. Hill phát hiện rằng cache <strong>direct-mapped</strong> đơn giản hoạt động tốt hơn so với thiết kế <strong>set-associative</strong> phức tạp (một lý do là trong caching, thiết kế đơn giản cho phép tra cứu nhanh hơn). Như Hill đã tóm tắt ngắn gọn: “To và ngu là tốt hơn.” Và do đó, chúng ta gọi lời khuyên tương tự này là <strong>Hill’s Law</strong>.</p>
</blockquote>
<h2 id="316-the-dining-philosophers"><a class="header" href="#316-the-dining-philosophers">31.6 The Dining Philosophers</a></h2>
<p>Một trong những bài toán concurrency nổi tiếng nhất được Dijkstra nêu ra và giải quyết là <strong>dining philosopher’s problem</strong> [D71]. Bài toán này nổi tiếng vì nó thú vị và có phần kích thích trí tuệ; tuy nhiên, tính ứng dụng thực tế của nó là thấp. Nhưng vì danh tiếng, nó vẫn được đưa vào đây; thực tế, bạn có thể bị hỏi về nó trong một buổi phỏng vấn, và bạn sẽ “ghét” giảng viên môn Hệ điều hành của mình nếu bỏ lỡ câu hỏi đó và mất cơ hội việc làm. Ngược lại, nếu bạn được nhận, hãy thoải mái gửi cho giảng viên một lời cảm ơn, hoặc vài cổ phiếu.</p>
<p>Bối cảnh cơ bản của bài toán như sau (<strong>Hình 31.14</strong>): giả sử có <strong>năm “triết gia”</strong> ngồi quanh một bàn tròn. Giữa mỗi cặp triết gia là một chiếc <strong>nĩa</strong> (fork) — tổng cộng năm chiếc. Mỗi triết gia có những khoảng thời gian <strong>suy nghĩ</strong> (không cần nĩa) và những khoảng thời gian <strong>ăn</strong>. Để ăn, một triết gia cần <strong>hai chiếc nĩa</strong>: một bên trái và một bên phải. Sự tranh chấp các chiếc nĩa này, và các vấn đề đồng bộ hóa phát sinh, chính là lý do bài toán này được nghiên cứu trong lập trình đồng thời.</p>
<p><img src="31/img/fig31_13.PNG" alt="" /></p>
<p><strong>Hình 31.14: The Dining Philosophers</strong></p>
<p>Dưới đây là vòng lặp cơ bản của mỗi triết gia, giả sử mỗi người có một <strong>thread identifier</strong> (ID luồng) duy nhất <code>p</code> từ 0 đến 4 (bao gồm):</p>
<p>Thách thức chính ở đây là viết các hàm <code>get_forks()</code> và <code>put_forks()</code> sao cho <strong>không xảy ra deadlock</strong>, <strong>không có triết gia nào bị đói</strong> (starvation) và không bao giờ được ăn, đồng thời <strong>độ đồng thời</strong> (concurrency) là cao nhất có thể (tức là có nhiều triết gia ăn cùng lúc nhất có thể).</p>
<p>Theo giải pháp của <strong>Downey</strong> [D08], chúng ta sẽ dùng một vài hàm trợ giúp để tiến tới lời giải. Chúng là:</p>
<pre><code class="language-c">int left(int p) { return p; }
int right(int p) { return (p + 1) % 5; }
</code></pre>
<p>Khi triết gia <code>p</code> muốn tham chiếu đến chiếc nĩa bên trái của mình, họ chỉ cần gọi <code>left(p)</code>. Tương tự, chiếc nĩa bên phải của triết gia <code>p</code> được tham chiếu bằng cách gọi <code>right(p)</code>; toán tử modulo ở đây xử lý trường hợp đặc biệt khi triết gia cuối cùng (<code>p=4</code>) cố gắng lấy chiếc nĩa bên phải của mình, vốn là nĩa số 0.</p>
<p>Chúng ta cũng sẽ cần một số <strong>semaphore</strong> để giải quyết vấn đề này. Giả sử chúng ta có 5 semaphore, mỗi cái cho một chiếc nĩa:</p>
<pre><code class="language-c">sem_t forks[5];
</code></pre>
<h3 id="giải-pháp-sai-broken-solution"><a class="header" href="#giải-pháp-sai-broken-solution">Giải pháp sai (Broken Solution)</a></h3>
<p>Chúng ta thử giải pháp đầu tiên cho vấn đề. Giả sử ta khởi tạo mỗi semaphore (trong mảng <code>forks</code>) với giá trị <strong>1</strong>. Giả sử thêm rằng mỗi triết gia biết số thứ tự của mình (<code>p</code>). Khi đó, ta có thể viết các hàm <code>get_forks()</code> và <code>put_forks()</code> (<strong>Hình 31.15</strong>, trang 15).</p>
<p><img src="31/img/fig31_14.PNG" alt="" /></p>
<p><strong>Hình 31.15: Các hàm get_forks() và put_forks()</strong></p>
<p>Trực giác đằng sau giải pháp (sai) này như sau: để lấy nĩa, ta chỉ cần “giữ lock” trên từng cái: trước tiên là cái bên trái, sau đó là cái bên phải. Khi ăn xong, ta nhả chúng ra. Nghe có vẻ đơn giản, đúng không? Đáng tiếc, trong trường hợp này, “đơn giản” lại đồng nghĩa với “sai”. Bạn có thấy vấn đề phát sinh không? Hãy suy nghĩ.</p>
<p>Vấn đề ở đây là <strong>deadlock</strong>. Nếu mỗi triết gia tình cờ lấy chiếc nĩa bên trái của mình trước khi bất kỳ ai lấy được chiếc nĩa bên phải, thì mỗi người sẽ bị kẹt, giữ một chiếc nĩa và chờ chiếc còn lại mãi mãi. Cụ thể: triết gia 0 lấy nĩa 0, triết gia 1 lấy nĩa 1, triết gia 2 lấy nĩa 2, triết gia 3 lấy nĩa 3, và triết gia 4 lấy nĩa 4; tất cả nĩa đều đã bị giữ, và tất cả triết gia đều bị kẹt chờ một chiếc nĩa mà người khác đang giữ. Chúng ta sẽ nghiên cứu deadlock chi tiết hơn sau; còn bây giờ, có thể nói rằng đây <strong>không</strong> phải là một giải pháp hoạt động.</p>
<h3 id="một-giải-pháp-phá-vỡ-sự-phụ-thuộc-breaking-the-dependency"><a class="header" href="#một-giải-pháp-phá-vỡ-sự-phụ-thuộc-breaking-the-dependency">Một giải pháp: Phá vỡ sự phụ thuộc (Breaking The Dependency)</a></h3>
<p>Cách đơn giản nhất để giải quyết vấn đề này là thay đổi cách lấy nĩa của ít nhất một triết gia; thực tế, đây chính là cách Dijkstra đã giải quyết vấn đề. Cụ thể, giả sử triết gia số 4 (người có số thứ tự cao nhất) sẽ lấy nĩa theo thứ tự khác với những người còn lại (<strong>Hình 31.16</strong>); code <code>put_forks()</code> vẫn giữ nguyên.</p>
<p><img src="31/img/fig31_15.PNG" alt="" /></p>
<p><strong>Hình 31.16: Phá vỡ sự phụ thuộc trong get_forks()</strong></p>
<p>Vì triết gia cuối cùng cố gắng lấy nĩa bên phải trước nĩa bên trái, sẽ không có tình huống tất cả triết gia đều giữ một nĩa và chờ nĩa còn lại; vòng chờ bị phá vỡ. Hãy suy nghĩ về hệ quả của giải pháp này và tự thuyết phục rằng nó hoạt động.</p>
<p>Có những bài toán “nổi tiếng” khác tương tự, ví dụ: <strong>cigarette smoker’s problem</strong> (bài toán người hút thuốc) hoặc <strong>sleeping barber problem</strong> (bài toán thợ cắt tóc ngủ). Hầu hết chỉ là cái cớ để suy nghĩ về concurrency; một số có tên gọi thú vị. Hãy tìm hiểu nếu bạn muốn biết thêm, hoặc chỉ để luyện tập tư duy đồng thời [D08].</p>
<h2 id="317-thread-throttling"><a class="header" href="#317-thread-throttling">31.7 Thread Throttling</a></h2>
<p>Một trường hợp sử dụng đơn giản khác của semaphore đôi khi xuất hiện, và chúng ta sẽ trình bày ở đây. Vấn đề cụ thể là: làm thế nào để lập trình viên ngăn “quá nhiều” thread làm một việc cùng lúc và làm chậm hệ thống? Câu trả lời: xác định một ngưỡng cho “quá nhiều”, và sau đó dùng semaphore để giới hạn số lượng thread đồng thời thực thi đoạn code đó. Chúng ta gọi cách tiếp cận này là <strong>throttling</strong> [T99], và coi nó như một dạng <strong>admission control</strong> (kiểm soát truy cập).</p>
<p>Hãy xét một ví dụ cụ thể hơn. Giả sử bạn tạo ra hàng trăm thread để xử lý song song một vấn đề. Tuy nhiên, trong một phần của code, mỗi thread cần cấp phát một lượng lớn bộ nhớ để thực hiện một phần tính toán; ta gọi phần code này là <strong>memory-intensive region</strong> (vùng tiêu tốn bộ nhớ). Nếu tất cả thread cùng vào vùng này cùng lúc, tổng yêu cầu cấp phát bộ nhớ sẽ vượt quá lượng bộ nhớ vật lý của máy. Kết quả là máy sẽ bắt đầu <strong>thrashing</strong> (tức là liên tục hoán đổi trang giữa RAM và đĩa), và toàn bộ quá trình tính toán sẽ chậm lại đáng kể.</p>
<p>Một semaphore đơn giản có thể giải quyết vấn đề này. Bằng cách khởi tạo giá trị của semaphore bằng số lượng tối đa thread mà bạn muốn cho phép vào vùng tiêu tốn bộ nhớ cùng lúc, và đặt <code>sem_wait()</code> và <code>sem_post()</code> bao quanh vùng này, semaphore sẽ tự nhiên giới hạn số lượng thread đồng thời ở trong vùng “nguy hiểm” của code.</p>
<h2 id="318-cách-triển-khai-semaphore"><a class="header" href="#318-cách-triển-khai-semaphore">31.8 Cách triển khai Semaphore</a></h2>
<p>Cuối cùng, hãy sử dụng các <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa) cấp thấp của chúng ta — <strong>lock</strong> và <strong>condition variable</strong> — để xây dựng phiên bản semaphore của riêng mình, gọi là... (trống đánh...) <strong>Zemaphores</strong>. Nhiệm vụ này khá đơn giản, như bạn có thể thấy trong <strong>Hình 31.17</strong> (trang 17).</p>
<p><img src="31/img/fig31_16.PNG" alt="" /></p>
<p><strong>Hình 31.17: Triển khai Zemaphore bằng Locks và Condition Variables</strong></p>
<p>Trong đoạn code trên, chúng ta chỉ sử dụng <strong>một lock</strong> và <strong>một condition variable</strong>, cùng với một biến trạng thái để theo dõi giá trị của semaphore. Hãy tự nghiên cứu đoạn code này cho đến khi bạn thực sự hiểu nó. Hãy làm đi!</p>
<p>Một điểm khác biệt tinh tế giữa Zemaphore của chúng ta và <strong>pure semaphore</strong> (semaphore thuần) như Dijkstra định nghĩa là chúng ta <strong>không duy trì bất biến</strong> rằng giá trị của semaphore, khi âm, phản ánh số lượng thread đang chờ; thực tế, giá trị này sẽ <strong>không bao giờ nhỏ hơn 0</strong>. Hành vi này dễ triển khai hơn và phù hợp với cách hiện tại Linux đang thực hiện.</p>
<p>Điều thú vị là, việc xây dựng <strong>condition variable</strong> từ semaphore lại là một nhiệm vụ khó khăn hơn nhiều. Một số lập trình viên giàu kinh nghiệm về lập trình đồng thời đã thử làm điều này trong môi trường Windows, và kết quả là xuất hiện rất nhiều lỗi khác nhau [B04]. Hãy tự thử và xem bạn có thể tìm ra lý do tại sao việc xây dựng condition variable từ semaphore lại là một vấn đề khó hơn so với vẻ bề ngoài hay không.</p>
<h2 id="319-tóm-tắt-summary"><a class="header" href="#319-tóm-tắt-summary">31.9 Tóm tắt (Summary)</a></h2>
<p><strong>Semaphore</strong> là một <strong>synchronization primitive</strong> (nguyên thủy đồng bộ hóa) mạnh mẽ và linh hoạt để viết các chương trình đồng thời. Một số lập trình viên thậm chí chỉ sử dụng semaphore, bỏ qua lock và condition variable, vì sự đơn giản và tính hữu dụng của nó.</p>
<p>Trong chương này, chúng ta đã trình bày một vài vấn đề và giải pháp kinh điển. Nếu bạn quan tâm và muốn tìm hiểu thêm, có rất nhiều tài liệu khác để tham khảo. Một nguồn tuyệt vời (và miễn phí) là cuốn sách của <strong>Allen Downey</strong> về concurrency và lập trình với semaphore [D08]. Cuốn sách này có rất nhiều bài tập dạng “puzzle” để bạn luyện tập, giúp cải thiện hiểu biết của bạn về semaphore nói riêng và concurrency nói chung. Trở thành một chuyên gia thực thụ về concurrency đòi hỏi nhiều năm nỗ lực; việc học vượt ra ngoài những gì bạn tiếp thu trong khóa học này chắc chắn là chìa khóa để làm chủ chủ đề này.</p>
<blockquote>
<p><strong>TIP: CẨN THẬN KHI TỔNG QUÁT HÓA (BE CAREFUL WITH GENERALIZATION)</strong><br />
Kỹ thuật trừu tượng hóa để tổng quát hóa có thể rất hữu ích trong thiết kế hệ thống, khi một ý tưởng tốt có thể được mở rộng một chút để giải quyết một lớp vấn đề lớn hơn. Tuy nhiên, hãy cẩn thận khi tổng quát hóa; như Lampson đã cảnh báo: <em>“Đừng tổng quát hóa; các tổng quát hóa thường là sai”</em> [L83].<br />
Người ta có thể coi semaphore là một sự tổng quát hóa của lock và condition variable; tuy nhiên, liệu sự tổng quát hóa này có thực sự cần thiết? Và, xét đến độ khó khi hiện thực một condition variable dựa trên semaphore, có lẽ sự tổng quát hóa này không “tổng quát” như bạn nghĩ.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-các-vấn-Đề-thường-gặp-trong-lập-trình-Đồng-thời-concurrency"><a class="header" href="#32-các-vấn-Đề-thường-gặp-trong-lập-trình-Đồng-thời-concurrency">32 Các Vấn Đề Thường Gặp Trong Lập Trình Đồng Thời (Concurrency)</a></h1>
<p>Trong nhiều năm qua, các nhà nghiên cứu đã dành rất nhiều thời gian và công sức để tìm hiểu về các lỗi (bug) trong lập trình đồng thời (concurrency bugs). Phần lớn các nghiên cứu ban đầu tập trung vào <strong>deadlock</strong> (bế tắc), một chủ đề mà chúng ta đã đề cập ở các chương trước, nhưng giờ sẽ đi sâu hơn [C+71]. Các nghiên cứu gần đây hơn tập trung vào việc tìm hiểu các loại lỗi đồng thời phổ biến khác (tức là lỗi <strong>non-deadlock</strong> – không phải bế tắc). Trong chương này, chúng ta sẽ xem xét một số ví dụ về các vấn đề đồng thời được tìm thấy trong mã nguồn thực tế, nhằm hiểu rõ hơn những vấn đề cần chú ý. Và đây là vấn đề trọng tâm của chương:</p>
<blockquote>
<p><strong>THE CRUX: CÁCH XỬ LÝ CÁC LỖI ĐỒNG THỜI PHỔ BIẾN</strong><br />
Các lỗi đồng thời thường xuất hiện theo nhiều mẫu (pattern) quen thuộc. Biết được những mẫu này là bước đầu tiên để viết ra mã đồng thời (concurrent code) chính xác và đáng tin cậy hơn.</p>
</blockquote>
<h2 id="321-có-những-loại-lỗi-nào"><a class="header" href="#321-có-những-loại-lỗi-nào">32.1 Có Những Loại Lỗi Nào?</a></h2>
<p>Câu hỏi đầu tiên và rõ ràng nhất là: <strong>Những loại lỗi đồng thời nào thường xuất hiện trong các chương trình phức tạp, đa luồng?</strong><br />
Câu hỏi này khó trả lời một cách tổng quát, nhưng may mắn là đã có những nghiên cứu thực nghiệm. Cụ thể, chúng ta dựa vào nghiên cứu của Lu và cộng sự [L+08], trong đó họ phân tích chi tiết một số ứng dụng đồng thời phổ biến để hiểu rõ các loại lỗi thường gặp trong thực tế.</p>
<p>Nghiên cứu này tập trung vào bốn ứng dụng mã nguồn mở quan trọng:</p>
<ul>
<li><strong>MySQL</strong> (một hệ quản trị cơ sở dữ liệu phổ biến)</li>
<li><strong>Apache</strong> (một web server nổi tiếng)</li>
<li><strong>Mozilla</strong> (trình duyệt web nổi tiếng)</li>
<li><strong>OpenOffice</strong> (bộ ứng dụng văn phòng miễn phí, tương tự MS Office)</li>
</ul>
<p>Trong nghiên cứu, các tác giả xem xét các lỗi đồng thời đã được phát hiện và sửa trong từng mã nguồn này, biến công việc của lập trình viên thành một phân tích định lượng về lỗi. Hiểu được kết quả này sẽ giúp bạn biết những vấn đề nào thực sự xảy ra trong các hệ thống phần mềm đã trưởng thành.</p>
<p>Hình dưới đây (Hình 32.1) tóm tắt các lỗi mà Lu và cộng sự đã nghiên cứu. Từ bảng, ta thấy có tổng cộng <strong>105 lỗi</strong>, trong đó <strong>74 lỗi là non-deadlock</strong> và <strong>31 lỗi là deadlock</strong>. Ngoài ra, số lượng lỗi ở mỗi ứng dụng cũng khác nhau: OpenOffice chỉ có 8 lỗi đồng thời, trong khi Mozilla có gần 60.</p>
<p><img src="32/img/fig32_1.PNG" alt="" /></p>
<p><strong>Hình 32.1: Các lỗi trong ứng dụng hiện đại</strong><br />
| Application | Chức năng         | Non-Deadlock | Deadlock |
| :---------- | :---------------- | :----------- | :------- |
| MySQL       | Database Server   | 14           | 9        |
| Apache      | Web Server        | 13           | 4        |
| Mozilla     | Web Browser       | 41           | 16       |
| OpenOffice  | Office Suite      | 6            | 2        |
| <strong>Total</strong>   |                   | <strong>74</strong>       | <strong>31</strong>   |</p>
<p>Giờ đây, chúng ta sẽ đi sâu hơn vào hai nhóm lỗi này (<strong>non-deadlock</strong> và <strong>deadlock</strong>).</p>
<ul>
<li>Với nhóm <strong>non-deadlock</strong>, chúng ta sẽ dùng các ví dụ từ nghiên cứu để phân tích.</li>
<li>Với nhóm <strong>deadlock</strong>, chúng ta sẽ bàn về các hướng tiếp cận nhằm phòng tránh, né tránh hoặc xử lý deadlock.</li>
</ul>
<h2 id="322-lỗi-non-deadlock"><a class="header" href="#322-lỗi-non-deadlock">32.2 Lỗi Non-Deadlock</a></h2>
<p>Theo nghiên cứu của Lu, lỗi <strong>non-deadlock</strong> chiếm đa số trong các lỗi đồng thời. Nhưng cụ thể chúng là gì? Chúng xuất hiện như thế nào? Và làm sao để sửa?<br />
Lu và cộng sự chỉ ra hai loại lỗi non-deadlock chính:</p>
<ol>
<li><strong>Atomicity violation</strong> (vi phạm tính nguyên tử)</li>
<li><strong>Order violation</strong> (vi phạm thứ tự)</li>
</ol>
<h3 id="lỗi-atomicity-violation"><a class="header" href="#lỗi-atomicity-violation">Lỗi Atomicity Violation</a></h3>
<p>Loại lỗi đầu tiên là <strong>atomicity violation</strong>. Dưới đây là một ví dụ đơn giản được tìm thấy trong MySQL. Trước khi đọc lời giải thích, hãy thử tìm lỗi.</p>
<p><img src="32/img/fig32_2.PNG" alt="" /></p>
<p><strong>Hình 32.2: Atomicity Violation (atomicity.c)</strong></p>
<p>Trong ví dụ này, hai <strong>thread</strong> (luồng) khác nhau truy cập trường <code>proc_info</code> trong cấu trúc <code>thd</code>.</p>
<ul>
<li>Thread thứ nhất kiểm tra xem giá trị có khác NULL không, rồi in ra giá trị đó.</li>
<li>Thread thứ hai đặt giá trị này thành NULL.</li>
</ul>
<p>Rõ ràng, nếu thread thứ nhất kiểm tra xong nhưng bị ngắt trước khi gọi <code>fputs</code>, thì thread thứ hai có thể chạy xen vào và đặt con trỏ thành NULL. Khi thread thứ nhất tiếp tục, nó sẽ bị crash vì <code>fputs</code> sẽ dereference một con trỏ NULL.</p>
<p><strong>Định nghĩa chính thức</strong> của atomicity violation theo Lu et al.:</p>
<blockquote>
<p>“Tính tuần tự mong muốn giữa nhiều truy cập bộ nhớ bị vi phạm (tức là một đoạn code được dự định là nguyên tử, nhưng tính nguyên tử không được đảm bảo khi thực thi).”</p>
</blockquote>
<p>Trong ví dụ trên, đoạn code giả định rằng việc kiểm tra <code>proc_info</code> khác NULL và việc sử dụng <code>proc_info</code> trong <code>fputs()</code> là nguyên tử. Khi giả định này sai, chương trình sẽ không hoạt động như mong muốn.</p>
<p><strong>Cách sửa:</strong><br />
Giải pháp thường (nhưng không phải luôn) khá đơn giản: thêm <strong>lock</strong> (khóa) quanh các truy cập biến chia sẻ.<br />
Trong ví dụ sửa (Hình 32.3), ta thêm khóa <code>proc_info_lock</code> để đảm bảo rằng khi bất kỳ thread nào truy cập <code>proc_info</code>, nó phải giữ khóa này. Tất nhiên, mọi đoạn code khác truy cập cấu trúc này cũng phải lấy cùng khóa.</p>
<p><img src="32/img/fig32_3.PNG" alt="" /></p>
<p><strong>Hình 32.3: Atomicity Violation Fixed (atomicity_fixed.c)</strong></p>
<h3 id="lỗi-order-violation"><a class="header" href="#lỗi-order-violation">Lỗi Order Violation</a></h3>
<p>Loại lỗi non-deadlock phổ biến thứ hai là <strong>order violation</strong>. Đây là một ví dụ khác; hãy thử tìm lỗi.</p>
<p><img src="32/img/fig32_4.PNG" alt="" /></p>
<p><strong>Hình 32.4: Ordering Bug (ordering.c)</strong></p>
<p>Như bạn có thể đoán, mã trong Thread 2 giả định rằng biến <code>mThread</code> đã được khởi tạo (và khác NULL). Tuy nhiên, nếu Thread 2 chạy ngay sau khi được tạo, <code>mThread</code> vẫn chưa được gán giá trị khi được truy cập trong <code>mMain()</code> của Thread 2, dẫn đến crash do dereference con trỏ NULL.<br />
Giả sử <code>mThread</code> ban đầu là NULL; nếu không, lỗi còn có thể nghiêm trọng hơn khi truy cập vào vùng nhớ tùy ý.</p>
<p><img src="32/img/fig32_5.PNG" alt="" /></p>
<p><strong>Hình 32.5: Fixing The Ordering Violation (ordering_fixed.c)</strong></p>
<p><strong>Định nghĩa chính thức</strong> của order violation:</p>
<blockquote>
<p>“Thứ tự mong muốn giữa hai (hoặc nhóm) truy cập bộ nhớ bị đảo ngược (tức là A luôn phải chạy trước B, nhưng thứ tự này không được đảm bảo khi thực thi)” [L+08].</p>
</blockquote>
<p><strong>Cách sửa:</strong><br />
Giải pháp là <strong>ép buộc thứ tự thực thi</strong>. Như đã bàn trước đây, sử dụng <strong>condition variable</strong> (biến điều kiện) là một cách dễ và hiệu quả để thêm đồng bộ hóa kiểu này vào mã.</p>
<p>Trong ví dụ sửa (Hình 32.5), ta thêm:</p>
<ul>
<li>Condition variable <code>mtCond</code></li>
<li>Lock <code>mtLock</code></li>
<li>Biến trạng thái <code>mtInit</code></li>
</ul>
<p>Khi mã khởi tạo chạy, nó đặt <code>mtInit = 1</code> và gửi tín hiệu (signal) rằng đã xong.</p>
<ul>
<li>Nếu Thread 2 chạy trước thời điểm này, nó sẽ chờ tín hiệu và thay đổi trạng thái.</li>
<li>Nếu Thread 2 chạy sau, nó sẽ thấy <code>mtInit = 1</code> và tiếp tục bình thường.</li>
</ul>
<p>Lưu ý: ta có thể dùng chính <code>mThread</code> làm biến trạng thái, nhưng ở đây tách riêng để đơn giản. Khi thứ tự giữa các thread quan trọng, <strong>condition variable</strong> hoặc <strong>semaphore</strong> là công cụ hữu ích.</p>
<h3 id="tóm-tắt-về-non-deadlock-bugs"><a class="header" href="#tóm-tắt-về-non-deadlock-bugs">Tóm tắt về Non-Deadlock Bugs</a></h3>
<p>Một tỷ lệ lớn (97%) các lỗi <strong>non-deadlock</strong> (không phải bế tắc) được Lu và cộng sự nghiên cứu là thuộc một trong hai loại: <strong>atomicity violation</strong> (vi phạm tính nguyên tử) hoặc <strong>order violation</strong> (vi phạm thứ tự). Do đó, bằng cách suy nghĩ cẩn thận về các mẫu lỗi này, lập trình viên có thể tránh được chúng hiệu quả hơn. Hơn nữa, khi các công cụ kiểm tra mã tự động ngày càng phát triển, chúng nên tập trung vào hai loại lỗi này, vì chúng chiếm phần lớn các lỗi non-deadlock được phát hiện trong môi trường triển khai thực tế.</p>
<p>Tuy nhiên, không phải tất cả các lỗi đều dễ sửa như các ví dụ chúng ta đã xem ở trên. Một số lỗi đòi hỏi phải hiểu sâu hơn về hoạt động của chương trình, hoặc cần tái cấu trúc một lượng lớn mã hoặc cấu trúc dữ liệu để khắc phục. Để biết thêm chi tiết, hãy đọc bài báo xuất sắc (và dễ đọc) của Lu và cộng sự.</p>
<h2 id="323-deadlock-bugs"><a class="header" href="#323-deadlock-bugs">32.3 Deadlock Bugs</a></h2>
<p>Ngoài các lỗi đồng thời đã đề cập ở trên, một vấn đề kinh điển thường xuất hiện trong nhiều hệ thống đồng thời với giao thức khóa (locking protocol) phức tạp được gọi là <strong>deadlock</strong> (bế tắc). Deadlock xảy ra, ví dụ, khi một <strong>thread</strong> (luồng) — giả sử Thread 1 — đang giữ một khóa (L1) và chờ một khóa khác (L2); không may, <strong>thread</strong> khác (Thread 2) đang giữ L2 lại chờ L1 được giải phóng. Dưới đây là một đoạn code minh họa khả năng xảy ra deadlock như vậy:</p>
<p><strong>Thread 1:</strong></p>
<pre><code class="language-c">pthread_mutex_lock(L1);
pthread_mutex_lock(L2);
</code></pre>
<p><strong>Thread 2:</strong></p>
<pre><code class="language-c">pthread_mutex_lock(L2);
pthread_mutex_lock(L1);
</code></pre>
<p><img src="32/img/fig32_6.PNG" alt="" /></p>
<p><strong>Hình 32.6: Simple Deadlock (deadlock.c)</strong></p>
<p>Lưu ý rằng khi chạy đoạn code này, deadlock không nhất thiết xảy ra; nó chỉ xảy ra nếu, ví dụ, Thread 1 lấy được L1 trước, sau đó xảy ra <strong>context switch</strong> (chuyển ngữ cảnh) sang Thread 2. Lúc này, Thread 2 lấy L2 và cố gắng lấy L1. Kết quả là chúng ta có deadlock, vì mỗi thread đang chờ thread kia và không thread nào có thể tiếp tục chạy. Xem <strong>Hình 32.7</strong> để thấy minh họa trực quan; sự xuất hiện của một chu trình (cycle) trong đồ thị là dấu hiệu của deadlock.</p>
<p><img src="32/img/fig32_7.PNG" alt="" /></p>
<p><strong>Hình 32.7: The Deadlock Dependency Graph</strong></p>
<p>Hình này cho thấy vấn đề một cách rõ ràng. Vậy lập trình viên nên viết mã như thế nào để xử lý deadlock?</p>
<blockquote>
<p><strong>THE CRUX: CÁCH ĐỐI PHÓ VỚI DEADLOCK</strong><br />
Chúng ta nên xây dựng hệ thống như thế nào để <strong>phòng ngừa</strong>, <strong>tránh</strong>, hoặc ít nhất là <strong>phát hiện và phục hồi</strong> sau deadlock? Liệu đây có phải là một vấn đề thực sự trong các hệ thống ngày nay?</p>
</blockquote>
<h3 id="tại-sao-deadlock-xảy-ra"><a class="header" href="#tại-sao-deadlock-xảy-ra">Tại sao Deadlock xảy ra?</a></h3>
<p>Như bạn có thể nghĩ, các deadlock đơn giản như ví dụ trên dường như có thể tránh được dễ dàng. Ví dụ, nếu cả Thread 1 và Thread 2 đều đảm bảo lấy khóa theo cùng một thứ tự, deadlock sẽ không bao giờ xảy ra. Vậy tại sao deadlock vẫn xảy ra?</p>
<p><strong>Nguyên nhân thứ nhất</strong> là trong các mã nguồn lớn, các phụ thuộc (dependency) phức tạp giữa các thành phần thường xuất hiện. Lấy ví dụ hệ điều hành: hệ thống <strong>virtual memory</strong> (bộ nhớ ảo) có thể cần truy cập <strong>file system</strong> (hệ thống tệp) để nạp (page in) một khối dữ liệu từ đĩa; ngược lại, file system có thể cần một trang bộ nhớ để đọc khối dữ liệu đó vào, và do đó phải liên hệ lại với virtual memory. Vì vậy, việc thiết kế chiến lược khóa trong các hệ thống lớn phải được thực hiện cẩn thận để tránh deadlock trong trường hợp các phụ thuộc vòng tròn (circular dependency) xuất hiện tự nhiên trong mã.</p>
<p><strong>Nguyên nhân thứ hai</strong> là do bản chất của <strong>encapsulation</strong> (đóng gói). Là lập trình viên, chúng ta được dạy phải ẩn chi tiết cài đặt để phần mềm dễ xây dựng theo mô-đun. Không may, tính mô-đun này lại không phù hợp với cơ chế khóa. Như Jula và cộng sự chỉ ra [J+08], một số giao diện tưởng chừng vô hại lại gần như “mời gọi” deadlock. Ví dụ, hãy xem lớp <code>Vector</code> trong Java và phương thức <code>AddAll()</code>. Phương thức này được gọi như sau:</p>
<pre><code class="language-java">Vector v1, v2;
v1.AddAll(v2);
</code></pre>
<p>Bên trong, vì phương thức cần đảm bảo an toàn đa luồng (multi-thread safe), nên phải lấy khóa cho cả vector được thêm vào (<code>v1</code>) và vector tham số (<code>v2</code>). Phương thức này lấy các khóa theo một thứ tự tùy ý (giả sử <code>v1</code> trước rồi <code>v2</code>) để thêm nội dung của <code>v2</code> vào <code>v1</code>. Nếu một thread khác gọi <code>v2.AddAll(v1)</code> gần như cùng lúc, chúng ta có khả năng xảy ra deadlock — và điều này hoàn toàn ẩn đối với ứng dụng gọi.</p>
<h3 id="các-điều-kiện-để-xảy-ra-deadlock"><a class="header" href="#các-điều-kiện-để-xảy-ra-deadlock">Các điều kiện để xảy ra Deadlock</a></h3>
<p>Bốn điều kiện cần đồng thời thỏa mãn để một <strong>deadlock</strong> (bế tắc) xảy ra [C+71]:</p>
<ul>
<li><strong>Mutual exclusion</strong> (loại trừ lẫn nhau): Các <strong>thread</strong> (luồng) yêu cầu quyền kiểm soát độc quyền đối với tài nguyên mà chúng cần (ví dụ: một thread giữ một <strong>lock</strong>).</li>
<li><strong>Hold-and-wait</strong> (giữ và chờ): Các thread giữ các tài nguyên đã được cấp cho chúng (ví dụ: các lock mà chúng đã lấy) trong khi chờ thêm các tài nguyên khác (ví dụ: các lock mà chúng muốn lấy tiếp).</li>
<li><strong>No preemption</strong> (không cưỡng đoạt): Các tài nguyên (ví dụ: lock) không thể bị thu hồi cưỡng bức từ các thread đang giữ chúng.</li>
<li><strong>Circular wait</strong> (chờ vòng tròn): Tồn tại một chuỗi vòng tròn các thread, trong đó mỗi thread giữ một hoặc nhiều tài nguyên (ví dụ: lock) mà thread tiếp theo trong chuỗi đang yêu cầu.</li>
</ul>
<p>Nếu <strong>bất kỳ</strong> điều kiện nào trong bốn điều kiện trên không được thỏa mãn, deadlock sẽ <strong>không thể</strong> xảy ra. Do đó, trước tiên chúng ta sẽ tìm hiểu các kỹ thuật <strong>phòng ngừa deadlock</strong>; mỗi chiến lược trong số này nhằm ngăn chặn một trong các điều kiện trên xuất hiện, và vì vậy là một cách tiếp cận để xử lý vấn đề deadlock.</p>
<h3 id="phòng-ngừa-prevention"><a class="header" href="#phòng-ngừa-prevention">Phòng ngừa (Prevention)</a></h3>
<h4 id="circular-wait"><a class="header" href="#circular-wait">Circular Wait</a></h4>
<p>Có lẽ kỹ thuật phòng ngừa thực tiễn nhất (và chắc chắn là thường được áp dụng) là viết mã khóa (locking code) sao cho <strong>không bao giờ</strong> tạo ra tình huống <strong>circular wait</strong>. Cách đơn giản nhất để làm điều này là <strong>đặt một thứ tự toàn phần</strong> (total ordering) cho việc lấy lock. Ví dụ, nếu hệ thống chỉ có hai lock (L1 và L2), bạn có thể ngăn deadlock bằng cách <strong>luôn</strong> lấy L1 trước L2. Thứ tự nghiêm ngặt này đảm bảo không xuất hiện vòng chờ, và do đó không có deadlock.</p>
<p>Tất nhiên, trong các hệ thống phức tạp hơn, sẽ có nhiều hơn hai lock, và việc đặt thứ tự toàn phần cho tất cả lock có thể khó thực hiện (và đôi khi không cần thiết). Vì vậy, <strong>thứ tự một phần</strong> (partial ordering) có thể là một cách hữu ích để tổ chức việc lấy lock nhằm tránh deadlock.<br />
Một ví dụ thực tế xuất sắc về <strong>partial lock ordering</strong> có thể thấy trong mã quản lý ánh xạ bộ nhớ (memory mapping) của Linux [T+94] (phiên bản 5.2); phần chú thích ở đầu mã nguồn liệt kê <strong>10 nhóm thứ tự lấy lock khác nhau</strong>, bao gồm các thứ tự đơn giản như “<code>i_mutex</code> trước <code>i_mmap_rwsem</code>” và các thứ tự phức tạp hơn như “<code>i_mmap_rwsem</code> trước <code>private lock</code> trước <code>swap lock</code> trước <code>i_pages lock</code>”.</p>
<blockquote>
<p><strong>TIP: ÁP DỤNG THỨ TỰ LẤY LOCK THEO ĐỊA CHỈ LOCK</strong><br />
Trong một số trường hợp, một hàm cần lấy hai (hoặc nhiều) lock; do đó, chúng ta biết rằng phải cẩn thận nếu không deadlock có thể xảy ra. Hãy tưởng tượng một hàm được gọi như sau:<br />
<code>do_something(mutex_t *m1, mutex_t *m2)</code><br />
Nếu mã <strong>luôn</strong> lấy <code>m1</code> trước <code>m2</code> (hoặc luôn <code>m2</code> trước <code>m1</code>), deadlock vẫn có thể xảy ra, vì một thread có thể gọi <code>do_something(L1, L2)</code> trong khi thread khác gọi <code>do_something(L2, L1)</code>.<br />
Để tránh vấn đề này, lập trình viên thông minh có thể sử dụng <strong>địa chỉ</strong> của mỗi lock như một cách để xác định thứ tự lấy lock. Bằng cách lấy lock theo thứ tự <strong>từ cao xuống thấp</strong> hoặc <strong>từ thấp lên cao</strong> dựa trên địa chỉ, <code>do_something()</code> có thể đảm bảo <strong>luôn</strong> lấy lock theo cùng một thứ tự, bất kể thứ tự truyền tham số.<br />
Ví dụ mã:</p>
<pre><code class="language-c">if (m1 &gt; m2) { // lấy theo thứ tự địa chỉ từ cao xuống thấp
    pthread_mutex_lock(m1);
    pthread_mutex_lock(m2);
} else {
    pthread_mutex_lock(m2);
    pthread_mutex_lock(m1);
}
// Giả định rằng m1 != m2 (không phải cùng một lock)
</code></pre>
<p>Bằng cách sử dụng kỹ thuật đơn giản này, lập trình viên có thể đảm bảo một cách triển khai lấy nhiều lock <strong>không deadlock</strong>, vừa đơn giản vừa hiệu quả.</p>
</blockquote>
<p>Như bạn có thể hình dung, cả <strong>total ordering</strong> và <strong>partial ordering</strong> đều yêu cầu thiết kế chiến lược khóa cẩn thận và phải được xây dựng rất kỹ lưỡng. Hơn nữa, thứ tự chỉ là một <strong>quy ước</strong>, và một lập trình viên cẩu thả có thể dễ dàng bỏ qua giao thức khóa, dẫn đến deadlock. Cuối cùng, lock ordering đòi hỏi hiểu sâu về toàn bộ mã nguồn và cách các hàm được gọi; chỉ một sai sót cũng có thể dẫn đến “từ D”^[1].</p>
<h4 id="hold-and-wait"><a class="header" href="#hold-and-wait">Hold-and-wait</a></h4>
<p>Điều kiện <strong>hold-and-wait</strong> để xảy ra deadlock có thể được loại bỏ bằng cách <strong>lấy tất cả lock cùng một lúc</strong>, theo cách nguyên tử (atomically). Trong thực tế, điều này có thể được thực hiện như sau:</p>
<p>^[1]: “Từ D” ở đây ám chỉ “Deadlock”.</p>
<p>Bằng cách trước tiên lấy <strong>lock</strong> <code>prevention</code>, đoạn code này đảm bảo rằng sẽ không có sự chuyển đổi <strong>thread</strong> (luồng) không đúng thời điểm xảy ra trong quá trình lấy lock, và do đó deadlock (bế tắc) một lần nữa có thể được tránh. Tất nhiên, điều này yêu cầu rằng bất cứ khi nào một thread muốn lấy một lock nào đó, nó phải lấy lock toàn cục <code>prevention</code> trước. Ví dụ, nếu một thread khác đang cố lấy các lock L1 và L2 theo một thứ tự khác, điều đó vẫn ổn, vì nó sẽ giữ lock <code>prevention</code> trong khi thực hiện.</p>
<p>Lưu ý rằng giải pháp này có một số vấn đề. Giống như trước đây, <strong>encapsulation</strong> (đóng gói) lại gây bất lợi: khi gọi một routine (hàm/thủ tục), cách tiếp cận này yêu cầu chúng ta phải biết chính xác những lock nào cần giữ và lấy chúng trước. Kỹ thuật này cũng có khả năng làm giảm <strong>concurrency</strong> (mức độ đồng thời), vì tất cả lock phải được lấy sớm (cùng lúc) thay vì chỉ khi thực sự cần.</p>
<h4 id="no-preemption"><a class="header" href="#no-preemption">No Preemption</a></h4>
<p>Bởi vì thông thường chúng ta coi lock được giữ cho đến khi <code>unlock</code> được gọi, việc lấy nhiều lock cùng lúc thường gây rắc rối, vì khi đang chờ một lock, ta lại đang giữ một lock khác. Nhiều thư viện thread cung cấp một tập hợp giao diện linh hoạt hơn để giúp tránh tình huống này. Cụ thể, routine <code>pthread_mutex_trylock()</code> hoặc sẽ lấy được lock (nếu nó đang rảnh) và trả về thành công, hoặc trả về mã lỗi cho biết lock đang bị giữ; trong trường hợp thứ hai, bạn có thể thử lại sau nếu muốn lấy lock đó.</p>
<p>Giao diện này có thể được sử dụng như sau để xây dựng một giao thức lấy lock <strong>không deadlock</strong> và <strong>ổn định về thứ tự</strong>:</p>
<pre><code>...
</code></pre>
<p>Lưu ý rằng một thread khác có thể tuân theo cùng giao thức nhưng lấy lock theo thứ tự ngược lại (L2 rồi L1) và chương trình vẫn không bị deadlock. Tuy nhiên, một vấn đề mới có thể phát sinh: <strong>livelock</strong>. Có khả năng (dù có thể hiếm) rằng hai thread đều liên tục thử thực hiện chuỗi thao tác này và liên tục thất bại trong việc lấy cả hai lock. Trong trường hợp này, cả hai hệ thống đều chạy qua đoạn code này lặp đi lặp lại (và do đó không phải deadlock), nhưng không có tiến triển nào được thực hiện, vì vậy mới có tên là livelock. Có những giải pháp cho vấn đề livelock, ví dụ: thêm một khoảng trễ ngẫu nhiên trước khi quay lại vòng lặp và thử lại toàn bộ, từ đó giảm khả năng xung đột lặp lại giữa các thread cạnh tranh.</p>
<p>Một điểm cần lưu ý về giải pháp này: nó né tránh những phần khó của việc sử dụng phương pháp <code>trylock</code>. Vấn đề đầu tiên có thể xuất hiện lại là do <strong>encapsulation</strong>: nếu một trong các lock này nằm sâu bên trong một routine được gọi, việc quay lại từ đầu trở nên phức tạp hơn để triển khai. Nếu đoạn code đã lấy một số tài nguyên khác (ngoài L1) trong quá trình, nó phải đảm bảo giải phóng chúng cẩn thận; ví dụ, nếu sau khi lấy L1, đoạn code đã cấp phát một vùng bộ nhớ, thì phải giải phóng vùng nhớ đó khi không lấy được L2, trước khi quay lại đầu để thử lại toàn bộ chuỗi. Tuy nhiên, trong một số trường hợp hạn chế (ví dụ: phương thức <code>Vector.AddAll()</code> trong Java được đề cập trước đó), cách tiếp cận này có thể hoạt động tốt.</p>
<p>Bạn cũng có thể nhận thấy rằng cách tiếp cận này thực ra không bổ sung <strong>preemption</strong> (hành động cưỡng bức lấy lock từ một thread đang giữ nó), mà thay vào đó sử dụng phương pháp <code>trylock</code> để cho phép lập trình viên <strong>tự từ bỏ quyền sở hữu lock</strong> (tức là tự preempt quyền sở hữu của mình) một cách an toàn. Tuy nhiên, đây là một cách tiếp cận thực tiễn, và vì vậy chúng tôi đưa nó vào đây, dù nó chưa hoàn hảo ở khía cạnh này.</p>
<h4 id="mutual-exclusion"><a class="header" href="#mutual-exclusion">Mutual Exclusion</a></h4>
<p>Kỹ thuật phòng ngừa cuối cùng là tránh hoàn toàn nhu cầu <strong>mutual exclusion</strong> (loại trừ lẫn nhau). Nói chung, chúng ta biết điều này là khó, vì đoạn code mà chúng ta muốn chạy thực sự có các <strong>critical section</strong> (vùng găng). Vậy chúng ta có thể làm gì?</p>
<p>Herlihy đã đưa ra ý tưởng rằng có thể thiết kế nhiều cấu trúc dữ liệu <strong>không dùng lock</strong> [H91, H93]. Ý tưởng đằng sau các phương pháp <strong>lock-free</strong> (không khóa) và liên quan là <strong>wait-free</strong> (không chờ) này khá đơn giản: sử dụng các lệnh phần cứng mạnh mẽ, bạn có thể xây dựng các cấu trúc dữ liệu theo cách không cần khóa tường minh.</p>
<p>Ví dụ đơn giản, giả sử chúng ta có một lệnh <strong><code>compare-and-swap</code></strong>, mà như bạn có thể nhớ, đây là một lệnh nguyên tử (atomic instruction) do phần cứng cung cấp, thực hiện như sau:</p>
<pre><code class="language-c">int CompareAndSwap(int *address, int expected, int new) {
    if (*address == expected) {
        *address = new;
        return 1; // success
    }
    return 0; // failure
}
</code></pre>
<p>Giả sử bây giờ chúng ta muốn <strong>tăng một giá trị một cách nguyên tử</strong> (atomically increment) thêm một lượng nhất định, sử dụng lệnh <code>compare-and-swap</code>. Chúng ta có thể thực hiện điều đó với hàm đơn giản sau:</p>
<pre><code class="language-c">void AtomicIncrement(int *value, int amount) {
    do {
        int old = *value;
    } while (CompareAndSwap(value, old, old + amount) == 0);
}
</code></pre>
<p>Thay vì lấy một <strong>lock</strong>, thực hiện cập nhật, rồi giải phóng lock, chúng ta xây dựng một cách tiếp cận khác: liên tục thử cập nhật giá trị lên giá trị mới và sử dụng <code>compare-and-swap</code> để thực hiện. Theo cách này, không có lock nào được lấy, và do đó không thể xảy ra <strong>deadlock</strong> (bế tắc) (mặc dù <strong>livelock</strong> vẫn có thể xảy ra, và vì vậy một giải pháp vững chắc sẽ phức tạp hơn đoạn code đơn giản ở trên).</p>
<p>Hãy xem xét một ví dụ phức tạp hơn một chút: <strong>chèn phần tử vào danh sách</strong> (list insertion). Dưới đây là đoạn code chèn một phần tử vào đầu danh sách:</p>
<pre><code class="language-c">void insert(int value) {
    node_t *n = malloc(sizeof(node_t));
    assert(n != NULL);
    n-&gt;value = value;
    n-&gt;next = head;
    head = n;
}
</code></pre>
<p>Đoạn code này thực hiện một phép chèn đơn giản, nhưng nếu được gọi bởi nhiều <strong>thread</strong> (luồng) “cùng lúc”, sẽ xuất hiện <strong>race condition</strong> (điều kiện tranh chấp). Bạn có thể tìm ra lý do không? (Hãy vẽ một sơ đồ về những gì có thể xảy ra với danh sách nếu hai phép chèn đồng thời diễn ra, giả sử như thường lệ rằng có một sự xen kẽ lịch trình (scheduling interleaving) bất lợi).<br />
Tất nhiên, chúng ta có thể giải quyết vấn đề này bằng cách bao quanh đoạn code với thao tác lấy lock và giải phóng lock:</p>
<pre><code class="language-c">void insert(int value) {
    node_t *n = malloc(sizeof(node_t));
    assert(n != NULL);
    n-&gt;value = value;
    pthread_mutex_lock(listlock); // begin critical section
    n-&gt;next = head;
    head = n;
    pthread_mutex_unlock(listlock); // end critical section
}
</code></pre>
<p>Trong giải pháp này, chúng ta đang sử dụng lock theo cách truyền thống². Thay vào đó, hãy thử thực hiện phép chèn này theo cách <strong>lock-free</strong> (không dùng khóa) chỉ với lệnh <code>compare-and-swap</code>. Dưới đây là một cách tiếp cận khả thi:</p>
<pre><code class="language-c">void insert(int value) {
    node_t *n = malloc(sizeof(node_t));
    assert(n != NULL);
    n-&gt;value = value;
    do {
        n-&gt;next = head;
    } while (CompareAndSwap(&amp;head, n-&gt;next, n) == 0);
}
</code></pre>
<p>²Người đọc tinh ý có thể sẽ hỏi tại sao chúng ta lại lấy lock muộn như vậy, thay vì ngay khi bước vào hàm <code>insert()</code>; bạn có thể, với sự tinh ý, tìm ra lý do tại sao điều đó có khả năng là đúng không? Ví dụ, đoạn code đưa ra giả định gì về call <code>malloc()</code>?</p>
<p>Trong đoạn code này, con trỏ <code>next</code> của nút mới được cập nhật để trỏ tới phần tử đầu hiện tại, sau đó cố gắng hoán đổi (swap) nút mới vào vị trí đầu danh sách bằng <code>compare-and-swap</code>. Tuy nhiên, thao tác này sẽ thất bại nếu một thread khác đã thành công trong việc hoán đổi một nút mới vào đầu danh sách trong khoảng thời gian đó, khiến thread này phải thử lại với phần tử đầu mới.</p>
<p>Tất nhiên, việc xây dựng một danh sách hữu ích đòi hỏi nhiều hơn là chỉ thao tác chèn; và không ngạc nhiên khi việc xây dựng một danh sách có thể chèn, xóa và tìm kiếm theo cách lock-free là <strong>không hề đơn giản</strong>. Hãy đọc thêm các tài liệu nghiên cứu phong phú về <strong>lock-free</strong> và <strong>wait-free synchronization</strong> (đồng bộ hóa không khóa và không chờ) để tìm hiểu thêm [H01, H91, H93].</p>
<h3 id="tránh-deadlock-thông-qua-scheduling"><a class="header" href="#tránh-deadlock-thông-qua-scheduling">Tránh Deadlock thông qua Scheduling</a></h3>
<p>Thay vì <strong>phòng ngừa deadlock</strong> (deadlock prevention), trong một số tình huống, <strong>tránh deadlock</strong> (deadlock avoidance) là lựa chọn tốt hơn. Tránh deadlock yêu cầu có kiến thức toàn cục về những lock mà các thread có thể lấy trong quá trình thực thi, và sau đó lập lịch (schedule) các thread đó theo cách đảm bảo rằng deadlock không thể xảy ra.</p>
<p>Ví dụ, giả sử chúng ta có <strong>hai bộ xử lý</strong> và <strong>bốn thread</strong> cần được lập lịch trên chúng. Giả sử thêm rằng:</p>
<ul>
<li>Thread 1 (T1) lấy các lock L1 và L2 (theo một thứ tự nào đó, tại một thời điểm nào đó trong quá trình thực thi)</li>
<li>Thread 2 (T2) cũng lấy L1 và L2</li>
<li>Thread 3 (T3) chỉ lấy L2</li>
<li>Thread 4 (T4) không lấy lock nào cả</li>
</ul>
<p>Chúng ta có thể biểu diễn yêu cầu lấy lock của các thread này dưới dạng bảng:</p>
<pre><code>...
</code></pre>
<p>Một <strong>scheduler</strong> (bộ lập lịch) thông minh có thể tính toán rằng miễn là T1 và T2 <strong>không chạy cùng lúc</strong>, deadlock sẽ không bao giờ xảy ra. Dưới đây là một lịch trình như vậy:</p>
<pre><code>...
</code></pre>
<p>Lưu ý rằng việc (T3 và T1) hoặc (T3 và T2) chạy đồng thời là <strong>chấp nhận được</strong>. Mặc dù T3 lấy lock L2, nó không thể gây ra deadlock khi chạy song song với các thread khác vì nó chỉ lấy <strong>một lock</strong>.</p>
<p>Hãy xem thêm một ví dụ nữa. Trong ví dụ này, có nhiều sự tranh chấp hơn đối với cùng một tài nguyên (vẫn là các lock L1 và L2), như được chỉ ra trong bảng tranh chấp (contention table) sau:</p>
<pre><code>...
</code></pre>
<blockquote>
<p><strong>TIP: ĐỪNG LÚC NÀO CŨNG CỐ LÀM HOÀN HẢO (ĐỊNH LUẬT CỦA TOM WEST)</strong><br />
Tom West, nổi tiếng với vai trò là nhân vật chính trong cuốn sách kinh điển về ngành công nghiệp máy tính <em>Soul of a New Machine</em> [K81], đã từng nói một câu nổi tiếng:<br />
“Not everything worth doing is worth doing well” (Không phải mọi việc đáng làm đều đáng để làm thật hoàn hảo), đây là một châm ngôn kỹ thuật tuyệt vời.<br />
Nếu một sự cố xấu chỉ xảy ra rất hiếm hoi, chắc chắn bạn không nên bỏ ra quá nhiều công sức để ngăn chặn nó, đặc biệt nếu chi phí khi sự cố đó xảy ra là nhỏ. Ngược lại, nếu bạn đang chế tạo một tàu con thoi, và chi phí của việc xảy ra sự cố là… tàu con thoi phát nổ, thì có lẽ bạn nên bỏ qua lời khuyên này.<br />
Một số độc giả phản đối: “Nghe như ông đang khuyên chọn sự tầm thường làm giải pháp!” Có thể họ đúng, rằng chúng ta nên cẩn trọng với lời khuyên như thế này. Tuy nhiên, kinh nghiệm cho chúng tôi thấy rằng trong thế giới kỹ thuật, với những hạn chót gấp gáp và các yếu tố thực tế khác, bạn sẽ luôn phải quyết định phần nào của hệ thống cần được xây dựng thật tốt và phần nào có thể để lại cho một ngày khác. Phần khó nhất là biết khi nào nên làm điều gì — một chút trực giác chỉ có được qua kinh nghiệm và sự tận tâm với công việc.</p>
</blockquote>
<p>Cụ thể, các <strong>thread</strong> (luồng) T1, T2 và T3 đều cần lấy cả hai <strong>lock</strong> L1 và L2 tại một thời điểm nào đó trong quá trình thực thi. Dưới đây là một lịch trình khả dĩ đảm bảo rằng deadlock (bế tắc) sẽ không bao giờ xảy ra:</p>
<pre><code>...
</code></pre>
<p>Như bạn có thể thấy, <strong>static scheduling</strong> (lập lịch tĩnh) dẫn đến một cách tiếp cận bảo thủ, trong đó T1, T2 và T3 đều chạy trên cùng một bộ xử lý, và do đó tổng thời gian hoàn thành công việc bị kéo dài đáng kể. Mặc dù có thể chạy các tác vụ này song song, nhưng nỗi lo về deadlock ngăn chúng ta làm vậy, và cái giá phải trả là hiệu năng.</p>
<p>Một ví dụ nổi tiếng về cách tiếp cận như thế này là <strong>Dijkstra’s Banker’s Algorithm</strong> [D64], và nhiều phương pháp tương tự đã được mô tả trong tài liệu nghiên cứu. Không may, chúng chỉ hữu ích trong những môi trường rất hạn chế, ví dụ như trong một <strong>embedded system</strong> (hệ thống nhúng) nơi ta có đầy đủ thông tin về toàn bộ tập hợp các tác vụ cần chạy và các lock mà chúng cần. Hơn nữa, các phương pháp này có thể hạn chế concurrency (tính đồng thời), như chúng ta đã thấy trong ví dụ thứ hai ở trên. Do đó, tránh deadlock thông qua scheduling không phải là một giải pháp tổng quát được sử dụng rộng rãi.</p>
<h3 id="detect-and-recover-phát-hiện-và-phục-hồi"><a class="header" href="#detect-and-recover-phát-hiện-và-phục-hồi">Detect and Recover (Phát hiện và Phục hồi)</a></h3>
<p>Một chiến lược tổng quát cuối cùng là cho phép deadlock thỉnh thoảng xảy ra, và sau đó thực hiện một hành động nào đó khi deadlock được phát hiện. Ví dụ, nếu một hệ điều hành (OS) bị treo một lần mỗi năm, bạn chỉ cần khởi động lại và tiếp tục làm việc (vui vẻ hoặc cau có). Nếu deadlock hiếm khi xảy ra, thì “giải pháp không giải pháp” này thực sự khá thực dụng.</p>
<p>Nhiều hệ quản trị cơ sở dữ liệu áp dụng kỹ thuật phát hiện và phục hồi deadlock. Một <strong>deadlock detector</strong> (bộ phát hiện deadlock) chạy định kỳ, xây dựng một <strong>resource graph</strong> (đồ thị tài nguyên) và kiểm tra xem có chu trình (cycle) nào không. Trong trường hợp phát hiện chu trình (deadlock), hệ thống cần được khởi động lại. Nếu trước đó cần sửa chữa phức tạp hơn đối với cấu trúc dữ liệu, có thể cần sự can thiệp của con người để hỗ trợ quá trình này.</p>
<p>Thông tin chi tiết hơn về concurrency (tính đồng thời) trong cơ sở dữ liệu, deadlock và các vấn đề liên quan có thể tìm thấy ở các tài liệu khác [B+87, K87]. Hãy đọc các tài liệu này, hoặc tốt hơn, tham gia một khóa học về cơ sở dữ liệu để tìm hiểu sâu hơn về chủ đề phong phú và thú vị này.</p>
<h2 id="324-tóm-tắt"><a class="header" href="#324-tóm-tắt">32.4 Tóm tắt</a></h2>
<p>Trong chương này, chúng ta đã nghiên cứu các loại lỗi (bug) xảy ra trong các chương trình đồng thời. Loại đầu tiên, <strong>non-deadlock bugs</strong> (lỗi không phải bế tắc), xuất hiện đáng ngạc nhiên là khá phổ biến, nhưng thường dễ sửa hơn. Chúng bao gồm:</p>
<ul>
<li><strong>Atomicity violations</strong> (vi phạm tính nguyên tử): một chuỗi lệnh lẽ ra phải được thực thi cùng nhau nhưng lại không được.</li>
<li><strong>Order violations</strong> (vi phạm thứ tự): thứ tự cần thiết giữa hai thread không được đảm bảo.</li>
</ul>
<p>Chúng ta cũng đã thảo luận ngắn gọn về <strong>deadlock</strong>: tại sao nó xảy ra và có thể làm gì để xử lý. Vấn đề này cổ xưa như chính khái niệm concurrency, và đã có hàng trăm bài báo được viết về chủ đề này. Giải pháp tốt nhất trong thực tế là cẩn trọng, xây dựng một <strong>lock acquisition order</strong> (thứ tự lấy lock) hợp lý, và do đó ngăn deadlock xảy ra ngay từ đầu. Các phương pháp <strong>wait-free</strong> (không chờ) cũng đầy hứa hẹn, vì một số cấu trúc dữ liệu wait-free hiện đã xuất hiện trong các thư viện và hệ thống quan trọng được sử dụng rộng rãi, bao gồm cả Linux. Tuy nhiên, sự thiếu tính tổng quát và độ phức tạp khi phát triển một cấu trúc dữ liệu wait-free mới có thể sẽ hạn chế tính hữu dụng chung của phương pháp này.<br />
Có lẽ giải pháp tốt nhất là phát triển các <strong>mô hình lập trình đồng thời</strong> mới: trong các hệ thống như <strong>MapReduce</strong> (từ Google) [GD02], lập trình viên có thể mô tả một số loại tính toán song song mà không cần bất kỳ lock nào. Lock vốn dĩ đã có nhiều vấn đề; có lẽ chúng ta nên tránh sử dụng chúng trừ khi thực sự cần thiết.</p>
<p>Bạn có muốn mình tiếp tục dịch <strong>các phần ví dụ minh họa về Banker’s Algorithm và resource graph</strong> để chương này hoàn thiện hơn không? Đây là phần rất thú vị để hiểu rõ hơn về tránh và phát hiện deadlock.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-lập-trình-đồng-thời-dựa-trên-sự-kiện-nâng-cao"><a class="header" href="#33-lập-trình-đồng-thời-dựa-trên-sự-kiện-nâng-cao">33. Lập trình đồng thời dựa trên sự kiện (Nâng cao)</a></h1>
<p>Cho đến nay, chúng ta đã viết về concurrency (tính đồng thời) như thể cách duy nhất để xây dựng các ứng dụng đồng thời là sử dụng threads (luồng). Giống như nhiều điều khác trong cuộc sống, điều này không hoàn toàn đúng. Cụ thể, một phong cách lập trình đồng thời khác thường được sử dụng trong cả các ứng dụng dựa trên GUI (giao diện đồ họa người dùng)^[1] [O96] cũng như một số loại internet servers (máy chủ Internet) [PDZ99]. Phong cách này, được gọi là <em>event-based concurrency</em> (đồng thời dựa trên sự kiện), đã trở nên phổ biến trong một số hệ thống hiện đại, bao gồm các framework phía server như <strong>node.js</strong> [N13], nhưng nguồn gốc của nó bắt đầu từ các hệ thống C/UNIX mà chúng ta sẽ thảo luận bên dưới.</p>
<p>Vấn đề mà <em>event-based concurrency</em> giải quyết là hai mặt. Thứ nhất, việc quản lý concurrency một cách chính xác trong các ứng dụng multi-threaded (đa luồng) có thể rất thách thức; như chúng ta đã thảo luận, việc thiếu locks (khóa), deadlock (bế tắc) và các vấn đề nghiêm trọng khác có thể phát sinh. Thứ hai, trong một ứng dụng multi-threaded, lập trình viên hầu như không có hoặc hoàn toàn không có quyền kiểm soát việc <em>scheduling</em> (lập lịch) tại một thời điểm nhất định; thay vào đó, lập trình viên chỉ đơn giản tạo ra các threads và hy vọng rằng hệ điều hành (OS) bên dưới sẽ lập lịch chúng một cách hợp lý trên các CPU khả dụng. Do khó khăn trong việc xây dựng một <em>general-purpose scheduler</em> (bộ lập lịch đa dụng) hoạt động tốt trong mọi trường hợp và với mọi loại tải công việc, đôi khi OS sẽ lập lịch công việc theo cách kém tối ưu. Và vì thế, chúng ta có...</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ XÂY DỰNG MÁY CHỦ ĐỒNG THỜI MÀ KHÔNG CẦN THREADS</strong><br />
Làm thế nào chúng ta có thể xây dựng một <em>concurrent server</em> (máy chủ đồng thời) mà không sử dụng threads, từ đó giữ quyền kiểm soát concurrency cũng như tránh một số vấn đề thường gặp trong các ứng dụng multi-threaded?</p>
</blockquote>
<h2 id="331-Ý-tưởng-cơ-bản-event-loop"><a class="header" href="#331-Ý-tưởng-cơ-bản-event-loop">33.1 Ý tưởng cơ bản: Event Loop</a></h2>
<p>Cách tiếp cận cơ bản mà chúng ta sẽ sử dụng, như đã nêu ở trên, được gọi là <em>event-based concurrency</em>. Cách tiếp cận này khá đơn giản: bạn chỉ cần chờ một điều gì đó (tức là một “event” – sự kiện) xảy ra; khi nó xảy ra, bạn kiểm tra loại sự kiện đó là gì và thực hiện một lượng nhỏ công việc cần thiết (có thể bao gồm việc gửi yêu cầu I/O, hoặc <em>scheduling</em> các sự kiện khác để xử lý trong tương lai, v.v.). Và hết!</p>
<p>Trước khi đi sâu vào chi tiết, hãy cùng xem một <em>event-based server</em> (máy chủ dựa trên sự kiện) điển hình trông như thế nào. Các ứng dụng như vậy được xây dựng xoay quanh một cấu trúc đơn giản gọi là <em>event loop</em> (vòng lặp sự kiện). Mã giả (pseudocode) cho một event loop như sau:</p>
<pre><code class="language-c">while (1) {
    events = getEvents();
    for (e in events)
        processEvent(e);
}
</code></pre>
<p>Thực sự đơn giản như vậy. Vòng lặp chính chỉ chờ một việc gì đó để làm (bằng cách gọi <code>getEvents()</code> trong đoạn code trên) và sau đó, với mỗi sự kiện được trả về, xử lý chúng lần lượt từng cái một; đoạn code xử lý mỗi sự kiện được gọi là <em>event handler</em> (trình xử lý sự kiện). Điều quan trọng là, khi một handler xử lý một sự kiện, đó là hoạt động duy nhất đang diễn ra trong hệ thống; do đó, việc quyết định sự kiện nào sẽ được xử lý tiếp theo tương đương với <em>scheduling</em>. Quyền kiểm soát tường minh đối với <em>scheduling</em> này là một trong những ưu điểm cơ bản của phương pháp <em>event-based</em>.</p>
<p>Tuy nhiên, phần thảo luận này để lại cho chúng ta một câu hỏi lớn hơn: chính xác thì một <em>event-based server</em> xác định các sự kiện đang diễn ra như thế nào, đặc biệt là đối với network I/O (I/O mạng) và disk I/O (I/O đĩa)? Cụ thể, làm thế nào một <em>event server</em> có thể biết rằng một thông điệp đã đến với nó?</p>
<p>^[1]: GUI (Graphical User Interface) – Giao diện đồ họa người dùng, cho phép người dùng tương tác với hệ thống thông qua các thành phần trực quan như cửa sổ, nút bấm, biểu tượng.</p>
<h2 id="332-một-api-quan-trọng-select-hoặc-poll"><a class="header" href="#332-một-api-quan-trọng-select-hoặc-poll">33.2 Một API quan trọng: <code>select()</code> (hoặc <code>poll()</code>)</a></h2>
<p>Với <em>event loop</em> (vòng lặp sự kiện) cơ bản đã được đề cập, bước tiếp theo chúng ta cần giải quyết là câu hỏi: làm thế nào để nhận các sự kiện? Trong hầu hết các hệ thống, một API cơ bản có sẵn thông qua <em>system call</em> (call hệ thống) <code>select()</code> hoặc <code>poll()</code>.</p>
<p>Những interface (giao diện lập trình) này cho phép một chương trình thực hiện một việc đơn giản: kiểm tra xem có I/O (nhập/xuất) đến nào cần được xử lý hay không. Ví dụ, hãy tưởng tượng một ứng dụng mạng (chẳng hạn như web server) muốn kiểm tra xem có gói tin mạng nào đã đến để xử lý hay chưa. Các <em>system call</em> này cho phép bạn làm chính xác điều đó.</p>
<p>Lấy <code>select()</code> làm ví dụ. Trang <em>manual</em> (trang hướng dẫn sử dụng) trên macOS mô tả API này như sau:</p>
<pre><code class="language-c">int select(int nfds,
           fd_set *restrict readfds,
           fd_set *restrict writefds,
           fd_set *restrict errorfds,
           struct timeval *restrict timeout);
</code></pre>
<blockquote>
<p><strong>ASIDE: BLOCKING VS. NON-BLOCKING INTERFACES</strong><br />
<em>Blocking</em> (hay <em>synchronous</em> – đồng bộ) interfaces thực hiện toàn bộ công việc của chúng trước khi trả quyền điều khiển về cho hàm gọi; <em>non-blocking</em> (hay <em>asynchronous</em> – bất đồng bộ) interfaces bắt đầu một công việc nhưng trả về ngay lập tức, cho phép phần công việc còn lại được thực hiện ở chế độ nền.<br />
Thủ phạm phổ biến nhất gây ra blocking là một dạng I/O nào đó. Ví dụ, nếu một call hàm cần đọc dữ liệu từ đĩa để hoàn tất, nó có thể bị block, chờ cho đến khi yêu cầu I/O gửi đến đĩa hoàn thành và trả dữ liệu về.<br />
<em>Non-blocking interfaces</em> có thể được sử dụng trong bất kỳ phong cách lập trình nào (ví dụ: với threads), nhưng là yếu tố thiết yếu trong phương pháp <em>event-based</em>, vì một call bị block sẽ làm dừng toàn bộ tiến trình xử lý.</p>
</blockquote>
<p>Mô tả thực tế từ <em>man page</em>: <code>select()</code> kiểm tra các tập hợp <em>I/O descriptor</em> (bộ mô tả I/O) có địa chỉ được truyền vào <code>readfds</code>, <code>writefds</code> và <code>errorfds</code> để xem liệu một số descriptor trong đó có sẵn sàng để đọc, sẵn sàng để ghi, hoặc đang có một điều kiện bất thường đang chờ xử lý hay không. <code>select()</code> sẽ kiểm tra các descriptor từ <code>0</code> đến <code>nfds-1</code> trong mỗi tập hợp. Khi trả về, <code>select()</code> thay thế các tập hợp descriptor đã cho bằng các tập hợp con chỉ bao gồm những descriptor sẵn sàng cho thao tác được yêu cầu. <code>select()</code> trả về tổng số descriptor sẵn sàng trong tất cả các tập hợp.</p>
<p>Một vài điểm cần lưu ý về <code>select()</code>:</p>
<ul>
<li>Thứ nhất, <code>select()</code> cho phép bạn kiểm tra xem descriptor có thể đọc được hay ghi được. Khả năng đọc cho phép server xác định rằng một gói tin mới đã đến và cần được xử lý, trong khi khả năng ghi cho phép server biết khi nào có thể gửi phản hồi (tức là hàng đợi gửi đi chưa đầy).</li>
<li>Thứ hai, lưu ý đối số <code>timeout</code>. Một cách sử dụng phổ biến là đặt <code>timeout</code> thành <code>NULL</code>, khiến <code>select()</code> block vô thời hạn cho đến khi một descriptor sẵn sàng. Tuy nhiên, các server mạnh mẽ hơn thường chỉ định một loại timeout nào đó; một kỹ thuật phổ biến là đặt timeout bằng 0, từ đó khiến call <code>select()</code> trả về ngay lập tức.</li>
</ul>
<p><em>System call</em> <code>poll()</code> khá giống với <code>select()</code>. Xem <em>man page</em> của nó hoặc tài liệu của Stevens và Rago [SR05] để biết chi tiết.</p>
<p>Dù sử dụng cách nào, các primitive (nguyên thủy) cơ bản này cung cấp cho chúng ta một cách để xây dựng <em>non-blocking event loop</em> (vòng lặp sự kiện không chặn), vòng lặp này chỉ đơn giản kiểm tra các gói tin đến, đọc từ các socket có chứa thông điệp, và phản hồi khi cần thiết.</p>
<h2 id="333-sử-dụng-select"><a class="header" href="#333-sử-dụng-select">33.3 Sử dụng <code>select()</code></a></h2>
<p>Để làm rõ hơn, hãy xem cách sử dụng <code>select()</code> để xác định những <em>network descriptor</em> (bộ mô tả mạng) nào có thông điệp đến. <strong>Hình 33.1</strong> dưới đây minh họa một ví dụ đơn giản.</p>
<p><img src="33/img/fig33_1.PNG" alt="Figure 33.1: Ví dụ đơn giản sử dụng select() để kiểm tra các network descriptor có dữ liệu đến" /></p>
<p><em>Hình 33.1: Mã nguồn đơn giản sử dụng <code>select()</code></em></p>
<p>Mã nguồn này thực tế khá dễ hiểu. Sau một số bước khởi tạo, server đi vào một vòng lặp vô hạn. Bên trong vòng lặp, nó sử dụng macro <code>FD_ZERO()</code> để xóa tập hợp <em>file descriptor</em> (bộ mô tả tệp) hiện tại, sau đó dùng <code>FD_SET()</code> để thêm tất cả các <em>file descriptor</em> từ <code>minFD</code> đến <code>maxFD</code> vào tập hợp. Tập hợp các descriptor này có thể đại diện, ví dụ, cho tất cả các <em>network socket</em> (socket mạng) mà server đang theo dõi. Cuối cùng, server gọi <code>select()</code> để kiểm tra kết nối nào có dữ liệu sẵn sàng. Sau đó, bằng cách sử dụng <code>FD_ISSET()</code> trong một vòng lặp, <em>event server</em> (máy chủ dựa trên sự kiện) có thể xác định descriptor nào đã sẵn sàng dữ liệu và xử lý dữ liệu đến.</p>
<p>Tất nhiên, một server thực tế sẽ phức tạp hơn nhiều, và cần thêm logic để xử lý việc gửi thông điệp, thực hiện <em>disk I/O</em> (I/O đĩa), và nhiều chi tiết khác. Để biết thêm thông tin, xem Stevens và Rago [SR05] để tìm hiểu về API, hoặc Pai et al. và Welsh et al. để có cái nhìn tổng quan về luồng xử lý của các <em>event-based server</em> [PDZ99, WCB01].</p>
<blockquote>
<p><strong>TIP: ĐỪNG ĐỂ BLOCK TRONG EVENT-BASED SERVER</strong><br />
<em>Event-based server</em> cho phép kiểm soát chi tiết việc <em>scheduling</em> (lập lịch) các tác vụ. Tuy nhiên, để duy trì khả năng kiểm soát này, tuyệt đối không được thực hiện bất kỳ call nào khiến tiến trình của hàm gọi bị block; vi phạm nguyên tắc này sẽ dẫn đến việc <em>event-based server</em> bị treo, khách hàng (client) bị gián đoạn, và khiến người khác nghi ngờ liệu bạn có thực sự đọc phần này của sách hay không.</p>
</blockquote>
<h2 id="334-tại-sao-đơn-giản-hơn-không-cần-locks"><a class="header" href="#334-tại-sao-đơn-giản-hơn-không-cần-locks">33.4 Tại sao đơn giản hơn? Không cần Locks</a></h2>
<p>Với một CPU đơn và một ứng dụng <em>event-based</em>, các vấn đề thường gặp trong lập trình đồng thời (concurrent programming) sẽ không còn. Cụ thể, vì chỉ có một sự kiện được xử lý tại một thời điểm, không cần phải <em>acquire</em> hoặc <em>release</em> locks (khóa); <em>event-based server</em> không thể bị gián đoạn bởi một thread khác vì nó hoàn toàn chạy ở chế độ <em>single-threaded</em> (đơn luồng). Do đó, các lỗi concurrency phổ biến trong chương trình đa luồng sẽ không xuất hiện trong phương pháp <em>event-based</em> cơ bản.</p>
<h2 id="335-một-vấn-đề-blocking-system-calls"><a class="header" href="#335-một-vấn-đề-blocking-system-calls">33.5 Một vấn đề: Blocking System Calls</a></h2>
<p>Cho đến giờ, lập trình <em>event-based</em> nghe có vẻ rất tuyệt, đúng không? Bạn lập trình một vòng lặp đơn giản và xử lý các sự kiện khi chúng xuất hiện. Bạn thậm chí không cần nghĩ đến việc dùng lock! Nhưng có một vấn đề: điều gì xảy ra nếu một sự kiện yêu cầu bạn thực hiện một <em>system call</em> (call hệ thống) có thể bị block?</p>
<p>Ví dụ, hãy tưởng tượng một yêu cầu từ client gửi đến server để đọc một tệp từ đĩa và trả nội dung về cho client (giống như một yêu cầu HTTP đơn giản). Để xử lý yêu cầu này, một <em>event handler</em> (trình xử lý sự kiện) cuối cùng sẽ phải gọi <em>system call</em> <code>open()</code> để mở tệp, sau đó là một loạt call <code>read()</code> để đọc tệp. Khi tệp đã được đọc vào bộ nhớ, server có thể bắt đầu gửi kết quả về cho client.</p>
<p>Cả <code>open()</code> và <code>read()</code> đều có thể gửi yêu cầu I/O đến hệ thống lưu trữ (nếu metadata hoặc dữ liệu cần thiết chưa có sẵn trong bộ nhớ), và do đó có thể mất nhiều thời gian để hoàn tất. Với một <em>thread-based server</em> (máy chủ dựa trên luồng), điều này không phải vấn đề: trong khi thread thực hiện yêu cầu I/O bị treo (chờ I/O hoàn tất), các thread khác vẫn có thể chạy, cho phép server tiếp tục xử lý. Thực tế, sự chồng lấp tự nhiên giữa I/O và tính toán khác chính là lý do khiến lập trình đa luồng trở nên tự nhiên và dễ hiểu.</p>
<p>Tuy nhiên, với phương pháp <em>event-based</em>, không có thread nào khác để chạy: chỉ có vòng lặp sự kiện chính. Điều này có nghĩa là nếu một <em>event handler</em> thực hiện một call bị block, toàn bộ server sẽ bị block cho đến khi call đó hoàn tất. Khi <em>event loop</em> bị block, hệ thống sẽ ngồi chờ, gây lãng phí tài nguyên nghiêm trọng. Vì vậy, chúng ta có một nguyên tắc bắt buộc trong hệ thống <em>event-based</em>: <strong>không được phép có call blocking</strong>.</p>
<h2 id="336-giải-pháp-asynchronous-io"><a class="header" href="#336-giải-pháp-asynchronous-io">33.6 Giải pháp: Asynchronous I/O</a></h2>
<p>Để vượt qua giới hạn này, nhiều hệ điều hành hiện đại đã giới thiệu các phương thức mới để gửi yêu cầu I/O đến hệ thống đĩa, được gọi chung là <em>asynchronous I/O</em> (I/O bất đồng bộ). Các interface này cho phép ứng dụng gửi yêu cầu I/O và trả quyền điều khiển ngay lập tức cho hàm gọi, trước khi I/O hoàn tất; các interface bổ sung cho phép ứng dụng xác định xem các I/O đã hoàn tất hay chưa.</p>
<p>Ví dụ, hãy xem interface được cung cấp trên macOS (các hệ thống khác có API tương tự). Các API này xoay quanh một cấu trúc cơ bản, <code>struct aiocb</code> hay còn gọi là <em>AIO control block</em> (khối điều khiển AIO). Phiên bản đơn giản hóa của cấu trúc này như sau (xem <em>man page</em> để biết thêm chi tiết):</p>
<pre><code class="language-c">struct aiocb {
    int            aio_fildes;    // File descriptor
    off_t          aio_offset;    // File offset
    volatile void  *aio_buf;      // Location of buffer
    size_t         aio_nbytes;    // Length of transfer
};
</code></pre>
<p>Để thực hiện một thao tác đọc bất đồng bộ từ tệp, ứng dụng cần điền vào cấu trúc này các thông tin liên quan: <em>file descriptor</em> của tệp cần đọc (<code>aio_fildes</code>), vị trí offset trong tệp (<code>aio_offset</code>), độ dài yêu cầu (<code>aio_nbytes</code>), và cuối cùng là vị trí bộ nhớ đích để sao chép dữ liệu đọc được (<code>aio_buf</code>).</p>
<p>Sau khi cấu trúc này được điền đầy đủ, ứng dụng phải gọi API đọc bất đồng bộ; trên macOS, API này đơn giản là:</p>
<pre><code class="language-c">int aio_read(struct aiocb *aiocbp);
</code></pre>
<p>Lời gọi này sẽ cố gắng gửi yêu cầu I/O; nếu thành công, nó trả về ngay lập tức và ứng dụng (tức <em>event-based server</em>) có thể tiếp tục công việc khác.</p>
<p>Tuy nhiên, vẫn còn một phần quan trọng cần giải quyết: làm thế nào để biết khi nào một I/O đã hoàn tất, và do đó bộ đệm (<code>aio_buf</code>) đã chứa dữ liệu được yêu cầu?</p>
<p>Cần thêm một API nữa. Trên macOS, API này được gọi (có phần gây nhầm lẫn) là <code>aio_error()</code>:</p>
<pre><code class="language-c">int aio_error(const struct aiocb *aiocbp);
</code></pre>
<p><em>System call</em> này kiểm tra xem yêu cầu được tham chiếu bởi <code>aiocbp</code> đã hoàn tất hay chưa. Nếu đã hoàn tất, hàm trả về thành công (giá trị 0); nếu chưa, nó trả về <code>EINPROGRESS</code>. Do đó, với mỗi I/O bất đồng bộ đang chờ, ứng dụng có thể định kỳ gọi <code>aio_error()</code> để kiểm tra trạng thái.</p>
<p>Một điều bạn có thể nhận thấy là việc kiểm tra I/O đã hoàn tất khá phiền toái; nếu một chương trình có hàng chục hoặc hàng trăm I/O đang chờ tại một thời điểm, liệu nó nên liên tục kiểm tra từng cái, hay chờ một lúc rồi mới kiểm tra, hay…?</p>
<p>Để khắc phục vấn đề này, một số hệ thống cung cấp phương pháp dựa trên <em>interrupt</em> (ngắt). Phương pháp này sử dụng tín hiệu UNIX để thông báo cho ứng dụng khi một I/O bất đồng bộ hoàn tất, loại bỏ nhu cầu phải liên tục hỏi hệ thống. Vấn đề <em>polling</em> so với <em>interrupt</em> này cũng xuất hiện ở các thiết bị phần cứng, như bạn sẽ thấy (hoặc đã thấy) trong chương về thiết bị I/O.</p>
<p>Trong các hệ thống không hỗ trợ <em>asynchronous I/O</em>, phương pháp <em>event-based</em> thuần túy không thể triển khai được. Tuy nhiên, các nhà nghiên cứu đã nghĩ ra những phương pháp thay thế hoạt động khá hiệu quả. Ví dụ, Pai et al. [PDZ99] mô tả một phương pháp lai, trong đó sự kiện được dùng để xử lý gói tin mạng, và một <em>thread pool</em> (bể luồng) được dùng để quản lý các I/O đang chờ. Bạn có thể đọc bài báo của họ để biết chi tiết.</p>
<h2 id="337-một-vấn-đề-khác-quản-lý-trạng-thái-state-management"><a class="header" href="#337-một-vấn-đề-khác-quản-lý-trạng-thái-state-management">33.7 Một vấn đề khác: Quản lý trạng thái (State Management)</a></h2>
<p>Một vấn đề khác với phương pháp <em>event-based</em> (dựa trên sự kiện) là mã nguồn kiểu này thường phức tạp hơn để viết so với mã nguồn <em>thread-based</em> (dựa trên luồng) truyền thống. Lý do như sau: khi một <em>event handler</em> (trình xử lý sự kiện) thực hiện một thao tác <em>asynchronous I/O</em> (I/O bất đồng bộ), nó phải đóng gói một số trạng thái của chương trình để <em>event handler</em> tiếp theo có thể sử dụng khi thao tác I/O đó cuối cùng hoàn tất; công việc bổ sung này không cần thiết trong các chương trình <em>thread-based</em>, vì trạng thái mà chương trình cần đã nằm trên <em>stack</em> (ngăn xếp) của thread. Adya và cộng sự gọi công việc này là <em>manual stack management</em> (quản lý ngăn xếp thủ công), và nó là một phần cơ bản của lập trình <em>event-based</em> [A+02].</p>
<p>Để làm rõ hơn, hãy xem một ví dụ đơn giản trong đó một <em>thread-based server</em> (máy chủ dựa trên luồng) cần đọc từ một <em>file descriptor</em> (<code>fd</code>) và, khi hoàn tất, ghi dữ liệu đã đọc từ tệp đó vào một <em>network socket descriptor</em> (<code>sd</code>). Mã nguồn (bỏ qua phần kiểm tra lỗi) như sau:</p>
<pre><code class="language-c">int rc = read(fd, buffer, size);
rc = write(sd, buffer, size);
</code></pre>
<p>Như bạn thấy, trong một chương trình <em>multi-threaded</em> (đa luồng), việc thực hiện công việc kiểu này là rất đơn giản; khi <code>read()</code> trả về, mã nguồn ngay lập tức biết socket nào cần ghi dữ liệu vào vì thông tin đó đã có sẵn trên <em>stack</em> của thread (trong biến <code>sd</code>).</p>
<p>Trong một hệ thống <em>event-based</em>, mọi thứ không đơn giản như vậy. Để thực hiện cùng một tác vụ, trước tiên chúng ta sẽ thực hiện thao tác đọc bất đồng bộ, sử dụng các call AIO đã mô tả ở trên. Giả sử sau đó chúng ta định kỳ kiểm tra việc đọc đã hoàn tất hay chưa bằng call <code>aio_error()</code>; khi call này thông báo rằng việc đọc đã hoàn tất, làm thế nào để <em>event-based server</em> biết cần phải làm gì tiếp theo?</p>
<blockquote>
<p><strong>ASIDE: UNIX SIGNALS</strong><br />
Một hạ tầng lớn và thú vị được gọi là <em>signals</em> (tín hiệu) tồn tại trong tất cả các biến thể UNIX hiện đại. Ở mức đơn giản nhất, <em>signal</em> cung cấp một cách để giao tiếp với một <em>process</em> (tiến trình). Cụ thể, một <em>signal</em> có thể được gửi đến một ứng dụng; khi đó ứng dụng sẽ tạm dừng những gì nó đang làm để chạy một <em>signal handler</em> (trình xử lý tín hiệu), tức là một đoạn code trong ứng dụng để xử lý tín hiệu đó. Khi hoàn tất, tiến trình sẽ tiếp tục hành vi trước đó.<br />
Mỗi <em>signal</em> có một tên, chẳng hạn như <code>HUP</code> (<em>hang up</em>), <code>INT</code> (<em>interrupt</em>), <code>SEGV</code> (<em>segmentation violation</em>), v.v.; xem <em>man page</em> để biết chi tiết. Thú vị là đôi khi chính <em>kernel</em> (nhân hệ điều hành) sẽ gửi tín hiệu. Ví dụ, khi chương trình của bạn gặp lỗi <em>segmentation violation</em>, OS sẽ gửi cho nó một <code>SIGSEGV</code> (thêm tiền tố <code>SIG</code> vào tên tín hiệu là cách đặt tên phổ biến); nếu chương trình của bạn được cấu hình để bắt tín hiệu đó, bạn có thể chạy một đoạn code để phản hồi hành vi lỗi này (hữu ích cho việc gỡ lỗi). Khi một tín hiệu được gửi đến một tiến trình không được cấu hình để xử lý tín hiệu đó, hành vi mặc định sẽ được thực thi; với <code>SEGV</code>, tiến trình sẽ bị kết thúc.<br />
Dưới đây là một chương trình đơn giản chạy vòng lặp vô hạn, nhưng trước đó đã thiết lập một <em>signal handler</em> để bắt <code>SIGHUP</code>:</p>
<pre><code class="language-c">void handle(int arg) {
    printf(&quot;stop wakin’ me up...\n&quot;);
}

int main(int argc, char *argv[]) {
    signal(SIGHUP, handle);
    while (1)
        ; // doin’ nothin’ except catchin’ some sigs
    return 0;
}
</code></pre>
<p>Bạn có thể gửi tín hiệu đến chương trình này bằng công cụ dòng lệnh <code>kill</code> (đúng, đây là một tên khá “mạnh bạo”). Việc này sẽ ngắt vòng lặp <code>while</code> chính trong chương trình và chạy đoạn code xử lý <code>handle()</code>:</p>
<pre><code class="language-bash">prompt&gt; ./main &amp;
36705
prompt&gt; kill -HUP 36705
stop wakin’ me up...
prompt&gt; kill -HUP 36705
stop wakin’ me up...
</code></pre>
<p>Còn rất nhiều điều để tìm hiểu về <em>signals</em>, đến mức một chương riêng, chứ chưa nói một trang, cũng chưa đủ. Như thường lệ, có một nguồn tài liệu tuyệt vời: Stevens và Rago [SR05]. Hãy đọc thêm nếu bạn quan tâm.</p>
</blockquote>
<p>Giải pháp, như Adya và cộng sự [A+02] mô tả, là sử dụng một cấu trúc ngôn ngữ lập trình cũ được gọi là <em>continuation</em> [FHK84]. Nghe có vẻ phức tạp, nhưng ý tưởng khá đơn giản: về cơ bản, ghi lại thông tin cần thiết để hoàn tất xử lý sự kiện này vào một cấu trúc dữ liệu; khi sự kiện xảy ra (tức là khi <em>disk I/O</em> hoàn tất), tra cứu thông tin cần thiết và xử lý sự kiện.</p>
<p>Trong trường hợp cụ thể này, giải pháp sẽ là ghi lại <em>socket descriptor</em> (<code>sd</code>) vào một cấu trúc dữ liệu nào đó (ví dụ: <em>hash table</em>), được đánh chỉ mục bởi <em>file descriptor</em> (<code>fd</code>). Khi <em>disk I/O</em> hoàn tất, <em>event handler</em> sẽ sử dụng <em>file descriptor</em> để tra cứu <em>continuation</em>, từ đó trả về giá trị của <em>socket descriptor</em> cho hàm gọi. Tại thời điểm này (cuối cùng), server có thể thực hiện bước cuối cùng là ghi dữ liệu vào socket.</p>
<h2 id="338-Điều-gì-vẫn-còn-khó-khăn-với-events"><a class="header" href="#338-Điều-gì-vẫn-còn-khó-khăn-với-events">33.8 Điều gì vẫn còn khó khăn với Events</a></h2>
<p>Có một số khó khăn khác với phương pháp <em>event-based</em> mà chúng ta cần đề cập. Ví dụ, khi hệ thống chuyển từ CPU đơn sang nhiều CPU, một phần sự đơn giản của phương pháp <em>event-based</em> biến mất. Cụ thể, để tận dụng nhiều hơn một CPU, <em>event server</em> phải chạy nhiều <em>event handler</em> song song; khi làm vậy, các vấn đề đồng bộ hóa thông thường (ví dụ: <em>critical section</em> – đoạn tới hạn) sẽ xuất hiện, và các giải pháp quen thuộc (ví dụ: <em>locks</em>) phải được áp dụng. Do đó, trên các hệ thống đa lõi hiện đại, việc xử lý sự kiện đơn giản mà không cần <em>lock</em> là không thể.</p>
<p>Một vấn đề khác với phương pháp <em>event-based</em> là nó không tích hợp tốt với một số loại hoạt động của hệ thống, chẳng hạn như <em>paging</em> (phân trang bộ nhớ). Ví dụ, nếu một <em>event handler</em> gặp <em>page fault</em> (lỗi trang), nó sẽ bị block, và do đó server sẽ không thể tiếp tục cho đến khi lỗi trang được xử lý xong. Mặc dù server đã được thiết kế để tránh <em>blocking</em> tường minh, nhưng loại <em>blocking</em> ngầm này do <em>page fault</em> gây ra rất khó tránh và có thể dẫn đến các vấn đề hiệu năng nghiêm trọng khi xảy ra thường xuyên.</p>
<p>Vấn đề thứ ba là mã nguồn <em>event-based</em> có thể khó bảo trì theo thời gian, vì ngữ nghĩa chính xác của các hàm có thể thay đổi [A+02]. Ví dụ, nếu một hàm thay đổi từ <em>non-blocking</em> sang <em>blocking</em>, <em>event handler</em> gọi hàm đó cũng phải thay đổi để thích ứng với bản chất mới của nó, bằng cách tách mã thành hai phần. Vì <em>blocking</em> gây hậu quả nghiêm trọng cho <em>event-based server</em>, lập trình viên phải luôn cảnh giác với những thay đổi về ngữ nghĩa của API mà mỗi sự kiện sử dụng.</p>
<p>Cuối cùng, mặc dù <em>asynchronous disk I/O</em> hiện đã khả dụng trên hầu hết các nền tảng, nhưng phải mất một thời gian dài mới đạt được [PDZ99], và nó chưa bao giờ tích hợp hoàn toàn với <em>asynchronous network I/O</em> theo cách đơn giản và thống nhất như mong muốn. Ví dụ, mặc dù lý tưởng là chỉ cần sử dụng interface <code>select()</code> để quản lý tất cả các I/O đang chờ, nhưng trên thực tế thường phải kết hợp <code>select()</code> cho mạng và các call AIO cho <em>disk I/O</em>.</p>
<h2 id="339-tóm-tắt"><a class="header" href="#339-tóm-tắt">33.9 Tóm tắt</a></h2>
<p>Chúng ta đã trình bày một phần giới thiệu cơ bản về một phong cách <em>concurrency</em> (lập trình đồng thời) khác dựa trên sự kiện. <em>Event-based server</em> trao quyền kiểm soát <em>scheduling</em> (lập lịch) cho chính ứng dụng, nhưng phải trả giá bằng sự phức tạp và khó khăn khi tích hợp với các khía cạnh khác của hệ thống hiện đại (ví dụ: <em>paging</em>). Do những thách thức này, chưa có một phương pháp nào nổi lên như là tối ưu nhất; vì vậy, cả <em>threads</em> (luồng) và <em>events</em> (sự kiện) nhiều khả năng sẽ tiếp tục tồn tại song song như hai cách tiếp cận khác nhau cho cùng một vấn đề <em>concurrency</em> (lập trình đồng thời) trong nhiều năm tới.</p>
<p>Hãy đọc một số bài báo nghiên cứu (ví dụ: [A+02, PDZ99, vB+03, WCB01]) hoặc, tốt hơn nữa, hãy tự viết một số mã nguồn <em>event-based</em> để tìm hiểu sâu hơn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="36-thiết-bị-io-io-devices"><a class="header" href="#36-thiết-bị-io-io-devices">36 Thiết bị I/O (I/O Devices)</a></h1>
<p>Trước khi đi sâu vào nội dung chính của phần này (về <strong>persistence</strong> – tính bền vững dữ liệu), trước hết chúng ta sẽ giới thiệu khái niệm <strong>thiết bị nhập/xuất</strong> (input/output – I/O device) và xem hệ điều hành (operating system) có thể tương tác với thực thể này như thế nào.<br />
I/O tất nhiên là cực kỳ quan trọng đối với hệ thống máy tính; hãy tưởng tượng một chương trình không có bất kỳ <strong>input</strong> nào (nó sẽ cho ra cùng một kết quả mỗi lần chạy); giờ hãy tưởng tượng một chương trình không có <strong>output</strong> (vậy mục đích chạy nó là gì?). Rõ ràng, để hệ thống máy tính trở nên hữu ích, cả input và output đều là cần thiết. Và do đó, chúng ta có vấn đề tổng quát sau:</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ TÍCH HỢP I/O VÀO HỆ THỐNG</strong><br />
Làm thế nào để tích hợp I/O vào hệ thống? Các cơ chế tổng quát là gì? Làm thế nào để chúng ta khiến chúng hoạt động hiệu quả?</p>
</blockquote>
<h2 id="361-kiến-trúc-hệ-thống-system-architecture"><a class="header" href="#361-kiến-trúc-hệ-thống-system-architecture">36.1 Kiến trúc hệ thống (System Architecture)</a></h2>
<p>Để bắt đầu, hãy xem một sơ đồ “kinh điển” của một hệ thống điển hình (<strong>Hình 36.1</strong>). Sơ đồ cho thấy một CPU đơn được kết nối với bộ nhớ chính (main memory) của hệ thống thông qua một loại <strong>memory bus</strong> hoặc <strong>interconnect</strong> nào đó. Một số thiết bị được kết nối với hệ thống thông qua một <strong>I/O bus</strong> tổng quát, mà trong nhiều hệ thống hiện đại sẽ là <strong>PCI</strong> (hoặc một trong nhiều biến thể của nó); card đồ họa và một số thiết bị I/O hiệu năng cao khác thường nằm ở đây. Cuối cùng, ở mức thấp hơn là một hoặc nhiều <strong>peripheral bus</strong> (bus ngoại vi), chẳng hạn như <strong>SCSI</strong>, <strong>SATA</strong> hoặc <strong>USB</strong>. Các bus này kết nối các thiết bị chậm với hệ thống, bao gồm đĩa cứng, chuột và bàn phím.</p>
<p><img src="36/img/fig36_1.PNG" alt="" /></p>
<p><strong>Hình 36.1: Kiến trúc hệ thống nguyên mẫu (Prototypical System Architecture)</strong></p>
<p>Một câu hỏi đặt ra: tại sao chúng ta cần một cấu trúc phân cấp như vậy? Nói ngắn gọn: <strong>vật lý</strong> và <strong>chi phí</strong>. Bus càng nhanh thì chiều dài của nó càng phải ngắn; do đó, một <strong>memory bus</strong> hiệu năng cao không có nhiều chỗ để cắm thêm thiết bị. Ngoài ra, việc thiết kế một bus hiệu năng cao là rất tốn kém. Vì vậy, các nhà thiết kế hệ thống đã áp dụng cách tiếp cận phân cấp này, trong đó các thành phần đòi hỏi hiệu năng cao (như card đồ họa) được đặt gần CPU hơn. Các thành phần hiệu năng thấp hơn được đặt xa hơn. Lợi ích của việc đặt đĩa và các thiết bị chậm khác trên <strong>peripheral bus</strong> là rất nhiều; đặc biệt, bạn có thể kết nối số lượng lớn thiết bị vào đó.</p>
<p>Tất nhiên, các hệ thống hiện đại ngày càng sử dụng <strong>chipset</strong> chuyên dụng và các kết nối <strong>point-to-point</strong> nhanh hơn để cải thiện hiệu năng. <strong>Hình 36.2</strong> cho thấy sơ đồ gần đúng của <strong>Intel Z270 Chipset</strong> [H17]. Ở phía trên, CPU kết nối trực tiếp nhất với hệ thống bộ nhớ, nhưng cũng có một kết nối hiệu năng cao tới card đồ họa (và do đó là màn hình) để hỗ trợ chơi game (ồ, thật khủng khiếp!) và các ứng dụng đòi hỏi đồ họa cao.</p>
<p><img src="36/img/fig36_2.PNG" alt="" /></p>
<p><strong>Hình 36.2: Kiến trúc hệ thống hiện đại (Modern System Architecture)</strong></p>
<p>CPU kết nối với một chip I/O thông qua <strong>DMI</strong> (Direct Media Interface) độc quyền của Intel, và phần còn lại của các thiết bị kết nối với chip này thông qua nhiều loại <strong>interconnect</strong> khác nhau. Ở bên phải, một hoặc nhiều ổ cứng kết nối với hệ thống qua giao diện <strong>eSATA</strong>; <strong>ATA</strong> (AT Attachment – kết nối cho máy IBM PC AT), sau đó là <strong>SATA</strong> (Serial ATA), và hiện nay là <strong>eSATA</strong> (external SATA) thể hiện sự tiến hóa của các giao diện lưu trữ trong nhiều thập kỷ qua, với mỗi bước tiến đều tăng hiệu năng để bắt kịp với các thiết bị lưu trữ hiện đại. Bên dưới chip I/O là một số kết nối <strong>USB</strong> (Universal Serial Bus), trong sơ đồ này dùng để kết nối bàn phím và chuột với máy tính. Trong nhiều hệ thống hiện đại, USB được dùng cho các thiết bị hiệu năng thấp như vậy. Cuối cùng, ở bên trái, các thiết bị hiệu năng cao khác có thể được kết nối với hệ thống qua <strong>PCIe</strong> (Peripheral Component Interconnect Express). Trong sơ đồ này, một <strong>network interface</strong> (giao diện mạng) được kết nối tại đây; các thiết bị lưu trữ hiệu năng cao hơn (như thiết bị lưu trữ bền vững NVMe) cũng thường được kết nối tại đây.</p>
<h2 id="362-một-thiết-bị-chuẩn-a-canonical-device"><a class="header" href="#362-một-thiết-bị-chuẩn-a-canonical-device">36.2 Một thiết bị chuẩn (A Canonical Device)</a></h2>
<p>Bây giờ, hãy xem xét một <strong>thiết bị chuẩn</strong> (không phải thiết bị thực), và sử dụng nó để tìm hiểu một số cơ chế cần thiết nhằm làm cho việc tương tác với thiết bị trở nên hiệu quả. Từ <strong>Hình 36.3</strong>, ta thấy một thiết bị có hai thành phần quan trọng:</p>
<ol>
<li><strong>Giao diện phần cứng</strong> (hardware interface) mà nó cung cấp cho phần còn lại của hệ thống. Giống như một phần mềm, phần cứng cũng phải cung cấp một loại giao diện nào đó cho phép phần mềm hệ thống điều khiển hoạt động của nó. Do đó, tất cả các thiết bị đều có một giao diện và giao thức (protocol) được xác định để tương tác điển hình.</li>
</ol>
<p><img src="36/img/fig36_3.PNG" alt="" /></p>
<p><strong>Hình 36.3: Một thiết bị chuẩn (A Canonical Device)</strong></p>
<ol start="2">
<li><strong>Cấu trúc bên trong</strong> (internal structure) của thiết bị. Phần này phụ thuộc vào cách triển khai và chịu trách nhiệm hiện thực hóa <strong>abstraction</strong> (sự trừu tượng hóa) mà thiết bị cung cấp cho hệ thống. Các thiết bị rất đơn giản sẽ chỉ có một hoặc vài chip phần cứng để thực hiện chức năng của chúng; các thiết bị phức tạp hơn sẽ bao gồm một CPU đơn giản, một số bộ nhớ đa dụng (general purpose memory), và các chip chuyên biệt khác để hoàn thành công việc. Ví dụ, các bộ điều khiển RAID hiện đại có thể bao gồm hàng trăm nghìn dòng <strong>firmware</strong> (phần mềm nằm trong thiết bị phần cứng) để thực hiện chức năng của chúng.</li>
</ol>
<h2 id="363-giao-thức-chuẩn-the-canonical-protocol"><a class="header" href="#363-giao-thức-chuẩn-the-canonical-protocol">36.3 Giao thức chuẩn (The Canonical Protocol)</a></h2>
<p>Trong sơ đồ trên, <strong>giao diện thiết bị</strong> (được đơn giản hóa) bao gồm ba <strong>register</strong>:</p>
<ul>
<li><strong>Status register</strong>: có thể đọc để biết trạng thái hiện tại của thiết bị.</li>
<li><strong>Command register</strong>: dùng để ra lệnh cho thiết bị thực hiện một tác vụ nhất định.</li>
<li><strong>Data register</strong>: dùng để truyền dữ liệu tới thiết bị hoặc nhận dữ liệu từ thiết bị.</li>
</ul>
<p>Bằng cách đọc và ghi vào các register này, hệ điều hành có thể điều khiển hành vi của thiết bị.</p>
<p>Bây giờ, hãy mô tả một tương tác điển hình mà <strong>hệ điều hành</strong> (OS) có thể thực hiện với thiết bị để yêu cầu thiết bị làm một việc nào đó thay cho nó. <strong>Giao thức</strong> (protocol) như sau:</p>
<pre><code>While (STATUS == BUSY)
  ; // chờ cho đến khi thiết bị không bận
Write data to DATA register
Write command to COMMAND register
// (bắt đầu thiết bị và thực thi lệnh)
While (STATUS == BUSY)
  ; // chờ cho đến khi thiết bị hoàn thành yêu cầu
</code></pre>
<p>Giao thức này có bốn bước:</p>
<ol>
<li><strong>OS</strong> chờ cho đến khi thiết bị sẵn sàng nhận lệnh bằng cách liên tục đọc <strong>status register</strong>; chúng ta gọi đây là <strong>polling</strong> thiết bị (về cơ bản là liên tục hỏi xem nó đang làm gì).</li>
<li>OS gửi một số dữ liệu xuống <strong>data register</strong>; có thể hình dung nếu đây là một ổ đĩa, thì sẽ cần nhiều lần ghi để truyền một khối dữ liệu (ví dụ 4KB) xuống thiết bị. Khi <strong>CPU</strong> chính tham gia trực tiếp vào việc di chuyển dữ liệu (như trong giao thức ví dụ này), ta gọi đó là <strong>programmed I/O</strong> (PIO).</li>
<li>OS ghi một lệnh vào <strong>command register</strong>; thao tác này ngầm báo cho thiết bị biết rằng dữ liệu đã sẵn sàng và nó nên bắt đầu thực hiện lệnh.</li>
<li>Cuối cùng, OS chờ thiết bị hoàn thành bằng cách tiếp tục polling trong vòng lặp, kiểm tra xem nó đã xong chưa (lúc này có thể nhận được mã lỗi để báo thành công hoặc thất bại).</li>
</ol>
<p>Giao thức cơ bản này có ưu điểm là <strong>đơn giản</strong> và <strong>hoạt động được</strong>. Tuy nhiên, nó cũng tồn tại một số <strong>điểm kém hiệu quả</strong> và <strong>bất tiện</strong>. Vấn đề đầu tiên dễ nhận thấy là <strong>polling</strong> có vẻ không hiệu quả; cụ thể, nó lãng phí rất nhiều thời gian CPU chỉ để chờ thiết bị (có thể rất chậm) hoàn thành công việc, thay vì chuyển sang chạy một <strong>process</strong> (tiến trình) khác đang sẵn sàng, từ đó tận dụng CPU tốt hơn.</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ TRÁNH CHI PHÍ CỦA POLLING</strong><br />
Làm thế nào để OS kiểm tra trạng thái thiết bị mà không cần polling liên tục, từ đó giảm chi phí CPU cần thiết để quản lý thiết bị?</p>
</blockquote>
<h2 id="364-giảm-tải-cpu-bằng-interrupts"><a class="header" href="#364-giảm-tải-cpu-bằng-interrupts">36.4 Giảm tải CPU bằng Interrupts</a></h2>
<p>Phát minh mà nhiều kỹ sư đã tìm ra từ nhiều năm trước để cải thiện tương tác này là một thứ mà chúng ta đã gặp: <strong>interrupt</strong> (ngắt).<br />
Thay vì polling thiết bị liên tục, OS có thể gửi yêu cầu, đưa <strong>process</strong> gọi I/O vào trạng thái ngủ (<strong>sleep</strong>), và <strong>context switch</strong> sang một tác vụ khác. Khi thiết bị hoàn tất thao tác, nó sẽ phát ra một <strong>hardware interrupt</strong> (ngắt phần cứng), khiến CPU nhảy vào OS tại một <strong>interrupt service routine</strong> (ISR) – hay đơn giản hơn là <strong>interrupt handler</strong>.<br />
Interrupt handler chỉ là một đoạn code trong hệ điều hành, có nhiệm vụ hoàn tất yêu cầu (ví dụ: đọc dữ liệu và có thể cả mã lỗi từ thiết bị) và đánh thức process đang chờ I/O, để nó tiếp tục thực thi.</p>
<p>Interrupts cho phép <strong>chồng lấp</strong> (overlap) giữa tính toán và I/O, đây là yếu tố then chốt để cải thiện mức sử dụng tài nguyên. Dưới đây là sơ đồ thời gian minh họa vấn đề:</p>
<pre><code>CPU:  1 1 1 1 1 p p p p p 1 1 1 1 1
Disk: -----------------------------
</code></pre>
<p>Trong sơ đồ, <strong>Process 1</strong> chạy trên CPU một thời gian (được biểu diễn bằng các số 1 lặp lại trên dòng CPU), sau đó gửi một yêu cầu I/O tới đĩa để đọc dữ liệu. <strong>Không có interrupts</strong>, hệ thống chỉ quay vòng (spin), polling trạng thái thiết bị liên tục cho đến khi I/O hoàn tất (biểu diễn bằng <code>p</code>). Đĩa xử lý yêu cầu và cuối cùng Process 1 mới chạy lại.</p>
<p>Nếu thay vào đó chúng ta sử dụng interrupts và cho phép chồng lấp:</p>
<pre><code>CPU:  1 1 1 1 1 2 2 2 2 2 1 1 1 1 1
Disk: -----------------------------
</code></pre>
<p>Trong ví dụ này, OS chạy <strong>Process 2</strong> trên CPU trong khi đĩa đang phục vụ yêu cầu của Process 1. Khi yêu cầu đĩa hoàn tất, một interrupt xảy ra, OS đánh thức Process 1 và chạy nó trở lại. Như vậy, cả CPU và đĩa đều được sử dụng hợp lý trong khoảng thời gian giữa.</p>
<p>Lưu ý rằng <strong>sử dụng interrupts không phải lúc nào cũng là giải pháp tốt nhất</strong>. Ví dụ, hãy tưởng tượng một thiết bị thực hiện tác vụ rất nhanh: lần polling đầu tiên thường đã thấy thiết bị hoàn tất. Sử dụng interrupt trong trường hợp này thực ra sẽ làm chậm hệ thống: việc chuyển sang process khác, xử lý interrupt, rồi chuyển lại process ban đầu là tốn kém.<br />
Vì vậy, nếu thiết bị <strong>nhanh</strong>, tốt nhất là polling; nếu thiết bị <strong>chậm</strong>, interrupts – cho phép chồng lấp – là lựa chọn tối ưu. Nếu tốc độ thiết bị <strong>không xác định</strong>, hoặc lúc nhanh lúc chậm, tốt nhất là dùng <strong>giải pháp lai</strong>: polling trong một khoảng ngắn, rồi nếu thiết bị chưa xong thì chuyển sang dùng interrupts. Cách tiếp cận hai giai đoạn này có thể đạt được lợi ích của cả hai phương pháp.</p>
<blockquote>
<p><strong>TIP: INTERRUPTS KHÔNG PHẢI LÚC NÀO CŨNG TỐT HƠN POLLING</strong><br />
Mặc dù interrupts cho phép chồng lấp giữa tính toán và I/O, chúng chỉ thực sự hợp lý cho các thiết bị chậm. Nếu không, chi phí xử lý interrupt và context switch có thể lớn hơn lợi ích mà interrupts mang lại. Cũng có những trường hợp một lượng lớn interrupts có thể làm quá tải hệ thống và dẫn đến <strong>livelock</strong> [MR96]; trong những trường hợp như vậy, polling mang lại cho OS khả năng kiểm soát tốt hơn trong việc lập lịch, và do đó lại trở nên hữu ích.</p>
</blockquote>
<p>Một lý do khác để <strong>không</strong> sử dụng <strong>interrupts</strong> (ngắt) xuất hiện trong lĩnh vực <strong>mạng máy tính</strong> [MR96]. Khi một luồng lớn các gói tin (packet) đến, và mỗi gói đều tạo ra một interrupt, hệ điều hành (OS) có thể rơi vào trạng thái <strong>livelock</strong> — tức là chỉ xử lý các interrupt mà không bao giờ cho phép một <strong>process</strong> (tiến trình) ở mức người dùng chạy để thực sự phục vụ các yêu cầu.<br />
Ví dụ, hãy tưởng tượng một <strong>web server</strong> gặp một đợt tải tăng đột biến vì nó trở thành mục tin đứng đầu trên <em>Hacker News</em> [H18]. Trong trường hợp này, thỉnh thoảng sử dụng <strong>polling</strong> sẽ tốt hơn để kiểm soát tốt hơn những gì đang diễn ra trong hệ thống, và cho phép web server xử lý một số yêu cầu trước khi quay lại thiết bị để kiểm tra các gói tin mới đến.</p>
<p>Một tối ưu hóa khác dựa trên interrupt là <strong>coalescing</strong> (gộp ngắt). Trong thiết lập này, một thiết bị cần phát ra interrupt sẽ chờ một chút trước khi gửi interrupt tới CPU. Trong khi chờ, các yêu cầu khác có thể sớm hoàn thành, và do đó nhiều interrupt có thể được gộp lại thành một lần gửi interrupt duy nhất, giúp giảm chi phí xử lý interrupt. Tất nhiên, chờ quá lâu sẽ làm tăng <strong>latency</strong> (độ trễ) của yêu cầu — đây là một sự đánh đổi phổ biến trong hệ thống. Xem Ahmad et al. [A+11] để có bản tóm tắt xuất sắc về chủ đề này.</p>
<h2 id="365-di-chuyển-dữ-liệu-hiệu-quả-hơn-với-dma"><a class="header" href="#365-di-chuyển-dữ-liệu-hiệu-quả-hơn-với-dma">36.5 Di chuyển dữ liệu hiệu quả hơn với DMA</a></h2>
<p>Thật không may, còn một khía cạnh khác của <strong>giao thức chuẩn</strong> (canonical protocol) cần được xem xét. Cụ thể, khi sử dụng <strong>programmed I/O</strong> (PIO) để truyền một khối dữ liệu lớn tới thiết bị, CPU lại một lần nữa bị quá tải với một tác vụ khá tầm thường, và do đó lãng phí nhiều thời gian và công sức — thời gian này có thể được dùng để chạy các process khác. Dòng thời gian dưới đây minh họa vấn đề:</p>
<pre><code>CPU:  1 1 1 1 1 c c c 2 2 2 2 2 1 1 1 1 1
Disk: -----------------------------------
</code></pre>
<p>Trong dòng thời gian này, <strong>Process 1</strong> đang chạy và sau đó muốn ghi một số dữ liệu xuống đĩa. Nó khởi tạo I/O, và phải sao chép dữ liệu từ bộ nhớ tới thiết bị một cách tường minh, từng từ (word) một (được đánh dấu <code>c</code> trong sơ đồ). Khi việc sao chép hoàn tất, I/O mới bắt đầu trên đĩa và CPU cuối cùng mới có thể được dùng cho việc khác.</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ GIẢM CHI PHÍ PIO</strong><br />
Với PIO, CPU tốn quá nhiều thời gian để tự tay di chuyển dữ liệu tới và từ thiết bị. Làm thế nào để chúng ta chuyển bớt công việc này đi nơi khác, từ đó cho phép CPU được sử dụng hiệu quả hơn?</p>
</blockquote>
<p>Giải pháp cho vấn đề này là <strong>Direct Memory Access</strong> (DMA). Một <strong>DMA engine</strong> về cơ bản là một thiết bị chuyên biệt trong hệ thống, có thể điều phối việc truyền dữ liệu giữa thiết bị và bộ nhớ chính mà không cần nhiều sự can thiệp của CPU.</p>
<p>DMA hoạt động như sau: để truyền dữ liệu tới thiết bị, OS sẽ lập trình DMA engine bằng cách cho nó biết dữ liệu nằm ở đâu trong bộ nhớ, lượng dữ liệu cần sao chép, và thiết bị đích. Tại thời điểm đó, OS coi như đã xong phần việc của mình và có thể tiếp tục làm việc khác. Khi DMA hoàn tất, <strong>DMA controller</strong> sẽ phát ra một interrupt, và OS sẽ biết quá trình truyền đã hoàn thành. Dòng thời gian được sửa đổi như sau:</p>
<pre><code>CPU:  1 1 1 1 1 2 2 2 2 2 1 1 1 1 1
DMA:          c c c
Disk: --------------------------------
</code></pre>
<p>Từ dòng thời gian, có thể thấy việc sao chép dữ liệu giờ đây do DMA controller đảm nhận. Vì CPU rảnh trong thời gian này, OS có thể làm việc khác — ở đây là chạy <strong>Process 2</strong>. Nhờ vậy, Process 2 được sử dụng CPU nhiều hơn trước khi Process 1 chạy lại.</p>
<h2 id="366-các-phương-thức-tương-tác-với-thiết-bị-methods-of-device-interaction"><a class="header" href="#366-các-phương-thức-tương-tác-với-thiết-bị-methods-of-device-interaction">36.6 Các phương thức tương tác với thiết bị (Methods Of Device Interaction)</a></h2>
<p>Bây giờ, khi đã hiểu một phần về các vấn đề hiệu năng liên quan đến việc thực hiện I/O, vẫn còn một số vấn đề khác cần xử lý để tích hợp thiết bị vào các hệ thống hiện đại. Một vấn đề bạn có thể đã nhận thấy: chúng ta vẫn chưa thực sự nói về cách OS <strong>giao tiếp</strong> với thiết bị! Do đó, vấn đề đặt ra:</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ GIAO TIẾP VỚI THIẾT BỊ</strong><br />
Phần cứng nên giao tiếp với thiết bị như thế nào? Có nên có các lệnh tường minh? Hay còn cách nào khác?</p>
</blockquote>
<p>Theo thời gian, đã phát triển hai phương pháp chính để giao tiếp với thiết bị:</p>
<ol>
<li>
<p><strong>Phương pháp đầu tiên</strong> và lâu đời nhất (được IBM mainframe sử dụng trong nhiều năm) là có các <strong>lệnh I/O tường minh</strong>. Các lệnh này quy định cách để OS gửi dữ liệu tới các <strong>device register</strong> cụ thể, từ đó cho phép xây dựng các giao thức như đã mô tả ở trên.<br />
Ví dụ, trên kiến trúc x86, các lệnh <code>in</code> và <code>out</code> có thể được dùng để giao tiếp với thiết bị. Để gửi dữ liệu tới thiết bị, chương trình gọi sẽ chỉ định một thanh ghi chứa dữ liệu và một <strong>port</strong> cụ thể để định danh thiết bị. Thực thi lệnh sẽ dẫn đến hành vi mong muốn.</p>
<p>Các lệnh này thường là <strong>privileged</strong> (đặc quyền). OS kiểm soát thiết bị, và do đó OS là thực thể duy nhất được phép giao tiếp trực tiếp với chúng. Hãy tưởng tượng nếu bất kỳ chương trình nào cũng có thể đọc hoặc ghi đĩa: sẽ là hỗn loạn hoàn toàn, vì bất kỳ chương trình người dùng nào cũng có thể lợi dụng lỗ hổng này để giành quyền kiểm soát toàn bộ máy.</p>
</li>
<li>
<p><strong>Phương pháp thứ hai</strong> để tương tác với thiết bị được gọi là <strong>memory-mapped I/O</strong>. Với cách tiếp cận này, phần cứng làm cho các device register khả dụng như thể chúng là các vị trí bộ nhớ. Để truy cập một register cụ thể, OS thực hiện một lệnh <strong>load</strong> (để đọc) hoặc <strong>store</strong> (để ghi) tới địa chỉ đó; phần cứng sau đó sẽ định tuyến thao tác load/store này tới thiết bị thay vì tới bộ nhớ chính.</p>
</li>
</ol>
<p>Không có ưu thế vượt trội tuyệt đối giữa hai phương pháp. <strong>Memory-mapped I/O</strong> có ưu điểm là không cần thêm lệnh mới để hỗ trợ, nhưng cả hai phương pháp vẫn đang được sử dụng song song cho đến ngày nay.</p>
<h2 id="367-tích-hợp-vào-hệ-điều-hành-device-driver"><a class="header" href="#367-tích-hợp-vào-hệ-điều-hành-device-driver">36.7 Tích hợp vào Hệ điều hành: Device Driver</a></h2>
<p>Một vấn đề cuối cùng chúng ta sẽ thảo luận: làm thế nào để tích hợp các thiết bị — mỗi thiết bị có giao diện (interface) rất riêng biệt — vào hệ điều hành (OS), trong khi chúng ta muốn giữ cho OS càng tổng quát càng tốt.<br />
Ví dụ, hãy xem xét một <strong>file system</strong> (hệ thống tệp). Chúng ta muốn xây dựng một file system có thể hoạt động trên nhiều loại ổ đĩa khác nhau như <strong>SCSI disk</strong>, <strong>IDE disk</strong>, <strong>USB keychain drive</strong>, v.v… và muốn file system này hầu như không cần quan tâm đến chi tiết cách gửi yêu cầu đọc (read) hoặc ghi (write) tới các loại ổ đĩa khác nhau. Do đó, vấn đề đặt ra:</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO XÂY DỰNG MỘT OS TRUNG LẬP VỚI THIẾT BỊ</strong><br />
Làm thế nào để giữ cho phần lớn OS trung lập với thiết bị, từ đó ẩn đi các chi tiết tương tác thiết bị khỏi các phân hệ chính của OS?</p>
</blockquote>
<p>Vấn đề này được giải quyết bằng kỹ thuật lâu đời: <strong>abstraction</strong> (trừu tượng hóa). Ở mức thấp nhất, một phần mềm trong OS phải biết chi tiết cách hoạt động của thiết bị. Phần mềm này được gọi là <strong>device driver</strong> (trình điều khiển thiết bị), và mọi chi tiết tương tác với thiết bị đều được đóng gói (encapsulated) bên trong nó.</p>
<p>Hãy xem abstraction này giúp ích cho thiết kế và triển khai OS như thế nào bằng cách xem xét <strong>ngăn xếp phần mềm file system</strong> của Linux. <strong>Hình 36.4</strong> là một mô tả gần đúng về tổ chức phần mềm của Linux.</p>
<p><img src="36/img/fig36_4.PNG" alt="" /></p>
<p><strong>Hình 36.4: Ngăn xếp file system (The File System Stack)</strong></p>
<p>Như bạn thấy từ sơ đồ, một file system (và chắc chắn là cả ứng dụng ở tầng trên) hoàn toàn không cần biết nó đang sử dụng loại ổ đĩa nào; nó chỉ đơn giản gửi các yêu cầu đọc/ghi block tới <strong>generic block layer</strong> (lớp khối tổng quát), lớp này sẽ định tuyến chúng tới <strong>device driver</strong> phù hợp, driver này sẽ xử lý chi tiết việc gửi yêu cầu cụ thể. Mặc dù sơ đồ đã được đơn giản hóa, nó cho thấy cách mà các chi tiết có thể được ẩn khỏi phần lớn OS.</p>
<p>Sơ đồ cũng cho thấy một <strong>raw interface</strong> (giao diện thô) tới thiết bị, cho phép các ứng dụng đặc biệt (như <strong>file-system checker</strong> – công cụ kiểm tra hệ thống tệp, sẽ được mô tả sau [AD14], hoặc công cụ chống phân mảnh đĩa) đọc và ghi trực tiếp các block mà không cần sử dụng abstraction của file. Hầu hết các hệ thống đều cung cấp loại giao diện này để hỗ trợ các ứng dụng quản lý lưu trữ cấp thấp.</p>
<p>Lưu ý rằng encapsulation như trên cũng có nhược điểm. Ví dụ, nếu một thiết bị có nhiều khả năng đặc biệt nhưng phải cung cấp một giao diện tổng quát cho phần còn lại của <strong>kernel</strong>, thì các khả năng đặc biệt đó sẽ không được sử dụng. Tình huống này xảy ra, chẳng hạn, trong Linux với các thiết bị SCSI, vốn có khả năng báo lỗi rất chi tiết; nhưng vì các thiết bị khối khác (ví dụ: ATA/IDE) có cơ chế xử lý lỗi đơn giản hơn, nên tầng phần mềm cao hơn chỉ nhận được một mã lỗi tổng quát <strong>EIO</strong> (generic I/O error); mọi chi tiết bổ sung mà SCSI có thể cung cấp đều bị mất đối với file system [G08].</p>
<p>Điều thú vị là, vì device driver cần thiết cho bất kỳ thiết bị nào bạn cắm vào hệ thống, theo thời gian chúng đã chiếm một tỷ lệ rất lớn trong mã nguồn kernel. Các nghiên cứu về Linux kernel cho thấy hơn 70% mã nguồn OS nằm trong device driver [C01]; với các hệ thống Windows, con số này cũng có khả năng rất cao. Do đó, khi ai đó nói rằng OS có hàng triệu dòng mã, thực chất họ đang nói rằng OS có hàng triệu dòng mã device driver. Tất nhiên, với mỗi cài đặt cụ thể, phần lớn mã này có thể không hoạt động (tức là chỉ một vài thiết bị được kết nối với hệ thống tại một thời điểm). Đáng buồn hơn, vì driver thường được viết bởi “nghiệp dư” (thay vì lập trình viên kernel toàn thời gian), chúng thường có nhiều lỗi hơn và là nguyên nhân chính gây ra <strong>kernel crash</strong> (sập kernel) [S03].</p>
<h2 id="368-nghiên-cứu-tình-huống-một-ide-disk-driver-đơn-giản"><a class="header" href="#368-nghiên-cứu-tình-huống-một-ide-disk-driver-đơn-giản">36.8 Nghiên cứu tình huống: Một IDE Disk Driver đơn giản</a></h2>
<p>Để tìm hiểu sâu hơn, hãy xem nhanh một thiết bị thực: <strong>IDE disk drive</strong> [L94]. Chúng ta sẽ tóm tắt giao thức như được mô tả trong tài liệu [W10]; đồng thời xem qua mã nguồn <strong>xv6</strong> để có ví dụ đơn giản về một IDE driver hoạt động [CK+08].</p>
<p><img src="36/img/fig36_5.PNG" alt="" /></p>
<p><strong>Hình 36.5: Giao diện IDE (The IDE Interface)</strong></p>
<p>Một IDE disk cung cấp một giao diện đơn giản cho hệ thống, bao gồm bốn loại <strong>register</strong>: control, command block, status, và error. Các register này có thể được truy cập bằng cách đọc hoặc ghi vào các “I/O address” cụ thể (ví dụ: 0x3F6) bằng cách sử dụng (trên x86) các lệnh I/O <code>in</code> và <code>out</code>.</p>
<p><strong>Giao thức cơ bản</strong> để tương tác với thiết bị như sau (giả sử thiết bị đã được khởi tạo):</p>
<ul>
<li><strong>Chờ ổ đĩa sẵn sàng</strong>: Đọc <strong>Status Register</strong> (0x1F7) cho đến khi ổ đĩa ở trạng thái READY và không BUSY.</li>
<li><strong>Ghi tham số vào command register</strong>: Ghi số sector, <strong>logical block address</strong> (LBA) của các sector cần truy cập, và số ổ (master = 0x00 hoặc slave = 0x10, vì IDE chỉ cho phép tối đa hai ổ) vào các command register (0x1F2–0x1F6).</li>
<li><strong>Bắt đầu I/O</strong>: Ghi lệnh READ hoặc WRITE vào command register (0x1F7).</li>
<li><strong>Truyền dữ liệu (đối với ghi)</strong>: Chờ cho đến khi trạng thái ổ đĩa là READY và DRQ (drive request for data); ghi dữ liệu vào data port.</li>
<li><strong>Xử lý interrupt</strong>: Trong trường hợp đơn giản, xử lý một interrupt cho mỗi sector được truyền; các phương pháp phức tạp hơn cho phép gộp (batching) và chỉ tạo một interrupt cuối cùng khi toàn bộ quá trình truyền hoàn tất.</li>
<li><strong>Xử lý lỗi</strong>: Sau mỗi thao tác, đọc status register. Nếu bit ERROR bật, đọc error register để biết chi tiết.</li>
</ul>
<p>Hầu hết giao thức này được tìm thấy trong <strong>xv6 IDE driver</strong> (<strong>Hình 36.6</strong>), driver này (sau khi khởi tạo) hoạt động qua bốn hàm chính:</p>
<ol>
<li><strong><code>ide_rw()</code></strong>: Xếp hàng một yêu cầu (nếu có yêu cầu khác đang chờ) hoặc gửi trực tiếp yêu cầu tới đĩa (thông qua <code>ide_start_request()</code>); trong cả hai trường hợp, routine này chờ yêu cầu hoàn tất và đưa process gọi vào trạng thái ngủ.</li>
<li><strong><code>ide_start_request()</code></strong>: Gửi một yêu cầu (và có thể cả dữ liệu, nếu là ghi) tới đĩa; các lệnh x86 <code>in</code> và <code>out</code> được gọi để đọc và ghi các device register tương ứng.</li>
<li><strong><code>ide_wait_ready()</code></strong>: Được <code>start_request</code> sử dụng để đảm bảo ổ đĩa sẵn sàng trước khi gửi yêu cầu.</li>
<li><strong><code>ide_intr()</code></strong>: Được gọi khi xảy ra interrupt; đọc dữ liệu từ thiết bị (nếu yêu cầu là đọc), đánh thức process đang chờ I/O hoàn tất, và nếu còn yêu cầu trong hàng đợi I/O, sẽ khởi động yêu cầu tiếp theo thông qua <code>ide_start_request()</code>.</li>
</ol>
<p><img src="36/img/fig36_6.PNG" alt="" /></p>
<p><strong>Hình 36.6: Trình điều khiển đĩa IDE trong xv6 (đơn giản hóa)</strong></p>
<h2 id="369-ghi-chú-lịch-sử-historical-notes"><a class="header" href="#369-ghi-chú-lịch-sử-historical-notes">36.9 Ghi chú lịch sử (Historical Notes)</a></h2>
<p>Trước khi kết thúc, chúng ta sẽ điểm qua một ghi chú lịch sử ngắn gọn về nguồn gốc của một số ý tưởng nền tảng này. Nếu bạn muốn tìm hiểu sâu hơn, hãy đọc bản tóm tắt xuất sắc của Smotherman [S08].</p>
<p><strong>Interrupt</strong> (ngắt) là một ý tưởng rất lâu đời, đã tồn tại trên những máy tính đầu tiên. Ví dụ, <strong>UNIVAC</strong> vào đầu những năm 1950 đã có một dạng <strong>interrupt vectoring</strong> (định tuyến ngắt), mặc dù không rõ chính xác năm nào tính năng này xuất hiện [S08]. Thật đáng tiếc là ngay cả khi ngành khoa học máy tính còn sơ khai, chúng ta đã bắt đầu đánh mất dấu vết về nguồn gốc lịch sử của nó.</p>
<p>Cũng có một số tranh luận về việc máy nào là máy đầu tiên giới thiệu ý tưởng <strong>DMA</strong> (Direct Memory Access – truy cập bộ nhớ trực tiếp). Ví dụ, Knuth và một số người khác cho rằng đó là <strong>DYSEAC</strong> (một “máy di động”, mà vào thời điểm đó nghĩa là có thể kéo đi bằng rơ-moóc), trong khi những người khác lại nghĩ rằng <strong>IBM SAGE</strong> có thể là máy đầu tiên [S08]. Dù thế nào, vào giữa những năm 1950, đã tồn tại các hệ thống với thiết bị I/O có thể giao tiếp trực tiếp với bộ nhớ và phát ra interrupt cho CPU khi hoàn tất. Lịch sử ở đây khó truy dấu vì các phát minh gắn liền với những cỗ máy thực tế, đôi khi rất ít được biết đến. Ví dụ, một số người cho rằng máy <strong>TX-2</strong> của Lincoln Labs là máy đầu tiên có <strong>vectored interrupts</strong> [S08], nhưng điều này vẫn chưa rõ ràng.</p>
<p>Bởi vì những ý tưởng này tương đối hiển nhiên — không cần một bước nhảy vọt kiểu Einstein để nghĩ ra việc cho phép CPU làm việc khác trong khi một I/O chậm đang chờ — nên có lẽ việc tập trung vào câu hỏi “ai là người đầu tiên?” là không cần thiết. Điều chắc chắn là: khi con người xây dựng những máy tính đầu tiên, họ nhanh chóng nhận ra rằng cần có hỗ trợ I/O. Interrupt, DMA và các ý tưởng liên quan đều là hệ quả trực tiếp từ bản chất của CPU nhanh và thiết bị chậm; nếu bạn ở đó vào thời điểm đó, có thể bạn cũng sẽ nảy ra những ý tưởng tương tự.</p>
<h2 id="3610-tóm-tắt-summary"><a class="header" href="#3610-tóm-tắt-summary">36.10 Tóm tắt (Summary)</a></h2>
<p>Đến đây, bạn đã có một hiểu biết cơ bản về cách một <strong>hệ điều hành</strong> (OS) tương tác với một thiết bị. Hai kỹ thuật — <strong>interrupt</strong> và <strong>DMA</strong> — đã được giới thiệu để giúp cải thiện hiệu năng thiết bị, cùng với hai phương pháp truy cập <strong>device register</strong> (thanh ghi thiết bị): <strong>explicit I/O instructions</strong> (các lệnh I/O tường minh) và <strong>memory-mapped I/O</strong> (I/O ánh xạ bộ nhớ). Cuối cùng, khái niệm <strong>device driver</strong> (trình điều khiển thiết bị) đã được trình bày, cho thấy cách OS có thể đóng gói các chi tiết mức thấp và nhờ đó giúp việc xây dựng phần còn lại của OS trở nên dễ dàng hơn theo hướng <strong>device-neutral</strong> (trung lập với thiết bị).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="37-Ổ-đĩa-cứng-hard-disk-drives"><a class="header" href="#37-Ổ-đĩa-cứng-hard-disk-drives">37. Ổ đĩa cứng (Hard Disk Drives)</a></h1>
<p>Chương trước đã giới thiệu khái niệm tổng quát về <strong>thiết bị I/O</strong> (I/O device) và cho thấy hệ điều hành (OS) có thể tương tác với loại thiết bị này như thế nào. Trong chương này, chúng ta sẽ đi sâu hơn vào chi tiết của một thiết bị cụ thể: <strong>ổ đĩa cứng</strong> (hard disk drive). Trong nhiều thập kỷ, các ổ đĩa này đã là hình thức lưu trữ dữ liệu bền vững (persistent storage) chính trong các hệ thống máy tính, và phần lớn sự phát triển của công nghệ <strong>file system</strong> (hệ thống tệp – sẽ được đề cập ở các chương sau) đều dựa trên hành vi của chúng. Do đó, việc hiểu rõ chi tiết hoạt động của ổ đĩa là rất cần thiết trước khi xây dựng phần mềm file system để quản lý nó. Nhiều chi tiết trong số này có thể tìm thấy trong các bài báo xuất sắc của Ruemmler và Wilkes [RW92], cũng như Anderson, Dykes và Riedel [ADR03].</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ LƯU TRỮ VÀ TRUY XUẤT DỮ LIỆU TRÊN Ổ ĐĨA</strong><br />
Ổ đĩa cứng hiện đại lưu trữ dữ liệu như thế nào? Giao diện của nó ra sao? Dữ liệu thực sự được bố trí và truy cập như thế nào? Lập lịch đĩa (disk scheduling) cải thiện hiệu năng ra sao?</p>
</blockquote>
<h2 id="371-giao-diện-the-interface"><a class="header" href="#371-giao-diện-the-interface">37.1 Giao diện (The Interface)</a></h2>
<p>Hãy bắt đầu bằng cách tìm hiểu <strong>giao diện</strong> của một ổ đĩa cứng hiện đại. Giao diện cơ bản của tất cả các ổ đĩa hiện đại khá đơn giản: ổ đĩa bao gồm một số lượng lớn <strong>sector</strong> (khối 512 byte), mỗi sector có thể được đọc hoặc ghi. Các sector được đánh số từ 0 đến n − 1 trên một ổ đĩa có n sector. Do đó, ta có thể hình dung ổ đĩa như một mảng các sector; dải địa chỉ từ 0 đến n − 1 chính là <strong>không gian địa chỉ</strong> (address space) của ổ đĩa.</p>
<p>Các thao tác trên nhiều sector là khả thi; trên thực tế, nhiều file system sẽ đọc hoặc ghi 4KB mỗi lần (hoặc nhiều hơn). Tuy nhiên, khi cập nhật ổ đĩa, <strong>nhà sản xuất</strong> chỉ đảm bảo rằng một lần ghi 512 byte là <strong>atomic</strong> (nguyên tử – tức là hoặc hoàn tất toàn bộ, hoặc không hoàn tất gì cả); do đó, nếu mất điện đột ngột, chỉ một phần của thao tác ghi lớn hơn có thể hoàn tất (điều này đôi khi được gọi là <strong>torn write</strong> – ghi bị xé lẻ).</p>
<p>Có một số giả định mà hầu hết các <strong>client</strong> (thành phần sử dụng ổ đĩa) thường mặc định, nhưng không được quy định trực tiếp trong giao diện; Schlosser và Ganger gọi đây là <strong>“hợp đồng ngầm”</strong> (unwritten contract) của ổ đĩa [SG04]. Cụ thể:</p>
<ul>
<li>Thông thường, có thể giả định rằng việc truy cập hai <strong>block</strong>¹ gần nhau trong không gian địa chỉ của ổ đĩa sẽ nhanh hơn so với truy cập hai block ở xa nhau.</li>
<li>Cũng thường có thể giả định rằng việc truy cập các block liền kề (tức là đọc hoặc ghi tuần tự – sequential read/write) là chế độ truy cập nhanh nhất, và thường nhanh hơn nhiều so với bất kỳ mẫu truy cập ngẫu nhiên nào.</li>
</ul>
<p><img src="37/img/fig37_1.PNG" alt="" /></p>
<p><strong>Hình 37.1: Ổ đĩa với chỉ một track</strong></p>
<h2 id="372-hình-học-cơ-bản-basic-geometry"><a class="header" href="#372-hình-học-cơ-bản-basic-geometry">37.2 Hình học cơ bản (Basic Geometry)</a></h2>
<p>Hãy bắt đầu tìm hiểu một số thành phần của ổ đĩa hiện đại. Chúng ta bắt đầu với <strong>platter</strong> – một bề mặt cứng hình tròn, nơi dữ liệu được lưu trữ bền vững bằng cách tạo ra các thay đổi từ tính trên nó. Một ổ đĩa có thể có một hoặc nhiều platter; mỗi platter có 2 mặt, mỗi mặt được gọi là một <strong>surface</strong>. Các platter này thường được làm từ vật liệu cứng (như nhôm), sau đó phủ một lớp từ tính mỏng cho phép ổ đĩa lưu trữ bit dữ liệu một cách bền vững ngay cả khi tắt nguồn.</p>
<p>Tất cả các platter được gắn chung quanh <strong>spindle</strong> (trục quay), trục này được nối với một <strong>motor</strong> (động cơ) để quay các platter (khi ổ đĩa được cấp nguồn) ở một tốc độ cố định. Tốc độ quay thường được đo bằng <strong>RPM</strong> (rotations per minute – vòng quay mỗi phút), và các giá trị phổ biến hiện nay nằm trong khoảng 7.200 RPM đến 15.000 RPM. Lưu ý rằng chúng ta thường quan tâm đến thời gian của một vòng quay đơn; ví dụ, một ổ đĩa quay ở 10.000 RPM nghĩa là một vòng quay mất khoảng 6 mili-giây (6 ms).</p>
<p>Dữ liệu được mã hóa trên mỗi surface thành các vòng tròn đồng tâm của các sector; mỗi vòng tròn như vậy được gọi là một <strong>track</strong>. Một surface duy nhất chứa hàng nghìn track, được xếp sát nhau, với hàng trăm track có thể nằm gọn trong bề rộng của một sợi tóc người.</p>
<p>Để đọc và ghi từ surface, chúng ta cần một cơ chế cho phép <strong>cảm nhận</strong> (read) các mẫu từ tính trên đĩa hoặc <strong>tạo ra thay đổi</strong> (write) chúng. Quá trình đọc và ghi này được thực hiện bởi <strong>disk head</strong> (đầu đọc/ghi đĩa); mỗi surface của ổ đĩa có một đầu đọc/ghi. Đầu đọc/ghi được gắn vào một <strong>disk arm</strong> (cần đĩa), di chuyển ngang qua surface để định vị đầu đọc/ghi trên track mong muốn.</p>
<p><img src="37/img/fig37_2.PNG" alt="" /></p>
<p><strong>Hình 37.2: Một track đơn và một đầu đọc/ghi</strong></p>
<p>¹Chúng tôi (và nhiều tác giả khác) thường sử dụng các thuật ngữ <strong>block</strong> và <strong>sector</strong> thay thế cho nhau, với giả định rằng người đọc sẽ hiểu rõ ý nghĩa trong từng ngữ cảnh. Xin lỗi vì sự bất tiện này!</p>
<h2 id="373-một-ổ-đĩa-đơn-giản-a-simple-disk-drive"><a class="header" href="#373-một-ổ-đĩa-đơn-giản-a-simple-disk-drive">37.3 Một ổ đĩa đơn giản (A Simple Disk Drive)</a></h2>
<p>Hãy tìm hiểu cách ổ đĩa hoạt động bằng cách xây dựng một mô hình từng track một. Giả sử chúng ta có một ổ đĩa đơn giản với một track duy nhất (<strong>Hình 37.1</strong>). Track này chỉ có 12 sector, mỗi sector có kích thước 512 byte (kích thước sector tiêu chuẩn, như đã nhắc lại) và được đánh địa chỉ từ 0 đến 11. Platter duy nhất này quay quanh spindle, được nối với một motor.</p>
<p>Tất nhiên, chỉ có track thôi thì chưa đủ thú vị; chúng ta muốn có thể đọc hoặc ghi các sector đó, và do đó cần một <strong>disk head</strong> gắn vào một <strong>disk arm</strong>, như minh họa trong <strong>Hình 37.2</strong>. Trong hình, đầu đọc/ghi đĩa, gắn ở cuối cần đĩa, đang được định vị trên sector số 6, và surface đang quay theo chiều ngược kim đồng hồ.</p>
<h3 id="Độ-trễ-trên-một-track-rotational-delay-độ-trễ-quay"><a class="header" href="#Độ-trễ-trên-một-track-rotational-delay-độ-trễ-quay">Độ trễ trên một track: <strong>Rotational Delay</strong> (độ trễ quay)</a></h3>
<p>Để hiểu cách một yêu cầu được xử lý trên ổ đĩa đơn giản chỉ có một track, hãy tưởng tượng chúng ta nhận được một yêu cầu đọc block 0. Ổ đĩa sẽ phục vụ yêu cầu này như thế nào?</p>
<p>Trong ổ đĩa đơn giản này, ổ đĩa không cần làm nhiều việc. Cụ thể, nó chỉ cần <strong>chờ</strong> cho sector mong muốn quay đến vị trí ngay dưới <strong>disk head</strong> (đầu đọc/ghi). Việc chờ này xảy ra khá thường xuyên ở các ổ đĩa hiện đại và là một thành phần đủ quan trọng trong <strong>I/O service time</strong> (thời gian phục vụ I/O) để có một tên riêng: <strong>rotational delay</strong> (độ trễ quay – đôi khi gọi là rotation delay, nhưng nghe hơi lạ).<br />
Trong ví dụ, nếu độ trễ quay toàn phần là <strong>R</strong>, ổ đĩa sẽ phải chịu một độ trễ quay khoảng <strong>R/2</strong> để chờ sector 0 đi qua dưới đầu đọc/ghi (nếu bắt đầu từ sector 6). Trường hợp xấu nhất trên track này là yêu cầu tới sector 5, khiến ổ đĩa phải chịu gần như toàn bộ độ trễ quay để phục vụ yêu cầu.</p>
<h3 id="nhiều-track-seek-time-thời-gian-tìm-kiếm"><a class="header" href="#nhiều-track-seek-time-thời-gian-tìm-kiếm">Nhiều track: <strong>Seek Time</strong> (thời gian tìm kiếm)</a></h3>
<p>Cho đến giờ, ổ đĩa của chúng ta chỉ có một track, điều này không thực tế; các ổ đĩa hiện đại tất nhiên có hàng triệu track. Hãy xem xét một bề mặt đĩa thực tế hơn một chút, với <strong>ba track</strong> (<strong>Hình 37.3</strong>, bên trái). Trong hình, đầu đọc/ghi hiện đang ở track trong cùng (chứa các sector từ 24 đến 35); track kế tiếp chứa các sector từ 12 đến 23, và track ngoài cùng chứa các sector từ 0 đến 11.</p>
<p>Để hiểu cách ổ đĩa truy cập một sector nhất định, hãy lần theo những gì xảy ra khi có yêu cầu đọc tới một sector ở xa, ví dụ: đọc sector 11. Để phục vụ yêu cầu này, ổ đĩa phải <strong>di chuyển cần đĩa</strong> (disk arm) tới đúng track (trong trường hợp này là track ngoài cùng), trong một quá trình gọi là <strong>seek</strong> (tìm kiếm). Seek, cùng với quay (rotation), là một trong những thao tác tốn kém nhất của ổ đĩa.</p>
<p>Seek có nhiều giai đoạn:</p>
<ul>
<li><strong>Tăng tốc</strong> khi cần đĩa bắt đầu di chuyển.</li>
<li><strong>Chạy đều</strong> khi cần di chuyển ở tốc độ tối đa.</li>
<li><strong>Giảm tốc</strong> khi cần chậm lại.</li>
<li>Cuối cùng là <strong>ổn định</strong> (settling) khi đầu đọc/ghi được định vị chính xác trên track mong muốn.</li>
</ul>
<p>Thời gian ổn định thường khá đáng kể, ví dụ từ 0,5 đến 2 ms, vì ổ đĩa phải chắc chắn tìm đúng track (hãy tưởng tượng nếu nó chỉ “gần đúng” thì sẽ ra sao!).</p>
<p>Sau khi seek, cần đĩa đã đưa đầu đọc/ghi đến đúng track. Minh họa seek được thể hiện trong <strong>Hình 37.3</strong> (bên phải).</p>
<p><img src="37/img/fig37_3.PNG" alt="" /></p>
<p><strong>Hình 37.3: Ba track và một đầu đọc/ghi (phải: với seek)</strong></p>
<p>Như ta thấy, trong quá trình seek, cần đĩa đã di chuyển tới track mong muốn, và platter tất nhiên vẫn quay — trong ví dụ này là khoảng 3 sector. Do đó, sector 9 sắp đi qua dưới đầu đọc/ghi, và chúng ta chỉ cần chịu một độ trễ quay ngắn để hoàn tất việc truyền dữ liệu.</p>
<p>Khi sector 11 đi qua dưới đầu đọc/ghi, giai đoạn cuối của I/O sẽ diễn ra, gọi là <strong>transfer</strong> (truyền dữ liệu), nơi dữ liệu được đọc từ hoặc ghi xuống bề mặt đĩa. Như vậy, ta có bức tranh hoàn chỉnh về <strong>I/O time</strong> (thời gian I/O): đầu tiên là <strong>seek</strong>, sau đó là <strong>rotational delay</strong>, và cuối cùng là <strong>transfer</strong>.</p>
<h3 id="một-số-chi-tiết-khác"><a class="header" href="#một-số-chi-tiết-khác">Một số chi tiết khác</a></h3>
<p>Mặc dù chúng ta sẽ không đi quá sâu, nhưng có một số chi tiết thú vị khác về cách ổ đĩa cứng hoạt động:</p>
<ul>
<li>Nhiều ổ đĩa sử dụng một dạng <strong>track skew</strong> (độ lệch track) để đảm bảo rằng các thao tác đọc tuần tự (sequential read) có thể được phục vụ chính xác ngay cả khi vượt qua ranh giới giữa các track. Trong ổ đĩa ví dụ đơn giản của chúng ta, điều này có thể trông như trong <strong>Hình 37.4</strong>.</li>
</ul>
<p><img src="37/img/fig37_4.PNG" alt="" /></p>
<p><strong>Hình 37.4: Ba track với track skew bằng 2</strong></p>
<p>Các sector thường được sắp xếp lệch như vậy vì khi chuyển từ track này sang track khác, ổ đĩa cần thời gian để định vị lại đầu đọc/ghi (ngay cả khi chỉ sang track liền kề). Nếu không có skew, khi đầu đọc/ghi được chuyển sang track tiếp theo, block mong muốn có thể đã quay qua mất, khiến ổ đĩa phải chờ gần như toàn bộ độ trễ quay để truy cập block tiếp theo.</p>
<ul>
<li>
<p>Một thực tế khác là các track ngoài thường có nhiều sector hơn các track trong, do yếu tố hình học — đơn giản là ở ngoài có nhiều không gian hơn. Các ổ đĩa như vậy thường được gọi là <strong>multi-zoned disk drives</strong> (ổ đĩa đa vùng), trong đó đĩa được tổ chức thành nhiều <strong>zone</strong> (vùng), mỗi vùng là một tập hợp liên tiếp các track trên một surface. Mỗi zone có cùng số sector trên mỗi track, và các zone ngoài có nhiều sector hơn các zone trong.</p>
</li>
<li>
<p>Cuối cùng, một phần quan trọng của bất kỳ ổ đĩa hiện đại nào là <strong>cache</strong> (bộ nhớ đệm), vì lý do lịch sử đôi khi được gọi là <strong>track buffer</strong>. Cache này chỉ là một lượng nhỏ bộ nhớ (thường khoảng 8 hoặc 16 MB) mà ổ đĩa có thể dùng để lưu dữ liệu đọc từ hoặc ghi xuống đĩa.<br />
Ví dụ: khi đọc một sector từ đĩa, ổ đĩa có thể quyết định đọc toàn bộ các sector trên track đó và lưu vào cache; điều này cho phép ổ đĩa phản hồi nhanh hơn với các yêu cầu tiếp theo tới cùng track.</p>
</li>
<li>
<p>Khi ghi (write), ổ đĩa có hai lựa chọn:</p>
<ol>
<li><strong>Xác nhận ghi hoàn tất</strong> khi dữ liệu đã được đưa vào bộ nhớ của nó.</li>
<li><strong>Xác nhận ghi hoàn tất</strong> chỉ sau khi dữ liệu đã thực sự được ghi xuống đĩa.</li>
</ol>
<p>Cách thứ nhất gọi là <strong>write-back caching</strong> (hoặc đôi khi là immediate reporting), cách thứ hai gọi là <strong>write-through</strong>. Write-back caching đôi khi khiến ổ đĩa trông “nhanh hơn”, nhưng có thể nguy hiểm; nếu file system hoặc ứng dụng yêu cầu dữ liệu phải được ghi xuống đĩa theo một thứ tự nhất định để đảm bảo tính đúng đắn, write-back caching có thể gây ra vấn đề (hãy đọc chương về <strong>file-system journaling</strong> để biết chi tiết).</p>
</li>
</ul>
<blockquote>
<p><strong>ASIDE: PHÂN TÍCH KÍCH THƯỚC (DIMENSIONAL ANALYSIS)</strong><br />
Bạn còn nhớ trong lớp Hóa học, cách mà bạn giải hầu hết mọi bài toán chỉ bằng cách thiết lập các đơn vị sao cho chúng triệt tiêu lẫn nhau, và bằng cách nào đó câu trả lời xuất hiện? “Phép màu” hóa học đó có tên gọi “cao siêu” là <strong>dimensional analysis</strong> (phân tích kích thước), và hóa ra nó cũng hữu ích trong phân tích hệ thống máy tính.</p>
<p>Hãy làm một ví dụ để xem <strong>dimensional analysis</strong> hoạt động thế nào và tại sao nó hữu ích. Trong trường hợp này, giả sử bạn cần tính xem một vòng quay của ổ đĩa mất bao lâu, tính bằng mili-giây. Không may là bạn chỉ được cho <strong>RPM</strong> (rotations per minute – số vòng quay mỗi phút) của ổ đĩa. Giả sử chúng ta đang nói về một ổ đĩa 10K RPM (tức là quay 10.000 vòng mỗi phút). Làm thế nào để thiết lập phân tích kích thước để nhận được thời gian mỗi vòng quay tính bằng mili-giây?</p>
<p>Để làm điều đó, ta bắt đầu bằng cách đặt đơn vị mong muốn ở bên trái; trong trường hợp này, ta muốn có <strong>thời gian (ms) trên mỗi vòng quay</strong>, vì vậy ta viết:<br />
<strong>Time (ms) / Rotation</strong>.<br />
Sau đó, ta viết ra tất cả những gì mình biết, đảm bảo triệt tiêu đơn vị khi có thể. Đầu tiên, ta có:<br />
<strong>1 minute / 10,000 Rotations</strong> (giữ “rotation” ở mẫu số, vì nó cũng ở mẫu số bên trái), sau đó đổi phút sang giây: <strong>60 seconds / 1 minute</strong>, và cuối cùng đổi giây sang mili-giây: <strong>1000 ms / 1 second</strong>.<br />
Kết quả cuối cùng (với các đơn vị được triệt tiêu gọn gàng) là:</p>
<pre><code>Time (ms) / Rot. = (1 minute / 10,000 Rot.) * (60 seconds / 1 minute) * (1000 ms / 1 second)
Time (ms) / Rot. = 60,000 ms / 10,000 Rot. = 6 ms / Rot.
</code></pre>
<p>Như bạn thấy từ ví dụ này, <strong>dimensional analysis</strong> biến điều tưởng chừng trực giác thành một quy trình đơn giản và có thể lặp lại. Ngoài phép tính RPM ở trên, nó còn hữu ích thường xuyên trong phân tích I/O.<br />
Ví dụ: bạn thường được cho tốc độ truyền của một ổ đĩa, chẳng hạn <strong>100 MB/second</strong>, và được hỏi: mất bao lâu để truyền một block 512 KB (tính bằng mili-giây)? Với <strong>dimensional analysis</strong>, điều này rất dễ:</p>
<pre><code>Time (ms) / Request = (1 Request / 512 KB) * (1 MB / 100 MB/second) * (1024 KB / 1 MB) * (1000 ms / 1 second)
Time (ms) / Request = (512 * 1024 * 1000) / (100 * 1024) = 5.12 ms (xấp xỉ, bản gốc có sai số nhỏ trong phép tính)
</code></pre>
</blockquote>
<h2 id="374-thời-gian-io-thực-hiện-phép-tính-io-time-doing-the-math"><a class="header" href="#374-thời-gian-io-thực-hiện-phép-tính-io-time-doing-the-math">37.4 Thời gian I/O: Thực hiện phép tính (I/O Time: Doing The Math)</a></h2>
<p>Bây giờ, khi đã có một mô hình trừu tượng về ổ đĩa, chúng ta có thể sử dụng một chút phân tích để hiểu rõ hơn về hiệu năng của ổ đĩa. Cụ thể, chúng ta có thể biểu diễn <strong>thời gian I/O</strong> như tổng của ba thành phần chính:</p>
<p>[
T_{I/O} = T_{seek} + T_{rotation} + T_{transfer} \tag{37.1}
]</p>
<p>Lưu ý rằng <strong>tốc độ I/O</strong> ((R_{I/O})), thường dễ sử dụng hơn để so sánh giữa các ổ đĩa (như chúng ta sẽ làm bên dưới), có thể dễ dàng tính từ thời gian. Chỉ cần chia kích thước dữ liệu truyền cho thời gian thực hiện:</p>
<p>[
R_{I/O} = \frac{Size_{Transfer}}{T_{I/O}} \tag{37.2}
]</p>
<p>Để cảm nhận rõ hơn về thời gian I/O, hãy thực hiện phép tính sau. Giả sử có hai loại <strong>workload</strong> (khối lượng công việc) mà chúng ta quan tâm:</p>
<ol>
<li><strong>Random workload</strong>: phát ra các yêu cầu đọc nhỏ (ví dụ: 4KB) tới các vị trí ngẫu nhiên trên ổ đĩa. Loại workload ngẫu nhiên này phổ biến trong nhiều ứng dụng quan trọng, bao gồm cả <strong>database management systems</strong> (hệ quản trị cơ sở dữ liệu).</li>
<li><strong>Sequential workload</strong>: chỉ đơn giản đọc một số lượng lớn sector liên tiếp từ ổ đĩa, không nhảy lung tung. Mẫu truy cập tuần tự này cũng rất phổ biến và quan trọng.</li>
</ol>
<p>Để hiểu sự khác biệt về hiệu năng giữa workload ngẫu nhiên và tuần tự, trước tiên chúng ta cần đưa ra một số giả định về ổ đĩa. Hãy xem xét hai ổ đĩa hiện đại của Seagate:</p>
<ul>
<li><strong>Cheetah 15K.5</strong> [S09b]: một ổ <strong>SCSI</strong> hiệu năng cao.</li>
<li><strong>Barracuda</strong> [S09a]: một ổ được thiết kế cho dung lượng lớn.</li>
</ul>
<p>Chi tiết của cả hai được thể hiện trong <strong>Hình 37.5</strong>.</p>
<p><img src="37/img/fig37_5.PNG" alt="" /></p>
<p><strong>Hình 37.5: Thông số ổ đĩa – SCSI so với SATA</strong></p>
<p>Như bạn có thể thấy, hai ổ đĩa có các đặc tính khá khác nhau, và theo nhiều cách, chúng tóm tắt khá rõ hai phân khúc quan trọng của thị trường ổ đĩa. Phân khúc thứ nhất là thị trường <strong>“high performance”</strong> (hiệu năng cao), nơi các ổ đĩa được thiết kế để quay nhanh nhất có thể, đạt thời gian seek thấp và truyền dữ liệu nhanh. Phân khúc thứ hai là thị trường <strong>“capacity”</strong> (dung lượng), nơi chi phí trên mỗi byte là yếu tố quan trọng nhất; do đó, các ổ đĩa này chậm hơn nhưng lưu trữ được nhiều bit nhất có thể trong không gian sẵn có.</p>
<p>Từ các con số này, chúng ta có thể bắt đầu tính toán hiệu năng của các ổ đĩa dưới hai loại <strong>workload</strong> (khối lượng công việc) đã nêu ở trên. Hãy bắt đầu với <strong>random workload</strong>. Giả sử mỗi lần đọc 4 KB xảy ra tại một vị trí ngẫu nhiên trên đĩa, ta có thể tính thời gian cho mỗi lần đọc như vậy. Với ổ <strong>Cheetah</strong>:</p>
<pre><code>Tseek = 4 ms, Trotation = 2 ms, Ttransfer = 30 microseconds
</code></pre>
<p>(37.3)</p>
<p>Thời gian seek trung bình (4 mili-giây) được lấy từ thông số trung bình do nhà sản xuất công bố; lưu ý rằng một lần seek toàn phần (từ một đầu bề mặt đến đầu kia) có thể mất gấp hai hoặc ba lần thời gian này. Độ trễ quay trung bình được tính trực tiếp từ RPM. 15000 RPM tương đương 250 RPS (rotations per second – vòng quay mỗi giây); do đó, mỗi vòng quay mất 4 ms. Trung bình, ổ đĩa sẽ phải chờ nửa vòng quay, tức khoảng 2 ms. Cuối cùng, thời gian truyền dữ liệu chỉ đơn giản là kích thước dữ liệu chia cho tốc độ truyền tối đa; ở đây nó rất nhỏ (30 micro-giây; lưu ý rằng cần 1000 micro-giây mới được 1 mili-giây!).</p>
<p>Do đó, từ phương trình ở trên, (T_{I/O}) cho Cheetah xấp xỉ 6 ms. Để tính tốc độ I/O ((R_{I/O})), ta chỉ cần chia kích thước dữ liệu truyền cho thời gian trung bình, và thu được (R_{I/O}) cho Cheetah dưới random workload vào khoảng <strong>0,66 MB/s</strong>. Cùng phép tính cho Barracuda cho ra (T_{I/O}) khoảng <strong>13,2 ms</strong> (chậm hơn hơn gấp đôi), và tốc độ khoảng <strong>0,31 MB/s</strong>.</p>
<p>Bây giờ hãy xem <strong>sequential workload</strong>. Ở đây, ta có thể giả định chỉ có một lần seek và quay trước khi thực hiện một lần truyền dữ liệu rất dài. Để đơn giản, giả sử kích thước dữ liệu truyền là 100 MB. Khi đó, (T_{I/O}) cho Cheetah và Barracuda lần lượt khoảng <strong>800 ms</strong> và <strong>950 ms</strong>. Tốc độ I/O do đó gần bằng tốc độ truyền tối đa: <strong>125 MB/s</strong> và <strong>105 MB/s</strong>. <strong>Hình 37.6</strong> tóm tắt các con số này.</p>
<blockquote>
<p><strong>TIP: SỬ DỤNG Ổ ĐĨA THEO TUẦN TỰ</strong><br />
Khi có thể, hãy truyền dữ liệu tới và từ ổ đĩa theo cách tuần tự. Nếu không thể tuần tự, ít nhất hãy nghĩ đến việc truyền dữ liệu theo các khối lớn: càng lớn càng tốt. Nếu I/O được thực hiện thành các mảnh nhỏ ngẫu nhiên, hiệu năng I/O sẽ giảm nghiêm trọng. Người dùng sẽ chịu khổ. Và bạn cũng sẽ chịu khổ, khi biết rằng mình đã gây ra nỗi khổ đó với những thao tác I/O ngẫu nhiên bất cẩn.</p>
</blockquote>
<p><img src="37/img/fig37_6.PNG" alt="" /></p>
<p><strong>Hình 37.6: Hiệu năng ổ đĩa – SCSI so với SATA</strong><br />
|                   | Cheetah       | Barracuda |
| :---------------- | :------------ | :-------- |
| RI/O Random       | 0.66 MB/s     | 0.31 MB/s |
| RI/O Sequential   | 125 MB/s      | 105 MB/s  |</p>
<p>Bảng trên cho thấy một số điểm quan trọng. Thứ nhất, và quan trọng nhất, là khoảng cách rất lớn về hiệu năng giữa random workload và sequential workload — gần 200 lần đối với Cheetah và hơn 300 lần đối với Barracuda. Và từ đó, chúng ta rút ra một lời khuyên thiết kế hiển nhiên nhất trong lịch sử ngành máy tính.</p>
<p>Điểm thứ hai, tinh tế hơn: có sự khác biệt lớn về hiệu năng giữa các ổ “performance” cao cấp và các ổ “capacity” giá rẻ. Vì lý do này (và nhiều lý do khác), mọi người thường sẵn sàng trả giá cao cho loại thứ nhất, trong khi cố gắng mua loại thứ hai với giá rẻ nhất có thể.</p>
<blockquote>
<p><strong>ASIDE: TÍNH “SEEK” TRUNG BÌNH</strong><br />
Trong nhiều sách và bài báo, bạn sẽ thấy thời gian seek trung bình của ổ đĩa được trích dẫn là xấp xỉ một phần ba thời gian seek toàn phần. Điều này đến từ đâu?</p>
<p>Hóa ra nó xuất phát từ một phép tính đơn giản dựa trên <strong>khoảng cách seek trung bình</strong>, không phải thời gian. Hãy hình dung ổ đĩa như một tập hợp các track, từ 0 đến N. Khoảng cách seek giữa hai track x và y được tính là giá trị tuyệt đối của hiệu số giữa chúng: (|x − y|).</p>
<p>Để tính khoảng cách seek trung bình, trước tiên bạn chỉ cần cộng tất cả các khoảng cách seek có thể:</p>
<pre><code>SUM(x=0 to N) SUM(y=0 to N) |x - y|   (37.4)
</code></pre>
<p>Sau đó, chia cho số lượng seek có thể có: (N^2). Để tính tổng, ta dùng dạng tích phân:</p>
<pre><code>Integral(x=0 to N) Integral(y=0 to N) |x - y| dy dx   (37.5)
</code></pre>
<p>Để tính tích phân bên trong, ta tách giá trị tuyệt đối:</p>
<pre><code>Integral(y=0 to x) (x - y) dy + Integral(y=x to N) (y - x) dy   (37.6)
</code></pre>
<p>Giải ra được ((xy − (1/2)y^2)) từ 0 đến x cộng với (((1/2)y^2 − xy)) từ x đến N, có thể rút gọn thành ((x^2 − Nx + (1/2)N^2)). Bây giờ ta tính tích phân bên ngoài:</p>
<pre><code>Integral(x=0 to N) (x^2 − Nx + (1/2)N^2) dx   (37.7)
</code></pre>
<p>Kết quả là:</p>
<pre><code>(1/3)x^3 − (1/2)Nx^2 + (1/2)N^2x từ 0 đến N
(1/3)N^3 − (1/2)N^3 + (1/2)N^3 = (1/3)N^3   (37.8)
</code></pre>
<p>Nhớ rằng ta vẫn phải chia cho tổng số seek ((N^2)) để tính khoảng cách seek trung bình: (((1/3)N^3) / N^2 = (1/3)N).<br />
Do đó, khoảng cách seek trung bình trên một ổ đĩa, xét trên tất cả các seek có thể, là <strong>một phần ba khoảng cách toàn phần</strong>. Và bây giờ, khi nghe rằng seek trung bình bằng một phần ba seek toàn phần, bạn sẽ biết nó đến từ đâu.</p>
</blockquote>
<h2 id="375-lập-lịch-đĩa-disk-scheduling"><a class="header" href="#375-lập-lịch-đĩa-disk-scheduling">37.5 Lập lịch đĩa (Disk Scheduling)</a></h2>
<p>Do chi phí I/O cao, hệ điều hành (OS) từ trước đến nay luôn đóng vai trò trong việc quyết định thứ tự các yêu cầu I/O được gửi tới ổ đĩa. Cụ thể hơn, khi có một tập hợp các yêu cầu I/O, <strong>disk scheduler</strong> (bộ lập lịch đĩa) sẽ xem xét các yêu cầu và quyết định yêu cầu nào sẽ được lập lịch tiếp theo [SCO90, JW91].</p>
<p>Không giống như <strong>job scheduling</strong> (lập lịch công việc), nơi thời lượng của mỗi job thường không được biết trước, với <strong>disk scheduling</strong>, ta có thể ước lượng khá tốt thời gian một “job” (tức là một yêu cầu đĩa) sẽ mất. Bằng cách ước lượng <strong>seek time</strong> (thời gian tìm kiếm) và <strong>rotational delay</strong> (độ trễ quay) có thể xảy ra của một yêu cầu, disk scheduler có thể biết mỗi yêu cầu sẽ mất bao lâu, và do đó (theo cách tham lam) chọn yêu cầu mất ít thời gian nhất để phục vụ trước. Vì vậy, disk scheduler sẽ cố gắng tuân theo nguyên tắc <strong>SJF</strong> (shortest job first – công việc ngắn nhất trước) trong hoạt động của mình.</p>
<h3 id="sstf-shortest-seek-time-first"><a class="header" href="#sstf-shortest-seek-time-first">SSTF: Shortest Seek Time First</a></h3>
<p>Một phương pháp lập lịch đĩa sớm được biết đến là <strong>shortest-seek-time-first</strong> (SSTF) (còn gọi là <strong>shortest-seek-first</strong> hoặc <strong>SSF</strong>). SSTF sắp xếp hàng đợi các yêu cầu I/O theo track, chọn các yêu cầu trên track gần nhất để hoàn thành trước.<br />
Ví dụ: giả sử vị trí hiện tại của đầu đọc/ghi (head) đang ở track trong cùng, và chúng ta có các yêu cầu cho sector 21 (track giữa) và sector 2 (track ngoài cùng), khi đó ta sẽ xử lý yêu cầu tới sector 21 trước, chờ hoàn tất, rồi mới xử lý yêu cầu tới sector 2 (<strong>Hình 37.7</strong>).</p>
<p><img src="37/img/fig37_7.PNG" alt="" /></p>
<p><strong>Hình 37.7: SSTF – Lập lịch các yêu cầu 21 và 2</strong></p>
<p>SSTF hoạt động tốt trong ví dụ này, tìm tới track giữa trước rồi tới track ngoài cùng. Tuy nhiên, SSTF không phải là “thuốc chữa bách bệnh”, vì các lý do sau:</p>
<ul>
<li>Thứ nhất, <strong>drive geometry</strong> (hình học của ổ đĩa) không được cung cấp cho OS; thay vào đó, OS chỉ thấy một mảng các block. May mắn là vấn đề này khá dễ khắc phục: thay vì SSTF, OS có thể triển khai <strong>nearest-block-first</strong> (NBF), lập lịch yêu cầu có địa chỉ block gần nhất tiếp theo.</li>
<li>Vấn đề thứ hai mang tính cơ bản hơn: <strong>starvation</strong> (đói tài nguyên). Hãy tưởng tượng trong ví dụ trên, nếu có một luồng yêu cầu liên tục tới track trong cùng (nơi head đang ở), thì các yêu cầu tới các track khác sẽ bị bỏ qua hoàn toàn nếu dùng SSTF thuần túy.</li>
</ul>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ XỬ LÝ STARVATION TRÊN Ổ ĐĨA</strong><br />
Làm thế nào để triển khai lập lịch kiểu SSTF nhưng tránh được starvation?</p>
</blockquote>
<h3 id="elevator-còn-gọi-là-scan-hoặc-c-scan"><a class="header" href="#elevator-còn-gọi-là-scan-hoặc-c-scan">Elevator (còn gọi là SCAN hoặc C-SCAN)</a></h3>
<p>Câu trả lời cho vấn đề này đã được phát triển từ lâu (xem [CKR72] chẳng hạn) và khá đơn giản. Thuật toán, ban đầu gọi là <strong>SCAN</strong>, chỉ đơn giản di chuyển qua lại trên ổ đĩa, phục vụ các yêu cầu theo thứ tự trên các track. Ta gọi một lần quét toàn bộ ổ đĩa (từ track ngoài vào track trong, hoặc ngược lại) là một <strong>sweep</strong>. Do đó, nếu một yêu cầu tới một block trên track đã được phục vụ trong sweep hiện tại, nó sẽ không được xử lý ngay, mà sẽ được đưa vào hàng đợi để xử lý ở sweep tiếp theo (theo hướng ngược lại).</p>
<p>SCAN có một số biến thể, tất cả đều hoạt động tương tự. Ví dụ, Coffman và cộng sự giới thiệu <strong>F-SCAN</strong>, đóng băng hàng đợi cần phục vụ khi đang thực hiện một sweep [CKR72]; các yêu cầu đến trong khi sweep đang diễn ra sẽ được đưa vào hàng đợi để xử lý sau. Cách này tránh starvation cho các yêu cầu ở xa, bằng cách trì hoãn xử lý các yêu cầu đến muộn nhưng ở gần.</p>
<p><strong>C-SCAN</strong> là một biến thể phổ biến khác, viết tắt của <strong>Circular SCAN</strong>. Thay vì quét theo cả hai hướng, thuật toán chỉ quét từ ngoài vào trong, rồi “reset” về track ngoài cùng để bắt đầu lại. Cách này công bằng hơn cho các track ngoài và trong, vì SCAN thuần túy ưu tiên các track giữa (sau khi phục vụ track ngoài, SCAN sẽ đi qua track giữa hai lần trước khi quay lại track ngoài).</p>
<p>Vì lý do này, thuật toán SCAN (và các biến thể) đôi khi được gọi là <strong>elevator algorithm</strong> (thuật toán thang máy), vì nó hoạt động giống như một thang máy chỉ đi lên hoặc đi xuống, chứ không phục vụ các tầng chỉ dựa trên việc tầng nào gần hơn. Hãy tưởng tượng bạn đang đi xuống từ tầng 10 xuống tầng 1, và ai đó ở tầng 3 bấm tầng 4, và thang máy lại đi lên tầng 4 vì nó “gần” hơn tầng 1! Trong thực tế, elevator algorithm giúp tránh những tình huống khó chịu như vậy; còn trong ổ đĩa, nó giúp tránh starvation.</p>
<p>Tuy nhiên, SCAN và các biến thể không phải là công nghệ lập lịch tốt nhất. Đặc biệt, SCAN (hoặc thậm chí SSTF) không tuân thủ nguyên tắc SJF một cách chặt chẽ nhất có thể, vì chúng <strong>bỏ qua yếu tố rotation</strong>. Và do đó, một vấn đề trọng tâm khác xuất hiện:</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ TÍNH ĐẾN CHI PHÍ QUAY CỦA Ổ ĐĨA</strong><br />
Làm thế nào để triển khai một thuật toán gần với SJF hơn bằng cách tính cả seek và rotation?</p>
</blockquote>
<h3 id="sptf-shortest-positioning-time-first"><a class="header" href="#sptf-shortest-positioning-time-first">SPTF: Shortest Positioning Time First</a></h3>
<p>Trước khi thảo luận về <strong>shortest positioning time first</strong> (SPTF) (đôi khi còn gọi là <strong>shortest access time first</strong> hoặc SATF) – giải pháp cho vấn đề trên – hãy đảm bảo rằng chúng ta hiểu rõ vấn đề. <strong>Hình 37.8</strong> đưa ra một ví dụ.</p>
<p>Trong ví dụ, head hiện đang ở sector 30 trên track trong cùng. Bộ lập lịch phải quyết định: nên lập lịch sector 16 (trên track giữa) hay sector 8 (trên track ngoài cùng) cho yêu cầu tiếp theo? Vậy nên phục vụ yêu cầu nào trước?</p>
<p>Câu trả lời, tất nhiên, là <strong>“còn tùy”</strong>. Trong kỹ thuật, “còn tùy” gần như luôn là câu trả lời, phản ánh rằng các đánh đổi (trade-off) là một phần tất yếu trong công việc của kỹ sư; đây cũng là một câu trả lời “an toàn” khi bạn chưa biết câu trả lời cho câu hỏi của sếp. Tuy nhiên, gần như luôn tốt hơn nếu biết <strong>tại sao</strong> lại “còn tùy”, và đó là điều chúng ta sẽ bàn ở đây.</p>
<p>Điều mà nó “tùy” ở đây là <strong>tương quan giữa thời gian seek và thời gian quay</strong>. Nếu, trong ví dụ này, thời gian seek lớn hơn nhiều so với độ trễ quay, thì SSTF (và các biến thể) là đủ tốt. Tuy nhiên, hãy tưởng tượng nếu seek nhanh hơn đáng kể so với rotation. Khi đó, trong ví dụ này, sẽ hợp lý hơn nếu seek xa hơn để phục vụ yêu cầu 8 trên track ngoài cùng, thay vì thực hiện seek ngắn hơn tới track giữa để phục vụ yêu cầu 16, vốn phải quay gần như cả vòng mới đi qua dưới đầu đọc/ghi.</p>
<p><img src="37/img/fig37_8.PNG" alt="" /></p>
<p><strong>Hình 37.8: SSTF – Đôi khi là chưa đủ tốt</strong></p>
<blockquote>
<p><strong>TIP: LUÔN LUÔN “CÒN TÙY” (ĐỊNH LUẬT CỦA LIVNY)</strong><br />
Hầu như bất kỳ câu hỏi nào cũng có thể trả lời bằng “còn tùy”, như đồng nghiệp của chúng tôi, Miron Livny, vẫn thường nói. Tuy nhiên, hãy sử dụng một cách thận trọng, vì nếu bạn trả lời quá nhiều câu hỏi theo cách này, mọi người sẽ ngừng hỏi bạn luôn. Ví dụ, ai đó hỏi: “Muốn đi ăn trưa không?” Bạn trả lời: “Còn tùy, bạn có đi cùng không?”</p>
</blockquote>
<p>Trên các ổ đĩa hiện đại, như chúng ta đã thấy ở trên, cả <strong>seek</strong> (tìm kiếm) và <strong>rotation</strong> (quay) đều có thời gian gần tương đương nhau (tất nhiên còn tùy thuộc vào yêu cầu cụ thể), và do đó <strong>SPTF</strong> (Shortest Positioning Time First) là hữu ích và cải thiện hiệu năng. Tuy nhiên, việc triển khai nó trong hệ điều hành còn khó hơn, vì OS thường không biết rõ ranh giới track ở đâu hoặc đầu đọc/ghi (disk head) hiện đang ở vị trí nào (theo nghĩa quay). Do đó, SPTF thường được thực hiện bên trong ổ đĩa, như mô tả dưới đây.</p>
<h3 id="các-vấn-đề-lập-lịch-khác"><a class="header" href="#các-vấn-đề-lập-lịch-khác">Các vấn đề lập lịch khác</a></h3>
<p>Có nhiều vấn đề khác mà chúng ta không bàn sâu trong phần mô tả ngắn gọn này về hoạt động cơ bản của ổ đĩa, lập lịch và các chủ đề liên quan. Một vấn đề như vậy là: <strong>lập lịch đĩa được thực hiện ở đâu trong các hệ thống hiện đại?</strong><br />
Trong các hệ thống cũ, hệ điều hành thực hiện toàn bộ việc lập lịch; sau khi xem xét tập hợp các yêu cầu đang chờ, OS sẽ chọn yêu cầu tốt nhất và gửi nó tới ổ đĩa. Khi yêu cầu đó hoàn tất, yêu cầu tiếp theo sẽ được chọn, và cứ thế tiếp tục. Ổ đĩa khi đó đơn giản hơn, và cuộc sống cũng vậy.</p>
<p>Trong các hệ thống hiện đại, ổ đĩa có thể xử lý nhiều yêu cầu đang chờ cùng lúc, và bản thân chúng có các <strong>internal scheduler</strong> (bộ lập lịch nội bộ) tinh vi (có thể triển khai SPTF một cách chính xác; bên trong <strong>disk controller</strong> – bộ điều khiển đĩa – mọi chi tiết liên quan đều có sẵn, bao gồm cả vị trí chính xác của đầu đọc và thông tin bố trí track chi tiết). Do đó, bộ lập lịch của OS thường chọn ra một số yêu cầu mà nó cho là tốt nhất (ví dụ 16 yêu cầu) và gửi tất cả tới ổ đĩa; ổ đĩa sau đó sử dụng kiến thức nội bộ về vị trí đầu đọc và bố trí track để phục vụ các yêu cầu đó theo thứ tự tối ưu nhất (SPTF).</p>
<p>Một nhiệm vụ quan trọng khác mà bộ lập lịch đĩa thực hiện là <strong>I/O merging</strong> (gộp I/O). Ví dụ, hãy tưởng tượng một loạt yêu cầu đọc các block 33, sau đó 8, rồi 34, như trong <strong>Hình 37.8</strong>. Trong trường hợp này, bộ lập lịch nên gộp các yêu cầu cho block 33 và 34 thành một yêu cầu đọc hai block duy nhất; mọi thao tác sắp xếp lại mà bộ lập lịch thực hiện sẽ được áp dụng trên các yêu cầu đã gộp. Việc gộp đặc biệt quan trọng ở cấp OS, vì nó giảm số lượng yêu cầu gửi tới ổ đĩa và do đó giảm chi phí xử lý.</p>
<p>Một vấn đề cuối cùng mà các bộ lập lịch hiện đại xử lý là: <strong>hệ thống nên chờ bao lâu trước khi gửi một yêu cầu I/O tới ổ đĩa?</strong><br />
Có thể bạn sẽ nghĩ một cách đơn giản rằng ổ đĩa, khi có bất kỳ yêu cầu I/O nào, nên lập tức gửi yêu cầu đó tới thiết bị; cách tiếp cận này được gọi là <strong>work-conserving</strong>, vì ổ đĩa sẽ không bao giờ nhàn rỗi nếu còn yêu cầu cần xử lý. Tuy nhiên, nghiên cứu về <strong>anticipatory disk scheduling</strong> (lập lịch đĩa dự đoán) đã chỉ ra rằng đôi khi tốt hơn là nên chờ một chút [ID01], trong cách tiếp cận gọi là <strong>non-work-conserving</strong>. Bằng cách chờ, có thể sẽ xuất hiện một yêu cầu mới và “tốt hơn” tới ổ đĩa, từ đó tăng hiệu quả tổng thể. Tất nhiên, việc quyết định khi nào nên chờ và chờ bao lâu có thể rất phức tạp; hãy xem bài báo nghiên cứu để biết chi tiết, hoặc xem triển khai trong Linux kernel để thấy cách những ý tưởng này được áp dụng vào thực tế (nếu bạn là người ưa thử thách).</p>
<h2 id="376-tóm-tắt"><a class="header" href="#376-tóm-tắt">37.6 Tóm tắt</a></h2>
<p>Chúng ta đã trình bày một bản tóm tắt về cách ổ đĩa hoạt động. Bản tóm tắt này thực chất là một <strong>mô hình chức năng chi tiết</strong>; nó không mô tả những yếu tố vật lý, điện tử và khoa học vật liệu tuyệt vời được áp dụng trong thiết kế ổ đĩa thực tế.<br />
Nếu bạn quan tâm đến những chi tiết sâu hơn về các khía cạnh này, có lẽ bạn nên chọn một chuyên ngành (hoặc chuyên ngành phụ) khác; còn nếu bạn hài lòng với mô hình này, thì tốt! Giờ đây, chúng ta có thể tiếp tục sử dụng mô hình này để xây dựng những hệ thống thú vị hơn dựa trên các thiết bị tuyệt vời này.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="38-mảng-đĩa-dư-thừa-giá-rẻ-redundant-arrays-of-inexpensive-disks--raids"><a class="header" href="#38-mảng-đĩa-dư-thừa-giá-rẻ-redundant-arrays-of-inexpensive-disks--raids">38 Mảng đĩa dư thừa giá rẻ (Redundant Arrays of Inexpensive Disks – RAIDs)</a></h1>
<p>Khi sử dụng một ổ đĩa, đôi khi chúng ta muốn nó <strong>nhanh hơn</strong>; các thao tác I/O vốn chậm và có thể trở thành <strong>nút thắt cổ chai</strong> cho toàn bộ hệ thống. Khi sử dụng một ổ đĩa, đôi khi chúng ta muốn nó <strong>lớn hơn</strong>; ngày càng nhiều dữ liệu được đưa lên môi trường trực tuyến, và do đó ổ đĩa của chúng ta ngày càng đầy. Khi sử dụng một ổ đĩa, đôi khi chúng ta muốn nó <strong>đáng tin cậy hơn</strong>; khi một ổ đĩa bị hỏng, nếu dữ liệu của chúng ta không được sao lưu, toàn bộ dữ liệu quý giá đó sẽ mất.</p>
<blockquote>
<p><strong>CRUX: LÀM THẾ NÀO ĐỂ TẠO MỘT Ổ ĐĨA LỚN, NHANH VÀ ĐÁNG TIN CẬY</strong><br />
Làm thế nào để xây dựng một hệ thống lưu trữ vừa lớn, vừa nhanh, vừa đáng tin cậy? Các kỹ thuật then chốt là gì? Những đánh đổi (trade-off) giữa các cách tiếp cận khác nhau ra sao?</p>
</blockquote>
<p>Trong chương này, chúng ta giới thiệu <strong>Redundant Array of Inexpensive Disks</strong> – thường được biết đến với tên <strong>RAID</strong> [P+88], một kỹ thuật sử dụng nhiều ổ đĩa phối hợp với nhau để xây dựng một hệ thống đĩa nhanh hơn, lớn hơn và đáng tin cậy hơn. Thuật ngữ này được giới thiệu vào cuối những năm 1980 bởi một nhóm nghiên cứu tại Đại học California, Berkeley (dẫn đầu bởi các Giáo sư David Patterson và Randy Katz, cùng nghiên cứu sinh khi đó là Garth Gibson); vào thời điểm đó, nhiều nhóm nghiên cứu khác nhau cũng đồng thời đưa ra ý tưởng cơ bản về việc sử dụng nhiều ổ đĩa để xây dựng một hệ thống lưu trữ tốt hơn [BG88, K86, K88, PB86, SG86].</p>
<p>Về <strong>bên ngoài</strong>, một RAID trông giống như một ổ đĩa: một tập hợp các block có thể đọc hoặc ghi. Về <strong>bên trong</strong>, RAID là một cấu trúc phức tạp, bao gồm nhiều ổ đĩa, bộ nhớ (cả volatile và non-volatile), và một hoặc nhiều bộ xử lý để quản lý hệ thống. Một <strong>hardware RAID</strong> (RAID phần cứng) rất giống một hệ thống máy tính, nhưng được chuyên biệt hóa cho nhiệm vụ quản lý một nhóm ổ đĩa.</p>
<p>RAID mang lại nhiều lợi thế so với một ổ đĩa đơn:</p>
<ul>
<li><strong>Hiệu năng</strong>: Sử dụng nhiều ổ đĩa song song có thể tăng tốc đáng kể thời gian I/O.</li>
<li><strong>Dung lượng</strong>: Các tập dữ liệu lớn đòi hỏi ổ đĩa có dung lượng lớn.</li>
<li><strong>Độ tin cậy</strong>: Việc phân tán dữ liệu trên nhiều ổ đĩa (mà không có kỹ thuật RAID) khiến dữ liệu dễ bị mất khi một ổ đĩa hỏng; với một số dạng <strong>redundancy</strong> (dư thừa), RAID có thể chịu được việc mất một ổ đĩa và vẫn tiếp tục hoạt động như không có vấn đề gì.</li>
</ul>
<blockquote>
<p><strong>TIP: TÍNH MINH BẠCH GIÚP TRIỂN KHAI DỄ DÀNG</strong><br />
Khi xem xét cách bổ sung chức năng mới cho một hệ thống, ta nên cân nhắc liệu chức năng đó có thể được thêm vào một cách <strong>minh bạch</strong> hay không, tức là không đòi hỏi thay đổi gì ở phần còn lại của hệ thống. Việc yêu cầu viết lại toàn bộ phần mềm hiện có (hoặc thay đổi phần cứng lớn) sẽ làm giảm khả năng áp dụng ý tưởng. RAID là một ví dụ hoàn hảo, và chắc chắn tính minh bạch của nó đã góp phần vào thành công; quản trị viên có thể cài đặt một mảng lưu trữ RAID dựa trên SCSI thay cho một ổ SCSI đơn, và phần còn lại của hệ thống (máy chủ, hệ điều hành, v.v.) không cần thay đổi gì để bắt đầu sử dụng. Bằng cách giải quyết vấn đề triển khai này, RAID đã thành công ngay từ ngày đầu.</p>
</blockquote>
<p>Điều đáng kinh ngạc là RAID cung cấp những lợi thế này <strong>một cách minh bạch</strong> đối với các hệ thống sử dụng nó, tức là một RAID chỉ đơn giản xuất hiện như một ổ đĩa lớn đối với hệ thống chủ. Vẻ đẹp của tính minh bạch nằm ở chỗ: bạn chỉ cần thay thế một ổ đĩa bằng một RAID mà không phải thay đổi một dòng mã phần mềm nào; hệ điều hành và các ứng dụng khách vẫn tiếp tục hoạt động mà không cần chỉnh sửa. Theo cách này, tính minh bạch cải thiện đáng kể khả năng triển khai RAID, cho phép người dùng và quản trị viên đưa RAID vào sử dụng mà không phải lo lắng về khả năng tương thích phần mềm.</p>
<p>Tiếp theo, chúng ta sẽ thảo luận một số khía cạnh quan trọng của RAID. Chúng ta bắt đầu với <strong>giao diện</strong> (interface), <strong>mô hình lỗi</strong> (fault model), và sau đó bàn về cách đánh giá một thiết kế RAID theo ba tiêu chí quan trọng: <strong>dung lượng</strong> (capacity), <strong>độ tin cậy</strong> (reliability), và <strong>hiệu năng</strong> (performance). Cuối cùng, chúng ta sẽ đề cập đến một số vấn đề khác quan trọng đối với thiết kế và triển khai RAID.</p>
<h2 id="381-giao-diện-và-cấu-trúc-bên-trong-của-raid-interface-and-raid-internals"><a class="header" href="#381-giao-diện-và-cấu-trúc-bên-trong-của-raid-interface-and-raid-internals">38.1 Giao diện và cấu trúc bên trong của RAID (Interface And RAID Internals)</a></h2>
<p>Đối với <strong>file system</strong> (hệ thống tệp) ở tầng trên, một <strong>RAID</strong> trông giống như một ổ đĩa lớn, (hy vọng là) nhanh và (hy vọng là) đáng tin cậy. Giống như một ổ đĩa đơn, nó được trình bày như một mảng tuyến tính các <strong>block</strong>, mỗi block có thể được đọc hoặc ghi bởi file system (hoặc các client khác).</p>
<p>Khi một file system gửi một yêu cầu <strong>logical I/O</strong> (I/O logic) tới RAID, bên trong RAID phải tính toán xem cần truy cập ổ đĩa (hoặc các ổ đĩa) nào để hoàn tất yêu cầu, và sau đó phát ra một hoặc nhiều <strong>physical I/O</strong> (I/O vật lý) để thực hiện. Bản chất chính xác của các I/O vật lý này phụ thuộc vào <strong>RAID level</strong> (cấp RAID), như chúng ta sẽ thảo luận chi tiết bên dưới. Tuy nhiên, như một ví dụ đơn giản, hãy xem xét một RAID lưu hai bản sao của mỗi block (mỗi bản trên một ổ đĩa riêng biệt); khi ghi vào một hệ thống RAID dạng <strong>mirrored</strong> (nhân bản), RAID sẽ phải thực hiện hai I/O vật lý cho mỗi một I/O logic được gửi tới.</p>
<p>Một hệ thống RAID thường được xây dựng như một thiết bị phần cứng riêng biệt, với kết nối tiêu chuẩn (ví dụ: <strong>SCSI</strong> hoặc <strong>SATA</strong>) tới máy chủ. Tuy nhiên, bên trong, RAID khá phức tạp, bao gồm một <strong>microcontroller</strong> (vi điều khiển) chạy <strong>firmware</strong> để điều khiển hoạt động của RAID, bộ nhớ <strong>volatile</strong> như <strong>DRAM</strong> để <strong>buffer</strong> (đệm) các block dữ liệu khi đọc và ghi, và trong một số trường hợp, bộ nhớ <strong>non-volatile</strong> để đệm ghi một cách an toàn, và thậm chí cả <strong>logic chuyên dụng</strong> để thực hiện các phép tính <strong>parity</strong> (chẵn lẻ – hữu ích trong một số cấp RAID, như chúng ta sẽ thấy bên dưới). Ở mức khái quát, một RAID rất giống một hệ thống máy tính chuyên dụng: nó có bộ xử lý, bộ nhớ và ổ đĩa; tuy nhiên, thay vì chạy các ứng dụng, nó chạy phần mềm chuyên biệt được thiết kế để vận hành RAID.</p>
<h2 id="382-mô-hình-lỗi-fault-model"><a class="header" href="#382-mô-hình-lỗi-fault-model">38.2 Mô hình lỗi (Fault Model)</a></h2>
<p>Để hiểu RAID và so sánh các cách tiếp cận khác nhau, chúng ta cần có một <strong>mô hình lỗi</strong> (fault model) trong đầu. RAID được thiết kế để phát hiện và khôi phục từ một số loại lỗi ổ đĩa nhất định; do đó, việc biết chính xác những lỗi nào cần dự đoán là rất quan trọng để đưa ra một thiết kế khả thi.</p>
<p>Mô hình lỗi đầu tiên mà chúng ta giả định khá đơn giản, và được gọi là <strong>fail-stop fault model</strong> [S84]. Trong mô hình này, một ổ đĩa chỉ có thể ở một trong hai trạng thái: <strong>working</strong> (hoạt động) hoặc <strong>failed</strong> (hỏng). Với một ổ đĩa đang hoạt động, tất cả các block có thể được đọc hoặc ghi. Ngược lại, khi một ổ đĩa bị hỏng, ta giả định rằng nó bị mất hoàn toàn và vĩnh viễn.</p>
<p>Một khía cạnh quan trọng của mô hình fail-stop là giả định về <strong>phát hiện lỗi</strong>. Cụ thể, khi một ổ đĩa bị hỏng, ta giả định rằng điều này có thể được phát hiện dễ dàng. Ví dụ, trong một mảng RAID, ta giả định rằng phần cứng (hoặc phần mềm) của <strong>RAID controller</strong> (bộ điều khiển RAID) có thể ngay lập tức nhận biết khi một ổ đĩa bị hỏng.</p>
<p>Do đó, ở thời điểm này, chúng ta chưa cần lo lắng về các lỗi “im lặng” (silent failures) phức tạp hơn như <strong>disk corruption</strong> (hỏng dữ liệu trên đĩa). Chúng ta cũng chưa cần lo về việc một block đơn lẻ trở nên không thể truy cập trên một ổ đĩa vẫn đang hoạt động (đôi khi gọi là <strong>latent sector error</strong> – lỗi sector tiềm ẩn). Chúng ta sẽ xem xét các lỗi đĩa phức tạp hơn (và đáng tiếc là thực tế hơn) này ở phần sau.</p>
<h2 id="383-cách-đánh-giá-một-raid-how-to-evaluate-a-raid"><a class="header" href="#383-cách-đánh-giá-một-raid-how-to-evaluate-a-raid">38.3 Cách đánh giá một RAID (How To Evaluate A RAID)</a></h2>
<p>Như chúng ta sẽ thấy ngay sau đây, có nhiều cách tiếp cận khác nhau để xây dựng một hệ thống RAID. Mỗi cách tiếp cận này có những đặc điểm riêng đáng để đánh giá, nhằm hiểu rõ điểm mạnh và điểm yếu của chúng.</p>
<p>Cụ thể, chúng ta sẽ đánh giá mỗi thiết kế RAID theo <strong>ba trục</strong> sau:</p>
<ul>
<li>
<p><strong>Trục thứ nhất: Dung lượng (Capacity)</strong><br />
Giả sử có một tập hợp <strong>N</strong> ổ đĩa, mỗi ổ có <strong>B</strong> block, dung lượng hữu ích mà RAID cung cấp cho client là bao nhiêu?<br />
Nếu <strong>không có redundancy</strong> (dữ liệu dự phòng), câu trả lời là ( N \cdot B ).<br />
Ngược lại, nếu hệ thống lưu hai bản sao của mỗi block (gọi là <strong>mirroring</strong> – nhân bản), dung lượng hữu ích sẽ là ( (N \cdot B) / 2 ).<br />
Các phương án khác (ví dụ: dựa trên <strong>parity</strong>) thường nằm ở khoảng giữa hai giá trị này.</p>
</li>
<li>
<p><strong>Trục thứ hai: Độ tin cậy (Reliability)</strong><br />
Thiết kế RAID có thể chịu được bao nhiêu lỗi ổ đĩa?<br />
Theo mô hình lỗi (fault model) mà chúng ta đã giả định, ta chỉ xét trường hợp <strong>một ổ đĩa hỏng hoàn toàn</strong>; ở các chương sau (ví dụ: về <strong>data integrity</strong> – tính toàn vẹn dữ liệu), chúng ta sẽ xem xét cách xử lý các dạng lỗi phức tạp hơn.</p>
</li>
<li>
<p><strong>Trục thứ ba: Hiệu năng (Performance)</strong><br />
Hiệu năng khó đánh giá hơn, vì nó phụ thuộc nhiều vào <strong>workload</strong> (khối lượng công việc) mà mảng đĩa phải xử lý.<br />
Do đó, trước khi đánh giá hiệu năng, chúng ta sẽ trình bày một tập hợp các workload điển hình cần xem xét.</p>
</li>
</ul>
<p>Tiếp theo, chúng ta sẽ xem xét ba thiết kế RAID quan trọng:</p>
<ul>
<li><strong>RAID Level 0</strong> (striping – phân dải dữ liệu)</li>
<li><strong>RAID Level 1</strong> (mirroring – nhân bản dữ liệu)</li>
<li><strong>RAID Levels 4/5</strong> (dự phòng dựa trên parity)</li>
</ul>
<p>Việc đặt tên các thiết kế này theo “level” bắt nguồn từ công trình tiên phong của Patterson, Gibson và Katz tại Berkeley [P+88].</p>
<h2 id="384-raid-level-0-striping"><a class="header" href="#384-raid-level-0-striping">38.4 RAID Level 0: Striping</a></h2>
<p>Cấp RAID đầu tiên thực ra <strong>không phải</strong> là một cấp RAID đúng nghĩa, vì nó <strong>không có redundancy</strong>. Tuy nhiên, <strong>RAID Level 0</strong>, hay còn được biết đến nhiều hơn với tên <strong>striping</strong> (phân dải dữ liệu), đóng vai trò như một <strong>giới hạn trên</strong> tuyệt vời về hiệu năng và dung lượng, và do đó rất đáng để tìm hiểu.</p>
<p>Hình thức striping đơn giản nhất sẽ phân bố các block trên các ổ đĩa của hệ thống như sau (giả sử ở đây là một mảng 4 ổ đĩa):</p>
<p>...</p>
<p><img src="38/img/fig38_1.PNG" alt="" /></p>
<p><strong>Hình 38.1: RAID-0 – Striping đơn giản</strong></p>
<p>Từ <strong>Hình 38.1</strong>, bạn có thể thấy ý tưởng cơ bản: phân tán các block của mảng dữ liệu lên các ổ đĩa theo kiểu <strong>round-robin</strong> (xoay vòng). Cách tiếp cận này được thiết kế để khai thác tối đa khả năng <strong>song song</strong> của mảng khi có các yêu cầu truy cập tới các khối dữ liệu liên tiếp (ví dụ: một thao tác đọc tuần tự lớn).<br />
Chúng ta gọi các block nằm trên cùng một hàng là một <strong>stripe</strong>; do đó, các block 0, 1, 2 và 3 ở trên thuộc cùng một stripe.</p>
<p>Trong ví dụ này, chúng ta đã đơn giản hóa bằng cách giả định rằng chỉ <strong>1 block</strong> (mỗi block giả sử có kích thước 4KB) được đặt trên mỗi ổ đĩa trước khi chuyển sang ổ tiếp theo. Tuy nhiên, cách sắp xếp này <strong>không bắt buộc</strong> phải như vậy.<br />
Ví dụ, chúng ta có thể sắp xếp các block trên các ổ đĩa như trong <strong>Hình 38.2</strong>:</p>
<p>...</p>
<p><img src="38/img/fig38_2.PNG" alt="" /></p>
<p><strong>Hình 38.2: Striping với kích thước chunk lớn hơn</strong></p>
<p>Trong ví dụ này, chúng ta đặt <strong>hai block 4KB</strong> trên mỗi ổ đĩa trước khi chuyển sang ổ tiếp theo. Do đó, <strong>chunk size</strong> (kích thước khối dữ liệu trên mỗi ổ trong một stripe) của mảng RAID này là <strong>8KB</strong>, và một stripe sẽ bao gồm <strong>4 chunk</strong>, tức <strong>32KB dữ liệu</strong>.</p>
<blockquote>
<p><strong>ASIDE: VẤN ĐỀ MAPPING TRONG RAID (THE RAID MAPPING PROBLEM)</strong><br />
Trước khi nghiên cứu các đặc tính về dung lượng, độ tin cậy và hiệu năng của RAID, trước hết chúng ta cần nói về một vấn đề gọi là <strong>mapping problem</strong> (bài toán ánh xạ).<br />
Vấn đề này xuất hiện trong tất cả các mảng RAID; nói đơn giản, khi có một <strong>logical block</strong> (block logic) cần đọc hoặc ghi, làm thế nào để RAID biết chính xác <strong>ổ đĩa vật lý</strong> và <strong>offset</strong> (vị trí) cần truy cập?</p>
<p>Với các cấp RAID đơn giản, chúng ta không cần quá nhiều sự phức tạp để ánh xạ đúng các block logic sang vị trí vật lý của chúng.<br />
Lấy ví dụ striping đầu tiên ở trên (<strong>chunk size = 1 block = 4KB</strong>). Trong trường hợp này, với một <strong>logical block address</strong> A, RAID có thể dễ dàng tính toán ổ đĩa và offset mong muốn bằng hai công thức đơn giản:</p>
<pre><code>Disk   = A % number_of_disks
Offset = A / number_of_disks
</code></pre>
<p>Lưu ý rằng đây đều là các phép toán số nguyên (ví dụ: 4 / 3 = 1 chứ không phải 1.33333...).<br />
Hãy xem các công thức này hoạt động thế nào qua một ví dụ đơn giản:<br />
Giả sử trong RAID đầu tiên ở trên, có một yêu cầu tới block 14. Với 4 ổ đĩa, điều này có nghĩa là ổ đĩa cần truy cập là (14 % 4 = 2): <strong>disk 2</strong>. Block chính xác được tính là (14 / 4 = 3): <strong>block 3</strong>.<br />
Như vậy, block 14 sẽ nằm ở <strong>block thứ tư</strong> (block 3, tính từ 0) của <strong>ổ đĩa thứ ba</strong> (disk 2, tính từ 0), và đó chính xác là vị trí của nó.</p>
<p>Bạn có thể suy nghĩ về cách các công thức này sẽ được điều chỉnh để hỗ trợ các <strong>chunk size</strong> khác nhau. Hãy thử làm! Không quá khó đâu.</p>
</blockquote>
<h3 id="kích-thước-chunk-chunk-sizes"><a class="header" href="#kích-thước-chunk-chunk-sizes">Kích thước chunk (Chunk Sizes)</a></h3>
<p><strong>Chunk size</strong> (kích thước khối dữ liệu trên mỗi ổ trong một stripe) chủ yếu ảnh hưởng đến <strong>hiệu năng</strong> của mảng đĩa.<br />
Ví dụ, một chunk size nhỏ có nghĩa là nhiều tệp sẽ được <strong>striped</strong> (phân dải) trên nhiều ổ đĩa, từ đó <strong>tăng mức độ song song</strong> của các thao tác đọc và ghi đối với một tệp duy nhất; tuy nhiên, <strong>thời gian định vị</strong> (positioning time) để truy cập các block trên nhiều ổ đĩa sẽ tăng lên, vì thời gian định vị cho toàn bộ yêu cầu được xác định bởi <strong>giá trị lớn nhất</strong> của thời gian định vị trong số các yêu cầu trên tất cả các ổ.</p>
<p>Ngược lại, một chunk size lớn sẽ <strong>giảm mức độ song song trong nội bộ tệp</strong> (intra-file parallelism), và do đó phụ thuộc vào nhiều yêu cầu đồng thời để đạt được <strong>throughput</strong> (băng thông) cao. Tuy nhiên, chunk size lớn lại <strong>giảm thời gian định vị</strong>; ví dụ, nếu một tệp vừa khít trong một chunk và do đó được đặt trên một ổ đĩa duy nhất, thời gian định vị khi truy cập nó sẽ chỉ là thời gian định vị của một ổ đĩa.</p>
<p>Vì vậy, việc xác định <strong>chunk size “tối ưu”</strong> là rất khó, vì nó đòi hỏi phải có nhiều kiến thức về <strong>workload</strong> (khối lượng công việc) mà hệ thống đĩa phải xử lý [CL95]. Trong phần còn lại của thảo luận này, chúng ta sẽ giả định rằng mảng đĩa sử dụng chunk size bằng <strong>một block</strong> (4KB). Hầu hết các mảng đĩa thực tế sử dụng chunk size lớn hơn (ví dụ: 64KB), nhưng đối với các vấn đề chúng ta bàn dưới đây, chunk size chính xác không quan trọng; do đó, chúng ta dùng một block để đơn giản hóa.</p>
<h3 id="quay-lại-phân-tích-raid-0-back-to-raid-0-analysis"><a class="header" href="#quay-lại-phân-tích-raid-0-back-to-raid-0-analysis">Quay lại phân tích RAID-0 (Back To RAID-0 Analysis)</a></h3>
<p>Bây giờ, hãy đánh giá <strong>dung lượng</strong>, <strong>độ tin cậy</strong> và <strong>hiệu năng</strong> của striping.</p>
<ul>
<li><strong>Dung lượng</strong>: Hoàn hảo – với N ổ đĩa, mỗi ổ có dung lượng B block, striping cung cấp ( N \cdot B ) block dung lượng hữu ích.</li>
<li><strong>Độ tin cậy</strong>: Cũng “hoàn hảo” nhưng theo nghĩa xấu – bất kỳ lỗi hỏng ổ đĩa nào cũng sẽ dẫn đến mất dữ liệu.</li>
<li><strong>Hiệu năng</strong>: Xuất sắc – tất cả các ổ đĩa đều được sử dụng, thường là song song, để phục vụ các yêu cầu I/O của người dùng.</li>
</ul>
<h3 id="Đánh-giá-hiệu-năng-raid-evaluating-raid-performance"><a class="header" href="#Đánh-giá-hiệu-năng-raid-evaluating-raid-performance">Đánh giá hiệu năng RAID (Evaluating RAID Performance)</a></h3>
<p>Khi phân tích hiệu năng RAID, ta có thể xem xét <strong>hai chỉ số hiệu năng</strong> khác nhau:</p>
<ol>
<li><strong>Single-request latency</strong> (độ trễ của một yêu cầu đơn lẻ): Hiểu được độ trễ của một yêu cầu I/O đơn tới RAID giúp ta biết được mức độ song song có thể đạt được trong một thao tác I/O logic duy nhất.</li>
<li><strong>Steady-state throughput</strong> (băng thông trạng thái ổn định) của RAID: tức tổng băng thông khi có nhiều yêu cầu đồng thời. Vì RAID thường được sử dụng trong các môi trường hiệu năng cao, băng thông trạng thái ổn định là yếu tố <strong>then chốt</strong>, và sẽ là trọng tâm chính trong các phân tích của chúng ta.</li>
</ol>
<p>Để hiểu rõ hơn về throughput, chúng ta cần đưa ra một số <strong>workload</strong> tiêu biểu. Trong phần này, chúng ta giả định có hai loại workload:</p>
<ul>
<li>
<p><strong>Sequential workload</strong> (tải tuần tự): Các yêu cầu tới mảng đĩa đến dưới dạng các khối dữ liệu liên tiếp lớn.<br />
Ví dụ: một yêu cầu (hoặc chuỗi yêu cầu) truy cập 1 MB dữ liệu, bắt đầu tại block x và kết thúc tại block (x + 1 MB), sẽ được coi là tuần tự.<br />
Workload tuần tự rất phổ biến trong nhiều môi trường (hãy nghĩ đến việc tìm kiếm một từ khóa trong một tệp lớn), và do đó được coi là quan trọng.</p>
</li>
<li>
<p><strong>Random workload</strong> (tải ngẫu nhiên): Mỗi yêu cầu tương đối nhỏ, và mỗi yêu cầu tới một vị trí ngẫu nhiên khác nhau trên đĩa.<br />
Ví dụ: một luồng yêu cầu ngẫu nhiên có thể truy cập 4KB tại địa chỉ logic 10, sau đó tại địa chỉ 550.000, rồi tại 20.100, v.v.<br />
Một số workload quan trọng, chẳng hạn như <strong>transactional workload</strong> (tải giao dịch) trên <strong>database management system</strong> (DBMS – hệ quản trị cơ sở dữ liệu), thể hiện kiểu truy cập này, và do đó cũng được coi là quan trọng.</p>
</li>
</ul>
<p>Tất nhiên, <strong>workload</strong> (khối lượng công việc) thực tế không đơn giản như vậy, và thường bao gồm sự pha trộn giữa các thành phần <strong>sequential</strong> (tuần tự) và <strong>random-seeming</strong> (có vẻ ngẫu nhiên), cũng như các hành vi nằm ở khoảng giữa hai loại này. Để đơn giản, chúng ta chỉ xét hai khả năng này.</p>
<p>Như bạn có thể thấy, <strong>sequential workload</strong> và <strong>random workload</strong> sẽ tạo ra các đặc tính hiệu năng rất khác nhau đối với một ổ đĩa.</p>
<ul>
<li>Với <strong>sequential access</strong> (truy cập tuần tự), ổ đĩa hoạt động ở chế độ hiệu quả nhất, dành ít thời gian cho <strong>seek</strong> (tìm kiếm) và chờ quay (<strong>rotational delay</strong>), và phần lớn thời gian để truyền dữ liệu (<strong>transfer</strong>).</li>
<li>Với <strong>random access</strong> (truy cập ngẫu nhiên), điều ngược lại xảy ra: phần lớn thời gian dành cho seek và chờ quay, và chỉ một phần nhỏ thời gian để truyền dữ liệu.</li>
</ul>
<p>Để phản ánh sự khác biệt này trong phân tích, chúng ta giả định rằng một ổ đĩa có thể truyền dữ liệu với tốc độ <strong>S MB/s</strong> khi xử lý sequential workload, và <strong>R MB/s</strong> khi xử lý random workload. Nói chung, <strong>S</strong> lớn hơn rất nhiều so với <strong>R</strong> (tức là ( S \gg R )).</p>
<p>Để đảm bảo chúng ta hiểu rõ sự khác biệt này, hãy làm một bài tập đơn giản. Cụ thể, hãy tính <strong>S</strong> và <strong>R</strong> dựa trên các đặc tính ổ đĩa sau. Giả sử:</p>
<ul>
<li>Kích thước truyền dữ liệu trung bình trong sequential transfer: <strong>10 MB</strong></li>
<li>Kích thước truyền dữ liệu trung bình trong random transfer: <strong>10 KB</strong></li>
<li>Đặc tính ổ đĩa:
<ul>
<li>Thời gian seek trung bình: <strong>7 ms</strong></li>
<li>Độ trễ quay trung bình: <strong>3 ms</strong></li>
<li>Tốc độ truyền dữ liệu: <strong>50 MB/s</strong></li>
</ul>
</li>
</ul>
<p><strong>Tính S</strong>:<br />
Trước tiên, ta xác định thời gian tiêu tốn cho một lần truyền 10 MB.</p>
<ul>
<li>Seek: 7 ms</li>
<li>Quay: 3 ms</li>
<li>Truyền dữ liệu: ( 10 \text{ MB} @ 50 \text{ MB/s} ) → ( \frac{1}{5} ) giây = <strong>200 ms</strong></li>
</ul>
<p>Tổng thời gian: ( 7 + 3 + 200 = 210 ) ms.</p>
<p>Công thức:</p>
<p>[
S = \frac{\text{Amount of Data}}{\text{Time to access}} = \frac{10 \ \text{MB}}{210 \ \text{ms}} = 47.62 \ \text{MB/s}
]</p>
<p>Như ta thấy, do thời gian truyền dữ liệu lớn, <strong>S</strong> gần bằng băng thông cực đại của ổ đĩa (chi phí seek và quay đã được <strong>amortized</strong> – phân bổ).</p>
<p><strong>Tính R</strong>:<br />
Seek và quay giữ nguyên như trên. Thời gian truyền dữ liệu: ( 10 \ \text{KB} @ 50 \ \text{MB/s} ) → <strong>0.195 ms</strong>.</p>
<p>Công thức:</p>
<p>[
R = \frac{\text{Amount of Data}}{\text{Time to access}} = \frac{10 \ \text{KB}}{10.195 \ \text{ms}} = 0.981 \ \text{MB/s}
]</p>
<p>Như vậy, <strong>R</strong> nhỏ hơn 1 MB/s, và tỉ lệ ( S / R ) gần <strong>50</strong>.</p>
<h3 id="quay-lại-phân-tích-raid-0"><a class="header" href="#quay-lại-phân-tích-raid-0">Quay lại phân tích RAID-0</a></h3>
<p>Bây giờ, hãy đánh giá hiệu năng của <strong>striping</strong>. Như đã nói ở trên, hiệu năng nói chung là tốt.</p>
<ul>
<li><strong>Về độ trễ</strong>: Độ trễ của một yêu cầu đọc/ghi một block sẽ gần như giống hệt với độ trễ của một ổ đĩa đơn; bởi vì RAID-0 chỉ đơn giản chuyển tiếp yêu cầu đó tới một trong các ổ đĩa của nó.</li>
<li><strong>Về băng thông tuần tự trạng thái ổn định</strong>: Ta kỳ vọng đạt được toàn bộ băng thông của hệ thống, tức là ( \text{Throughput} = N \times S ) (N là số ổ đĩa, S là băng thông tuần tự của một ổ).</li>
<li><strong>Với nhiều I/O ngẫu nhiên</strong>: Ta cũng có thể sử dụng tất cả các ổ đĩa, do đó đạt ( N \times R ) MB/s.</li>
</ul>
<p>Như chúng ta sẽ thấy ở phần sau, các giá trị này vừa dễ tính toán, vừa đóng vai trò là <strong>giới hạn trên</strong> khi so sánh với các cấp RAID khác.</p>
<h2 id="385-raid-level-1-mirroring"><a class="header" href="#385-raid-level-1-mirroring">38.5 RAID Level 1: Mirroring</a></h2>
<p>Cấp RAID đầu tiên vượt ra ngoài striping được gọi là <strong>RAID Level 1</strong>, hay <strong>mirroring</strong> (nhân bản dữ liệu). Với một hệ thống mirrored, chúng ta đơn giản tạo <strong>nhiều hơn một bản sao</strong> của mỗi block trong hệ thống; tất nhiên, mỗi bản sao phải được đặt trên một ổ đĩa riêng biệt. Bằng cách này, hệ thống có thể <strong>chịu được lỗi hỏng ổ đĩa</strong>.</p>
<p>...</p>
<p><img src="38/img/fig38_3.PNG" alt="" /></p>
<p><strong>Hình 38.3: RAID-1 đơn giản – Mirroring</strong></p>
<p>Trong một hệ thống <strong>mirrored</strong> (nhân bản) điển hình, chúng ta giả định rằng với mỗi <strong>logical block</strong> (block logic), RAID sẽ lưu giữ <strong>hai bản sao vật lý</strong> của nó. Ví dụ: trong minh họa, <strong>disk 0</strong> và <strong>disk 1</strong> có nội dung giống hệt nhau, và <strong>disk 2</strong> và <strong>disk 3</strong> cũng vậy; dữ liệu được <strong>striped</strong> (phân dải) trên các cặp mirror này.<br />
Thực tế, bạn có thể nhận thấy rằng có nhiều cách khác nhau để bố trí các bản sao block trên các ổ đĩa. Cách bố trí ở trên là một cách phổ biến và đôi khi được gọi là <strong>RAID-10</strong> (hoặc <strong>RAID 1+0</strong>, stripe of mirrors) vì nó sử dụng các cặp mirror (RAID-1) và sau đó <strong>striping</strong> (RAID-0) trên các cặp này; một cách bố trí phổ biến khác là <strong>RAID-01</strong> (hoặc <strong>RAID 0+1</strong>, mirror of stripes), bao gồm hai mảng striping (RAID-0) lớn, sau đó được mirror (RAID-1) ở tầng trên.<br />
Trong phạm vi này, chúng ta sẽ chỉ nói về mirroring với giả định bố trí như ở trên.</p>
<p>Khi đọc một block từ một mảng mirrored, RAID có quyền lựa chọn: nó có thể đọc từ <strong>bất kỳ bản sao nào</strong>. Ví dụ, nếu RAID nhận yêu cầu đọc <strong>logical block 5</strong>, nó có thể đọc từ <strong>disk 2</strong> hoặc <strong>disk 3</strong>.<br />
Tuy nhiên, khi ghi một block, không có sự lựa chọn như vậy: RAID <strong>phải</strong> cập nhật cả hai bản sao dữ liệu để đảm bảo độ tin cậy. Lưu ý rằng các thao tác ghi này có thể diễn ra <strong>song song</strong>; ví dụ, một thao tác ghi vào logical block 5 có thể được thực hiện đồng thời trên <strong>disk 2</strong> và <strong>disk 3</strong>.</p>
<h3 id="phân-tích-raid-1-raid-1-analysis"><a class="header" href="#phân-tích-raid-1-raid-1-analysis">Phân tích RAID-1 (RAID-1 Analysis)</a></h3>
<ul>
<li>
<p><strong>Về dung lượng (Capacity)</strong>: RAID-1 <strong>tốn kém</strong>; với mức mirroring = 2, chúng ta chỉ thu được <strong>một nửa</strong> dung lượng hữu ích tối đa. Với <strong>N</strong> ổ đĩa, mỗi ổ có <strong>B</strong> block, dung lượng hữu ích của RAID-1 là ((N \cdot B) / 2).</p>
</li>
<li>
<p><strong>Về độ tin cậy (Reliability)</strong>: RAID-1 hoạt động tốt. Nó có thể chịu được lỗi hỏng của <strong>bất kỳ một ổ đĩa</strong> nào.<br />
Bạn cũng có thể nhận thấy RAID-1 thậm chí có thể làm tốt hơn thế, nếu may mắn.<br />
Ví dụ, trong hình minh họa ở trên, nếu <strong>disk 0</strong> và <strong>disk 2</strong> cùng hỏng, sẽ <strong>không có mất mát dữ liệu</strong>!<br />
Nói chung hơn, một hệ thống mirrored (với mức mirroring = 2) chắc chắn chịu được <strong>1 lỗi ổ đĩa</strong>, và có thể chịu tới <strong>N/2 lỗi</strong> tùy thuộc vào ổ nào bị hỏng.<br />
Tuy nhiên, trong thực tế, chúng ta thường không muốn phụ thuộc vào may mắn; do đó, hầu hết mọi người coi mirroring là giải pháp tốt để xử lý <strong>một lỗi ổ đĩa</strong>.</p>
</li>
<li>
<p><strong>Về hiệu năng (Performance)</strong>:</p>
<ul>
<li><strong>Đọc (Read)</strong>: Xét về độ trễ của một yêu cầu đọc đơn, thời gian gần như <strong>tương đương</strong> với một ổ đĩa đơn; RAID-1 chỉ đơn giản là chuyển yêu cầu đọc tới một trong các bản sao.</li>
<li><strong>Ghi (Write)</strong>: Khác một chút – cần <strong>hai thao tác ghi vật lý</strong> để hoàn tất. Hai thao tác này diễn ra song song, nên thời gian sẽ xấp xỉ thời gian của một thao tác ghi đơn; tuy nhiên, vì thao tác ghi logic phải <strong>chờ cả hai ghi vật lý hoàn tất</strong>, nó sẽ chịu <strong>thời gian seek và độ trễ quay tệ nhất</strong> trong hai yêu cầu, và do đó (trung bình) sẽ <strong>hơi cao hơn</strong> so với ghi trên một ổ đĩa đơn.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>ASIDE: VẤN ĐỀ CẬP NHẬT NHẤT QUÁN TRONG RAID (THE RAID CONSISTENT-UPDATE PROBLEM)</strong></p>
<p>Trước khi phân tích RAID-1, hãy cùng thảo luận về một vấn đề có thể xảy ra trong bất kỳ hệ thống RAID nhiều ổ đĩa nào, được gọi là <strong>consistent-update problem</strong> (vấn đề cập nhật nhất quán) [DAA05]. Vấn đề này xảy ra khi một thao tác ghi (write) tới RAID phải cập nhật <strong>nhiều ổ đĩa</strong> trong một thao tác logic duy nhất. Trong trường hợp này, giả sử chúng ta đang xét một mảng đĩa <strong>mirrored</strong> (nhân bản).</p>
<p>Hãy tưởng tượng một thao tác ghi được gửi tới RAID, và RAID quyết định rằng dữ liệu phải được ghi lên <strong>hai ổ đĩa</strong>, disk 0 và disk 1. RAID sau đó gửi lệnh ghi tới disk 0, nhưng ngay trước khi RAID có thể gửi yêu cầu tới disk 1, một sự cố mất điện (hoặc <strong>system crash</strong> – sập hệ thống) xảy ra. Trong tình huống không may này, giả sử yêu cầu tới disk 0 đã hoàn tất (nhưng rõ ràng yêu cầu tới disk 1 chưa được thực hiện, vì nó chưa bao giờ được gửi).</p>
<p>Kết quả của sự cố mất điện này là <strong>hai bản sao của block trở nên không nhất quán</strong>; bản trên disk 0 là phiên bản mới, còn bản trên disk 1 là phiên bản cũ. Điều chúng ta mong muốn là trạng thái của cả hai ổ đĩa phải thay đổi <strong>một cách nguyên tử</strong> (atomically), tức là hoặc cả hai đều trở thành phiên bản mới, hoặc cả hai đều giữ nguyên phiên bản cũ.</p>
<p>Cách tổng quát để giải quyết vấn đề này là sử dụng một dạng <strong>write-ahead log</strong> (ghi nhật ký trước khi ghi dữ liệu) để trước tiên ghi lại những gì RAID sắp thực hiện (ví dụ: cập nhật hai ổ đĩa với một dữ liệu nhất định) trước khi thực sự thực hiện. Bằng cách này, chúng ta có thể đảm bảo rằng khi xảy ra sự cố, hệ thống vẫn xử lý đúng; bằng cách chạy một <strong>quy trình khôi phục</strong> (recovery procedure) để phát lại tất cả các giao dịch đang chờ trên RAID, chúng ta có thể đảm bảo rằng không có hai bản sao mirrored (trong trường hợp RAID-1) nào bị lệch dữ liệu.</p>
<p>Một lưu ý cuối: vì việc ghi log xuống đĩa cho <strong>mỗi lần ghi</strong> là cực kỳ tốn kém, hầu hết phần cứng RAID đều bao gồm một lượng nhỏ <strong>non-volatile RAM</strong> (RAM không mất dữ liệu khi mất điện, ví dụ: RAM có pin dự phòng) để thực hiện loại ghi log này. Nhờ đó, việc cập nhật nhất quán được đảm bảo mà không phải chịu chi phí cao của việc ghi log xuống đĩa.</p>
</blockquote>
<p>Để phân tích <strong>steady-state throughput</strong> (băng thông trạng thái ổn định), hãy bắt đầu với <strong>sequential workload</strong> (tải tuần tự). Khi ghi tuần tự xuống đĩa, mỗi thao tác ghi logic phải dẫn đến <strong>hai thao tác ghi vật lý</strong>; ví dụ, khi ghi <strong>logical block 0</strong> (trong hình minh họa ở trên), RAID sẽ ghi block này lên cả <strong>disk 0</strong> và <strong>disk 1</strong>. Do đó, ta có thể kết luận rằng <strong>băng thông tối đa</strong> đạt được khi ghi tuần tự vào một mảng mirrored là:</p>
<p>[
\frac{N}{2} \cdot S
]</p>
<p>tức <strong>một nửa</strong> băng thông cực đại.</p>
<p>Đáng tiếc là chúng ta cũng thu được <strong>hiệu năng tương tự</strong> khi đọc tuần tự. Có thể bạn nghĩ rằng đọc tuần tự sẽ tốt hơn, vì chỉ cần đọc <strong>một bản sao</strong> dữ liệu, không phải cả hai. Tuy nhiên, hãy xét ví dụ sau để thấy tại sao điều này không giúp ích nhiều:</p>
<p>Giả sử chúng ta cần đọc các block 0, 1, 2, 3, 4, 5, 6 và 7.</p>
<ul>
<li>Ta gửi yêu cầu đọc block 0 tới <strong>disk 0</strong>, block 1 tới <strong>disk 2</strong>, block 2 tới <strong>disk 1</strong>, và block 3 tới <strong>disk 3</strong>.</li>
<li>Tiếp tục, ta gửi yêu cầu đọc block 4, 5, 6, 7 tới <strong>disk 0</strong>, <strong>disk 2</strong>, <strong>disk 1</strong>, và <strong>disk 3</strong> tương ứng.</li>
</ul>
<p>Có thể bạn nghĩ rằng vì đang sử dụng tất cả các ổ đĩa, ta sẽ đạt được <strong>toàn bộ băng thông</strong> của mảng. Nhưng thực tế không hẳn vậy.</p>
<p>Hãy xem các yêu cầu mà <strong>một ổ đĩa</strong> nhận được (ví dụ: disk 0):</p>
<ul>
<li>Đầu tiên, nó nhận yêu cầu cho block 0.</li>
<li>Sau đó, nó nhận yêu cầu cho block 4 (<strong>bỏ qua block 2</strong>).</li>
</ul>
<p>Thực tế, mỗi ổ đĩa nhận yêu cầu cho <strong>mỗi block cách nhau một block</strong>. Khi đầu đọc quay qua block bị bỏ qua, nó <strong>không cung cấp băng thông hữu ích</strong> cho client. Do đó, mỗi ổ đĩa chỉ cung cấp <strong>một nửa</strong> băng thông cực đại của nó. Vì vậy, <strong>đọc tuần tự</strong> chỉ đạt được băng thông:</p>
<p>[
\frac{N}{2} \cdot S \ \text{MB/s}
]</p>
<p><strong>Random reads</strong> (đọc ngẫu nhiên) là <strong>trường hợp tốt nhất</strong> cho RAID mirrored. Trong trường hợp này, chúng ta có thể phân phối các yêu cầu đọc trên <strong>tất cả các ổ đĩa</strong>, và do đó đạt được <strong>toàn bộ băng thông khả dụng</strong>. Vì vậy, với random reads, RAID-1 đạt:</p>
<p>[
N \cdot R \ \text{MB/s}
]</p>
<p>Cuối cùng, <strong>random writes</strong> (ghi ngẫu nhiên) hoạt động đúng như bạn mong đợi:</p>
<p>[
\frac{N}{2} \cdot R \ \text{MB/s}
]</p>
<p>Mỗi thao tác ghi logic phải biến thành <strong>hai thao tác ghi vật lý</strong>, và do đó mặc dù tất cả các ổ đĩa đều được sử dụng, client chỉ nhận thấy <strong>một nửa băng thông khả dụng</strong>.<br />
Ngay cả khi một thao tác ghi vào <strong>logical block x</strong> biến thành <strong>hai thao tác ghi song song</strong> tới hai ổ đĩa vật lý khác nhau, băng thông của nhiều yêu cầu nhỏ chỉ đạt <strong>một nửa</strong> so với striping.<br />
Như chúng ta sẽ thấy ngay sau đây, đạt được <strong>một nửa băng thông khả dụng</strong> thực ra đã là <strong>khá tốt</strong>!</p>
<h2 id="386-raid-level-4-tiết-kiệm-dung-lượng-với-parity-saving-space-with-parity"><a class="header" href="#386-raid-level-4-tiết-kiệm-dung-lượng-với-parity-saving-space-with-parity">38.6 RAID Level 4: Tiết kiệm dung lượng với Parity (Saving Space With Parity)</a></h2>
<p>Chúng ta sẽ giới thiệu một phương pháp khác để bổ sung <strong>redundancy</strong> (dữ liệu dự phòng) cho một mảng đĩa, được gọi là <strong>parity</strong> (bit chẵn lẻ). Các phương pháp dựa trên parity cố gắng sử dụng ít dung lượng hơn, từ đó khắc phục nhược điểm lớn về dung lượng mà các hệ thống <strong>mirrored</strong> (nhân bản) phải trả. Tuy nhiên, chúng phải đánh đổi một yếu tố: <strong>hiệu năng</strong>.</p>
<p><img src="38/img/fig38_4.PNG" alt="" /></p>
<p><strong>Hình 38.4: RAID-4 với Parity (RAID-4 With Parity)</strong></p>
<p>Dưới đây là ví dụ về một hệ thống RAID-4 gồm 5 ổ đĩa (<strong>Hình 38.4</strong>). Với mỗi <strong>stripe</strong> (dải dữ liệu), chúng ta thêm một <strong>parity block</strong> (block chẵn lẻ) lưu trữ thông tin dự phòng cho stripe đó.<br />
Ví dụ: parity block <strong>P1</strong> chứa thông tin dự phòng được tính toán từ các block 4, 5, 6 và 7.</p>
<p>Để tính toán parity, chúng ta cần sử dụng một hàm toán học cho phép chịu được việc mất bất kỳ một block nào trong stripe. Hóa ra, hàm đơn giản <strong>XOR</strong> (phép loại trừ logic) thực hiện điều này khá tốt.<br />
Với một tập hợp các bit, XOR của tất cả các bit đó trả về <strong>0</strong> nếu có <strong>số lượng bit 1 chẵn</strong>, và trả về <strong>1</strong> nếu có <strong>số lượng bit 1 lẻ</strong>.<br />
Ví dụ:</p>
<p>...</p>
<p>Trong hàng đầu tiên (0, 0, 1, 1), có hai bit 1 (C2, C3), do đó XOR của tất cả các giá trị này sẽ là 0 (P); tương tự, trong hàng thứ hai chỉ có một bit 1 (C1), nên XOR phải là 1 (P).<br />
Bạn có thể ghi nhớ điều này một cách đơn giản: <strong>tổng số bit 1 trong bất kỳ hàng nào, bao gồm cả bit parity, phải là một số chẵn</strong>; đây là <strong>bất biến</strong> (invariant) mà RAID phải duy trì để đảm bảo parity là chính xác.</p>
<p>Từ ví dụ trên, bạn cũng có thể đoán được cách thông tin parity được sử dụng để <strong>khôi phục dữ liệu khi xảy ra lỗi</strong>.<br />
Giả sử cột có nhãn <strong>C2</strong> bị mất. Để xác định giá trị ban đầu của cột này, chúng ta chỉ cần đọc tất cả các giá trị khác trong hàng đó (bao gồm cả bit parity đã được XOR) và tái tạo lại giá trị đúng.<br />
Cụ thể, giả sử giá trị ở hàng đầu tiên, cột C2 bị mất (giá trị ban đầu là 1); bằng cách đọc các giá trị khác trong hàng đó (0 từ C0, 0 từ C1, 1 từ C3 và 0 từ cột parity P), ta thu được các giá trị 0, 0, 1 và 0.<br />
Vì chúng ta biết rằng XOR luôn đảm bảo số lượng bit 1 trong mỗi hàng là <strong>chẵn</strong>, nên giá trị bị thiếu phải là <strong>1</strong>.<br />
Đó chính là cách <strong>reconstruction</strong> (tái tạo dữ liệu) hoạt động trong một hệ thống parity dựa trên XOR!<br />
Lưu ý rằng cách tính giá trị tái tạo cũng giống hệt cách chúng ta tính parity ban đầu: chỉ cần XOR các bit dữ liệu và bit parity lại với nhau.</p>
<p>Có thể bạn đang thắc mắc: chúng ta đang nói về việc XOR tất cả các bit, nhưng ở trên ta biết rằng RAID lưu các block 4KB (hoặc lớn hơn) trên mỗi ổ đĩa; vậy làm thế nào để áp dụng XOR cho nhiều block để tính parity?<br />
Thực ra, điều này cũng khá đơn giản: chỉ cần thực hiện <strong>bitwise XOR</strong> (XOR theo từng bit) trên từng bit của các block dữ liệu; đặt kết quả của mỗi phép XOR bitwise vào vị trí bit tương ứng trong parity block.<br />
Ví dụ, nếu chúng ta có các block kích thước 4 bit (vâng, điều này nhỏ hơn rất nhiều so với block 4KB, nhưng bạn sẽ hiểu ý tưởng), chúng có thể trông như sau:</p>
<p>...</p>
<p>Như bạn thấy từ hình minh họa, parity được tính cho từng bit của mỗi block và kết quả được đặt vào parity block.</p>
<h3 id="phân-tích-raid-4-raid-4-analysis"><a class="header" href="#phân-tích-raid-4-raid-4-analysis">Phân tích RAID-4 (RAID-4 Analysis)</a></h3>
<ul>
<li><strong>Về dung lượng (Capacity)</strong>: RAID-4 sử dụng <strong>1 ổ đĩa</strong> để lưu thông tin parity cho mỗi nhóm ổ đĩa mà nó bảo vệ. Do đó, dung lượng hữu ích của một nhóm RAID là:</li>
</ul>
<p>[
(N - 1) \cdot B
]</p>
<ul>
<li><strong>Về độ tin cậy (Reliability)</strong>: RAID-4 có thể chịu được <strong>1 lỗi ổ đĩa</strong> và không hơn. Nếu mất nhiều hơn một ổ đĩa, sẽ <strong>không có cách nào</strong> để tái tạo dữ liệu đã mất.</li>
</ul>
<p><img src="38/img/fig38_5.PNG" alt="" /></p>
<p><strong>Hình 38.5: Ghi full-stripe trong RAID-4 (Full-stripe Writes In RAID-4)</strong></p>
<p>Cuối cùng, chúng ta xét đến <strong>hiệu năng</strong>. Lần này, hãy bắt đầu bằng việc phân tích <strong>steady-state throughput</strong> (băng thông trạng thái ổn định).<br />
Hiệu năng đọc tuần tự (<strong>sequential read</strong>) có thể tận dụng tất cả các ổ đĩa <strong>ngoại trừ</strong> ổ đĩa parity, và do đó đạt <strong>băng thông hiệu dụng cực đại</strong> là:</p>
<p>[
(N - 1) \cdot S \ \text{MB/s}
]</p>
<p>(đây là trường hợp dễ tính).</p>
<p>Để hiểu hiệu năng của <strong>ghi tuần tự</strong> (<strong>sequential write</strong>), trước tiên chúng ta cần hiểu cách nó được thực hiện.<br />
Khi ghi một khối dữ liệu lớn xuống đĩa, RAID-4 có thể thực hiện một tối ưu hóa đơn giản được gọi là <strong>full-stripe write</strong>.<br />
Ví dụ, giả sử các block 0, 1, 2 và 3 được gửi tới RAID như một phần của một yêu cầu ghi (<strong>Hình 38.5</strong>).</p>
<p>Trong trường hợp này, RAID chỉ cần tính toán giá trị mới của <strong>P0</strong> (bằng cách thực hiện phép <strong>XOR</strong> trên các block 0, 1, 2 và 3), sau đó ghi <strong>tất cả các block</strong> (bao gồm cả block parity) lên 5 ổ đĩa ở trên <strong>song song</strong> (được tô xám trong hình).<br />
Do đó, <strong>full-stripe write</strong> là cách hiệu quả nhất để RAID-4 ghi dữ liệu xuống đĩa.</p>
<p>Khi đã hiểu full-stripe write, việc tính toán hiệu năng ghi tuần tự của RAID-4 trở nên đơn giản; <strong>băng thông hiệu dụng</strong> cũng là:</p>
<p>[
(N - 1) \cdot S \ \text{MB/s}
]</p>
<p>Mặc dù ổ đĩa parity luôn được sử dụng trong quá trình này, client <strong>không nhận được lợi ích hiệu năng</strong> từ nó.</p>
<p>Bây giờ, hãy phân tích hiệu năng của <strong>đọc ngẫu nhiên</strong> (<strong>random read</strong>).<br />
Như bạn có thể thấy từ hình minh họa ở trên, một tập hợp các yêu cầu đọc ngẫu nhiên kích thước 1 block sẽ được phân bổ trên các ổ đĩa dữ liệu của hệ thống, nhưng <strong>không</strong> trên ổ đĩa parity.<br />
Do đó, hiệu năng hiệu dụng là:</p>
<p>[
(N - 1) \cdot R \ \text{MB/s}
]</p>
<p><strong>Ghi ngẫu nhiên</strong> (<strong>random write</strong>) – phần chúng ta để lại cuối cùng – là trường hợp thú vị nhất đối với RAID-4.<br />
Giả sử chúng ta muốn ghi đè block 1 trong ví dụ ở trên.<br />
Chúng ta có thể ghi đè trực tiếp, nhưng điều đó sẽ gây ra một vấn đề: block parity <strong>P0</strong> sẽ <strong>không còn phản ánh chính xác</strong> giá trị parity của stripe; trong ví dụ này, <strong>P0</strong> cũng phải được cập nhật.<br />
Vậy làm thế nào để cập nhật nó <strong>đúng</strong> và <strong>hiệu quả</strong>?</p>
<p>Hóa ra có <strong>hai phương pháp</strong>:</p>
<ol>
<li>
<p><strong>Additive parity</strong>:</p>
<ul>
<li>Để tính giá trị mới của parity block, đọc <strong>tất cả các block dữ liệu khác</strong> trong stripe <strong>song song</strong> (trong ví dụ: block 0, 2 và 3) và XOR chúng với block mới (block 1).</li>
<li>Kết quả là parity block mới.</li>
<li>Sau đó, ghi dữ liệu mới và parity mới xuống các ổ đĩa tương ứng, cũng song song.</li>
<li>Vấn đề của kỹ thuật này là nó <strong>tỷ lệ thuận với số lượng ổ đĩa</strong>; trong các RAID lớn, nó yêu cầu <strong>nhiều thao tác đọc</strong> để tính toán parity.</li>
</ul>
</li>
<li>
<p><strong>Subtractive parity</strong>:</p>
<ul>
<li>Ví dụ, giả sử chúng ta có chuỗi bit (4 bit dữ liệu, 1 bit parity):<br />
...</li>
<li>Giả sử chúng ta muốn ghi đè bit <strong>C2</strong> bằng giá trị mới <strong>C2new</strong>.</li>
<li>Phương pháp subtractive hoạt động qua <strong>3 bước</strong>:
<ol>
<li>Đọc dữ liệu cũ tại C2 (<strong>C2old = 1</strong>) và parity cũ (<strong>Pold = 0</strong>).</li>
<li>So sánh dữ liệu cũ và dữ liệu mới:
<ul>
<li>Nếu chúng <strong>giống nhau</strong> (ví dụ: C2new = C2old), parity bit sẽ <strong>không thay đổi</strong> (Pnew = Pold).</li>
<li>Nếu chúng <strong>khác nhau</strong>, ta phải <strong>đảo bit parity</strong> sang trạng thái ngược lại:
<ul>
<li>Nếu Pold = 1 → Pnew = 0</li>
<li>Nếu Pold = 0 → Pnew = 1</li>
</ul>
</li>
</ul>
</li>
<li>Công thức gọn gàng bằng XOR (⊕ là toán tử XOR):</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>[
P_{new} = (C_{old} \oplus C_{new}) \oplus P_{old} \tag{38.1}
]</p>
<p>Vì chúng ta đang xử lý <strong>block</strong> chứ không phải bit, phép tính này được thực hiện trên <strong>tất cả các bit</strong> trong block (ví dụ: 4096 byte mỗi block × 8 bit/byte).<br />
Do đó, trong hầu hết các trường hợp, block mới sẽ khác block cũ, và parity block mới cũng sẽ khác.</p>
<p>Bạn bây giờ có thể suy luận khi nào nên dùng <strong>additive parity</strong> và khi nào nên dùng <strong>subtractive parity</strong>.<br />
Hãy nghĩ về số lượng ổ đĩa trong hệ thống để phương pháp additive thực hiện <strong>ít I/O hơn</strong> so với subtractive; đâu là <strong>điểm giao nhau</strong> (cross-over point)?</p>
<p>Trong phân tích hiệu năng này, giả sử chúng ta sử dụng <strong>subtractive method</strong>.<br />
Như vậy, với mỗi thao tác ghi, RAID phải thực hiện <strong>4 I/O vật lý</strong> (2 lần đọc và 2 lần ghi).<br />
Bây giờ, giả sử có rất nhiều yêu cầu ghi được gửi tới RAID; câu hỏi là: <strong>RAID-4 có thể thực hiện bao nhiêu thao tác song song?</strong><br />
Để hiểu điều này, hãy cùng xem lại <strong>bố trí RAID-4</strong> (<strong>Hình 38.6</strong>).</p>
<p><img src="38/img/fig38_6.PNG" alt="" /></p>
<p><strong>Hình 38.6: Ví dụ – Ghi vào block 4, 13 và các block parity tương ứng</strong></p>
<p>Giờ hãy tưởng tượng có <strong>2 thao tác ghi nhỏ</strong> được gửi tới RAID-4 gần như cùng lúc, tới các block 4 và 13 (được đánh dấu ∗ trong sơ đồ).<br />
Dữ liệu của các block này nằm trên <strong>disk 0</strong> và <strong>disk 1</strong>, do đó thao tác đọc và ghi dữ liệu có thể diễn ra <strong>song song</strong> – đây là điểm tốt.<br />
Vấn đề phát sinh ở <strong>ổ đĩa parity</strong>: cả hai yêu cầu đều phải đọc các block parity liên quan tới block 4 và 13, tức <strong>parity block 1</strong> và <strong>parity block 3</strong> (được đánh dấu +).</p>
<p>Hy vọng giờ vấn đề đã rõ: <strong>ổ đĩa parity trở thành nút thắt cổ chai</strong> trong kiểu tải công việc này; đôi khi chúng ta gọi đây là <strong>small-write problem</strong> (vấn đề ghi nhỏ) đối với các RAID dựa trên parity.<br />
Vì vậy, mặc dù các ổ dữ liệu có thể được truy cập song song, ổ parity lại <strong>ngăn cản</strong> việc hiện thực hóa song song; tất cả các thao tác ghi vào hệ thống sẽ bị <strong>tuần tự hóa</strong> do ổ parity.</p>
<p>Vì ổ parity phải thực hiện <strong>hai I/O</strong> (một đọc, một ghi) cho mỗi I/O logic, ta có thể tính hiệu năng của các thao tác ghi ngẫu nhiên nhỏ trong RAID-4 bằng cách tính hiệu năng của ổ parity trên hai I/O này, và kết quả đạt được là:</p>
<p>[
\frac{R}{2} \ \text{MB/s}
]</p>
<p>Thông lượng (throughput) của RAID-4 đối với ghi ngẫu nhiên nhỏ là <strong>rất tệ</strong>; nó <strong>không cải thiện</strong> ngay cả khi bạn thêm nhiều ổ đĩa vào hệ thống.</p>
<p>Chúng ta kết thúc phần này bằng việc phân tích <strong>độ trễ I/O</strong> trong RAID-4.<br />
Như bạn đã biết, một thao tác đọc đơn (giả sử không có lỗi) chỉ được ánh xạ tới <strong>một ổ đĩa duy nhất</strong>, do đó độ trễ của nó tương đương với độ trễ của một yêu cầu trên ổ đĩa đơn.<br />
Độ trễ của một thao tác ghi đơn yêu cầu <strong>hai lần đọc</strong> và sau đó <strong>hai lần ghi</strong>; các thao tác đọc có thể diễn ra song song, cũng như các thao tác ghi, do đó tổng độ trễ vào khoảng <strong>gấp đôi</strong> so với một ổ đĩa đơn (có một số khác biệt vì ta phải chờ cả hai lần đọc hoàn tất và do đó chịu <strong>thời gian định vị tệ nhất</strong>, nhưng sau đó các thao tác cập nhật không phải chịu chi phí seek nên có thể tốt hơn mức trung bình).</p>
<h2 id="387-raid-level-5-rotating-parity"><a class="header" href="#387-raid-level-5-rotating-parity">38.7 RAID Level 5: Rotating Parity</a></h2>
<p>Để giải quyết <strong>small-write problem</strong> (ít nhất là một phần), Patterson, Gibson và Katz đã giới thiệu <strong>RAID-5</strong>.<br />
RAID-5 hoạt động gần như giống hệt RAID-4, ngoại trừ việc <strong>xoay vòng (rotate)</strong> block parity qua các ổ đĩa (<strong>Hình 38.7</strong>).</p>
<p><img src="38/img/fig38_7.PNG" alt="" /></p>
<p><strong>Hình 38.7: RAID-5 với parity xoay vòng (RAID-5 With Rotated Parity)</strong></p>
<p>Như bạn thấy, block parity cho mỗi stripe giờ được <strong>xoay vòng</strong> qua các ổ đĩa, nhằm loại bỏ nút thắt cổ chai của ổ parity trong RAID-4.</p>
<h3 id="phân-tích-raid-5-raid-5-analysis"><a class="header" href="#phân-tích-raid-5-raid-5-analysis">Phân tích RAID-5 (RAID-5 Analysis)</a></h3>
<p>Phần lớn phân tích cho RAID-5 <strong>giống hệt</strong> RAID-4.<br />
Ví dụ: <strong>dung lượng hữu dụng</strong> và <strong>khả năng chịu lỗi</strong> của hai cấp này là như nhau.<br />
Hiệu năng đọc và ghi tuần tự cũng tương tự.<br />
Độ trễ của một yêu cầu đơn (dù là đọc hay ghi) cũng giống RAID-4.</p>
<p>Hiệu năng đọc ngẫu nhiên (<strong>random read</strong>) tốt hơn một chút, vì giờ đây chúng ta có thể tận dụng <strong>tất cả các ổ đĩa</strong>.<br />
Cuối cùng, hiệu năng ghi ngẫu nhiên (<strong>random write</strong>) cải thiện đáng kể so với RAID-4, vì nó cho phép <strong>song song hóa</strong> giữa các yêu cầu.<br />
Ví dụ: một thao tác ghi vào block 1 và một thao tác ghi vào block 10 sẽ biến thành:</p>
<ul>
<li>Yêu cầu tới <strong>disk 1</strong> và <strong>disk 4</strong> (cho block 1 và parity của nó)</li>
<li>Yêu cầu tới <strong>disk 0</strong> và <strong>disk 2</strong> (cho block 10 và parity của nó)</li>
</ul>
<p>Do đó, chúng có thể tiến hành song song.<br />
Trên thực tế, ta có thể giả định rằng với một số lượng lớn yêu cầu ngẫu nhiên, chúng ta sẽ có thể giữ cho tất cả các ổ đĩa <strong>bận rộn tương đối đồng đều</strong>.<br />
Nếu đúng như vậy, <strong>tổng băng thông</strong> cho ghi nhỏ sẽ là:</p>
<p>[
\frac{N}{4} \cdot R \ \text{MB/s}
]</p>
<p>Hệ số mất 4 lần này là do mỗi thao tác ghi RAID-5 vẫn tạo ra <strong>4 I/O</strong> tổng cộng – đây đơn giản là <strong>cái giá phải trả</strong> khi sử dụng RAID dựa trên parity.</p>
<p>Vì RAID-5 về cơ bản giống RAID-4 ngoại trừ một số trường hợp tốt hơn, nó đã gần như <strong>hoàn toàn thay thế</strong> RAID-4 trên thị trường.<br />
Ngoại lệ duy nhất là trong các hệ thống <strong>chỉ thực hiện ghi lớn</strong> (large write), do đó tránh được hoàn toàn small-write problem [HLM94]; trong các trường hợp đó, RAID-4 đôi khi vẫn được sử dụng vì <strong>dễ xây dựng hơn một chút</strong>.</p>
<h2 id="388-so-sánh-raid-tóm-tắt-raid-comparison-a-summary"><a class="header" href="#388-so-sánh-raid-tóm-tắt-raid-comparison-a-summary">38.8 So sánh RAID: Tóm tắt (RAID Comparison: A Summary)</a></h2>
<p>Chúng ta sẽ tóm tắt <strong>so sánh đơn giản hóa</strong> các cấp RAID trong <strong>Hình 38.8</strong>.<br />
Lưu ý rằng chúng ta đã <strong>bỏ qua một số chi tiết</strong> để đơn giản hóa phân tích.<br />
Ví dụ: khi ghi trong một hệ thống mirrored, <strong>thời gian seek trung bình</strong> sẽ cao hơn một chút so với khi ghi vào một ổ đĩa đơn, vì thời gian seek là <strong>giá trị lớn nhất</strong> của hai lần seek (một trên mỗi ổ).<br />
Do đó, hiệu năng ghi ngẫu nhiên tới hai ổ đĩa thường sẽ <strong>thấp hơn một chút</strong> so với hiệu năng ghi ngẫu nhiên của một ổ đơn.</p>
<p>Ngoài ra, khi cập nhật ổ parity trong RAID-4/5:</p>
<ul>
<li>Lần đọc đầu tiên của parity cũ có thể gây ra <strong>seek và quay toàn phần</strong></li>
<li>Nhưng lần ghi thứ hai của parity chỉ gây ra <strong>quay</strong></li>
</ul>
<p>Cuối cùng, <strong>I/O tuần tự</strong> tới RAID mirrored chịu <strong>mức phạt hiệu năng gấp đôi (2×)</strong> so với các phương pháp khác<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><img src="38/img/fig38_8.PNG" alt="" /></p>
<p><strong>Hình 38.8: Dung lượng, độ tin cậy và hiệu năng của RAID (RAID Capacity, Reliability, and Performance)</strong></p>
<p>Tuy nhiên, so sánh trong <strong>Hình 38.8</strong> đã nêu bật được những khác biệt cốt lõi và hữu ích để hiểu các <strong>trade-off</strong> (đánh đổi) giữa các cấp RAID.<br />
Trong phân tích độ trễ (<strong>latency analysis</strong>), chúng ta đơn giản sử dụng <strong>T</strong> để biểu diễn thời gian mà một yêu cầu tới một ổ đĩa đơn sẽ mất.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Mức phạt 1/2 giả định một mô hình đọc/ghi ngây thơ cho mirroring; một cách tiếp cận tinh vi hơn, gửi các yêu cầu I/O lớn tới các phần khác nhau của mỗi bản mirror, có thể đạt được băng thông tối đa. Hãy suy nghĩ về điều này để xem bạn có thể tìm ra lý do tại sao.</p>
</div>
<p>Kết luận:</p>
<ul>
<li>Nếu bạn chỉ quan tâm đến <strong>hiệu năng</strong> và không quan tâm đến <strong>độ tin cậy</strong>, <strong>striping</strong> rõ ràng là lựa chọn tốt nhất.</li>
<li>Nếu bạn muốn <strong>hiệu năng I/O ngẫu nhiên</strong> và <strong>độ tin cậy</strong>, <strong>mirroring</strong> là tốt nhất; cái giá phải trả là <strong>mất dung lượng</strong>.</li>
<li>Nếu <strong>dung lượng</strong> và <strong>độ tin cậy</strong> là mục tiêu chính, thì <strong>RAID-5</strong> là lựa chọn tối ưu; cái giá phải trả là hiệu năng kém khi ghi nhỏ (<strong>small-write performance</strong>).</li>
<li>Cuối cùng, nếu bạn <strong>luôn</strong> thực hiện I/O tuần tự và muốn tối đa hóa dung lượng, <strong>RAID-5</strong> cũng là lựa chọn hợp lý nhất.</li>
</ul>
<h2 id="389-một-số-vấn-đề-thú-vị-khác-về-raid-other-interesting-raid-issues"><a class="header" href="#389-một-số-vấn-đề-thú-vị-khác-về-raid-other-interesting-raid-issues">38.9 Một số vấn đề thú vị khác về RAID (Other Interesting RAID Issues)</a></h2>
<p>Có nhiều ý tưởng thú vị khác mà chúng ta có thể (và có lẽ nên) thảo luận khi nói về RAID. Dưới đây là một số điều mà chúng ta có thể sẽ viết thêm.</p>
<p>Ví dụ:</p>
<ul>
<li>Có nhiều thiết kế RAID khác, bao gồm <strong>Level 2</strong> và <strong>Level 3</strong> từ phân loại gốc, và <strong>Level 6</strong> để chịu được nhiều lỗi ổ đĩa [C+04].</li>
<li>Câu hỏi: RAID sẽ làm gì khi một ổ đĩa bị hỏng? Đôi khi hệ thống có một <strong>hot spare</strong> (ổ dự phòng nóng) sẵn sàng thay thế cho ổ bị hỏng.</li>
<li>Điều gì xảy ra với hiệu năng khi có lỗi, và hiệu năng trong quá trình <strong>reconstruction</strong> (tái tạo) ổ đĩa bị hỏng?</li>
<li>Có các <strong>mô hình lỗi</strong> thực tế hơn, tính đến <strong>latent sector errors</strong> (lỗi sector tiềm ẩn) hoặc <strong>block corruption</strong> (hỏng block) [B+08], và nhiều kỹ thuật để xử lý các lỗi này (xem chương về <strong>data integrity</strong> để biết chi tiết).</li>
<li>Cuối cùng, bạn thậm chí có thể xây dựng RAID như một <strong>lớp phần mềm</strong>: các hệ thống <strong>software RAID</strong> như vậy rẻ hơn nhưng có những vấn đề khác, bao gồm cả <strong>consistent-update problem</strong> (vấn đề cập nhật nhất quán) [DAA05].</li>
</ul>
<h2 id="3810-tóm-tắt-summary"><a class="header" href="#3810-tóm-tắt-summary">38.10 Tóm tắt (Summary)</a></h2>
<p>Chúng ta đã thảo luận về RAID. RAID biến nhiều ổ đĩa độc lập thành một thực thể duy nhất <strong>lớn hơn</strong>, <strong>dung lượng cao hơn</strong> và <strong>đáng tin cậy hơn</strong>; quan trọng là nó thực hiện điều này <strong>một cách minh bạch</strong> (transparently), do đó phần cứng và phần mềm ở tầng trên hầu như không nhận thấy sự thay đổi.</p>
<p>Có nhiều cấp RAID khác nhau để lựa chọn, và cấp RAID chính xác cần sử dụng phụ thuộc nhiều vào điều gì là quan trọng đối với <strong>người dùng cuối</strong>.<br />
Ví dụ:</p>
<ul>
<li><strong>Mirrored RAID</strong> đơn giản, đáng tin cậy và thường cung cấp hiệu năng tốt, nhưng <strong>chi phí dung lượng</strong> cao.</li>
<li><strong>RAID-5</strong> thì ngược lại: đáng tin cậy và tốt hơn về mặt dung lượng, nhưng hiệu năng rất kém khi workload có nhiều thao tác ghi nhỏ.</li>
<li>Việc chọn một RAID và thiết lập các tham số của nó (<strong>chunk size</strong>, số lượng ổ đĩa, v.v.) phù hợp cho một workload cụ thể là một thách thức, và vẫn mang tính <strong>nghệ thuật</strong> nhiều hơn là <strong>khoa học</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phần-xen-kẽ-tệp-và-thư-mục-interlude-files-and-directories"><a class="header" href="#phần-xen-kẽ-tệp-và-thư-mục-interlude-files-and-directories">Phần xen kẽ: Tệp và Thư mục (Interlude: Files and Directories)</a></h1>
<p>Cho đến nay, chúng ta đã thấy sự hình thành của hai <strong>abstraction</strong> (lớp trừu tượng) quan trọng trong hệ điều hành: <strong>process</strong> (tiến trình) – là sự ảo hóa của CPU, và <strong>address space</strong> (không gian địa chỉ) – là sự ảo hóa của bộ nhớ.<br />
Kết hợp lại, hai abstraction này cho phép một chương trình chạy như thể nó đang ở trong một thế giới riêng tư, tách biệt; như thể nó có bộ xử lý (hoặc nhiều bộ xử lý) riêng; như thể nó có bộ nhớ riêng.<br />
Ảo tưởng này giúp việc lập trình hệ thống trở nên dễ dàng hơn rất nhiều, và vì thế ngày nay nó phổ biến không chỉ trên máy tính để bàn và máy chủ mà còn ngày càng xuất hiện trên mọi nền tảng lập trình được, bao gồm cả điện thoại di động và các thiết bị tương tự.</p>
<p>Trong phần này, chúng ta sẽ bổ sung một mảnh ghép quan trọng nữa vào bức tranh ảo hóa: <strong>persistent storage</strong> (lưu trữ bền vững).<br />
Một thiết bị lưu trữ bền vững, chẳng hạn như <strong>ổ đĩa cứng</strong> (hard disk drive) truyền thống hoặc <strong>thiết bị lưu trữ thể rắn</strong> (solid-state storage device) hiện đại, lưu trữ thông tin một cách lâu dài (hoặc ít nhất là trong một thời gian dài).<br />
Không giống như bộ nhớ, nơi dữ liệu bị mất khi mất điện, thiết bị lưu trữ bền vững giữ nguyên dữ liệu.<br />
Do đó, hệ điều hành phải đặc biệt cẩn trọng với loại thiết bị này: đây là nơi người dùng lưu trữ dữ liệu mà họ thực sự quan tâm.</p>
<h3 id="crux-quẢn-lÝ-thiẾt-bỊ-lƯu-trỮ-bỀn-vỮng-nhƯ-thẾ-nÀo"><a class="header" href="#crux-quẢn-lÝ-thiẾt-bỊ-lƯu-trỮ-bỀn-vỮng-nhƯ-thẾ-nÀo">CRUX: QUẢN LÝ THIẾT BỊ LƯU TRỮ BỀN VỮNG NHƯ THẾ NÀO?</a></h3>
<blockquote>
<p>Hệ điều hành nên quản lý một thiết bị lưu trữ bền vững như thế nào? Các API là gì? Những khía cạnh quan trọng trong triển khai là gì?</p>
</blockquote>
<p>Vì vậy, trong vài chương tiếp theo, chúng ta sẽ khám phá các kỹ thuật quan trọng để quản lý dữ liệu bền vững, tập trung vào các phương pháp cải thiện hiệu năng và độ tin cậy.<br />
Tuy nhiên, trước tiên chúng ta sẽ bắt đầu với phần tổng quan về <strong>API</strong>: các giao diện mà bạn sẽ gặp khi tương tác với <strong>UNIX file system</strong> (hệ thống tệp UNIX).</p>
<h2 id="391-tệp-và-thư-mục-files-and-directories"><a class="header" href="#391-tệp-và-thư-mục-files-and-directories">39.1 Tệp và Thư mục (Files And Directories)</a></h2>
<p>Hai abstraction quan trọng đã được phát triển theo thời gian trong quá trình ảo hóa lưu trữ.</p>
<p><strong>Abstraction</strong> đầu tiên là <strong>file</strong> (tệp).<br />
Một file đơn giản là một mảng tuyến tính các byte, mỗi byte có thể được đọc hoặc ghi.<br />
Mỗi file có một dạng tên mức thấp nào đó, thường là một con số; người dùng thường không biết đến tên này.<br />
Vì lý do lịch sử, tên mức thấp của một file thường được gọi là <strong>inode number</strong> (số inode, hay i-number).<br />
Chúng ta sẽ tìm hiểu nhiều hơn về inode trong các chương sau; hiện tại, chỉ cần giả định rằng mỗi file có một inode number gắn liền với nó.</p>
<p>Trong hầu hết các hệ thống, hệ điều hành không biết nhiều về cấu trúc bên trong của file (ví dụ: nó là một bức ảnh, một tệp văn bản, hay mã C); thay vào đó, trách nhiệm của <strong>file system</strong> (hệ thống tệp) chỉ đơn giản là lưu trữ dữ liệu đó một cách bền vững trên đĩa và đảm bảo rằng khi bạn yêu cầu dữ liệu lần nữa, bạn nhận được đúng dữ liệu mà bạn đã lưu ban đầu.<br />
Làm được điều này không đơn giản như tưởng tượng!</p>
<p><strong>Abstraction</strong> thứ hai là <strong>directory</strong> (thư mục).<br />
Một directory, giống như file, cũng có một tên mức thấp (tức inode number), nhưng nội dung của nó rất đặc thù: nó chứa một danh sách các cặp <strong>(tên đọc được bởi người dùng, tên mức thấp)</strong>.<br />
Ví dụ: giả sử có một file với tên mức thấp là “10”, và nó được người dùng gọi bằng tên “foo”.<br />
Directory chứa “foo” sẽ có một mục <strong>(“foo”, “10”)</strong> ánh xạ tên đọc được sang tên mức thấp.<br />
Mỗi mục trong một directory tham chiếu tới hoặc là file, hoặc là directory khác.<br />
Bằng cách đặt các directory bên trong các directory khác, người dùng có thể xây dựng một <strong>directory tree</strong> (cây thư mục) hoặc <strong>directory hierarchy</strong> (hệ phân cấp thư mục) tùy ý, trong đó tất cả file và directory đều được lưu trữ.</p>
<p>Cây thư mục bắt đầu từ <strong>root directory</strong> (thư mục gốc) – trong các hệ thống dựa trên UNIX, thư mục gốc được ký hiệu đơn giản là <code>/</code> – và sử dụng một ký tự phân tách nào đó để đặt tên các thư mục con tiếp theo cho đến khi chỉ ra được file hoặc directory mong muốn.<br />
Ví dụ: nếu một người dùng tạo một thư mục <code>foo</code> trong thư mục gốc <code>/</code>, và sau đó tạo một file <code>bar.txt</code> trong thư mục <code>foo</code>, chúng ta có thể tham chiếu tới file này bằng <strong>absolute pathname</strong> (đường dẫn tuyệt đối), trong trường hợp này sẽ là:</p>
<pre><code>/foo/bar.txt
</code></pre>
<p><img src="39/img/fig39_1.PNG" alt="" /></p>
<p><strong>Hình 39.1: Ví dụ về cây thư mục (An Example Directory Tree)</strong></p>
<blockquote>
<p><strong>TIP: SUY NGHĨ CẨN THẬN VỀ VIỆC ĐẶT TÊN</strong></p>
<p>Đặt tên (<strong>naming</strong>) là một khía cạnh quan trọng của các hệ thống máy tính. Trong các hệ thống UNIX, hầu như mọi thứ bạn có thể nghĩ tới đều được đặt tên thông qua <strong>file system</strong> (hệ thống tệp). Không chỉ các file, mà cả thiết bị (<strong>device</strong>), ống dẫn (<strong>pipe</strong>), và thậm chí cả <strong>process</strong> (tiến trình) cũng có thể được tìm thấy trong một cấu trúc trông giống như một hệ thống tệp thông thường.<br />
Sự thống nhất trong cách đặt tên này giúp đơn giản hóa mô hình khái niệm của bạn về hệ thống, và làm cho hệ thống trở nên đơn giản hơn và có tính mô-đun cao hơn. Vì vậy, bất cứ khi nào tạo một hệ thống hoặc giao diện, hãy suy nghĩ kỹ về những cái tên bạn đang sử dụng.</p>
</blockquote>
<p>Các <strong>directory</strong> (thư mục) và <strong>file</strong> (tệp) có thể trùng tên miễn là chúng nằm ở các vị trí khác nhau trong cây hệ thống tệp.<br />
Ví dụ: có thể tồn tại hai file tên <code>bar.txt</code> như trong hình minh họa: <code>/foo/bar.txt</code> và <code>/bar/foo/bar.txt</code>.</p>
<h2 id="392-giao-diện-hệ-thống-tệp-the-file-system-interface"><a class="header" href="#392-giao-diện-hệ-thống-tệp-the-file-system-interface">39.2 Giao diện hệ thống tệp (The File System Interface)</a></h2>
<p>Bây giờ, chúng ta sẽ thảo luận chi tiết hơn về <strong>file system interface</strong> (giao diện hệ thống tệp).<br />
Chúng ta sẽ bắt đầu với những thao tác cơ bản: tạo, truy cập và xóa file.<br />
Bạn có thể nghĩ rằng điều này khá đơn giản, nhưng trong quá trình tìm hiểu, chúng ta sẽ khám phá một <strong>system call</strong> bí ẩn được dùng để xóa file, gọi là <code>unlink()</code>.<br />
Hy vọng rằng, đến cuối chương này, lời giải cho “bí ẩn” đó sẽ trở nên rõ ràng với bạn.</p>
<h2 id="393-tạo-file-creating-files"><a class="header" href="#393-tạo-file-creating-files">39.3 Tạo file (Creating Files)</a></h2>
<p>Chúng ta sẽ bắt đầu với thao tác cơ bản nhất: <strong>tạo một file</strong>.<br />
Điều này có thể thực hiện được với <strong>system call</strong> <code>open</code>; bằng cách gọi <code>open()</code> và truyền vào cờ (<strong>flag</strong>) <code>O_CREAT</code>, một chương trình có thể tạo ra một file mới.<br />
Dưới đây là ví dụ mã nguồn để tạo một file tên “foo” trong <strong>current working directory</strong> (thư mục làm việc hiện tại):</p>
<pre><code class="language-c">int fd = open(&quot;foo&quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR);
</code></pre>
<blockquote>
<p><strong>ASIDE: SYSTEM CALL CREAT()</strong></p>
<p>Cách cũ hơn để tạo file là gọi <code>creat()</code>, như sau:</p>
<pre><code class="language-c">// tùy chọn: thêm tham số thứ hai để thiết lập quyền truy cập
int fd = creat(&quot;foo&quot;);
</code></pre>
<p>Bạn có thể coi <code>creat()</code> tương đương với <code>open()</code> với các cờ: <code>O_CREAT | O_WRONLY | O_TRUNC</code>.<br />
Vì <code>open()</code> có thể tạo file, nên việc sử dụng <code>creat()</code> đã phần nào ít phổ biến hơn.<br />
Tuy nhiên, nó vẫn giữ một vị trí đặc biệt trong “truyền thuyết” UNIX.<br />
Cụ thể, khi Ken Thompson được hỏi ông sẽ làm gì khác nếu thiết kế lại UNIX, ông trả lời:<br />
“Tôi sẽ viết <code>creat</code> với một chữ e” (tức là <code>create</code>).</p>
</blockquote>
<p>Một khía cạnh quan trọng của <code>open()</code> là giá trị nó trả về: <strong>file descriptor</strong> (bộ mô tả tệp).<br />
File descriptor chỉ đơn giản là một số nguyên, riêng cho mỗi <strong>process</strong> (tiến trình), và được dùng trong các hệ thống UNIX để truy cập file.</p>
<p>Các file descriptor được hệ điều hành quản lý <strong>theo từng process</strong>.<br />
Điều này có nghĩa là một cấu trúc dữ liệu đơn giản nào đó (ví dụ: một mảng) được lưu trong <strong>proc structure</strong> (cấu trúc tiến trình) trên các hệ thống UNIX.<br />
Dưới đây là phần liên quan từ <strong>xv6 kernel</strong>:</p>
<h2 id="394-Đọc-và-ghi-tệp-reading-and-writing-files"><a class="header" href="#394-Đọc-và-ghi-tệp-reading-and-writing-files">39.4 Đọc và ghi tệp (Reading And Writing Files)</a></h2>
<p>Khi đã có một số file, tất nhiên chúng ta sẽ muốn đọc hoặc ghi chúng.<br />
Hãy bắt đầu bằng việc đọc một file đã tồn tại.<br />
Nếu đang gõ lệnh trong <strong>command line</strong> (dòng lệnh), chúng ta có thể dùng chương trình <code>cat</code> để hiển thị nội dung của file ra màn hình.</p>
<pre><code class="language-sh">prompt&gt; echo hello &gt; foo
prompt&gt; cat foo
hello
prompt&gt;
</code></pre>
<p>Để tìm hiểu điều gì thực sự xảy ra, chúng ta sẽ sử dụng một công cụ cực kỳ hữu ích để <strong>theo dõi các system call</strong> mà một chương trình thực hiện.<br />
Trên Linux, công cụ này được gọi là <code>strace</code>.<br />
Dưới đây là ví dụ sử dụng <code>strace</code> để tìm hiểu <code>cat</code> đang làm gì (một số call đã được lược bỏ để dễ đọc):</p>
<p>...</p>
<p>Tại sao lần gọi <code>open()</code> đầu tiên lại trả về <strong>3</strong>, chứ không phải <strong>0</strong> hoặc <strong>1</strong>?<br />
Hóa ra, mỗi <strong>process</strong> (tiến trình) đang chạy đã mặc định mở sẵn <strong>ba file</strong>:</p>
<ul>
<li><strong>standard input</strong> (stdin – bộ mô tả tệp số 0)</li>
<li><strong>standard output</strong> (stdout – bộ mô tả tệp số 1)</li>
<li><strong>standard error</strong> (stderr – bộ mô tả tệp số 2)</li>
</ul>
<p>Sau khi <code>open</code> thành công, <code>cat</code> sử dụng <strong>system call</strong> <code>read()</code> để liên tục đọc một số byte từ file.<br />
Chương trình sau đó cố gắng đọc thêm, nhưng vì không còn byte nào, <code>read()</code> trả về <strong>0</strong> và chương trình hiểu rằng nó đã đọc hết toàn bộ file.<br />
Do đó, chương trình gọi <code>close()</code> để báo rằng nó đã hoàn tất.</p>
<h2 id="395-Đọc-và-ghi-nhưng-không-theo-tuần-tự-reading-and-writing-but-not-sequentially"><a class="header" href="#395-Đọc-và-ghi-nhưng-không-theo-tuần-tự-reading-and-writing-but-not-sequentially">39.5 Đọc và ghi, nhưng không theo tuần tự (Reading And Writing, But Not Sequentially)</a></h2>
<p>Đôi khi, chúng ta cần đọc hoặc ghi tại một <strong>offset</strong> (vị trí bù) cụ thể trong file.<br />
Để làm điều này, ta sử dụng <strong>system call</strong> <code>lseek()</code>:</p>
<pre><code class="language-c">off_t lseek(int fildes, off_t offset, int whence);
</code></pre>
<p>Tham số <code>whence</code> xác định chính xác cách dịch chuyển con trỏ file:</p>
<ul>
<li><strong>SEEK_SET</strong>: đặt offset hiện tại thành <code>offset</code> byte.</li>
<li><strong>SEEK_CUR</strong>: đặt offset thành vị trí hiện tại cộng thêm <code>offset</code> byte.</li>
<li><strong>SEEK_END</strong>: đặt offset thành kích thước file cộng thêm <code>offset</code> byte.</li>
</ul>
<p>Với mỗi file mà một process mở, hệ điều hành sẽ theo dõi một <strong>offset hiện tại</strong> (current offset), xác định vị trí bắt đầu cho lần đọc hoặc ghi tiếp theo.<br />
Offset này được cập nhật <strong>ngầm</strong> khi gọi <code>read</code> hoặc <code>write</code>, hoặc <strong>tường minh</strong> khi gọi <code>lseek</code>.<br />
Offset này được lưu trong <strong>struct file</strong>.<br />
Dưới đây là định nghĩa (đơn giản hóa) của cấu trúc này trong <strong>xv6</strong>:</p>
<pre><code class="language-c">struct file {
  int ref;
  char readable;
  char writable;
  struct inode *ip;
  uint off;
};
</code></pre>
<blockquote>
<p><strong>ASIDE: GỌI LSEEK() KHÔNG THỰC HIỆN DISK SEEK</strong></p>
<p>Tên gọi của system call <code>lseek()</code> dễ gây nhầm lẫn cho nhiều sinh viên.<br />
Lời gọi <code>lseek()</code> chỉ đơn giản thay đổi một biến trong bộ nhớ của hệ điều hành, biến này theo dõi offset hiện tại.<br />
<strong>Disk seek</strong> (dịch chuyển đầu đọc đĩa) chỉ xảy ra khi một thao tác đọc hoặc ghi tới đĩa nằm trên một track khác so với thao tác trước đó.<br />
Gọi <code>lseek()</code> có thể dẫn đến một disk seek trong thao tác đọc hoặc ghi tiếp theo, nhưng bản thân nó <strong>không hề</strong> gây ra bất kỳ I/O vật lý nào.</p>
</blockquote>
<p>Hãy theo dõi một process mở một file (kích thước 300 byte) và đọc nó bằng cách gọi <code>read()</code> nhiều lần, mỗi lần đọc 100 byte.</p>
<h2 id="396-chia-sẻ-entry-trong-bảng-file-mở-fork-và-dup-shared-file-table-entries-fork-and-dup"><a class="header" href="#396-chia-sẻ-entry-trong-bảng-file-mở-fork-và-dup-shared-file-table-entries-fork-and-dup">39.6 Chia sẻ entry trong bảng file mở: fork() và dup() (Shared File Table Entries: fork() And dup())</a></h2>
<p>Trong nhiều trường hợp, ánh xạ từ <strong>file descriptor</strong> (bộ mô tả tệp) tới một entry trong <strong>open file table</strong> (bảng file mở) là ánh xạ <strong>một-một</strong>.<br />
Tuy nhiên, có một số trường hợp thú vị khi một entry trong open file table được <strong>chia sẻ</strong>.<br />
Một trong những trường hợp đó xảy ra khi <strong>process cha</strong> tạo ra <strong>process con</strong> bằng <code>fork()</code>.</p>
<p><img src="39/img/fig39_2.PNG" alt="" /></p>
<p><strong>Hình 39.2: Chia sẻ entry bảng file giữa tiến trình cha/con (fork-seek.c)</strong></p>
<p>Khi chạy chương trình này, chúng ta thấy kết quả sau:</p>
<pre><code class="language-sh">prompt&gt; ./fork-seek
child: offset 10
parent: offset 10
prompt&gt;
</code></pre>
<p>Một trường hợp chia sẻ khác xảy ra với <strong>system call</strong> <code>dup()</code>.<br />
Lời gọi <code>dup()</code> cho phép một <strong>process</strong> (tiến trình) tạo ra một <strong>file descriptor</strong> (bộ mô tả tệp) mới tham chiếu tới <strong>cùng một file đã mở</strong> (open file) như một descriptor hiện có.</p>
<p>...</p>
<p><img src="39/img/fig39_3.PNG" alt="" /></p>
<p><strong>Hình 39.4: Chia sẻ entry bảng file với dup() (dup.c)</strong></p>
<h2 id="397-ghi-ngay-lập-tức-với-fsync-writing-immediately-with-fsync"><a class="header" href="#397-ghi-ngay-lập-tức-với-fsync-writing-immediately-with-fsync">39.7 Ghi ngay lập tức với fsync() (Writing Immediately With fsync())</a></h2>
<p>Thông thường, khi một chương trình gọi <code>write()</code>, <strong>file system</strong> (hệ thống tệp) sẽ <strong>buffer</strong> (đệm) các thao tác ghi này trong bộ nhớ một thời gian vì lý do hiệu năng.<br />
Tuy nhiên, một số ứng dụng yêu cầu khả năng <strong>ép</strong> dữ liệu được ghi xuống đĩa ngay lập tức.</p>
<p>Để hỗ trợ các ứng dụng loại này, hầu hết các file system cung cấp <strong>system call</strong>:</p>
<pre><code class="language-c">int fsync(int fd);
</code></pre>
<p>Khi một process gọi <code>fsync()</code>, file system sẽ buộc tất cả dữ liệu <strong>dirty</strong> (chưa được ghi xuống đĩa) của file được tham chiếu bởi file descriptor chỉ định phải được ghi xuống đĩa.</p>
<h2 id="398-Đổi-tên-file-renaming-files"><a class="header" href="#398-Đổi-tên-file-renaming-files">39.8 Đổi tên file (Renaming Files)</a></h2>
<p>Để đổi tên một file, lệnh <code>mv</code> sử dụng <strong>system call</strong>:</p>
<pre><code class="language-c">int rename(char *old, char *new);
</code></pre>
<p>Một đảm bảo thú vị mà <code>rename()</code> cung cấp là nó (thường) được triển khai như một call <strong>atomic</strong> (nguyên tử) đối với các sự cố <strong>system crash</strong> (sập hệ thống).<br />
Điều này rất quan trọng đối với các ứng dụng yêu cầu cập nhật trạng thái file một cách nguyên tử.<br />
Ví dụ, một trình soạn thảo file có thể thực hiện các bước sau để lưu thay đổi một cách an toàn:</p>
<p>...</p>
<p>Bước cuối cùng này <strong>hoán đổi nguyên tử</strong> file mới vào vị trí, đồng thời xóa phiên bản cũ của file.</p>
<h2 id="399-lấy-thông-tin-về-file-getting-information-about-files"><a class="header" href="#399-lấy-thông-tin-về-file-getting-information-about-files">39.9 Lấy thông tin về file (Getting Information About Files)</a></h2>
<p>File system lưu trữ khá nhiều thông tin về mỗi file, mà chúng ta thường gọi là <strong>metadata</strong> (siêu dữ liệu).<br />
Để xem metadata của một file cụ thể, chúng ta có thể sử dụng <strong>system call</strong> <code>stat()</code> hoặc <code>fstat()</code>.<br />
Các call này sẽ điền thông tin vào một cấu trúc <code>stat</code>:</p>
<p>...</p>
<p><img src="39/img/fig39_4.PNG" alt="" /></p>
<p><strong>Hình 39.5: Cấu trúc stat (The stat structure)</strong></p>
<p>Bạn cũng có thể sử dụng công cụ dòng lệnh <code>stat</code> để xem thông tin này.</p>
<h2 id="3910-xóa-file-removing-files"><a class="header" href="#3910-xóa-file-removing-files">39.10 Xóa file (Removing Files)</a></h2>
<p>Tại thời điểm này, chúng ta đã biết cách tạo tập tin (file) và truy cập chúng, theo tuần tự hoặc không tuần tự. Nhưng làm thế nào để xóa tập tin? Nếu bạn đã từng sử dụng UNIX, có lẽ bạn nghĩ mình biết: chỉ cần chạy chương trình <code>rm</code>. Nhưng <code>rm</code> sử dụng <strong>system call</strong> (lời gọi hệ thống) nào để xóa một tập tin?<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>Hãy dùng lại công cụ quen thuộc <code>strace</code> để tìm hiểu. Dưới đây là ví dụ khi chúng ta xóa tập tin <code>foo</code>:</p>
<pre><code class="language-bash">prompt&gt; strace rm foo
...
unlink(&quot;foo&quot;) = 0
...
</code></pre>
<p>Chúng ta đã loại bỏ nhiều phần thông tin không liên quan từ kết quả <code>strace</code>, chỉ giữ lại một lời gọi duy nhất tới <strong>system call</strong> có tên khá bí ẩn <code>unlink()</code>. Như bạn thấy, <code>unlink()</code> chỉ nhận tên của tập tin cần xóa và trả về giá trị 0 khi thành công. Nhưng điều này dẫn đến một câu hỏi thú vị: tại sao lời gọi hệ thống này lại có tên là <code>unlink</code>? Tại sao không đặt là <code>remove</code> hoặc <code>delete</code>? Để trả lời câu hỏi này, chúng ta cần hiểu không chỉ về tập tin, mà còn về thư mục (directory).</p>
<h2 id="tạo-thư-mục-making-directories"><a class="header" href="#tạo-thư-mục-making-directories">Tạo thư mục (Making Directories)</a></h2>
<p>Ngoài tập tin, một tập hợp các <strong>system call</strong> liên quan đến thư mục cho phép bạn tạo, đọc và xóa thư mục. Lưu ý rằng bạn không bao giờ có thể ghi trực tiếp vào một thư mục. Nguyên nhân là vì định dạng của thư mục được xem là <strong>metadata</strong> (siêu dữ liệu) của hệ thống tập tin, và hệ thống tập tin chịu trách nhiệm đảm bảo tính toàn vẹn của dữ liệu thư mục. Do đó, bạn chỉ có thể cập nhật thư mục một cách gián tiếp, ví dụ: bằng cách tạo tập tin, thư mục con hoặc các loại đối tượng khác bên trong nó. Bằng cách này, hệ thống tập tin đảm bảo nội dung thư mục luôn đúng như mong đợi.</p>
<p>Để tạo một thư mục, có một <strong>system call</strong> duy nhất là <code>mkdir()</code>. Chương trình <code>mkdir</code> cùng tên có thể được dùng để tạo thư mục. Hãy xem điều gì xảy ra khi chúng ta chạy <code>mkdir</code> để tạo một thư mục đơn giản tên <code>foo</code>:</p>
<pre><code class="language-bash">prompt&gt; strace mkdir foo
...
mkdir(&quot;foo&quot;, 0777) = 0
...
prompt&gt;
</code></pre>
<p>Khi một thư mục được tạo, nó được xem là “rỗng”, mặc dù thực tế nó vẫn chứa một số nội dung tối thiểu. Cụ thể, một thư mục rỗng có hai mục (entry): một mục tham chiếu đến chính nó, và một mục tham chiếu đến thư mục cha. Mục thứ nhất được gọi là “.” (dot), và mục thứ hai là “..” (dot-dot). Bạn có thể thấy các mục này bằng cách truyền tùy chọn (<code>-a</code>) cho chương trình <code>ls</code>:</p>
<pre><code class="language-bash">prompt&gt; ls -a
./ ../
prompt&gt; ls -al
total 8
drwxr-x--- 2 remzi remzi    6 Apr 30 16:17 ./
drwxr-x--- 26 remzi remzi 4096 Apr 30 16:17 ../
</code></pre>
<blockquote>
<p><strong>TIP: CẨN TRỌNG VỚI CÁC LỆNH MẠNH</strong>
Chương trình <code>rm</code> là một ví dụ điển hình về các lệnh mạnh mẽ, và đôi khi sức mạnh quá mức có thể gây hại. Ví dụ, để xóa nhiều tập tin cùng lúc, bạn có thể gõ:</p>
<pre><code class="language-bash">prompt&gt; rm *
</code></pre>
<p>Trong đó, ký tự <code>*</code> sẽ khớp với tất cả các tập tin trong thư mục hiện tại. Nhưng đôi khi bạn cũng muốn xóa cả thư mục và toàn bộ nội dung của chúng. Bạn có thể làm điều này bằng cách yêu cầu <code>rm</code> đệ quy đi vào từng thư mục và xóa nội dung bên trong:</p>
<pre><code class="language-bash">prompt&gt; rm -rf *
</code></pre>
<p>Vấn đề nghiêm trọng xảy ra khi bạn vô tình chạy lệnh này từ thư mục gốc của hệ thống tập tin, dẫn đến việc xóa toàn bộ tập tin và thư mục. Vì vậy, hãy nhớ rằng các lệnh mạnh mẽ giống như con dao hai lưỡi: chúng cho phép bạn làm được rất nhiều việc chỉ với vài phím bấm, nhưng cũng có thể gây ra thiệt hại lớn trong chớp mắt.</p>
</blockquote>
<h2 id="Đọc-thư-mục-reading-directories"><a class="header" href="#Đọc-thư-mục-reading-directories">Đọc thư mục (Reading Directories)</a></h2>
<p>Bây giờ chúng ta đã tạo được một thư mục, có thể chúng ta cũng muốn đọc nội dung của nó. Thực tế, đó chính là điều mà chương trình <code>ls</code> thực hiện. Hãy thử viết một công cụ nhỏ giống <code>ls</code> để xem cách làm. Thay vì chỉ mở thư mục như một tập tin, chúng ta sẽ dùng một tập hợp lời gọi mới. Dưới đây là chương trình ví dụ in ra nội dung của một thư mục. Chương trình sử dụng ba lời gọi <code>opendir()</code>, <code>readdir()</code> và <code>closedir()</code> để thực hiện công việc. Giao diện này khá đơn giản: chỉ cần một vòng lặp để đọc từng mục thư mục một, rồi in ra tên và số inode của mỗi tập tin.</p>
<pre><code class="language-c">int main(int argc, char *argv[]) {
    DIR *dp = opendir(&quot;.&quot;);
    assert(dp != NULL);
    struct dirent *d;
    while ((d = readdir(dp)) != NULL) {
        printf(&quot;%lu %s\n&quot;, (unsigned long) d-&gt;d_ino, d-&gt;d_name);
    }
    closedir(dp);
    return 0;
}
</code></pre>
<p>Khai báo dưới đây cho thấy thông tin có trong mỗi mục thư mục, được lưu trong cấu trúc dữ liệu <code>struct dirent</code>:</p>
<pre><code class="language-c">struct dirent {
    char          d_name[256]; // tên tập tin
    ino_t         d_ino;       // số inode
    off_t         d_off;       // vị trí (offset) tới mục tiếp theo
    unsigned short d_reclen;   // độ dài bản ghi này
    unsigned char d_type;      // loại tập tin
};
</code></pre>
<p>Vì thư mục chứa rất ít thông tin (về cơ bản chỉ ánh xạ tên sang số inode, cùng một vài chi tiết khác), một chương trình có thể muốn gọi <code>stat()</code> trên từng tập tin để lấy thêm thông tin, chẳng hạn như kích thước hoặc các thuộc tính chi tiết khác. Thực tế, đây chính là điều <code>ls</code> làm khi bạn truyền cho nó tùy chọn <code>-l</code>. Hãy thử dùng <code>strace</code> trên <code>ls</code> với và không có tùy chọn này để tự kiểm chứng.</p>
<h2 id="xóa-thư-mục-deleting-directories"><a class="header" href="#xóa-thư-mục-deleting-directories">Xóa thư mục (Deleting Directories)</a></h2>
<p>Cuối cùng, bạn có thể xóa một thư mục bằng lời gọi <code>rmdir()</code> (được sử dụng bởi chương trình cùng tên <code>rmdir</code>). Không giống như việc xóa tập tin, xóa thư mục nguy hiểm hơn, vì bạn có thể xóa một lượng lớn dữ liệu chỉ với một lệnh. Do đó, <code>rmdir()</code> yêu cầu thư mục phải rỗng (tức là chỉ chứa các mục “.” và “..”) trước khi bị xóa. Nếu bạn cố gắng xóa một thư mục không rỗng, lời gọi <code>rmdir()</code> sẽ thất bại.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><code>strace</code> là công cụ theo dõi các <strong>system call</strong> mà một tiến trình thực hiện, rất hữu ích để tìm hiểu cách chương trình tương tác với kernel.</p>
</div>
<p>Dưới đây là bản dịch tiếng Việt hoàn chỉnh, tuân thủ đầy đủ các yêu cầu bạn đưa ra, giữ nguyên thuật ngữ kỹ thuật phổ biến, bổ sung giải thích khi cần, và trình bày theo phong cách học thuật dành cho sinh viên ngành Khoa học Máy tính.</p>
<h2 id="hard-links-liên-kết-cứng"><a class="header" href="#hard-links-liên-kết-cứng">Hard Links (Liên kết cứng)</a></h2>
<p>Bây giờ chúng ta quay lại câu hỏi bí ẩn: tại sao việc xóa một tập tin lại được thực hiện thông qua <code>unlink()</code>? Để hiểu điều này, ta cần biết một cách khác để tạo một mục (entry) trong cây hệ thống tập tin, thông qua một <strong>system call</strong> (lời gọi hệ thống) có tên <code>link()</code>. Lời gọi <code>link()</code> nhận hai tham số: một đường dẫn cũ và một đường dẫn mới; khi bạn “link” (liên kết) một tên tập tin mới tới một tên tập tin cũ, bạn thực chất đang tạo thêm một cách khác để tham chiếu đến cùng một tập tin. Chương trình dòng lệnh <code>ln</code> được dùng để làm việc này, như trong ví dụ sau:</p>
<pre><code class="language-bash">prompt&gt; echo hello &gt; file
prompt&gt; cat file
hello
prompt&gt; ln file file2
prompt&gt; cat file2
hello
</code></pre>
<p>Ở đây, chúng ta tạo một tập tin chứa từ “hello” và đặt tên là <code>file</code>. Sau đó, chúng ta tạo một <strong>hard link</strong> (liên kết cứng) tới tập tin đó bằng chương trình <code>ln</code>. Sau bước này, chúng ta có thể đọc nội dung tập tin bằng cách mở <code>file</code> hoặc <code>file2</code>. Cách <code>link()</code> hoạt động là: nó chỉ đơn giản tạo thêm một tên mới trong thư mục mà bạn đang tạo liên kết, và trỏ tên đó tới cùng <strong>inode number</strong> (số inode – định danh mức thấp của tập tin) của tập tin gốc. Tập tin không hề được sao chép; thay vào đó, bạn có hai tên dễ đọc (<code>file</code> và <code>file2</code>) cùng trỏ tới cùng một tập tin. Chúng ta có thể thấy điều này ngay trong thư mục, bằng cách in ra số inode của từng tập tin:</p>
<pre><code class="language-bash">prompt&gt; ls -i file file2
67158084 file
67158084 file2
prompt&gt;
</code></pre>
<p>Khi truyền tùy chọn <code>-i</code> cho <code>ls</code>, nó sẽ in ra số inode của mỗi tập tin (cùng với tên tập tin). Như vậy, bạn có thể thấy <code>link</code> thực chất đã làm gì: chỉ tạo một tham chiếu mới tới cùng một số inode (67158084 trong ví dụ này).</p>
<p>Đến đây, bạn có thể bắt đầu hiểu tại sao <code>unlink()</code> lại có tên như vậy. Khi bạn tạo một tập tin, thực chất bạn đang làm hai việc:</p>
<ol>
<li>Tạo một cấu trúc dữ liệu (inode) để lưu hầu hết thông tin liên quan đến tập tin, bao gồm kích thước, vị trí các block trên đĩa, v.v.</li>
<li>Liên kết một tên dễ đọc với tập tin đó, và đặt liên kết này vào một thư mục.</li>
</ol>
<p>Sau khi tạo một hard link tới tập tin, hệ thống tập tin không phân biệt giữa tên gốc (<code>file</code>) và tên mới (<code>file2</code>); cả hai chỉ là các liên kết tới metadata (siêu dữ liệu) của tập tin, được lưu trong inode số 67158084.</p>
<p>Vì vậy, để xóa một tập tin khỏi hệ thống tập tin, ta gọi <code>unlink()</code>. Trong ví dụ trên, ta có thể xóa tập tin <code>file</code> và vẫn truy cập được nội dung qua <code>file2</code>:</p>
<pre><code class="language-bash">prompt&gt; rm file
removed ‘file’
prompt&gt; cat file2
hello
</code></pre>
<p>Điều này hoạt động được vì khi hệ thống tập tin thực hiện <code>unlink()</code> trên <code>file</code>, nó sẽ kiểm tra <strong>reference count</strong> (bộ đếm tham chiếu, đôi khi gọi là link count) trong inode. Reference count cho biết có bao nhiêu tên tập tin khác nhau đang liên kết tới inode này. Khi <code>unlink()</code> được gọi, nó xóa liên kết giữa tên dễ đọc (tập tin bị xóa) và inode tương ứng, đồng thời giảm reference count đi 1; chỉ khi reference count giảm xuống 0, hệ thống tập tin mới giải phóng inode và các block dữ liệu liên quan, và khi đó tập tin mới thực sự bị “xóa” khỏi đĩa.<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>Bạn có thể xem reference count của một tập tin bằng cách dùng <code>stat()</code>. Hãy xem ví dụ khi chúng ta tạo và xóa các hard link tới một tập tin. Trong ví dụ này, ta sẽ tạo ba liên kết tới cùng một tập tin, rồi xóa chúng. Hãy chú ý đến link count:</p>
<pre><code class="language-bash">prompt&gt; echo hello &gt; file
prompt&gt; stat file
... Inode: 67158084 Links: 1 ...
prompt&gt; ln file file2
prompt&gt; stat file
... Inode: 67158084 Links: 2 ...
prompt&gt; stat file2
... Inode: 67158084 Links: 2 ...
prompt&gt; ln file2 file3
prompt&gt; stat file
... Inode: 67158084 Links: 3 ...
prompt&gt; rm file
prompt&gt; stat file2
... Inode: 67158084 Links: 2 ...
prompt&gt; rm file2
prompt&gt; stat file3
... Inode: 67158084 Links: 1 ...
prompt&gt; rm file3
</code></pre>
<h2 id="symbolic-links-liên-kết-tượng-trưng"><a class="header" href="#symbolic-links-liên-kết-tượng-trưng">Symbolic Links (Liên kết tượng trưng)</a></h2>
<p>Có một loại liên kết khác rất hữu ích, gọi là <strong>symbolic link</strong> (liên kết tượng trưng) hoặc đôi khi là <strong>soft link</strong> (liên kết mềm). Hard link có một số hạn chế: bạn không thể tạo hard link tới một thư mục (để tránh tạo vòng lặp trong cây thư mục); bạn không thể hard link tới tập tin ở phân vùng đĩa khác (vì số inode chỉ là duy nhất trong một hệ thống tập tin, không phải giữa các hệ thống tập tin khác nhau); v.v. Vì vậy, một loại liên kết mới – symbolic link – đã được tạo ra.<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<p>Để tạo symbolic link, bạn vẫn dùng chương trình <code>ln</code>, nhưng thêm tùy chọn <code>-s</code>. Ví dụ:</p>
<pre><code class="language-bash">prompt&gt; echo hello &gt; file
prompt&gt; ln -s file file2
prompt&gt; cat file2
hello
</code></pre>
<p>Như bạn thấy, việc tạo soft link trông khá giống với hard link, và tập tin gốc giờ có thể được truy cập qua tên <code>file</code> hoặc qua symbolic link <code>file2</code>. Tuy nhiên, ngoài sự giống nhau bề ngoài này, symbolic link thực chất khác hard link ở nhiều điểm. Điểm khác biệt đầu tiên là symbolic link thực chất là một tập tin riêng, thuộc loại khác. Chúng ta đã nói về regular file (tập tin thường) và directory (thư mục); symbolic link là loại thứ ba mà hệ thống tập tin nhận biết. Khi chạy <code>stat</code> trên symbolic link, bạn sẽ thấy:</p>
<pre><code class="language-bash">prompt&gt; stat file
... regular file ...
prompt&gt; stat file2
... symbolic link ...
</code></pre>
<p>Chạy <code>ls</code> cũng cho thấy điều này. Nếu bạn để ý ký tự đầu tiên trong cột ngoài cùng bên trái của kết quả <code>ls -l</code>, bạn sẽ thấy: ký tự <code>-</code> cho regular file, <code>d</code> cho directory, và <code>l</code> cho symbolic link. Bạn cũng có thể thấy kích thước của symbolic link (4 byte trong trường hợp này) và tập tin mà nó trỏ tới (<code>file</code>):</p>
<pre><code class="language-bash">prompt&gt; ls -al
drwxr-x--- 2 remzi remzi   29 May  3 19:10 ./
drwxr-x--- 27 remzi remzi 4096 May  3 15:14 ../
-rw-r----- 1 remzi remzi    6 May  3 19:10 file
lrwxrwxrwx 1 remzi remzi    4 May  3 19:10 file2 -&gt; file
</code></pre>
<p>Lý do <code>file2</code> có kích thước 4 byte là vì symbolic link lưu <strong>pathname</strong> (đường dẫn) của tập tin mà nó trỏ tới như dữ liệu của chính symbolic link đó. Vì chúng ta liên kết tới tập tin tên <code>file</code>, symbolic link <code>file2</code> chỉ dài 4 byte. Nếu liên kết tới một đường dẫn dài hơn, symbolic link sẽ lớn hơn:</p>
<pre><code class="language-bash">prompt&gt; echo hello &gt; alongerfilename
prompt&gt; ln -s alongerfilename file3
prompt&gt; ls -al alongerfilename file3
-rw-r----- 1 remzi remzi  6 May 3 19:17 alongerfilename
lrwxrwxrwx 1 remzi remzi 15 May 3 19:17 file3 -&gt; alongerfilename
</code></pre>
<p>Cuối cùng, do cách symbolic link được tạo ra, nó có thể dẫn đến tình huống gọi là <strong>dangling reference</strong> (tham chiếu treo):</p>
<pre><code class="language-bash">prompt&gt; echo hello &gt; file
prompt&gt; ln -s file file2
prompt&gt; cat file2
hello
prompt&gt; rm file
prompt&gt; cat file2
cat: file2: No such file or directory
</code></pre>
<p>Như bạn thấy, khác với hard link, khi xóa tập tin gốc <code>file</code>, symbolic link sẽ trỏ tới một đường dẫn không còn tồn tại.</p>
<h2 id="permission-bits-và-access-control-lists-danh-sách-kiểm-soát-truy-cập"><a class="header" href="#permission-bits-và-access-control-lists-danh-sách-kiểm-soát-truy-cập">Permission Bits và Access Control Lists (Danh sách kiểm soát truy cập)</a></h2>
<p>Khái niệm trừu tượng (abstraction) của <strong>process</strong> (tiến trình) cung cấp hai dạng ảo hóa (virtualization) trung tâm: ảo hóa CPU và ảo hóa bộ nhớ. Mỗi dạng ảo hóa này tạo cho tiến trình ảo giác rằng nó có CPU riêng và bộ nhớ riêng; trên thực tế, <strong>OS</strong> (hệ điều hành) bên dưới sử dụng nhiều kỹ thuật khác nhau để chia sẻ tài nguyên vật lý hạn chế giữa các thực thể cạnh tranh một cách an toàn và bảo mật.</p>
<p><strong>File system</strong> (hệ thống tập tin) cũng cung cấp một cái nhìn ảo về đĩa, biến nó từ một tập hợp các block thô thành các tập tin và thư mục thân thiện hơn với người dùng, như đã mô tả trong chương này. Tuy nhiên, sự trừu tượng này khác đáng kể so với CPU và bộ nhớ, ở chỗ tập tin thường được chia sẻ giữa nhiều người dùng và tiến trình, và không phải lúc nào cũng là riêng tư. Do đó, trong file system thường tồn tại một tập hợp cơ chế toàn diện hơn để cho phép các mức độ chia sẻ khác nhau.</p>
<p>Hình thức cơ bản đầu tiên của các cơ chế này là <strong>permission bits</strong> (các bit quyền truy cập) kiểu UNIX cổ điển. Để xem quyền truy cập của một tập tin <code>foo.txt</code>, chỉ cần gõ:</p>
<pre><code class="language-bash">prompt&gt; ls -l foo.txt
-rw-r--r-- 1 remzi wheel 0 Aug 24 16:29 foo.txt
</code></pre>
<p>Chúng ta sẽ chỉ tập trung vào phần đầu tiên của kết quả này, cụ thể là <code>-rw-r--r--</code>. Ký tự đầu tiên cho biết loại tập tin: <code>-</code> cho <strong>regular file</strong> (tập tin thường, như <code>foo.txt</code>), <code>d</code> cho <strong>directory</strong> (thư mục), <code>l</code> cho <strong>symbolic link</strong> (liên kết tượng trưng), v.v.; phần này (hầu hết) không liên quan đến quyền truy cập, nên tạm thời bỏ qua.</p>
<p>Phần chúng ta quan tâm là <strong>permission bits</strong>, được biểu diễn bởi chín ký tự tiếp theo (<code>rw-r--r--</code>). Các bit này xác định, đối với mỗi tập tin thường, thư mục hoặc thực thể khác, ai có thể truy cập và truy cập như thế nào. Quyền được chia thành ba nhóm: quyền của <strong>owner</strong> (chủ sở hữu tập tin), quyền của <strong>group</strong> (nhóm) mà tập tin thuộc về, và quyền của <strong>others</strong> (người dùng khác). Các quyền này bao gồm: đọc (read), ghi (write) và thực thi (execute) tập tin.</p>
<p>Trong ví dụ trên, ba ký tự đầu tiên (<code>rw-</code>) cho biết tập tin có thể đọc và ghi bởi owner; ba ký tự tiếp theo (<code>r--</code>) cho biết chỉ có thể đọc bởi các thành viên của group <code>wheel</code>; và ba ký tự cuối (<code>r--</code>) cho biết chỉ có thể đọc bởi mọi người khác trong hệ thống.</p>
<p>Owner của tập tin có thể thay đổi các quyền này, ví dụ bằng lệnh <code>chmod</code> (change mode). Để loại bỏ quyền truy cập của tất cả mọi người trừ owner, bạn có thể gõ:</p>
<pre><code class="language-bash">prompt&gt; chmod 600 foo.txt
</code></pre>
<blockquote>
<p><strong>ASIDE: SUPERUSER TRONG FILE SYSTEM</strong>
Người dùng nào được phép thực hiện các thao tác đặc quyền để quản trị file system? Ví dụ, nếu cần xóa tập tin của một người dùng không hoạt động để giải phóng dung lượng, ai có quyền làm điều đó? Trong file system cục bộ, mặc định phổ biến là có một <strong>superuser</strong> (người dùng siêu cấp, thường là <code>root</code>) có thể truy cập tất cả tập tin bất kể quyền hạn. Trong file system phân tán như AFS (có <strong>access control lists</strong>), một nhóm gọi là <code>system:administrators</code> chứa các người dùng được tin cậy để làm việc này. Trong cả hai trường hợp, các người dùng đặc quyền này tiềm ẩn rủi ro bảo mật; nếu kẻ tấn công giả mạo được họ, toàn bộ dữ liệu trong hệ thống có thể bị truy cập, vi phạm tính riêng tư và bảo vệ dữ liệu.</p>
</blockquote>
<p>Lệnh trên bật bit đọc (4) và bit ghi (2) cho owner (OR hai giá trị này được 6), nhưng đặt quyền của group và others về 0, tạo thành quyền <code>rw-------</code>.</p>
<p>Bit thực thi (<strong>execute bit</strong>) đặc biệt thú vị. Đối với regular file, bit này quyết định chương trình có thể chạy hay không. Ví dụ, nếu có một shell script tên <code>hello.csh</code>, ta có thể chạy nó bằng:</p>
<pre><code class="language-bash">prompt&gt; ./hello.csh
hello, from shell world.
</code></pre>
<p>Tuy nhiên, nếu không đặt bit thực thi đúng cách:</p>
<pre><code class="language-bash">prompt&gt; chmod 600 hello.csh
prompt&gt; ./hello.csh
./hello.csh: Permission denied.
</code></pre>
<p>Đối với directory, bit thực thi hoạt động khác: nó cho phép người dùng (hoặc group, hoặc mọi người) có thể <strong>cd</strong> vào thư mục đó, và kết hợp với bit ghi, có thể tạo tập tin bên trong. Cách tốt nhất để hiểu rõ là tự thử nghiệm.</p>
<p>Ngoài permission bits, một số file system như AFS (được đề cập ở chương sau) cung cấp cơ chế kiểm soát tinh vi hơn, dưới dạng <strong>Access Control List</strong> (ACL) cho mỗi thư mục. ACL cho phép xác định chính xác ai có thể truy cập tài nguyên. Trong file system, ACL cho phép tạo danh sách cụ thể ai được và không được đọc một tập hợp tập tin, khác với mô hình owner/group/others hạn chế của permission bits.</p>
<p>Ví dụ, đây là quyền truy cập của một thư mục riêng tư trong tài khoản AFS của một tác giả, hiển thị bằng lệnh <code>fs listacl</code>:</p>
<pre><code class="language-bash">prompt&gt; fs listacl private
Access list for private is
Normal rights:
  system:administrators rlidwka
  remzi rlidwka
</code></pre>
<p>Danh sách này cho thấy cả system administrators và người dùng <code>remzi</code> đều có quyền lookup, insert, delete, quản trị thư mục, cũng như đọc, ghi và khóa tập tin. Để cho phép người khác (ở đây là tác giả còn lại) truy cập thư mục này, <code>remzi</code> chỉ cần gõ:</p>
<pre><code class="language-bash">prompt&gt; fs setacl private/ andrea rl
</code></pre>
<p>Vậy là quyền riêng tư của remzi đã mất! Nhưng bạn cũng học được một bài học quan trọng hơn: trong một cuộc hôn nhân tốt đẹp, không có bí mật — ngay cả trong file system.<sup class="footnote-reference"><a href="#4">4</a></sup></p>
<h2 id="tạo-và-mount-một-file-system"><a class="header" href="#tạo-và-mount-một-file-system">Tạo và Mount một File System</a></h2>
<p>Chúng ta đã tìm hiểu các giao diện cơ bản để truy cập tập tin, thư mục và một số loại liên kết đặc biệt. Nhưng còn một chủ đề nữa: làm thế nào để ghép một cây thư mục hoàn chỉnh từ nhiều file system bên dưới. Việc này được thực hiện bằng cách tạo file system, sau đó <strong>mount</strong> chúng để nội dung có thể truy cập.</p>
<p>Để tạo file system, hầu hết các hệ thống cung cấp công cụ <code>mkfs</code> (viết tắt của “make file system”), thực hiện đúng nhiệm vụ này. Ý tưởng: cung cấp cho công cụ một thiết bị (ví dụ: phân vùng đĩa <code>/dev/sda1</code>) và loại file system (ví dụ: <code>ext3</code>), nó sẽ ghi một file system trống, bắt đầu với thư mục gốc, vào phân vùng đó.</p>
<p>Tuy nhiên, sau khi tạo, file system cần được gắn vào cây thư mục thống nhất. Việc này được thực hiện bằng chương trình <code>mount</code> (gọi <strong>system call</strong> <code>mount()</code> để thực hiện). <code>mount</code> sẽ lấy một thư mục hiện có làm <strong>mount point</strong> (điểm gắn) và “dán” file system mới vào cây thư mục tại đó.</p>
<p>Ví dụ: giả sử ta có một file system <code>ext3</code> chưa mount, nằm ở phân vùng <code>/dev/sda1</code>, chứa thư mục gốc với hai thư mục con <code>a</code> và <code>b</code>, mỗi thư mục chứa một tập tin <code>foo</code>. Ta muốn mount nó vào <code>/home/users</code>:</p>
<pre><code class="language-bash">prompt&gt; mount -t ext3 /dev/sda1 /home/users
</code></pre>
<p>Nếu thành công, file system mới sẽ khả dụng. Để xem nội dung thư mục gốc của nó:</p>
<pre><code class="language-bash">prompt&gt; ls /home/users/
a b
</code></pre>
<p>Dưới đây là bản dịch tiếng Việt hoàn chỉnh, tuân thủ đầy đủ các yêu cầu của bạn, giữ nguyên thuật ngữ kỹ thuật phổ biến, bổ sung giải thích khi cần, và trình bày theo phong cách học thuật dành cho sinh viên ngành Khoa học Máy tính.</p>
<hr />
<p>Như bạn thấy, <strong>pathname</strong> <code>/home/users/</code> giờ đây trỏ tới thư mục gốc của thư mục vừa được <strong>mount</strong> (gắn kết). Tương tự, chúng ta có thể truy cập các thư mục <code>a</code> và <code>b</code> thông qua các pathname <code>/home/users/a</code> và <code>/home/users/b</code>. Cuối cùng, các tập tin tên <code>foo</code> có thể được truy cập qua <code>/home/users/a/foo</code> và <code>/home/users/b/foo</code>. Đây chính là ưu điểm của <code>mount</code>: thay vì có nhiều file system riêng biệt, <code>mount</code> hợp nhất tất cả các file system thành một cây duy nhất, giúp việc đặt tên trở nên thống nhất và thuận tiện.</p>
<p>Để xem những gì đang được mount trên hệ thống của bạn, và tại các điểm mount nào, chỉ cần chạy chương trình <code>mount</code>. Bạn sẽ thấy kết quả tương tự như sau:</p>
<pre><code class="language-bash">/dev/sda1 on / type ext3 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
/dev/sda5 on /tmp type ext3 (rw)
/dev/sda7 on /var/vice/cache type ext3 (rw)
tmpfs on /dev/shm type tmpfs (rw)
AFS on /afs type afs (rw)
</code></pre>
<p>Sự kết hợp “hỗn hợp” này cho thấy nhiều loại file system khác nhau, bao gồm <code>ext3</code> (một file system tiêu chuẩn dựa trên đĩa), file system <code>proc</code> (dùng để truy cập thông tin về các <strong>process</strong> – tiến trình – đang chạy), <code>tmpfs</code> (file system dành cho các tập tin tạm thời), và <code>AFS</code> (một file system phân tán), tất cả đều được “ghép” vào cùng một cây file system của máy.</p>
<blockquote>
<p><strong>TIP: CẨN TRỌNG VỚI TOCTTOU</strong></p>
<p>Năm 1974, McPhee phát hiện một vấn đề trong các hệ thống máy tính. Cụ thể, McPhee nhận thấy rằng: “... nếu tồn tại một khoảng thời gian giữa bước kiểm tra tính hợp lệ (validity-check) và thao tác liên quan đến bước kiểm tra đó, [và,] thông qua <strong>multitasking</strong> (đa nhiệm), các biến được kiểm tra có thể bị thay đổi có chủ đích trong khoảng thời gian này, dẫn đến việc chương trình điều khiển thực hiện một thao tác không hợp lệ.” Ngày nay, chúng ta gọi đây là vấn đề <strong>Time Of Check To Time Of Use</strong> (TOCTTOU – từ lúc kiểm tra đến lúc sử dụng), và đáng tiếc là nó vẫn có thể xảy ra.</p>
<p>Một ví dụ đơn giản, được mô tả bởi Bishop và Dilger<sup class="footnote-reference"><a href="#5">5</a></sup>, cho thấy cách một người dùng có thể đánh lừa một dịch vụ đáng tin cậy hơn và gây ra sự cố. Hãy tưởng tượng một dịch vụ email chạy với quyền <code>root</code> (và do đó có đặc quyền truy cập tất cả tập tin trên hệ thống). Dịch vụ này nối thêm một thông điệp mới vào tập tin hộp thư đến (inbox) của người dùng như sau: đầu tiên, nó gọi <code>lstat()</code> để lấy thông tin về tập tin, đảm bảo rằng đây thực sự là một <strong>regular file</strong> (tập tin thường) thuộc sở hữu của người dùng đích, và không phải là một liên kết (link) tới tập tin khác mà máy chủ email không nên cập nhật. Sau khi kiểm tra thành công, máy chủ sẽ cập nhật tập tin với thông điệp mới.</p>
<p>Vấn đề là khoảng trống giữa bước kiểm tra và bước cập nhật: kẻ tấn công (trong trường hợp này là chính người nhận email, và do đó có quyền truy cập hộp thư đến) thay thế tập tin inbox (thông qua lời gọi <code>rename()</code>) để trỏ tới một tập tin nhạy cảm như <code>/etc/passwd</code> (chứa thông tin về người dùng và mật khẩu). Nếu việc thay thế này xảy ra đúng thời điểm (giữa bước kiểm tra và bước truy cập), máy chủ sẽ vô tình cập nhật tập tin nhạy cảm với nội dung email. Khi đó, kẻ tấn công có thể ghi vào tập tin nhạy cảm chỉ bằng cách gửi email – một hình thức leo thang đặc quyền; bằng cách cập nhật <code>/etc/passwd</code>, kẻ tấn công có thể thêm một tài khoản với quyền root và chiếm quyền điều khiển hệ thống.</p>
<p>Không có giải pháp đơn giản và hoàn hảo cho vấn đề TOCTTOU<sup class="footnote-reference"><a href="#6">6</a></sup>. Một cách tiếp cận là giảm số lượng dịch vụ cần chạy với quyền root, điều này giúp giảm rủi ro. Cờ <code>O_NOFOLLOW</code> khiến <code>open()</code> thất bại nếu mục tiêu là một symbolic link, từ đó tránh được các tấn công dựa trên liên kết này. Các phương pháp triệt để hơn, như sử dụng <strong>transactional file system</strong> (file system giao dịch)<sup class="footnote-reference"><a href="#7">7</a></sup>, có thể giải quyết vấn đề, nhưng hiện chưa có nhiều hệ thống như vậy được triển khai rộng rãi. Vì vậy, lời khuyên (có phần yếu ớt) thường là: hãy cẩn thận khi viết mã chạy với đặc quyền cao!</p>
</blockquote>
<hr />
<h2 id="tóm-tắt-summary"><a class="header" href="#tóm-tắt-summary">Tóm tắt (Summary)</a></h2>
<p>Giao diện file system trong các hệ thống UNIX (và thực tế là trong bất kỳ hệ thống nào) thoạt nhìn có vẻ khá đơn giản, nhưng để thành thạo, bạn cần hiểu rất nhiều khía cạnh. Không gì tốt hơn là <strong>thực hành sử dụng thường xuyên</strong>. Và tất nhiên, hãy đọc thêm; như thường lệ, Stevens<sup class="footnote-reference"><a href="#8">8</a></sup> là điểm khởi đầu tuyệt vời.</p>
<blockquote>
<p><strong>ASIDE: CÁC THUẬT NGỮ QUAN TRỌNG TRONG FILE SYSTEM</strong></p>
<ul>
<li><strong>File</strong> (tập tin) là một mảng byte có thể được tạo, đọc, ghi và xóa. Nó có một tên mức thấp (low-level name, tức là một số) để định danh duy nhất. Tên mức thấp này thường được gọi là <strong>i-number</strong>.</li>
<li><strong>Directory</strong> (thư mục) là một tập hợp các bộ dữ liệu (tuple), mỗi bộ chứa một tên dễ đọc và tên mức thấp mà nó ánh xạ tới. Mỗi mục (entry) trỏ tới một thư mục khác hoặc một tập tin. Mỗi thư mục cũng có một i-number riêng. Một thư mục luôn có hai mục đặc biệt: <code>.</code> trỏ tới chính nó, và <code>..</code> trỏ tới thư mục cha.</li>
<li><strong>Directory tree</strong> hoặc <strong>directory hierarchy</strong> (cây thư mục) tổ chức tất cả tập tin và thư mục thành một cây lớn, bắt đầu từ thư mục gốc (root).</li>
<li>Để truy cập một tập tin, một <strong>process</strong> (tiến trình) phải sử dụng một <strong>system call</strong> (thường là <code>open()</code>) để yêu cầu quyền từ hệ điều hành. Nếu được cấp quyền, OS trả về một <strong>file descriptor</strong>, có thể dùng để đọc hoặc ghi tùy theo quyền và mục đích.</li>
<li>Mỗi file descriptor là một thực thể riêng tư, thuộc về từng process, trỏ tới một mục trong <strong>open file table</strong>. Mục này lưu thông tin tập tin được truy cập, vị trí hiện tại (offset) trong tập tin (tức là phần nào của tập tin sẽ được đọc hoặc ghi tiếp theo), và các thông tin liên quan khác.</li>
<li>Các lời gọi <code>read()</code> và <code>write()</code> sẽ tự động cập nhật offset hiện tại; ngoài ra, process có thể dùng <code>lseek()</code> để thay đổi giá trị này, cho phép truy cập ngẫu nhiên tới các phần khác nhau của tập tin.</li>
<li>Để buộc cập nhật dữ liệu xuống thiết bị lưu trữ lâu dài (persistent media), process phải dùng <code>fsync()</code> hoặc các lời gọi liên quan. Tuy nhiên, làm điều này đúng cách mà vẫn duy trì hiệu năng cao là một thách thức<sup class="footnote-reference"><a href="#9">9</a></sup>, nên cần cân nhắc kỹ.</li>
<li>Để có nhiều tên dễ đọc trong file system cùng trỏ tới một tập tin gốc, hãy dùng <strong>hard link</strong> hoặc <strong>symbolic link</strong>. Mỗi loại có ưu và nhược điểm riêng, nên cân nhắc trước khi sử dụng. Và nhớ rằng, xóa một tập tin thực chất là thực hiện lần <code>unlink()</code> cuối cùng của nó khỏi cây thư mục.</li>
<li>Hầu hết các file system có cơ chế bật/tắt chia sẻ. Dạng cơ bản là <strong>permission bits</strong>; dạng nâng cao hơn là <strong>access control list</strong> cho phép kiểm soát chính xác hơn ai có thể truy cập và thao tác dữ liệu.</li>
</ul>
</blockquote>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Some file systems call these structures similar, but slightly different, names, such as dnodes; the basic idea is similar however.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Note again how creative the authors of this book are. We also used to have a cat named “Cat” (true story). However, she died, and we now have a hamster named “Hammy.” Update: Hammy is now dead too. The pet bodies are piling up.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>“A Fast File System for UNIX” by Marshall K. McKusick, William N. Joy, Sam J. Leffler, Robert S. Fabry. ACM TOCS, 2:3, August 1984. We’ll talk about the Fast File System (FFS) explicitly later on. Here, we refer to it because of all the other random fun things it introduced, like long file names and symbolic links. Sometimes, when you are building a system to improve one thing, you improve a lot of other things along the way.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Married happily since 1996, if you were wondering. We know, you weren’t.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>“Checking for Race Conditions in File Accesses” by Matt Bishop, Michael Dilger. Computing Systems 9:2, 1996. A great description of the TOCTTOU problem and its presence in file systems.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>“Portably Solving File TOCTTOU Races with Hardness Amplification” by D. Tsafrir, T. Hertz, D. Wagner, D. Da Silva. FAST ’08, San Jose, California, 2008. Not the paper that introduced TOCTTOU, but a recent-ish and well-done description of the problem and a way to solve the problem in a portable manner.</p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p>“TxFS: Leveraging File-System Crash Consistency to Provide ACID Transactions” by Y. Hu, Z. Zhu, I. Neal, Y. Kwon, T. Cheng, V. Chidambaram, E. Witchel. USENIX ATC ’18, June 2018. The best paper at USENIX ATC ’18, and a good recent place to start to learn about transactional file systems.</p>
</div>
<div class="footnote-definition" id="8"><sup class="footnote-definition-label">8</sup>
<p>“Advanced Programming in the UNIX Environment” by W. Richard Stevens and Stephen A. Rago. Addison-Wesley, 2005. We have probably referenced this book a few hundred thousand times. It is that useful to you, if you care to become an awesome systems programmer.</p>
</div>
<div class="footnote-definition" id="9"><sup class="footnote-definition-label">9</sup>
<p>“All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-Consistent Applications” by Thanumalayan S. Pillai, Vijay Chidambaram, Ramnatthan Alagappan, Samer Al-Kiswany, Andrea C. Arpaci-Dusseau, and Remzi H. Arpaci-Dusseau. OSDI ’14, Broomfield, Colorado, October 2014. The full conference paper on this topic – with many more details and interesting tidbits than the first workshop paper above.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="40-triển-khai-hệ-thống-tệp-file-system-implementation"><a class="header" href="#40-triển-khai-hệ-thống-tệp-file-system-implementation">40. Triển khai hệ thống tệp (File System Implementation)</a></h1>
<p>Trong chương này, chúng ta sẽ giới thiệu một triển khai hệ thống tệp đơn giản, được gọi là <strong>vsfs</strong> (<em>Very Simple File System</em> – hệ thống tệp rất đơn giản).<br />
Hệ thống tệp này là một phiên bản đơn giản hóa của <strong>UNIX file system</strong> (hệ thống tệp UNIX) và do đó sẽ giúp giới thiệu một số cấu trúc cơ bản trên đĩa (<strong>on-disk structures</strong>), các phương thức truy cập (<strong>access methods</strong>) và nhiều chính sách (<strong>policies</strong>) mà bạn sẽ thấy trong nhiều hệ thống tệp hiện nay.</p>
<p>Hệ thống tệp này hoàn toàn là phần mềm; không giống như quá trình phát triển <strong>CPU virtualization</strong> (ảo hóa CPU) và <strong>memory virtualization</strong> (ảo hóa bộ nhớ), chúng ta sẽ không bổ sung các tính năng phần cứng để cải thiện một khía cạnh nào đó của hệ thống tệp (mặc dù chúng ta vẫn cần chú ý đến các đặc tính của thiết bị để đảm bảo hệ thống tệp hoạt động tốt).</p>
<p>Vì có sự linh hoạt rất lớn trong việc xây dựng hệ thống tệp, nên đã có rất nhiều hệ thống tệp khác nhau được tạo ra, từ <strong>AFS</strong> (<em>Andrew File System</em>) [H+88] cho đến <strong>ZFS</strong> (<em>Sun’s Zettabyte File System</em>) [B07].<br />
Tất cả các hệ thống tệp này đều có các cấu trúc dữ liệu khác nhau và thực hiện một số việc tốt hơn hoặc kém hơn so với các hệ thống khác.</p>
<p>Do đó, cách chúng ta học về hệ thống tệp sẽ thông qua <strong>case study</strong> (nghiên cứu tình huống):</p>
<ul>
<li>Đầu tiên, một hệ thống tệp đơn giản (<strong>vsfs</strong>) trong chương này để giới thiệu hầu hết các khái niệm.</li>
<li>Sau đó là một loạt nghiên cứu về các hệ thống tệp thực tế để hiểu cách chúng khác nhau trong thực tiễn.</li>
</ul>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ TRIỂN KHAI MỘT HỆ THỐNG TỆP ĐƠN GIẢN</strong><br />
Làm thế nào để xây dựng một hệ thống tệp đơn giản? Cần những cấu trúc nào trên đĩa? Chúng cần theo dõi những gì? Chúng được truy cập như thế nào?</p>
</blockquote>
<h2 id="401-cách-tư-duy-the-way-to-think"><a class="header" href="#401-cách-tư-duy-the-way-to-think">40.1 Cách tư duy (The Way To Think)</a></h2>
<p>Khi suy nghĩ về hệ thống tệp, chúng ta thường đề xuất xem xét <strong>hai khía cạnh</strong> khác nhau; nếu bạn hiểu cả hai khía cạnh này, bạn có thể hiểu cơ bản cách hệ thống tệp hoạt động.</p>
<p><strong>Khía cạnh thứ nhất</strong> là <strong>các cấu trúc dữ liệu</strong> (<strong>data structures</strong>) của hệ thống tệp.<br />
Nói cách khác, những loại <strong>on-disk structures</strong> nào được hệ thống tệp sử dụng để tổ chức dữ liệu (<strong>data</strong>) và siêu dữ liệu (<strong>metadata</strong>) của nó?<br />
Các hệ thống tệp đầu tiên mà chúng ta sẽ thấy (bao gồm cả <strong>vsfs</strong> bên dưới) sử dụng các cấu trúc đơn giản, như <strong>mảng các block</strong> hoặc các đối tượng khác.</p>
<blockquote>
<p><strong>ASIDE: MÔ HÌNH TƯ DUY (MENTAL MODELS) VỀ HỆ THỐNG TỆP</strong><br />
Như chúng ta đã thảo luận trước đây, <strong>mental model</strong> (mô hình tư duy) là thứ bạn thực sự cần phát triển khi học về các hệ thống.<br />
Đối với hệ thống tệp, mental model của bạn cuối cùng nên bao gồm câu trả lời cho các câu hỏi như:</p>
<ul>
<li>Những <strong>on-disk structures</strong> nào lưu trữ dữ liệu và metadata của hệ thống tệp?</li>
<li>Điều gì xảy ra khi một <strong>process</strong> mở một file?</li>
<li>Những cấu trúc nào trên đĩa được truy cập trong quá trình đọc hoặc ghi?</li>
</ul>
<p>Bằng cách làm việc và cải thiện mental model của mình, bạn sẽ phát triển một sự hiểu biết trừu tượng về những gì đang diễn ra, thay vì chỉ cố gắng hiểu các chi tiết cụ thể của một đoạn code hệ thống tệp nào đó (mặc dù điều đó cũng hữu ích, tất nhiên!).</p>
</blockquote>
<p>Trong khi đó, các hệ thống tệp tinh vi hơn, như <strong>SGI’s XFS</strong>, sử dụng các cấu trúc dạng cây (<strong>tree-based structures</strong>) phức tạp hơn [S+96].</p>
<p><strong>Khía cạnh thứ hai</strong> của một hệ thống tệp là <strong>các phương thức truy cập</strong> (<strong>access methods</strong>).<br />
Hệ thống tệp ánh xạ các call (<strong>system call</strong>) do một process thực hiện, chẳng hạn như <code>open()</code>, <code>read()</code>, <code>write()</code>, v.v., vào các cấu trúc của nó như thế nào?<br />
Những cấu trúc nào được đọc trong quá trình thực thi một system call cụ thể?<br />
Những cấu trúc nào được ghi?<br />
Tất cả các bước này được thực hiện hiệu quả đến mức nào?</p>
<p>Nếu bạn hiểu <strong>các cấu trúc dữ liệu</strong> và <strong>các phương thức truy cập</strong> của một hệ thống tệp, bạn đã phát triển được một <strong>mental model</strong> tốt về cách nó thực sự hoạt động – đây là một phần quan trọng trong tư duy hệ thống (<strong>systems mindset</strong>).<br />
Hãy cố gắng xây dựng mental model của bạn khi chúng ta bắt đầu đi sâu vào triển khai đầu tiên này.</p>
<h2 id="402-tổ-chức-tổng-thể-overall-organization"><a class="header" href="#402-tổ-chức-tổng-thể-overall-organization">40.2 Tổ chức tổng thể (Overall Organization)</a></h2>
<p>Bây giờ chúng ta sẽ xây dựng <strong>tổ chức tổng thể trên đĩa</strong> (<em>on-disk organization</em>) của các cấu trúc dữ liệu trong hệ thống tệp <strong>vsfs</strong>.<br />
Điều đầu tiên cần làm là <strong>chia đĩa thành các block</strong>; các hệ thống tệp đơn giản chỉ sử dụng <strong>một kích thước block duy nhất</strong>, và đó cũng chính là cách chúng ta sẽ làm ở đây.<br />
Chúng ta chọn kích thước phổ biến là <strong>4 KB</strong>.</p>
<p>Như vậy, cách nhìn của chúng ta về <strong>phân vùng đĩa</strong> nơi xây dựng hệ thống tệp sẽ rất đơn giản: một dãy các block, mỗi block có kích thước 4 KB.<br />
Các block được đánh địa chỉ từ <strong>0</strong> đến <strong>N − 1</strong>, trong một phân vùng có kích thước <strong>N block 4 KB</strong>.<br />
Giả sử chúng ta có một đĩa rất nhỏ, chỉ với <strong>64 block</strong>:</p>
<p>...</p>
<p>Tiếp theo, hãy nghĩ về những gì cần lưu trữ trong các block này để xây dựng một hệ thống tệp.<br />
Tất nhiên, điều đầu tiên xuất hiện trong đầu là <strong>dữ liệu người dùng</strong> (<em>user data</em>).<br />
Thực tế, phần lớn dung lượng trong bất kỳ hệ thống tệp nào là (và nên là) dữ liệu người dùng.<br />
Chúng ta sẽ gọi vùng đĩa dùng cho dữ liệu người dùng là <strong>data region</strong> (vùng dữ liệu), và, để đơn giản, dành một phần cố định của đĩa cho các block này – giả sử <strong>56 block cuối cùng</strong> trong tổng số 64 block trên đĩa:</p>
<p>...</p>
<p>Như chúng ta đã tìm hiểu (một chút) ở chương trước, hệ thống tệp phải <strong>theo dõi thông tin về mỗi file</strong>.<br />
Thông tin này là một phần <strong>metadata</strong> (siêu dữ liệu) quan trọng, bao gồm:</p>
<ul>
<li>Các data block (trong data region) tạo thành file</li>
<li>Kích thước file</li>
<li>Chủ sở hữu và quyền truy cập</li>
<li>Thời gian truy cập và chỉnh sửa</li>
<li>Và các thông tin tương tự khác</li>
</ul>
<p>Để lưu trữ thông tin này, hệ thống tệp thường có một cấu trúc gọi là <strong>inode</strong> (chúng ta sẽ tìm hiểu kỹ hơn về inode ở phần sau).</p>
<p>Để chứa các inode, chúng ta cũng cần dành một phần dung lượng trên đĩa cho chúng.<br />
Chúng ta sẽ gọi phần này là <strong>inode table</strong> (bảng inode), đơn giản là một mảng các inode lưu trên đĩa.<br />
Như vậy, hình ảnh hệ thống tệp trên đĩa của chúng ta bây giờ sẽ như sau, giả sử chúng ta dùng <strong>5 block</strong> trong tổng số 64 block cho inode (được ký hiệu bằng chữ <strong>I</strong> trong sơ đồ):</p>
<p>...</p>
<p>Cần lưu ý rằng inode thường <strong>không lớn</strong>, ví dụ 128 hoặc 256 byte.<br />
Giả sử mỗi inode có kích thước <strong>256 byte</strong>, một block 4 KB có thể chứa <strong>16 inode</strong>, và hệ thống tệp ở trên sẽ có tổng cộng <strong>80 inode</strong>.<br />
Trong hệ thống tệp đơn giản của chúng ta, được xây dựng trên một phân vùng nhỏ 64 block, con số này chính là <strong>số lượng file tối đa</strong> mà hệ thống tệp có thể chứa; tuy nhiên, cũng cần lưu ý rằng cùng một hệ thống tệp này, nếu được xây dựng trên một đĩa lớn hơn, chỉ cần cấp phát một <strong>inode table</strong> lớn hơn là có thể chứa nhiều file hơn.</p>
<p>Cho đến lúc này, hệ thống tệp của chúng ta đã có <strong>data block</strong> (D) và <strong>inode</strong> (I), nhưng vẫn còn thiếu một số thành phần.<br />
Một thành phần quan trọng vẫn cần, như bạn có thể đoán, là <strong>cách để theo dõi inode hoặc data block nào đang rảnh (free) hoặc đã được cấp phát (allocated)</strong>.<br />
Các cấu trúc theo dõi cấp phát (<strong>allocation structures</strong>) là thành phần bắt buộc trong bất kỳ hệ thống tệp nào.</p>
<p>Có nhiều phương pháp để theo dõi cấp phát.<br />
Ví dụ: chúng ta có thể dùng <strong>free list</strong> (danh sách các block rảnh) trỏ tới block rảnh đầu tiên, block này lại trỏ tới block rảnh tiếp theo, và cứ thế.<br />
Tuy nhiên, ở đây chúng ta chọn một cấu trúc đơn giản và phổ biến gọi là <strong>bitmap</strong> – một cho <strong>data region</strong> (<strong>data bitmap</strong>) và một cho <strong>inode table</strong> (<strong>inode bitmap</strong>).</p>
<p><strong>Bitmap</strong> là một cấu trúc đơn giản: mỗi bit được dùng để biểu thị xem đối tượng/block tương ứng là <strong>free</strong> (0) hay <strong>in-use</strong> (1).</p>
<p>Và như vậy, <strong>bố cục mới trên đĩa</strong> của chúng ta sẽ bao gồm <strong>inode bitmap</strong> (i) và <strong>data bitmap</strong> (d):</p>
<p>Bạn có thể nhận thấy rằng việc sử dụng <strong>toàn bộ một block 4 KB</strong> cho các <strong>bitmap</strong> này có phần hơi “dư thừa”; một bitmap như vậy có thể theo dõi trạng thái cấp phát của <strong>32K đối tượng</strong>, trong khi chúng ta chỉ có <strong>80 inode</strong> và <strong>56 data block</strong>.<br />
Tuy nhiên, để đơn giản, chúng ta vẫn dành nguyên một block 4 KB cho mỗi bitmap.</p>
<p>Người đọc tinh ý (tức là người vẫn còn tỉnh táo) có thể nhận ra rằng còn <strong>một block trống</strong> trong thiết kế cấu trúc trên đĩa của hệ thống tệp rất đơn giản này.<br />
Chúng ta sẽ dành block này cho <strong>superblock</strong>, được ký hiệu bằng <strong>S</strong> trong sơ đồ bên dưới.</p>
<p><strong>Superblock</strong> chứa thông tin về hệ thống tệp cụ thể này, bao gồm, ví dụ:</p>
<ul>
<li>Số lượng inode và data block trong hệ thống tệp (lần lượt là 80 và 56 trong ví dụ này)</li>
<li>Vị trí bắt đầu của <strong>inode table</strong> (block số 3)</li>
<li>Và các thông tin khác</li>
</ul>
<p>Superblock cũng thường chứa một <strong>magic number</strong> nào đó để nhận diện loại hệ thống tệp (trong trường hợp này là <strong>vsfs</strong>).</p>
<p>...</p>
<p>Do đó, khi <strong>mount</strong> (gắn kết) một hệ thống tệp, hệ điều hành sẽ đọc <strong>superblock</strong> trước tiên để khởi tạo các tham số cần thiết, sau đó gắn volume vào <strong>cây hệ thống tệp</strong>.<br />
Khi các file trong volume được truy cập, hệ thống sẽ biết chính xác cần tìm các cấu trúc trên đĩa ở đâu.</p>
<h2 id="403-tổ-chức-file-inode-file-organization-the-inode"><a class="header" href="#403-tổ-chức-file-inode-file-organization-the-inode">40.3 Tổ chức file: Inode (File Organization: The Inode)</a></h2>
<p>Một trong những <strong>cấu trúc trên đĩa</strong> quan trọng nhất của hệ thống tệp là <strong>inode</strong>; hầu như tất cả các hệ thống tệp đều có một cấu trúc tương tự.<br />
Tên gọi <strong>inode</strong> là viết tắt của <strong>index node</strong>, tên lịch sử được đặt cho nó trong UNIX [RT74] và có thể cả các hệ thống trước đó, vì ban đầu các node này được sắp xếp trong một mảng, và mảng này được <strong>index</strong> (đánh chỉ số) để truy cập inode cụ thể.</p>
<blockquote>
<p><strong>ASIDE: CẤU TRÚC DỮ LIỆU — INODE</strong><br />
Inode là tên gọi chung được sử dụng trong nhiều hệ thống tệp để mô tả cấu trúc lưu trữ <strong>metadata</strong> (siêu dữ liệu) của một file, chẳng hạn như:</p>
<ul>
<li>Độ dài file</li>
<li>Quyền truy cập (permissions)</li>
<li>Vị trí các block dữ liệu cấu thành file</li>
</ul>
<p>Tên gọi này xuất hiện ít nhất từ thời UNIX (và có thể sớm hơn, như trong hệ thống Multics hoặc các hệ thống trước đó); nó là viết tắt của <strong>index node</strong>, vì <strong>inode number</strong> được dùng để truy cập vào mảng inode trên đĩa nhằm tìm inode tương ứng.<br />
Như chúng ta sẽ thấy, thiết kế inode là một phần quan trọng trong thiết kế hệ thống tệp.<br />
Hầu hết các hệ thống hiện đại đều có một cấu trúc tương tự cho mỗi file mà chúng quản lý, nhưng có thể đặt tên khác (như <strong>dnodes</strong>, <strong>fnodes</strong>, v.v.).</p>
</blockquote>
<p>Mỗi inode được tham chiếu ngầm định bởi một số (gọi là <strong>i-number</strong>), mà trước đây chúng ta đã gọi là <strong>tên mức thấp</strong> của file.<br />
Trong <strong>vsfs</strong> (và các hệ thống tệp đơn giản khác), khi biết <strong>i-number</strong>, bạn có thể trực tiếp tính toán vị trí inode tương ứng trên đĩa.</p>
<p>Ví dụ: xét <strong>inode table</strong> của vsfs như trên:</p>
<ul>
<li>Kích thước 20 KB (gồm 5 block 4 KB)</li>
<li>Chứa 80 inode (giả sử mỗi inode có kích thước 256 byte)</li>
<li>Giả sử vùng inode bắt đầu tại địa chỉ 12 KB (tức là: superblock bắt đầu ở 0 KB, <strong>inode bitmap</strong> ở địa chỉ 4 KB, <strong>data bitmap</strong> ở 8 KB, và <strong>inode table</strong> ngay sau đó)</li>
</ul>
<p>Trong vsfs, chúng ta có bố cục cho phần đầu của phân vùng hệ thống tệp như sau (xem ở dạng phóng to):</p>
<p>Để đọc <strong>inode</strong> số 32, hệ thống tệp trước tiên sẽ tính <strong>offset</strong> (vị trí bù) trong vùng inode:</p>
<p>[
32 \cdot \text{sizeof(inode)} = 8192 \ \text{byte}
]</p>
<p>Sau đó cộng giá trị này với địa chỉ bắt đầu của <strong>inode table</strong> trên đĩa (<code>inodeStartAddr = 12KB</code>), và thu được <strong>địa chỉ byte</strong> chính xác của block inode mong muốn: <strong>20KB</strong>.</p>
<p>Nhắc lại rằng <strong>đĩa không được đánh địa chỉ theo byte</strong> (<em>byte addressable</em>), mà bao gồm một số lượng lớn các <strong>sector</strong> có thể đánh địa chỉ, thường là <strong>512 byte</strong> mỗi sector.<br />
Do đó, để lấy block inode chứa inode số 32, hệ thống tệp sẽ thực hiện thao tác đọc từ sector:</p>
<p>[
(20 \times 1024) / 512 = 40
]</p>
<p>để lấy block inode mong muốn.</p>
<p>Tổng quát hơn, địa chỉ sector <code>sector</code> của block inode có thể được tính như sau:</p>
<pre><code class="language-c">blk = (inumber * sizeof(inode_t)) / blockSize;
sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;
</code></pre>
<p>Bên trong mỗi <strong>inode</strong> chứa hầu như toàn bộ thông tin cần thiết về một file:</p>
<ul>
<li><strong>Loại file</strong> (ví dụ: regular file, directory, v.v.)</li>
<li><strong>Kích thước file</strong></li>
<li><strong>Số lượng block</strong> đã được cấp phát cho file</li>
<li><strong>Thông tin bảo vệ</strong> (protection information) như: ai là chủ sở hữu file, ai có quyền truy cập</li>
<li><strong>Thông tin thời gian</strong>: thời điểm file được tạo, chỉnh sửa, hoặc truy cập lần cuối</li>
<li><strong>Thông tin vị trí các data block</strong> trên đĩa (ví dụ: các con trỏ tới block dữ liệu)</li>
</ul>
<p>Chúng ta gọi toàn bộ thông tin này là <strong>metadata</strong> (siêu dữ liệu); thực tế, bất kỳ thông tin nào bên trong hệ thống tệp mà không phải dữ liệu người dùng thuần túy đều được coi là metadata.</p>
<p>Một ví dụ về inode trong <strong>ext2</strong> [P09] được minh họa trong <strong>Hình 40.1</strong>^[1].</p>
<p>Một trong những quyết định quan trọng nhất trong thiết kế inode là <strong>cách nó tham chiếu tới vị trí các data block</strong>.<br />
Một cách tiếp cận đơn giản là đặt một hoặc nhiều <strong>direct pointer</strong> (con trỏ trực tiếp – địa chỉ đĩa) bên trong inode; mỗi con trỏ trỏ tới một block dữ liệu thuộc về file.<br />
Cách tiếp cận này có giới hạn: ví dụ, nếu bạn muốn có một file rất lớn (lớn hơn kích thước block nhân với số lượng direct pointer trong inode), bạn sẽ không thể lưu trữ được.</p>
<h3 id="chỉ-mục-nhiều-cấp-the-multi-level-index"><a class="header" href="#chỉ-mục-nhiều-cấp-the-multi-level-index">Chỉ mục nhiều cấp (The Multi-Level Index)</a></h3>
<p>Để hỗ trợ các file lớn hơn, các nhà thiết kế hệ thống tệp đã phải đưa vào inode những cấu trúc khác nhau.<br />
Một ý tưởng phổ biến là sử dụng một con trỏ đặc biệt gọi là <strong>indirect pointer</strong> (con trỏ gián tiếp).</p>
<p>Thay vì trỏ tới một block chứa dữ liệu người dùng, nó trỏ tới một block chứa <strong>nhiều con trỏ khác</strong>, mỗi con trỏ lại trỏ tới một block dữ liệu người dùng.</p>
<p>Do đó, một inode có thể có một số lượng cố định các <strong>direct pointer</strong> (ví dụ: 12), và <strong>một indirect pointer</strong>.<br />
Nếu file đủ lớn, một <strong>indirect block</strong> sẽ được cấp phát (từ vùng data block trên đĩa), và vị trí dành cho indirect pointer trong inode sẽ được trỏ tới block này.</p>
<p>Giả sử block 4 KB và địa chỉ đĩa dài 4 byte, thì một indirect block sẽ chứa thêm <strong>1024 con trỏ</strong>; khi đó, file có thể lớn tới:</p>
<p>[
(12 + 1024) \times 4\text{KB} = 4144\ \text{KB}
]</p>
<blockquote>
<p><strong>TIP: CÂN NHẮC CÁC TIẾP CẬN DỰA TRÊN EXTENT (EXTENT-BASED APPROACHES)</strong><br />
Một cách tiếp cận khác là sử dụng <strong>extent</strong> thay vì các <strong>pointer</strong> (con trỏ).<br />
Một extent đơn giản là một <strong>disk pointer</strong> (con trỏ tới đĩa) cộng với một <strong>độ dài</strong> (tính theo block); do đó, thay vì cần một con trỏ cho <strong>mỗi block</strong> của file, bạn chỉ cần một con trỏ và một độ dài để xác định vị trí của file trên đĩa.<br />
Chỉ sử dụng một extent là hạn chế, vì có thể gặp khó khăn khi tìm một vùng trống liên tục trên đĩa khi cấp phát file.<br />
Do đó, các <strong>file system</strong> dựa trên extent thường cho phép nhiều hơn một extent, từ đó mang lại nhiều tự do hơn cho hệ thống tệp trong quá trình cấp phát file.</p>
<p>Khi so sánh hai cách tiếp cận, phương pháp dựa trên con trỏ (<strong>pointer-based</strong>) linh hoạt hơn nhưng sử dụng nhiều <strong>metadata</strong> (siêu dữ liệu) trên mỗi file (đặc biệt là với các file lớn).<br />
Phương pháp dựa trên extent kém linh hoạt hơn nhưng gọn hơn; đặc biệt, chúng hoạt động tốt khi có đủ không gian trống trên đĩa và file có thể được bố trí liên tục (điều này vốn là mục tiêu của hầu hết các chính sách cấp phát file).</p>
</blockquote>
<p>Không có gì ngạc nhiên, với cách tiếp cận này, bạn có thể muốn hỗ trợ các file <strong>lớn hơn nữa</strong>.<br />
Để làm điều đó, chỉ cần thêm một con trỏ khác vào <strong>inode</strong>: <strong>double indirect pointer</strong> (con trỏ gián tiếp kép).<br />
Con trỏ này trỏ tới một block chứa các con trỏ tới <strong>indirect block</strong> (block gián tiếp), mỗi block gián tiếp lại chứa các con trỏ tới <strong>data block</strong> (block dữ liệu).</p>
<p>Một <strong>double indirect block</strong> do đó cho phép mở rộng file thêm <strong>1024 × 1024</strong> block 4 KB, tức là hỗ trợ các file có kích thước <strong>hơn 4 GB</strong>.<br />
Bạn có thể muốn nhiều hơn thế, và chúng tôi đoán bạn biết điều này sẽ dẫn tới đâu: <strong>triple indirect pointer</strong> (con trỏ gián tiếp ba cấp).</p>
<p>Tổng thể, cấu trúc <strong>cây mất cân bằng</strong> này được gọi là <strong>multi-level index</strong> (chỉ mục nhiều cấp) để tham chiếu tới các block dữ liệu của file.<br />
Hãy xem xét một ví dụ với <strong>12 direct pointer</strong>, cùng với <strong>một single indirect block</strong> và <strong>một double indirect block</strong>.<br />
Giả sử kích thước block là 4 KB và con trỏ dài 4 byte, cấu trúc này có thể chứa một file có kích thước <strong>hơn 4 GB</strong> (tức là ((12 + 1024 + 1024^2) \times 4\ \text{KB})).<br />
Bạn có thể tính được kích thước file tối đa nếu bổ sung thêm một <strong>triple indirect block</strong> không? (gợi ý: rất lớn)</p>
<p>Nhiều hệ thống tệp sử dụng <strong>multi-level index</strong>, bao gồm các hệ thống tệp phổ biến như <strong>Linux ext2</strong> [P09] và <strong>ext3</strong>, <strong>NetApp’s WAFL</strong>, cũng như <strong>UNIX file system</strong> nguyên bản.<br />
Các hệ thống tệp khác, bao gồm <strong>SGI XFS</strong> và <strong>Linux ext4</strong>, sử dụng <strong>extent</strong> thay vì con trỏ đơn giản; xem phần <strong>ASIDE</strong> trước đó để biết chi tiết về cách hoạt động của các cơ chế dựa trên extent (chúng tương tự như <strong>segment</strong> trong phần thảo luận về <strong>virtual memory</strong>).</p>
<p>Bạn có thể tự hỏi: tại sao lại sử dụng một cây mất cân bằng như vậy? Tại sao không dùng cách khác?<br />
Thực tế, nhiều nhà nghiên cứu đã nghiên cứu về hệ thống tệp và cách chúng được sử dụng, và hầu như luôn tìm thấy một số “sự thật” đúng trong nhiều thập kỷ.<br />
Một phát hiện như vậy là <strong>hầu hết các file đều nhỏ</strong>.<br />
Thiết kế mất cân bằng này phản ánh thực tế đó; nếu hầu hết file thực sự nhỏ, thì hợp lý khi tối ưu cho trường hợp này.<br />
Do đó, với một số lượng nhỏ <strong>direct pointer</strong> (12 là con số điển hình), một inode có thể trỏ trực tiếp tới <strong>48 KB</strong> dữ liệu, và chỉ cần một (hoặc nhiều hơn) block gián tiếp cho các file lớn hơn.</p>
<p>Xem nghiên cứu gần đây của <strong>Agrawal et al.</strong> [A+07]; <strong>Hình 40.2</strong> tóm tắt các kết quả đó.</p>
<p><img src="40/img/fig40_1.PNG" alt="" /></p>
<p><strong>Hình 40.2: Tóm tắt đo lường hệ thống tệp (File System Measurement Summary)</strong></p>
<p>Tất nhiên, trong không gian thiết kế inode, còn rất nhiều khả năng khác; suy cho cùng, inode chỉ là một <strong>cấu trúc dữ liệu</strong>, và bất kỳ cấu trúc dữ liệu nào lưu trữ thông tin liên quan và có thể truy vấn hiệu quả đều là đủ.<br />
Vì phần mềm hệ thống tệp có thể dễ dàng thay đổi, bạn nên sẵn sàng khám phá các thiết kế khác nhau nếu <strong>workload</strong> hoặc công nghệ thay đổi.</p>
<h2 id="404-tổ-chức-thư-mục-directory-organization"><a class="header" href="#404-tổ-chức-thư-mục-directory-organization">40.4 Tổ chức thư mục (Directory Organization)</a></h2>
<p>Trong <strong>vsfs</strong> (cũng như trong nhiều <strong>file system</strong> khác), <strong>directory</strong> (thư mục) có một tổ chức đơn giản; một thư mục về cơ bản chỉ chứa một danh sách các cặp <strong>(entry name, inode number)</strong>.<br />
Đối với mỗi <strong>file</strong> hoặc <strong>directory</strong> trong một thư mục nhất định, sẽ có một chuỗi ký tự (string) và một số nguyên (inode number) được lưu trong các <strong>data block</strong> của thư mục đó.<br />
Đối với mỗi chuỗi, cũng có thể lưu thêm độ dài (trong trường hợp tên có kích thước thay đổi).</p>
<p>Ví dụ: giả sử một thư mục <code>dir</code> (có <strong>inode number</strong> là 5) chứa ba file (<code>foo</code>, <code>bar</code>, và <code>foobar_is_a_pretty_longname</code>), với các <strong>inode number</strong> lần lượt là 12, 13 và 24.<br />
Dữ liệu lưu trên đĩa cho <code>dir</code> có thể trông như sau:</p>
<p>...</p>
<p>Trong ví dụ này, mỗi entry có:</p>
<ul>
<li><strong>inode number</strong></li>
<li><strong>record length</strong> (tổng số byte cho tên cộng với bất kỳ khoảng trống còn lại nào)</li>
<li><strong>string length</strong> (độ dài thực tế của tên)</li>
<li>Và cuối cùng là <strong>tên entry</strong></li>
</ul>
<p>Lưu ý rằng mỗi thư mục có hai entry đặc biệt: <code>.</code> (<strong>dot</strong>) và <code>..</code> (<strong>dot-dot</strong>);</p>
<ul>
<li><code>.</code> là thư mục hiện tại (trong ví dụ này là <code>dir</code>)</li>
<li><code>..</code> là thư mục cha (trong trường hợp này là thư mục gốc – root)</li>
</ul>
<p>Việc xóa một file (ví dụ: gọi <code>unlink()</code>) có thể để lại một khoảng trống ở giữa thư mục, do đó cần có cách để đánh dấu khoảng trống này (ví dụ: bằng một <strong>inode number</strong> dự trữ như 0).<br />
Việc xóa như vậy là một lý do để sử dụng <strong>record length</strong>: một entry mới có thể tái sử dụng một entry cũ lớn hơn và do đó có thêm khoảng trống bên trong.</p>
<blockquote>
<p><strong>ASIDE: CÁC TIẾP CẬN DỰA TRÊN LIÊN KẾT (LINKED-BASED APPROACHES)</strong><br />
Một cách tiếp cận đơn giản hơn trong thiết kế <strong>inode</strong> là sử dụng <strong>linked list</strong> (danh sách liên kết).<br />
Thay vì có nhiều con trỏ bên trong inode, bạn chỉ cần một con trỏ trỏ tới <strong>block đầu tiên</strong> của file.<br />
Để xử lý các file lớn hơn, thêm một con trỏ khác ở cuối block dữ liệu đó, và cứ thế tiếp tục, nhờ đó bạn có thể hỗ trợ các file lớn.</p>
<p>Như bạn có thể đoán, <strong>linked file allocation</strong> (cấp phát file theo danh sách liên kết) hoạt động kém hiệu quả đối với một số loại <strong>workload</strong>; hãy nghĩ đến việc đọc block cuối cùng của một file, hoặc chỉ đơn giản là truy cập ngẫu nhiên.<br />
Để cải thiện hiệu năng của linked allocation, một số hệ thống sẽ giữ một <strong>bảng thông tin liên kết</strong> trong bộ nhớ (<strong>in-memory table</strong>), thay vì lưu các con trỏ “next” cùng với các block dữ liệu.<br />
Bảng này được đánh chỉ số theo địa chỉ của một <strong>data block</strong> D; nội dung của một entry trong bảng đơn giản là <strong>next pointer</strong> của D, tức là địa chỉ của block tiếp theo trong file sau D.<br />
Cũng có thể có giá trị null (biểu thị <strong>end-of-file</strong>) hoặc một ký hiệu khác để chỉ rằng block đó đang rảnh.<br />
Việc có một bảng các con trỏ “next” như vậy giúp cho cơ chế linked allocation có thể thực hiện truy cập ngẫu nhiên hiệu quả, chỉ đơn giản bằng cách quét bảng (trong bộ nhớ) để tìm block mong muốn, rồi truy cập trực tiếp block đó trên đĩa.</p>
<p>Nghe bảng này có quen không? Những gì chúng ta vừa mô tả chính là cấu trúc cơ bản của <strong>file allocation table</strong> hay <strong>FAT file system</strong>.<br />
Đúng vậy, hệ thống tệp Windows cổ điển này, trước khi có <strong>NTFS</strong> [C94], dựa trên một cơ chế cấp phát liên kết đơn giản.<br />
Cũng có những điểm khác biệt so với hệ thống tệp UNIX tiêu chuẩn; ví dụ: không có inode theo đúng nghĩa, mà thay vào đó là các entry trong thư mục lưu <strong>metadata</strong> về file và tham chiếu trực tiếp tới block đầu tiên của file đó, điều này khiến việc tạo <strong>hard link</strong> là không thể.<br />
Xem Brouwer [B02] để biết thêm các chi tiết “kém thanh lịch” này.</p>
</blockquote>
<p>Bạn có thể tự hỏi: các thư mục được lưu trữ ở đâu?<br />
Thường thì, các file system coi thư mục là một loại file đặc biệt.<br />
Do đó, một thư mục có một inode, nằm đâu đó trong <strong>inode table</strong> (với trường <strong>type</strong> của inode được đánh dấu là “directory” thay vì “regular file”).<br />
Thư mục có các <strong>data block</strong> được trỏ tới bởi inode (và có thể cả <strong>indirect block</strong>); các data block này nằm trong vùng <strong>data block region</strong> của hệ thống tệp đơn giản của chúng ta.<br />
Cấu trúc trên đĩa của chúng ta vì thế vẫn không thay đổi.</p>
<p>Cũng cần lưu ý rằng danh sách tuyến tính đơn giản của các entry thư mục không phải là cách duy nhất để lưu trữ thông tin này.<br />
Như đã nói trước đó, bất kỳ cấu trúc dữ liệu nào cũng có thể được sử dụng.<br />
Ví dụ: <strong>XFS</strong> [S+96] lưu trữ thư mục dưới dạng <strong>B-tree</strong>, giúp cho các thao tác tạo file (cần đảm bảo tên file chưa được sử dụng trước khi tạo) nhanh hơn so với các hệ thống dùng danh sách tuyến tính phải quét toàn bộ.</p>
<blockquote>
<p><strong>ASIDE: QUẢN LÝ VÙNG TRỐNG (FREE SPACE MANAGEMENT)</strong><br />
Có nhiều cách để quản lý vùng trống; <strong>bitmap</strong> chỉ là một trong số đó.<br />
Một số hệ thống tệp (file system) đời đầu sử dụng <strong>free list</strong> (danh sách khối trống), trong đó một con trỏ duy nhất trong <strong>superblock</strong> được dùng để trỏ tới <strong>block trống đầu tiên</strong>; bên trong block đó lại lưu con trỏ tới block trống tiếp theo, và cứ thế tạo thành một danh sách liên kết qua các block trống của hệ thống. Khi cần cấp phát một block, block ở đầu danh sách sẽ được sử dụng và danh sách được cập nhật tương ứng.</p>
<p>Các hệ thống tệp hiện đại sử dụng các cấu trúc dữ liệu tinh vi hơn. Ví dụ, <strong>SGI’s XFS</strong> [S+96] sử dụng một dạng <strong>B-tree</strong> để biểu diễn gọn gàng các vùng đĩa còn trống. Giống như bất kỳ cấu trúc dữ liệu nào, luôn tồn tại các đánh đổi giữa thời gian và không gian lưu trữ.</p>
</blockquote>
<h2 id="405-quản-lý-vùng-trống-free-space-management"><a class="header" href="#405-quản-lý-vùng-trống-free-space-management">40.5 Quản lý vùng trống (Free Space Management)</a></h2>
<p>Một hệ thống tệp phải theo dõi <strong>inode</strong> và <strong>data block</strong> nào đang trống và cái nào đã được sử dụng, để khi cần cấp phát một file hoặc thư mục mới, nó có thể tìm được không gian lưu trữ phù hợp.<br />
Do đó, <strong>free space management</strong> là thành phần quan trọng đối với mọi hệ thống tệp.<br />
Trong <strong>vsfs</strong>, chúng ta sử dụng <strong>hai bitmap đơn giản</strong> cho nhiệm vụ này.</p>
<p>Ví dụ: khi tạo một file, hệ thống tệp sẽ phải cấp phát một inode cho file đó.<br />
Hệ thống tệp sẽ tìm trong <strong>bitmap</strong> để tìm một inode đang trống, và cấp phát nó cho file; sau đó, hệ thống sẽ đánh dấu inode này là đã sử dụng (bằng giá trị 1) và cuối cùng cập nhật bitmap trên đĩa với thông tin chính xác.<br />
Một quy trình tương tự cũng diễn ra khi cấp phát một data block.</p>
<p>Ngoài ra, còn có một số yếu tố khác cần xem xét khi cấp phát data block cho một file mới.<br />
Ví dụ: một số hệ thống tệp Linux như <strong>ext2</strong> và <strong>ext3</strong> sẽ tìm một dãy các block trống (ví dụ: 8 block) khi tạo một file mới và cần cấp phát data block; bằng cách tìm một dãy block trống như vậy và cấp phát chúng cho file mới, hệ thống tệp đảm bảo rằng một phần của file sẽ được lưu <strong>liên tiếp</strong> trên đĩa, từ đó cải thiện hiệu năng.<br />
Chính sách <strong>pre-allocation</strong> (cấp phát trước) như vậy là một <strong>heuristic</strong> (kinh nghiệm thực tiễn) thường được sử dụng khi cấp phát không gian cho data block.</p>
<h2 id="406-Đường-truy-cập-Đọc-và-ghi-access-paths-reading-and-writing"><a class="header" href="#406-Đường-truy-cập-Đọc-và-ghi-access-paths-reading-and-writing">40.6 Đường truy cập: Đọc và ghi (Access Paths: Reading and Writing)</a></h2>
<p>Giờ đây, khi chúng ta đã có cái nhìn tổng quan về cách file và thư mục được lưu trữ trên đĩa, chúng ta có thể theo dõi <strong>luồng hoạt động</strong> trong quá trình đọc hoặc ghi một file.<br />
Hiểu được điều gì xảy ra trên <strong>đường truy cập</strong> (access path) này là <strong>yếu tố then chốt thứ hai</strong> để nắm bắt cách một hệ thống tệp hoạt động; hãy chú ý!</p>
<p>Trong các ví dụ sau, giả sử rằng hệ thống tệp đã được <strong>mount</strong> (gắn kết) và do đó <strong>superblock</strong> đã nằm trong bộ nhớ.<br />
Mọi thứ khác (ví dụ: inode, thư mục) vẫn nằm trên đĩa.</p>
<p><img src="40/img/fig40_2.PNG" alt="" /></p>
<p><strong>Hình 40.3: Dòng thời gian đọc file (File Read Timeline – thời gian tăng dần từ trên xuống)</strong></p>
<h3 id="Đọc-một-tệp-từ-đĩa-reading-a-file-from-disk"><a class="header" href="#Đọc-một-tệp-từ-đĩa-reading-a-file-from-disk">Đọc một tệp từ đĩa (Reading A File From Disk)</a></h3>
<p>Trong ví dụ đơn giản này, giả sử bạn muốn mở một tệp (ví dụ: <code>/foo/bar</code>), đọc nội dung của nó, rồi đóng lại.<br />
Để đơn giản, giả sử tệp này chỉ có kích thước <strong>12KB</strong> (tức là gồm <strong>3 block</strong>).</p>
<p>Khi bạn gọi:</p>
<pre><code class="language-c">open(&quot;/foo/bar&quot;, ORDONLY)
</code></pre>
<p><strong>File system</strong> (hệ thống tệp) trước tiên cần tìm <strong>inode</strong> của tệp <code>bar</code> để lấy một số thông tin cơ bản về tệp (thông tin quyền truy cập – <em>permissions</em>, kích thước tệp, v.v.).<br />
Để làm được điều này, hệ thống tệp phải tìm được inode, nhưng lúc này nó chỉ có <strong>đường dẫn đầy đủ</strong> (<em>full pathname</em>).<br />
Hệ thống tệp phải <strong>duyệt qua đường dẫn</strong> (<em>traverse the pathname</em>) để tìm ra inode mong muốn.</p>
<p>Mọi quá trình duyệt đều bắt đầu từ <strong>root</strong> của hệ thống tệp, tức <strong>root directory</strong> (thư mục gốc) được ký hiệu đơn giản là <code>/</code>.<br />
Vì vậy, điều đầu tiên mà <strong>FS</strong> (file system) sẽ đọc từ đĩa là <strong>inode</strong> của thư mục gốc.<br />
Nhưng inode này nằm ở đâu?</p>
<p>Để tìm một inode, chúng ta phải biết <strong>i-number</strong> (số inode).<br />
Thông thường, i-number của một tệp hoặc thư mục được tìm thấy trong thư mục cha của nó; tuy nhiên, <strong>root</strong> không có thư mục cha (theo định nghĩa).<br />
Do đó, <strong>i-number</strong> của root phải là một giá trị “được biết trước” (<em>well known</em>); FS phải biết giá trị này khi hệ thống tệp được <strong>mount</strong>.<br />
Trong hầu hết các hệ thống tệp UNIX, <strong>i-number</strong> của root là <strong>2</strong>.</p>
<p>Vì vậy, để bắt đầu quá trình, FS sẽ đọc block chứa inode số 2 (block inode đầu tiên).</p>
<p>Khi inode đã được đọc vào bộ nhớ, FS có thể xem bên trong inode để tìm các <strong>con trỏ</strong> (<em>pointer</em>) tới các <strong>data block</strong> chứa nội dung của thư mục gốc.<br />
FS sẽ sử dụng các con trỏ trên đĩa này để đọc qua thư mục, trong trường hợp này là tìm một entry cho <code>foo</code>.<br />
Bằng cách đọc một hoặc nhiều <strong>directory data block</strong>, FS sẽ tìm thấy entry cho <code>foo</code>; khi tìm thấy, FS cũng sẽ biết được <strong>i-number</strong> của <code>foo</code> (giả sử là 44) – thông tin cần thiết cho bước tiếp theo.</p>
<p>Bước tiếp theo là <strong>duyệt đệ quy</strong> (<em>recursively traverse</em>) đường dẫn cho đến khi tìm được inode mong muốn.<br />
Trong ví dụ này, FS sẽ đọc block chứa inode của <code>foo</code>, sau đó đọc dữ liệu thư mục của nó, và cuối cùng tìm ra <strong>i-number</strong> của <code>bar</code>.</p>
<blockquote>
<p><strong>ASIDE: ĐỌC KHÔNG TRUY CẬP CÁC CẤU TRÚC CẤP PHÁT (READS DON’T ACCESS ALLOCATION STRUCTURES)</strong>
Nhiều sinh viên thường nhầm lẫn về các cấu trúc cấp phát như bitmap. Cụ thể, nhiều người nghĩ rằng khi bạn chỉ đọc một file và không cấp phát block mới, thì bitmap vẫn sẽ được tham chiếu. Điều này là không đúng! Các cấu trúc cấp phát như bitmap chỉ được truy cập khi cần cấp phát. Inode, directory và indirect block đã có đầy đủ thông tin cần thiết để hoàn thành một yêu cầu đọc; không cần phải kiểm tra một block đã được cấp phát hay chưa khi inode đã trỏ đến nó.</p>
</blockquote>
<p>Bước cuối cùng của <code>open()</code> là đọc inode của <code>bar</code> vào bộ nhớ; sau đó FS (file system) thực hiện kiểm tra quyền truy cập (permissions) lần cuối, cấp phát một file descriptor cho tiến trình này trong bảng file mở theo tiến trình (per-process open-file table), và trả về descriptor đó cho người dùng.</p>
<p>Khi đã mở, chương trình có thể gọi system call <code>read()</code> để đọc từ file. Lần đọc đầu tiên (tại offset 0 trừ khi đã gọi <code>lseek()</code>) sẽ đọc block đầu tiên của file, tham chiếu inode để tìm vị trí của block đó; FS cũng có thể cập nhật inode với thời điểm truy cập lần cuối (last-accessed time) mới. Lời gọi read này cũng cập nhật bảng file mở trong bộ nhớ (in-memory open file table) cho file descriptor này, cập nhật file offset để lần đọc tiếp theo sẽ đọc block thứ hai của file, v.v.</p>
<p>Tới một thời điểm nào đó, file sẽ được đóng (close). Công việc ở đây ít hơn nhiều; rõ ràng file descriptor cần được giải phóng (deallocate), nhưng tạm thời đó là tất cả những gì FS cần làm. Không có I/O đĩa nào diễn ra.</p>
<p>Toàn bộ quá trình này được minh họa trong Hình 40.3 (trang 11); thời gian tăng dần từ trên xuống trong hình. Trong hình, call open dẫn đến nhiều lần đọc để cuối cùng tìm ra inode của file. Sau đó, mỗi lần đọc block yêu cầu file system trước hết tham chiếu inode, rồi đọc block, và sau đó cập nhật trường thời gian truy cập lần cuối (last-accessed-time) của inode bằng một lần ghi (write). Hãy dành thời gian để hiểu kỹ điều gì đang diễn ra.</p>
<p>Cũng lưu ý rằng lượng I/O phát sinh bởi open tỉ lệ với độ dài của pathname (đường dẫn). Với mỗi thư mục bổ sung trong đường dẫn, chúng ta phải đọc inode của nó cũng như dữ liệu của nó. Tệ hơn nữa là sự hiện diện của các thư mục lớn; ở đây, chúng ta chỉ phải đọc một block để lấy nội dung của một thư mục, trong khi với một thư mục lớn, chúng ta có thể phải đọc nhiều data block để tìm được entry mong muốn. Đúng vậy, việc đọc một file có thể khá “đau đớn”; và như bạn sắp thấy, việc ghi một file (đặc biệt là tạo mới) thậm chí còn tệ hơn.</p>
<h3 id="ghi-một-tệp-xuống-đĩa-writing-a-file-to-disk"><a class="header" href="#ghi-một-tệp-xuống-đĩa-writing-a-file-to-disk">Ghi một tệp xuống đĩa (Writing A File To Disk)</a></h3>
<p>Quy trình ghi vào một tệp tương tự như đọc.<br />
Trước tiên, tệp phải được <strong>mở</strong> (giống như ở phần trên).<br />
Sau đó, ứng dụng có thể gọi <strong><code>write()</code></strong> để cập nhật tệp với nội dung mới.<br />
Cuối cùng, tệp sẽ được <strong>đóng</strong>.</p>
<p>Không giống như đọc, việc ghi vào tệp có thể yêu cầu <strong>cấp phát một block mới</strong> (trừ khi block hiện tại chỉ bị ghi đè, chẳng hạn).<br />
Khi ghi một tệp mới, mỗi thao tác ghi không chỉ phải ghi dữ liệu xuống đĩa mà trước đó còn phải quyết định <strong>block nào sẽ được cấp phát</strong> cho tệp, và do đó phải cập nhật các cấu trúc khác trên đĩa tương ứng (ví dụ: <strong>data bitmap</strong> và <strong>inode</strong>).</p>
<p>Vì vậy, <strong>mỗi thao tác ghi</strong> vào một tệp về mặt logic sẽ tạo ra <strong>5 thao tác I/O</strong>:</p>
<ol>
<li><strong>Đọc data bitmap</strong> (sau đó được cập nhật để đánh dấu block mới cấp phát là đã sử dụng)</li>
<li><strong>Ghi data bitmap</strong> (để phản ánh trạng thái mới xuống đĩa)</li>
<li><strong>Đọc inode</strong> (để lấy thông tin hiện tại)</li>
<li><strong>Ghi inode</strong> (đã được cập nhật với vị trí block mới)</li>
<li><strong>Ghi block dữ liệu thực tế</strong></li>
</ol>
<p><img src="40/img/fig40_3.PNG" alt="" /></p>
<p><strong>Hình 40.4: Dòng thời gian tạo tệp (File Creation Timeline – thời gian tăng dần từ trên xuống)</strong></p>
<p>Lượng <strong>ghi</strong> còn tệ hơn nữa khi xét đến một thao tác đơn giản và phổ biến như <strong>tạo tệp</strong>.<br />
Để tạo một tệp, hệ thống tệp không chỉ phải <strong>cấp phát một inode</strong>, mà còn phải <strong>cấp phát không gian trong thư mục</strong> chứa tệp mới đó.</p>
<p>Tổng lượng I/O cần thiết để làm điều này là khá lớn:</p>
<ul>
<li><strong>1 lần đọc inode bitmap</strong> (để tìm một inode trống)</li>
<li><strong>1 lần ghi inode bitmap</strong> (để đánh dấu inode đã được cấp phát)</li>
<li><strong>1 lần ghi inode mới</strong> (để khởi tạo nó)</li>
<li><strong>1 lần ghi dữ liệu thư mục</strong> (để liên kết tên mức cao của tệp với inode number của nó)</li>
<li><strong>1 lần đọc và 1 lần ghi inode của thư mục</strong> (để cập nhật nó)</li>
</ul>
<p>Nếu thư mục cần mở rộng để chứa entry mới, sẽ cần thêm các thao tác I/O bổ sung (ví dụ: tới <strong>data bitmap</strong> và block thư mục mới).<br />
Tất cả những điều đó chỉ để <strong>tạo một tệp</strong>!</p>
<p>Hãy xem một ví dụ cụ thể, khi tệp <code>/foo/bar</code> được tạo và <strong>ba block</strong> được ghi vào nó.</p>
<p><strong>Hình 40.4</strong> (trang 13) cho thấy điều gì xảy ra trong quá trình <code>open()</code> (tạo tệp) và trong mỗi lần ghi 4KB.</p>
<p>Trong hình, các thao tác đọc và ghi xuống đĩa được nhóm theo <strong>system call</strong> nào đã gây ra chúng, và thứ tự thực hiện xấp xỉ được sắp xếp từ trên xuống dưới.<br />
Bạn có thể thấy khối lượng công việc để tạo tệp: <strong>10 thao tác I/O</strong> trong trường hợp này, để duyệt qua pathname và cuối cùng tạo tệp.<br />
Bạn cũng có thể thấy rằng <strong>mỗi thao tác ghi có cấp phát</strong> tốn <strong>5 thao tác I/O</strong>:</p>
<ul>
<li>Một cặp để đọc và cập nhật inode</li>
<li>Một cặp để đọc và cập nhật data bitmap</li>
<li>Và cuối cùng là ghi dữ liệu thực tế</li>
</ul>
<p>Làm thế nào để một hệ thống tệp có thể thực hiện tất cả những điều này <strong>một cách hiệu quả</strong>?</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ GIẢM CHI PHÍ I/O CỦA HỆ THỐNG TỆP</strong><br />
Ngay cả những thao tác đơn giản nhất như mở, đọc hoặc ghi một tệp cũng tạo ra một số lượng lớn các thao tác I/O, rải rác khắp đĩa.<br />
Hệ thống tệp có thể làm gì để giảm chi phí cao khi phải thực hiện quá nhiều I/O như vậy?</p>
</blockquote>
<h2 id="407-caching-và-buffering"><a class="header" href="#407-caching-và-buffering">40.7 Caching và Buffering</a></h2>
<p>Như các ví dụ ở trên cho thấy, việc đọc và ghi file có thể rất tốn kém, gây ra nhiều thao tác I/O tới đĩa (vốn chậm).<br />
Để khắc phục vấn đề hiệu năng nghiêm trọng này, hầu hết các <strong>file system</strong> (hệ thống tệp) đều tận dụng mạnh mẽ bộ nhớ hệ thống (<strong>DRAM</strong>) để <strong>cache</strong> (lưu đệm) các block quan trọng.</p>
<p>Hãy hình dung ví dụ mở file ở trên: nếu <strong>không có caching</strong>, mỗi lần mở file sẽ yêu cầu ít nhất <strong>hai lần đọc</strong> cho mỗi cấp trong cây thư mục (<strong>directory hierarchy</strong>) — một lần để đọc <strong>inode</strong> của thư mục cần thiết, và ít nhất một lần để đọc dữ liệu của nó.<br />
Với một <strong>pathname</strong> dài (ví dụ: <code>/1/2/3/.../100/file.txt</code>), hệ thống tệp sẽ phải thực hiện <strong>hàng trăm lần đọc</strong> chỉ để mở file!</p>
<p>Các hệ thống tệp đời đầu đã giới thiệu một <strong>cache kích thước cố định</strong> để lưu các block được truy cập thường xuyên.<br />
Tương tự như trong phần thảo luận về <strong>virtual memory</strong> (bộ nhớ ảo), các chiến lược như <strong>LRU</strong> (Least Recently Used) và các biến thể khác sẽ quyết định block nào được giữ lại trong cache.<br />
Cache kích thước cố định này thường được cấp phát ngay khi khởi động (<strong>boot time</strong>) với dung lượng khoảng <strong>10% tổng bộ nhớ</strong>.</p>
<p>Tuy nhiên, việc <strong>phân vùng bộ nhớ tĩnh</strong> như vậy có thể gây lãng phí;<br />
Điều gì sẽ xảy ra nếu tại một thời điểm nào đó, hệ thống tệp <strong>không cần</strong> tới 10% bộ nhớ?<br />
Với cách tiếp cận kích thước cố định như trên, các trang (<strong>page</strong>) không được sử dụng trong <strong>file cache</strong> sẽ <strong>không thể</strong> được tái sử dụng cho mục đích khác, và do đó bị lãng phí.</p>
<p>Ngược lại, các hệ thống hiện đại áp dụng cách <strong>phân vùng động</strong>.<br />
Cụ thể, nhiều <strong>hệ điều hành</strong> hiện đại tích hợp <strong>virtual memory pages</strong> và <strong>file system pages</strong> vào một <strong>unified page cache</strong> (bộ nhớ đệm trang hợp nhất) [S00].<br />
Bằng cách này, bộ nhớ có thể được phân bổ linh hoạt hơn giữa <strong>virtual memory</strong> và <strong>file system</strong>, tùy thuộc vào bên nào cần nhiều bộ nhớ hơn tại một thời điểm nhất định.</p>
<p>Hãy hình dung lại ví dụ mở file nhưng <strong>có caching</strong>:<br />
Lần mở đầu tiên có thể tạo ra nhiều lưu lượng I/O để đọc inode và dữ liệu thư mục, nhưng các lần mở file tiếp theo của <strong>cùng file đó</strong> (hoặc các file trong cùng thư mục) sẽ <strong>hầu hết trúng cache</strong> (<em>cache hit</em>), và do đó <strong>không cần I/O</strong> nào nữa.</p>
<blockquote>
<p><strong>TIP: HIỂU RÕ SỰ KHÁC NHAU GIỮA PHÂN VÙNG TĨNH VÀ PHÂN VÙNG ĐỘNG (STATIC VS. DYNAMIC PARTITIONING)</strong><br />
Khi phân chia một tài nguyên cho nhiều client/người dùng khác nhau, bạn có thể sử dụng <strong>phân vùng tĩnh</strong> (<em>static partitioning</em>) hoặc <strong>phân vùng động</strong> (<em>dynamic partitioning</em>).</p>
<ul>
<li><strong>Phân vùng tĩnh</strong>: đơn giản là chia tài nguyên thành các phần cố định ngay từ đầu; ví dụ, nếu có hai người dùng bộ nhớ, bạn có thể cấp một tỷ lệ cố định bộ nhớ cho một người, và phần còn lại cho người kia.</li>
<li><strong>Phân vùng động</strong>: linh hoạt hơn, phân bổ lượng tài nguyên khác nhau theo thời gian; ví dụ, một người dùng có thể được cấp tỷ lệ băng thông đĩa cao hơn trong một khoảng thời gian, nhưng sau đó hệ thống có thể chuyển và cấp cho người dùng khác một phần lớn hơn của băng thông đĩa khả dụng.</li>
</ul>
<p>Mỗi cách tiếp cận đều có ưu điểm riêng:</p>
<ul>
<li><strong>Phân vùng tĩnh</strong> đảm bảo mỗi người dùng nhận được một phần tài nguyên, thường mang lại hiệu năng dự đoán được hơn và dễ triển khai hơn.</li>
<li><strong>Phân vùng động</strong> có thể đạt hiệu suất sử dụng tốt hơn (bằng cách cho phép người dùng “đói” tài nguyên tiêu thụ phần tài nguyên đang nhàn rỗi), nhưng có thể phức tạp hơn để triển khai, và có thể dẫn đến hiệu năng kém hơn cho những người dùng mà tài nguyên nhàn rỗi của họ bị người khác sử dụng và mất nhiều thời gian để thu hồi lại khi cần.<br />
Như thường lệ, không có phương pháp nào là “tốt nhất” tuyệt đối; thay vào đó, bạn nên xem xét vấn đề cụ thể và quyết định cách tiếp cận phù hợp nhất. Thực tế, chẳng phải bạn luôn nên làm như vậy sao?</li>
</ul>
</blockquote>
<p>Chúng ta cũng cần xem xét <strong>tác động của caching đối với ghi (write)</strong>.<br />
Trong khi <strong>read I/O</strong> có thể được loại bỏ hoàn toàn nếu cache đủ lớn, thì <strong>lưu lượng ghi</strong> vẫn phải được gửi xuống đĩa để trở thành dữ liệu bền vững (<em>persistent</em>).<br />
Do đó, cache không đóng vai trò như một bộ lọc hiệu quả cho ghi như nó làm đối với đọc.</p>
<p>Tuy nhiên, <strong>write buffering</strong> (đệm ghi – đôi khi được gọi như vậy) chắc chắn mang lại nhiều lợi ích về hiệu năng:</p>
<ol>
<li><strong>Trì hoãn ghi</strong> cho phép hệ thống tệp gom nhiều cập nhật thành một tập nhỏ các thao tác I/O; ví dụ, nếu <strong>inode bitmap</strong> được cập nhật khi một file được tạo và sau đó lại được cập nhật ngay sau đó khi một file khác được tạo, hệ thống tệp sẽ tiết kiệm được một thao tác I/O bằng cách trì hoãn việc ghi sau lần cập nhật đầu tiên.</li>
<li><strong>Đệm nhiều thao tác ghi trong bộ nhớ</strong> cho phép hệ thống lập lịch (schedule) các thao tác I/O tiếp theo một cách tối ưu hơn, từ đó cải thiện hiệu năng.</li>
<li><strong>Tránh một số thao tác ghi hoàn toàn</strong> nhờ trì hoãn chúng; ví dụ, nếu một ứng dụng tạo một file rồi xóa nó ngay sau đó, việc trì hoãn ghi thông tin tạo file xuống đĩa sẽ giúp bỏ qua hoàn toàn các thao tác ghi này. Trong trường hợp này, “lười biếng” (trong việc ghi block xuống đĩa) lại là một ưu điểm.</li>
</ol>
<p>Vì những lý do trên, hầu hết các hệ thống tệp hiện đại <strong>đệm ghi trong bộ nhớ</strong> từ <strong>5 đến 30 giây</strong>, điều này tạo ra một sự đánh đổi khác:</p>
<ul>
<li>Nếu hệ thống bị crash trước khi các cập nhật được ghi xuống đĩa, các cập nhật này sẽ bị mất.</li>
<li>Tuy nhiên, bằng cách giữ dữ liệu ghi trong bộ nhớ lâu hơn, hiệu năng có thể được cải thiện nhờ <strong>gom nhóm (batching)</strong>, <strong>lập lịch (scheduling)</strong>, và thậm chí <strong>tránh được một số thao tác ghi</strong>.</li>
</ul>
<blockquote>
<p><strong>TIP: HIỂU RÕ SỰ ĐÁNH ĐỔI GIỮA TÍNH BỀN VỮNG VÀ HIỆU NĂNG (DURABILITY/PERFORMANCE TRADE-OFF)</strong><br />
Các <strong>storage system</strong> (hệ thống lưu trữ) thường đưa ra cho người dùng một sự đánh đổi giữa <strong>tính bền vững</strong> (<em>durability</em>) và <strong>hiệu năng</strong> (<em>performance</em>).</p>
<ul>
<li>Nếu người dùng muốn dữ liệu vừa ghi phải <strong>ngay lập tức bền vững</strong> (tức được lưu vĩnh viễn), hệ thống phải thực hiện đầy đủ quá trình <strong>commit</strong> dữ liệu mới xuống đĩa, và do đó thao tác ghi sẽ <strong>chậm</strong> (nhưng <strong>an toàn</strong>).</li>
<li>Ngược lại, nếu người dùng có thể chấp nhận mất một lượng nhỏ dữ liệu, hệ thống có thể <strong>buffer</strong> (đệm) các thao tác ghi trong bộ nhớ một thời gian rồi mới ghi xuống đĩa (ở chế độ nền – <em>background</em>).</li>
</ul>
<p>Cách làm này khiến thao tác ghi <strong>có vẻ</strong> hoàn tất nhanh chóng, cải thiện <strong>hiệu năng cảm nhận</strong> (<em>perceived performance</em>); tuy nhiên, nếu xảy ra <strong>crash</strong> (sập hệ thống), các thao tác ghi chưa được commit xuống đĩa sẽ bị mất — và đó chính là sự đánh đổi.</p>
<p>Để hiểu cách đưa ra quyết định đánh đổi hợp lý, tốt nhất là phải hiểu <strong>yêu cầu của ứng dụng</strong> đang sử dụng hệ thống lưu trữ. Ví dụ: việc mất vài hình ảnh cuối cùng được tải xuống bởi trình duyệt web có thể chấp nhận được, nhưng mất một phần của <strong>giao dịch cơ sở dữ liệu</strong> đang cộng tiền vào tài khoản ngân hàng của bạn thì khó chấp nhận hơn. Trừ khi bạn rất giàu, tất nhiên; khi đó, có lẽ bạn chẳng bận tâm đến việc giữ từng xu cuối cùng.</p>
</blockquote>
<p>Một số ứng dụng (như <strong>database</strong>) không chấp nhận sự đánh đổi này.<br />
Do đó, để tránh mất dữ liệu ngoài ý muốn do <strong>write buffering</strong>, chúng đơn giản <strong>ép</strong> hệ thống ghi dữ liệu xuống đĩa, bằng cách gọi <code>fsync()</code>, sử dụng các giao diện <strong>direct I/O</strong> để bỏ qua cache, hoặc sử dụng giao diện <strong>raw disk</strong> và bỏ qua hoàn toàn file system².</p>
<p>Trong khi hầu hết các ứng dụng chấp nhận sự đánh đổi mà file system đưa ra, vẫn có đủ các cơ chế kiểm soát để buộc hệ thống thực hiện theo ý bạn nếu mặc định không đáp ứng được.</p>
<h2 id="408-tóm-tắt-summary"><a class="header" href="#408-tóm-tắt-summary">40.8 Tóm tắt (Summary)</a></h2>
<p>Chúng ta đã tìm hiểu các thành phần cơ bản cần có để xây dựng một <strong>file system</strong>.<br />
Cần có thông tin về mỗi file (<strong>metadata</strong> – siêu dữ liệu), thường được lưu trong một cấu trúc gọi là <strong>inode</strong>.<br />
<strong>Directory</strong> (thư mục) chỉ là một loại file đặc biệt lưu ánh xạ <strong>tên → inode number</strong>.<br />
Ngoài ra, còn cần các cấu trúc khác; ví dụ, file system thường sử dụng một cấu trúc như <strong>bitmap</strong> để theo dõi inode hoặc data block nào đang trống hoặc đã được cấp phát.</p>
<p>Điểm tuyệt vời của thiết kế file system là <strong>tính tự do</strong>; các file system mà chúng ta sẽ khám phá trong những chương tiếp theo đều tận dụng sự tự do này để tối ưu một khía cạnh nào đó của hệ thống tệp.<br />
Rõ ràng vẫn còn nhiều <strong>chính sách</strong> (policy) mà chúng ta chưa đề cập.<br />
Ví dụ: khi tạo một file mới, nó nên được đặt ở đâu trên đĩa?<br />
Chính sách này và các chính sách khác sẽ là chủ đề của những chương sau.<br />
Hay là… sẽ không?³</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="41-tính-cục-bộ-locality-và-hệ-thống-tệp-nhanh-fast-file-system"><a class="header" href="#41-tính-cục-bộ-locality-và-hệ-thống-tệp-nhanh-fast-file-system">41 Tính cục bộ (Locality) và Hệ thống tệp nhanh (Fast File System)</a></h1>
<p>Khi hệ điều hành <strong>UNIX</strong> lần đầu tiên được giới thiệu, chính “phù thủy” UNIX – <strong>Ken Thompson</strong> – đã viết hệ thống tệp đầu tiên.<br />
Chúng ta sẽ gọi đó là <strong>“old UNIX file system”</strong> (hệ thống tệp UNIX cũ), và nó thực sự rất đơn giản.<br />
Về cơ bản, các cấu trúc dữ liệu của nó trên đĩa trông như sau:</p>
<p>...</p>
<p><strong>Super block</strong> (S) chứa thông tin về toàn bộ hệ thống tệp: kích thước của volume, số lượng <strong>inode</strong>, con trỏ tới phần đầu của <strong>free list</strong> (danh sách các block trống), và các thông tin khác.<br />
Vùng <strong>inode</strong> trên đĩa chứa tất cả các inode của hệ thống tệp.<br />
Cuối cùng, phần lớn dung lượng đĩa được chiếm bởi các <strong>data block</strong> (block dữ liệu).</p>
<p>Điểm tốt của hệ thống tệp cũ là nó <strong>đơn giản</strong> và hỗ trợ các <strong>abstraction</strong> (trừu tượng hóa) cơ bản mà hệ thống tệp muốn cung cấp: <strong>file</strong> và <strong>cây thư mục</strong> (directory hierarchy).<br />
Hệ thống dễ sử dụng này là một bước tiến thực sự so với các hệ thống lưu trữ dựa trên bản ghi (record-based storage systems) cồng kềnh trước đây, và cấu trúc cây thư mục là một cải tiến vượt trội so với các hệ thống cũ chỉ hỗ trợ cấu trúc thư mục một cấp.</p>
<h2 id="411-vấn-đề-hiệu-năng-kém-the-problem-poor-performance"><a class="header" href="#411-vấn-đề-hiệu-năng-kém-the-problem-poor-performance">41.1 Vấn đề: Hiệu năng kém (The Problem: Poor Performance)</a></h2>
<p>Vấn đề: hiệu năng <strong>rất tệ</strong>.<br />
Theo đo đạc của <strong>Kirk McKusick</strong> và các đồng nghiệp tại Berkeley [MJLF84], hiệu năng ban đầu đã kém và càng tệ hơn theo thời gian, đến mức hệ thống tệp chỉ cung cấp <strong>2% băng thông tổng thể của đĩa</strong>!</p>
<p>Nguyên nhân chính là hệ thống tệp UNIX cũ <strong>đối xử với đĩa như bộ nhớ truy cập ngẫu nhiên</strong> (<em>random-access memory</em>); dữ liệu bị rải khắp nơi mà không quan tâm đến việc phương tiện lưu trữ là <strong>đĩa</strong>, vốn có <strong>chi phí định vị (positioning cost)</strong> thực sự và đắt đỏ.<br />
Ví dụ: các <strong>data block</strong> của một file thường nằm rất xa <strong>inode</strong> của nó, dẫn đến việc phải thực hiện một <strong>seek</strong> (dịch chuyển đầu đọc) tốn kém mỗi khi đọc inode rồi đọc các data block của file (một thao tác khá phổ biến).</p>
<p>Tệ hơn nữa, hệ thống tệp dễ bị <strong>phân mảnh</strong> (<em>fragmentation</em>), do vùng trống không được quản lý cẩn thận.<br />
<strong>Free list</strong> cuối cùng sẽ trỏ tới một loạt các block nằm rải rác khắp đĩa, và khi cấp phát file mới, hệ thống chỉ đơn giản lấy block trống tiếp theo.<br />
Kết quả là một file <strong>liên tiếp về mặt logic</strong> lại được truy cập bằng cách di chuyển qua lại trên đĩa, làm giảm hiệu năng nghiêm trọng.</p>
<p>Ví dụ: hãy hình dung vùng <strong>data block</strong> sau, chứa bốn file (A, B, C và D), mỗi file có kích thước <strong>2 block</strong>:</p>
<p>...</p>
<p>Nếu B và D bị xóa, bố cục còn lại sẽ là:</p>
<p>...</p>
<p>Như bạn thấy, vùng trống bị phân mảnh thành <strong>hai cụm</strong> mỗi cụm 2 block, thay vì một cụm liền mạch gồm 4 block.<br />
Giả sử bây giờ bạn muốn cấp phát một file E có kích thước <strong>4 block</strong>:</p>
<p>...</p>
<p>Bạn có thể thấy điều gì xảy ra: <strong>E</strong> bị phân tán khắp đĩa, và kết quả là khi truy cập <strong>E</strong>, bạn không đạt được hiệu năng tối đa (truy cập tuần tự) từ đĩa.<br />
Thay vào đó, bạn phải đọc <strong>E1</strong> và <strong>E2</strong>, sau đó <strong>seek</strong> (dịch chuyển đầu đọc), rồi mới đọc <strong>E3</strong> và <strong>E4</strong>.<br />
Vấn đề <strong>phân mảnh</strong> (<em>fragmentation</em>) này xảy ra thường xuyên trong <strong>old UNIX file system</strong> và làm giảm hiệu năng đáng kể.</p>
<p>Một lưu ý bên lề: đây chính xác là vấn đề mà các công cụ <strong>disk defragmentation</strong> (chống phân mảnh đĩa) giải quyết; chúng <strong>tái tổ chức dữ liệu trên đĩa</strong> để đặt các file nằm liền nhau và tạo ra vùng trống liên tục (một hoặc vài vùng), bằng cách di chuyển dữ liệu và sau đó ghi lại <strong>inode</strong> và các cấu trúc liên quan để phản ánh thay đổi.</p>
<p>Một vấn đề khác: <strong>kích thước block ban đầu quá nhỏ</strong> (512 byte).<br />
Do đó, việc truyền dữ liệu từ đĩa vốn đã kém hiệu quả.<br />
Block nhỏ có ưu điểm là giảm <strong>internal fragmentation</strong> (lãng phí bên trong block), nhưng lại bất lợi cho việc truyền dữ liệu vì mỗi block có thể yêu cầu một chi phí định vị (<strong>positioning overhead</strong>) để truy cập.<br />
Vì vậy, vấn đề đặt ra là:</p>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO TỔ CHỨC DỮ LIỆU TRÊN ĐĨA ĐỂ CẢI THIỆN HIỆU NĂNG</strong><br />
Làm thế nào chúng ta có thể tổ chức các cấu trúc dữ liệu của hệ thống tệp để cải thiện hiệu năng?<br />
Cần những chính sách cấp phát nào trên các cấu trúc dữ liệu đó?<br />
Làm thế nào để khiến hệ thống tệp “nhận thức về đĩa” (<em>disk aware</em>)?</p>
</blockquote>
<h2 id="412-ffs-disk-awareness-là-giải-pháp-disk-awareness-is-the-solution"><a class="header" href="#412-ffs-disk-awareness-là-giải-pháp-disk-awareness-is-the-solution">41.2 FFS: “Disk Awareness” là giải pháp (Disk Awareness Is The Solution)</a></h2>
<p>Một nhóm tại <strong>Berkeley</strong> đã quyết định xây dựng một hệ thống tệp tốt hơn và nhanh hơn, mà họ đặt tên một cách thông minh là <strong>Fast File System (FFS)</strong>.<br />
Ý tưởng là thiết kế các cấu trúc và chính sách cấp phát của hệ thống tệp sao cho <strong>“disk aware”</strong> (nhận thức được đặc tính của đĩa) để cải thiện hiệu năng — và đó chính xác là những gì họ đã làm.</p>
<p>FFS đã mở ra một kỷ nguyên mới trong nghiên cứu hệ thống tệp; bằng cách <strong>giữ nguyên giao diện</strong> với hệ thống tệp (các API như <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code> và các system call khác) nhưng <strong>thay đổi phần triển khai bên trong</strong>, các tác giả đã mở đường cho việc xây dựng các hệ thống tệp mới — công việc vẫn tiếp tục cho đến ngày nay.</p>
<p>Hầu như tất cả các hệ thống tệp hiện đại đều tuân thủ giao diện hiện có (và do đó duy trì khả năng tương thích với ứng dụng) trong khi thay đổi phần bên trong để cải thiện hiệu năng, độ tin cậy hoặc vì các lý do khác.</p>
<h2 id="413-tổ-chức-cấu-trúc-cylinder-group-organizing-structure-the-cylinder-group"><a class="header" href="#413-tổ-chức-cấu-trúc-cylinder-group-organizing-structure-the-cylinder-group">41.3 Tổ chức cấu trúc: Cylinder Group (Organizing Structure: The Cylinder Group)</a></h2>
<p>Bước đầu tiên là thay đổi các cấu trúc trên đĩa.<br />
FFS chia đĩa thành một số <strong>cylinder group</strong>.</p>
<p>Một <strong>cylinder</strong> là tập hợp các track trên các bề mặt khác nhau của ổ cứng, nhưng có cùng khoảng cách tới tâm của ổ đĩa; nó được gọi là “cylinder” vì hình dạng tương tự hình trụ trong hình học.<br />
FFS gộp <strong>N cylinder liên tiếp</strong> thành một nhóm, và do đó toàn bộ đĩa có thể được xem như một tập hợp các cylinder group.</p>
<p>Dưới đây là một ví dụ đơn giản, minh họa <strong>bốn track ngoài cùng</strong> của một ổ đĩa với <strong>sáu platter</strong>, và một cylinder group bao gồm <strong>ba cylinder</strong>:</p>
<p>...</p>
<p>Lưu ý rằng các ổ đĩa hiện đại <strong>không cung cấp đủ thông tin</strong> để hệ thống tệp thực sự biết một cylinder cụ thể đang được sử dụng hay không; như đã thảo luận trước đây [AD14a], các ổ đĩa xuất ra một <strong>không gian địa chỉ logic</strong> của các block và <strong>ẩn đi chi tiết hình học</strong> của chúng với phía client.</p>
<p>Do đó, các hệ thống tệp hiện đại (như <strong>Linux ext2</strong>, <strong>ext3</strong> và <strong>ext4</strong>) thay vào đó tổ chức ổ đĩa thành các <strong>block group</strong>, mỗi block group chỉ đơn giản là một phần liên tiếp của không gian địa chỉ của đĩa.</p>
<p>Hình minh họa dưới đây cho thấy một ví dụ trong đó <strong>mỗi 8 block</strong> được tổ chức thành một block group khác nhau (lưu ý rằng trong thực tế, mỗi group sẽ bao gồm nhiều block hơn rất nhiều):</p>
<p>...</p>
<p>Dù bạn gọi chúng là <strong>cylinder group</strong> hay <strong>block group</strong>, thì các nhóm này chính là <strong>cơ chế trung tâm</strong> mà <strong>FFS</strong> (Fast File System) sử dụng để cải thiện hiệu năng.<br />
Điểm mấu chốt là: bằng cách đặt hai file trong cùng một nhóm, FFS có thể đảm bảo rằng việc truy cập file này ngay sau file kia sẽ <strong>không</strong> dẫn đến các thao tác <strong>seek</strong> (dịch chuyển đầu đọc) dài trên đĩa.</p>
<p>Để sử dụng các nhóm này cho việc lưu trữ file và thư mục, FFS cần có khả năng <strong>đặt file và thư mục vào một nhóm</strong> và <strong>theo dõi toàn bộ thông tin cần thiết</strong> về chúng trong nhóm đó.<br />
Để làm được điều này, FFS bao gồm tất cả các cấu trúc mà bạn mong đợi một hệ thống tệp có trong mỗi nhóm, ví dụ:</p>
<ul>
<li>Vùng lưu <strong>inode</strong></li>
<li>Vùng lưu <strong>data block</strong></li>
<li>Và một số cấu trúc để theo dõi xem mỗi inode hoặc data block đã được cấp phát hay còn trống</li>
</ul>
<p>Dưới đây là sơ đồ mô tả những gì FFS lưu trữ trong một <strong>cylinder group</strong> duy nhất:</p>
<p>...</p>
<p>Bây giờ, hãy xem xét chi tiết các thành phần của một cylinder group duy nhất này.<br />
FFS giữ <strong>một bản sao của super block (S)</strong> trong mỗi nhóm vì lý do <strong>độ tin cậy</strong>.<br />
Super block là thành phần cần thiết để <strong>mount</strong> (gắn kết) hệ thống tệp; bằng cách giữ nhiều bản sao, nếu một bản bị hỏng, bạn vẫn có thể mount và truy cập hệ thống tệp bằng một bản sao còn hoạt động.</p>
<p>Bên trong mỗi nhóm, FFS cần theo dõi xem <strong>inode</strong> và <strong>data block</strong> của nhóm đó đã được cấp phát hay chưa.<br />
Một <strong>inode bitmap</strong> (ib) và <strong>data bitmap</strong> (db) riêng cho từng nhóm đảm nhận vai trò này đối với inode và data block trong nhóm.<br />
<strong>Bitmap</strong> là một cách tuyệt vời để quản lý vùng trống trong hệ thống tệp vì nó giúp dễ dàng tìm được một vùng trống lớn và cấp phát nó cho một file, từ đó có thể tránh được một số vấn đề phân mảnh mà <strong>free list</strong> trong hệ thống tệp cũ gặp phải.</p>
<p>Cuối cùng, vùng <strong>inode</strong> và <strong>data block</strong> trong mỗi nhóm cũng giống như trong hệ thống tệp rất đơn giản trước đây (<strong>VSFS</strong>).<br />
Phần lớn dung lượng của mỗi cylinder group, như thường lệ, là <strong>data block</strong>.</p>
<blockquote>
<p><strong>ASIDE: QUÁ TRÌNH TẠO FILE TRONG FFS (FFS FILE CREATION)</strong><br />
Ví dụ, hãy nghĩ về những cấu trúc dữ liệu nào phải được cập nhật khi tạo một file; giả sử, trong ví dụ này, người dùng tạo một file mới <code>/foo/bar.txt</code> và file này dài <strong>1 block</strong> (4KB).<br />
File này là mới, do đó cần một <strong>inode mới</strong>; vì vậy, cả <strong>inode bitmap</strong> và <strong>inode mới được cấp phát</strong> sẽ được ghi xuống đĩa.<br />
File này cũng có dữ liệu, nên nó cũng phải được cấp phát block dữ liệu; do đó, <strong>data bitmap</strong> và một <strong>data block</strong> sẽ (cuối cùng) được ghi xuống đĩa.<br />
Như vậy, <strong>ít nhất bốn thao tác ghi</strong> vào cylinder group hiện tại sẽ diễn ra (hãy nhớ rằng các thao tác ghi này có thể được <strong>buffer</strong> trong bộ nhớ một thời gian trước khi thực sự ghi xuống đĩa).<br />
Nhưng chưa hết! Khi tạo một file mới, bạn cũng phải đặt file đó vào <strong>cây thư mục</strong> của hệ thống tệp, tức là thư mục chứa nó phải được cập nhật.<br />
Cụ thể, thư mục cha <code>foo</code> phải được cập nhật để thêm entry cho <code>bar.txt</code>; bản cập nhật này có thể vừa với một data block hiện có của <code>foo</code> hoặc yêu cầu cấp phát một block mới (kèm theo cập nhật <strong>data bitmap</strong>).<br />
<strong>Inode</strong> của <code>foo</code> cũng phải được cập nhật, vừa để phản ánh độ dài mới của thư mục, vừa để cập nhật các trường thời gian (chẳng hạn như <strong>last-modified-time</strong>).<br />
Tổng thể, đây là <strong>rất nhiều công việc</strong> chỉ để tạo một file mới! Có lẽ lần tới khi bạn làm điều đó, bạn nên biết ơn hơn — hoặc ít nhất là ngạc nhiên rằng mọi thứ lại hoạt động trơn tru đến vậy.</p>
</blockquote>
<h2 id="414-chính-sách-cách-cấp-phát-file-và-thư-mục-policies-how-to-allocate-files-and-directories"><a class="header" href="#414-chính-sách-cách-cấp-phát-file-và-thư-mục-policies-how-to-allocate-files-and-directories">41.4 Chính sách: Cách cấp phát file và thư mục (Policies: How To Allocate Files and Directories)</a></h2>
<p>Với cấu trúc <strong>group</strong> (nhóm) đã được thiết lập, <strong>FFS</strong> (Fast File System) giờ đây phải quyết định cách <strong>đặt file, thư mục và metadata</strong> (siêu dữ liệu) liên quan lên đĩa để cải thiện hiệu năng.<br />
Nguyên tắc cơ bản (<em>mantra</em>) rất đơn giản: <strong>giữ các dữ liệu liên quan ở gần nhau</strong> (và hệ quả của nó: <strong>giữ các dữ liệu không liên quan ở xa nhau</strong>).</p>
<p>Do đó, để tuân theo nguyên tắc này, FFS phải xác định <strong>thế nào là “liên quan”</strong> và đặt chúng trong <strong>cùng một block group</strong>; ngược lại, các mục không liên quan nên được đặt ở <strong>các block group khác nhau</strong>.<br />
Để đạt được điều này, FFS sử dụng một số <strong>heuristic</strong> (kinh nghiệm thực tiễn) đơn giản trong việc bố trí dữ liệu.</p>
<p><strong>Đầu tiên</strong> là việc bố trí <strong>thư mục</strong>.<br />
FFS áp dụng một cách tiếp cận đơn giản:</p>
<ul>
<li>Tìm <strong>cylinder group</strong> có <strong>ít thư mục đã được cấp phát</strong> (để cân bằng số lượng thư mục giữa các nhóm)</li>
<li>Và có <strong>nhiều inode trống</strong> (để sau đó có thể cấp phát nhiều file)</li>
<li>Sau đó đặt <strong>dữ liệu thư mục</strong> và <strong>inode</strong> của nó vào nhóm đó.</li>
</ul>
<p>Tất nhiên, có thể sử dụng các heuristic khác ở đây (ví dụ: xét đến số lượng <strong>data block</strong> trống).</p>
<p><strong>Đối với file</strong>, FFS thực hiện hai điều:</p>
<ol>
<li>Đảm bảo (trong trường hợp tổng quát) <strong>cấp phát các data block của file trong cùng group với inode của nó</strong>, từ đó tránh các thao tác <strong>seek</strong> dài giữa inode và dữ liệu (như trong hệ thống tệp cũ).</li>
<li>Đặt <strong>tất cả các file trong cùng một thư mục</strong> vào <strong>cylinder group</strong> của thư mục đó.</li>
</ol>
<p>Ví dụ: nếu người dùng tạo bốn file <code>/a/b</code>, <code>/a/c</code>, <code>/a/d</code>, và <code>/b/f</code>, FFS sẽ cố gắng đặt <strong>ba file đầu tiên</strong> gần nhau (cùng group) và <strong>file thứ tư</strong> ở xa (một group khác).</p>
<p>Hãy xem một ví dụ về cách cấp phát như vậy.<br />
Trong ví dụ này, giả sử <strong>mỗi group chỉ có 10 inode và 10 data block</strong> (cả hai con số này đều nhỏ một cách phi thực tế), và ba thư mục (<strong>root directory</strong> <code>/</code>, <code>/a</code>, và <code>/b</code>) cùng bốn file (<code>/a/c</code>, <code>/a/d</code>, <code>/a/e</code>, <code>/b/f</code>) được đặt vào các group theo đúng chính sách của FFS.</p>
<p>Giả sử các file thường (<strong>regular file</strong>) mỗi file có kích thước <strong>2 block</strong>, và các thư mục chỉ có <strong>1 block dữ liệu</strong>.<br />
Trong hình minh họa, chúng ta sử dụng các ký hiệu hiển nhiên cho mỗi file hoặc thư mục (ví dụ: <code>/</code> cho thư mục gốc, <code>a</code> cho <code>/a</code>, <code>f</code> cho <code>/b/f</code>, v.v.).</p>
<p>...</p>
<p>Lưu ý rằng chính sách của <strong>FFS</strong> mang lại hai lợi ích rõ rệt:</p>
<ul>
<li><strong>Data block</strong> của mỗi file nằm gần <strong>inode</strong> của chính file đó</li>
<li>Các file trong cùng một thư mục nằm gần nhau (cụ thể, <code>/a/c</code>, <code>/a/d</code> và <code>/a/e</code> đều nằm trong <strong>Group 1</strong>, còn thư mục <code>/b</code> và file <code>/b/f</code> của nó nằm gần nhau trong <strong>Group 2</strong>).</li>
</ul>
<p>Ngược lại, hãy xem xét một chính sách cấp phát <strong>inode</strong> khác, trong đó chỉ đơn giản là phân tán inode ra các group, nhằm đảm bảo rằng bảng inode của không group nào bị lấp đầy quá nhanh.<br />
Kết quả cấp phát cuối cùng có thể trông như sau:</p>
<p>...</p>
<p>Như bạn có thể thấy từ hình minh họa, mặc dù chính sách này thực sự giữ dữ liệu file (và thư mục) gần inode tương ứng của nó, nhưng các file trong cùng một thư mục lại bị phân tán ngẫu nhiên khắp đĩa, và do đó <strong>tính cục bộ theo tên</strong> (<em>name-based locality</em>) không được duy trì.<br />
Việc truy cập các file <code>/a/c</code>, <code>/a/d</code> và <code>/a/e</code> giờ đây phải trải qua <strong>ba group</strong> thay vì chỉ một group như cách tiếp cận của FFS.</p>
<p>Các heuristic (kinh nghiệm thực tiễn) trong chính sách của FFS <strong>không</strong> dựa trên các nghiên cứu sâu rộng về lưu lượng truy cập hệ thống tệp hay các phân tích phức tạp; thay vào đó, chúng dựa trên <strong>common sense</strong> (lẽ thường) cổ điển (chẳng phải <strong>CS</strong> là viết tắt của <em>common sense</em> sao?)<sup class="footnote-reference"><a href="#1">1</a></sup>.<br />
Các file trong một thư mục thường được truy cập cùng nhau: hãy tưởng tượng việc biên dịch một loạt file rồi liên kết chúng thành một file thực thi duy nhất.<br />
Bởi vì tồn tại tính cục bộ dựa trên không gian tên (<em>namespace locality</em>) như vậy, FFS thường sẽ cải thiện hiệu năng, đảm bảo rằng các thao tác seek giữa các file liên quan là ngắn và nhanh.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Một số người gọi <em>common sense</em> là <em>horse sense</em>, đặc biệt là những người thường xuyên làm việc với ngựa. Tuy nhiên, chúng tôi cảm giác rằng thành ngữ này có thể sẽ bị mai một khi “con ngựa cơ giới” – tức là ô tô – ngày càng phổ biến. Họ sẽ phát minh ra gì tiếp theo? Một cỗ máy bay chăng??!!</p>
</div>
<h2 id="415-Đo-lường-tính-cục-bộ-của-file-measuring-file-locality"><a class="header" href="#415-Đo-lường-tính-cục-bộ-của-file-measuring-file-locality">41.5 Đo lường tính cục bộ của file (Measuring File Locality)</a></h2>
<p>Để hiểu rõ hơn liệu các heuristic này có hợp lý hay không, hãy phân tích một số <strong>trace</strong> (bản ghi) truy cập hệ thống tệp và xem liệu thực sự có tồn tại <strong>namespace locality</strong> hay không.<br />
Vì một lý do nào đó, dường như chưa có một nghiên cứu tốt nào về chủ đề này trong tài liệu học thuật.</p>
<p>Cụ thể, chúng ta sẽ sử dụng <strong>SEER traces</strong> [K94] và phân tích xem các lần truy cập file “cách xa” nhau như thế nào trong cây thư mục.<br />
Ví dụ: nếu file <code>f</code> được mở, và sau đó lại được mở tiếp ngay trong trace (trước khi bất kỳ file nào khác được mở), thì khoảng cách giữa hai lần mở này trong cây thư mục là <strong>0</strong> (vì chúng là cùng một file).<br />
Nếu một file <code>f</code> trong thư mục <code>dir</code> (tức <code>dir/f</code>) được mở, và tiếp theo là mở file <code>g</code> trong cùng thư mục (tức <code>dir/g</code>), thì khoảng cách giữa hai lần truy cập file này là <strong>1</strong>, vì chúng cùng thư mục nhưng không phải cùng file.</p>
<p>Nói cách khác, <strong>metric khoảng cách</strong> của chúng ta đo xem phải đi lên bao nhiêu cấp trong cây thư mục để tìm <strong>tổ tiên chung</strong> của hai file; chúng càng gần nhau trong cây, metric này càng nhỏ.</p>
<p><img src="41/img/fig41_1.PNG" alt="" /></p>
<p><strong>Hình 41.1: Tính cục bộ của FFS đối với SEER traces</strong></p>
<p>Hình 41.1 cho thấy tính cục bộ quan sát được trong SEER traces trên tất cả các workstation trong cụm SEER, xét trên toàn bộ các trace.<br />
Biểu đồ vẽ <strong>metric khoảng cách</strong> trên trục hoành (x-axis) và hiển thị <strong>tỷ lệ tích lũy</strong> của các lần mở file có khoảng cách đó trên trục tung (y-axis).</p>
<p>Cụ thể, đối với SEER traces (được đánh dấu “Trace” trong biểu đồ), bạn có thể thấy rằng khoảng <strong>7%</strong> các lần truy cập file là tới <strong>file vừa được mở trước đó</strong>, và gần <strong>40%</strong> các lần truy cập file là tới <strong>cùng file</strong> hoặc <strong>file trong cùng thư mục</strong> (tức khoảng cách bằng 0 hoặc 1).<br />
Do đó, giả định về tính cục bộ của FFS có vẻ hợp lý (ít nhất là đối với các trace này).</p>
<p>Thú vị là, khoảng <strong>25%</strong> số lần truy cập file còn lại là tới các file có khoảng cách bằng <strong>2</strong>.<br />
Loại tính cục bộ này xảy ra khi người dùng tổ chức một tập hợp các thư mục liên quan theo cấu trúc nhiều cấp và thường xuyên chuyển qua lại giữa chúng.<br />
Ví dụ: nếu người dùng có thư mục <code>src</code> và biên dịch các file đối tượng (<code>.o</code>) vào thư mục <code>obj</code>, và cả hai thư mục này đều là thư mục con của thư mục chính <code>proj</code>, thì một mẫu truy cập phổ biến sẽ là <code>proj/src/foo.c</code> tiếp theo là <code>proj/obj/foo.o</code>.<br />
Khoảng cách giữa hai lần truy cập này là <strong>2</strong>, vì <code>proj</code> là tổ tiên chung.<br />
FFS <strong>không</strong> nắm bắt được loại tính cục bộ này trong chính sách của nó, và do đó sẽ có nhiều thao tác seek hơn giữa các lần truy cập như vậy.</p>
<p>Để so sánh, biểu đồ cũng hiển thị tính cục bộ đối với một trace “Random”.<br />
Trace ngẫu nhiên này được tạo ra bằng cách chọn các file từ một SEER trace hiện có theo thứ tự ngẫu nhiên, và tính metric khoảng cách giữa các lần truy cập được sắp xếp ngẫu nhiên này.<br />
Như bạn thấy, tính cục bộ theo không gian tên trong trace ngẫu nhiên thấp hơn, như dự đoán.<br />
Tuy nhiên, vì cuối cùng mọi file đều có một tổ tiên chung (ví dụ: thư mục root), nên vẫn tồn tại một mức độ cục bộ nhất định, và do đó trace ngẫu nhiên hữu ích như một điểm so sánh.</p>
<h2 id="416-ngoại-lệ-đối-với-tệp-lớn-the-large-file-exception"><a class="header" href="#416-ngoại-lệ-đối-với-tệp-lớn-the-large-file-exception">41.6 Ngoại lệ đối với tệp lớn (The Large-File Exception)</a></h2>
<p>Trong <strong>FFS</strong> (Fast File System), có một ngoại lệ quan trọng đối với chính sách chung về bố trí file, và ngoại lệ này áp dụng cho <strong>các file lớn</strong>.<br />
Nếu không có một quy tắc khác, một file lớn sẽ <strong>lấp đầy toàn bộ block group</strong> mà nó được đặt vào đầu tiên (và có thể cả các group khác).<br />
Việc lấp đầy một block group theo cách này là <strong>không mong muốn</strong>, vì nó ngăn cản các file “liên quan” được đặt vào cùng block group đó, từ đó có thể làm giảm <strong>tính cục bộ truy cập file</strong> (<em>file-access locality</em>).</p>
<p>Vì vậy, đối với các file lớn, FFS thực hiện như sau:<br />
Sau khi một số lượng block nhất định được cấp phát trong block group đầu tiên (ví dụ: 12 block, hoặc bằng số lượng <strong>direct pointer</strong> có trong một inode), FFS sẽ đặt <strong>phần “lớn” tiếp theo</strong> của file (ví dụ: các block được trỏ tới bởi <strong>indirect block</strong> đầu tiên) vào <strong>một block group khác</strong> (có thể được chọn vì mức sử dụng thấp).<br />
Sau đó, phần tiếp theo của file sẽ được đặt vào <strong>một block group khác nữa</strong>, và cứ thế tiếp tục.</p>
<p>Hãy xem một số sơ đồ để hiểu rõ hơn chính sách này.<br />
Nếu <strong>không</strong> có ngoại lệ cho file lớn, một file lớn duy nhất sẽ đặt <strong>tất cả các block</strong> của nó vào <strong>một vùng</strong> trên đĩa.<br />
Chúng ta xét một ví dụ nhỏ: một file (<code>/a</code>) có <strong>30 block</strong> trong một FFS được cấu hình với <strong>10 inode</strong> và <strong>40 data block</strong> mỗi group.<br />
Dưới đây là minh họa FFS <strong>không</strong> áp dụng ngoại lệ cho file lớn:</p>
<p>...</p>
<p>Như bạn thấy trong hình, <code>/a</code> chiếm hầu hết các data block trong <strong>Group 0</strong>, trong khi các group khác vẫn trống.<br />
Nếu bây giờ tạo thêm một số file khác trong thư mục gốc (<code>/</code>), sẽ <strong>không còn nhiều chỗ</strong> cho dữ liệu của chúng trong group này.</p>
<p>Với ngoại lệ cho file lớn (trong ví dụ này được đặt là <strong>5 block mỗi phần</strong>), FFS thay vào đó <strong>phân tán file</strong> ra nhiều group, và mức sử dụng trong mỗi group sẽ <strong>không quá cao</strong>:</p>
<p>...</p>
<p>Người đọc tinh ý (chính là bạn) sẽ nhận ra rằng việc <strong>phân tán các block của một file</strong> khắp đĩa sẽ <strong>làm giảm hiệu năng</strong>, đặc biệt trong trường hợp khá phổ biến là <strong>truy cập tuần tự</strong> (ví dụ: khi người dùng hoặc ứng dụng đọc các phần từ 0 đến 29 theo thứ tự).<br />
Và bạn hoàn toàn đúng!<br />
Tuy nhiên, bạn có thể giải quyết vấn đề này bằng cách <strong>chọn kích thước phần (chunk size)</strong> một cách hợp lý.</p>
<p>Cụ thể, nếu chunk size đủ lớn, hệ thống tệp sẽ dành <strong>phần lớn thời gian</strong> để truyền dữ liệu từ đĩa và chỉ một <strong>phần nhỏ</strong> thời gian để seek giữa các chunk.<br />
Quá trình <strong>giảm chi phí cố định bằng cách thực hiện nhiều công việc hơn cho mỗi lần trả chi phí</strong> này được gọi là <strong>amortization</strong> (phân bổ chi phí) và là một kỹ thuật phổ biến trong các hệ thống máy tính.</p>
<p>Hãy làm một ví dụ:</p>
<ul>
<li>Giả sử <strong>thời gian định vị trung bình</strong> (<em>average positioning time</em>, bao gồm seek và quay đĩa) của một ổ đĩa là <strong>10 ms</strong>.</li>
<li>Giả sử thêm rằng ổ đĩa truyền dữ liệu với tốc độ <strong>40 MB/s</strong>.</li>
</ul>
<p>Nếu mục tiêu của bạn là <strong>dành một nửa thời gian để seek giữa các chunk</strong> và <strong>một nửa thời gian để truyền dữ liệu</strong> (tức đạt <strong>50% hiệu năng đĩa tối đa</strong>), bạn sẽ cần <strong>10 ms truyền dữ liệu</strong> cho mỗi <strong>10 ms định vị</strong>.</p>
<p>Vậy câu hỏi là: <strong>chunk phải lớn bao nhiêu</strong> để mất 10 ms cho việc truyền dữ liệu?<br />
Rất đơn giản, chỉ cần dùng toán học, cụ thể là <strong>phân tích thứ nguyên</strong> (<em>dimensional analysis</em>) đã đề cập trong chương về đĩa [AD14a]:</p>
<p>[
40 \frac{\text{MB}}{\text{sec}} \cdot \frac{1024 \ \text{KB}}{1 \ \text{MB}} \cdot \frac{1 \ \text{sec}}{1000 \ \text{ms}} \cdot 10 \ \text{ms} = 409.6 \ \text{KB}
]<br />
<em>(41.1)</em></p>
<p>Về cơ bản, phương trình này nói rằng: nếu bạn truyền dữ liệu với tốc độ <strong>40 MB/s</strong>, bạn chỉ cần truyền <strong>409,6 KB</strong> mỗi lần seek để dành <strong>một nửa thời gian cho seek</strong> và <strong>một nửa thời gian cho truyền dữ liệu</strong>.<br />
Tương tự, bạn có thể tính kích thước <strong>chunk</strong> (phần dữ liệu) cần thiết để đạt <strong>90% băng thông cực đại</strong> (kết quả khoảng <strong>3,6 MB</strong>), hoặc thậm chí <strong>99% băng thông cực đại</strong> (<strong>39,6 MB</strong>!).<br />
Như bạn thấy, càng muốn tiến gần đến mức cực đại, kích thước chunk càng phải lớn (xem <strong>Hình 41.2</strong> để thấy đồ thị các giá trị này).</p>
<p><img src="41/img/fig41_2.PNG" alt="" /></p>
<p><strong>Hình 41.2: Amortization – Chunk phải lớn đến mức nào? (Amortization: How Big Do Chunks Have To Be?)</strong></p>
<p>Tuy nhiên, <strong>FFS</strong> không sử dụng kiểu tính toán này để phân tán các file lớn ra nhiều group.<br />
Thay vào đó, nó áp dụng một cách tiếp cận đơn giản, dựa trên <strong>cấu trúc của inode</strong>.<br />
Cụ thể:</p>
<ul>
<li><strong>12 direct block</strong> đầu tiên được đặt trong cùng group với inode</li>
<li>Mỗi <strong>indirect block</strong> tiếp theo, và tất cả các block mà nó trỏ tới, được đặt trong một group khác</li>
</ul>
<p>Với kích thước block là <strong>4 KB</strong> và địa chỉ đĩa 32-bit, chiến lược này có nghĩa là <strong>mỗi 1024 block</strong> của file (<strong>4 MB</strong>) sẽ được đặt ở các group khác nhau, ngoại lệ duy nhất là <strong>48 KB đầu tiên</strong> của file (được trỏ tới bởi các direct pointer).</p>
<p>Lưu ý rằng xu hướng của ổ đĩa là <strong>tốc độ truyền dữ liệu</strong> được cải thiện khá nhanh (do các nhà sản xuất đĩa ngày càng lưu được nhiều bit hơn trên cùng một bề mặt), nhưng các yếu tố cơ học liên quan đến seek (tốc độ di chuyển tay đọc và tốc độ quay) lại cải thiện khá chậm [P98].<br />
Điều này có nghĩa là theo thời gian, <strong>chi phí cơ học</strong> trở nên tương đối đắt đỏ hơn, và để <strong>amortize</strong> (phân bổ) chi phí này, bạn phải truyền nhiều dữ liệu hơn giữa các lần seek.</p>
<h2 id="417-một-vài-điểm-khác-về-ffs-a-few-other-things-about-ffs"><a class="header" href="#417-một-vài-điểm-khác-về-ffs-a-few-other-things-about-ffs">41.7 Một vài điểm khác về FFS (A Few Other Things About FFS)</a></h2>
<p>FFS cũng giới thiệu một số cải tiến khác.<br />
Đặc biệt, các nhà thiết kế rất lo ngại về việc hỗ trợ <strong>các file nhỏ</strong>; thực tế, vào thời điểm đó, nhiều file chỉ khoảng <strong>2 KB</strong>, và việc sử dụng block 4 KB – tuy tốt cho tốc độ truyền dữ liệu – lại không hiệu quả về mặt sử dụng không gian.<br />
Hiện tượng <strong>internal fragmentation</strong> (phân mảnh bên trong) này có thể dẫn đến việc <strong>lãng phí khoảng một nửa dung lượng đĩa</strong> đối với một hệ thống tệp điển hình.</p>
<p>Giải pháp mà các nhà thiết kế FFS đưa ra rất đơn giản và giải quyết được vấn đề:<br />
Họ quyết định giới thiệu <strong>sub-block</strong> – các block nhỏ 512 byte mà hệ thống tệp có thể cấp phát cho file.<br />
Nhờ đó, nếu bạn tạo một file nhỏ (ví dụ: 1 KB), nó sẽ chỉ chiếm <strong>hai sub-block</strong> và không lãng phí cả block 4 KB.<br />
Khi file lớn dần, hệ thống tệp sẽ tiếp tục cấp phát các block 512 byte cho đến khi đạt đủ 4 KB dữ liệu.<br />
Tại thời điểm đó, FFS sẽ tìm một block 4 KB, <strong>sao chép các sub-block vào đó</strong>, và giải phóng các sub-block để tái sử dụng.</p>
<p><img src="41/img/fig41_3.PNG" alt="" /></p>
<p><strong>Hình 41.3: FFS – So sánh bố trí chuẩn và bố trí tham số hóa (Standard Versus Parameterized Placement)</strong></p>
<p>Bạn có thể nhận thấy rằng quá trình này <strong>không hiệu quả</strong>, vì yêu cầu nhiều công việc bổ sung cho hệ thống tệp (đặc biệt là nhiều thao tác I/O để thực hiện việc sao chép).<br />
Và bạn lại đúng!<br />
Vì vậy, FFS thường tránh hành vi kém hiệu quả này bằng cách <strong>chỉnh sửa thư viện libc</strong>; thư viện này sẽ <strong>buffer</strong> (đệm) các thao tác ghi và sau đó gửi chúng thành các chunk 4 KB tới hệ thống tệp, nhờ đó tránh hoàn toàn việc phải xử lý sub-block trong hầu hết các trường hợp.</p>
<p>Một điểm thú vị thứ hai mà <strong>FFS</strong> (Fast File System) giới thiệu là <strong>bố trí dữ liệu trên đĩa được tối ưu cho hiệu năng</strong>.<br />
Vào thời điểm đó (trước khi có <strong>SCSI</strong> và các giao tiếp thiết bị hiện đại hơn), ổ đĩa kém tinh vi hơn nhiều và yêu cầu <strong>CPU</strong> của máy chủ điều khiển hoạt động của chúng theo cách “thủ công” hơn.<br />
Một vấn đề phát sinh trong FFS khi một file được đặt trên <strong>các sector liên tiếp</strong> của đĩa, như minh họa bên trái trong <strong>Hình 41.3</strong>.</p>
<p>Cụ thể, vấn đề xảy ra trong quá trình <strong>đọc tuần tự</strong> (<em>sequential read</em>).<br />
FFS sẽ gửi yêu cầu đọc <strong>block 0</strong>; đến khi việc đọc hoàn tất và FFS gửi yêu cầu đọc <strong>block 1</strong>, thì đã quá muộn: <strong>block 1</strong> đã quay qua khỏi đầu đọc, và bây giờ việc đọc block 1 sẽ phải chịu <strong>một vòng quay đầy đủ</strong> (<em>full rotation</em>).</p>
<p>FFS giải quyết vấn đề này bằng một <strong>bố trí khác</strong>, như bạn thấy ở bên phải <strong>Hình 41.3</strong>.<br />
Bằng cách <strong>bỏ qua mỗi block xen kẽ</strong> (trong ví dụ), FFS có đủ thời gian để yêu cầu block tiếp theo trước khi nó đi qua đầu đọc.<br />
Thực tế, FFS đủ “thông minh” để xác định, đối với một ổ đĩa cụ thể, cần bỏ qua bao nhiêu block khi bố trí dữ liệu để tránh các vòng quay thừa; kỹ thuật này được gọi là <strong>parameterization</strong> (tham số hóa), vì FFS sẽ xác định các tham số hiệu năng cụ thể của ổ đĩa và sử dụng chúng để quyết định <strong>sơ đồ bố trí so le</strong> chính xác.</p>
<p>Bạn có thể nghĩ: “Cách này cũng không hay lắm”.<br />
Thực tế, bạn chỉ đạt được <strong>50% băng thông cực đại</strong> với kiểu bố trí này, vì bạn phải quay quanh mỗi track <strong>hai lần</strong> chỉ để đọc mỗi block một lần.<br />
May mắn thay, các ổ đĩa hiện đại thông minh hơn nhiều: chúng <strong>đọc toàn bộ track</strong> vào và lưu trong <strong>bộ nhớ đệm nội bộ</strong> (<em>internal disk cache</em>, thường gọi là <strong>track buffer</strong> vì lý do này).<br />
Sau đó, ở các lần đọc tiếp theo trên track đó, ổ đĩa sẽ chỉ trả về dữ liệu mong muốn từ cache của nó.<br />
Do đó, các hệ thống tệp không còn phải lo lắng về những chi tiết cực kỳ thấp này nữa.<br />
<strong>Abstraction</strong> (trừu tượng hóa) và các giao diện cấp cao hơn có thể là một điều tốt, khi được thiết kế hợp lý.</p>
<blockquote>
<p><strong>TIP: LÀM CHO HỆ THỐNG DỄ SỬ DỤNG (MAKE THE SYSTEM USABLE)</strong><br />
Có lẽ bài học cơ bản nhất từ FFS là: không chỉ giới thiệu ý tưởng tốt về <strong>bố trí dữ liệu nhận thức đĩa</strong> (<em>disk-aware layout</em>), mà còn bổ sung nhiều tính năng giúp hệ thống <strong>dễ sử dụng hơn</strong>.<br />
Các tính năng như <strong>tên file dài</strong>, <strong>symbolic link</strong>, và thao tác <strong>rename</strong> hoạt động nguyên tử (<em>atomic</em>) đều cải thiện tính hữu ích của hệ thống; mặc dù khó để viết một bài nghiên cứu dài về chúng (hãy tưởng tượng đọc 14 trang về “The Symbolic Link: Hard Link’s Long Lost Cousin”), nhưng những tính năng nhỏ này khiến FFS hữu dụng hơn và có khả năng cao hơn được chấp nhận rộng rãi.<br />
Làm cho hệ thống dễ sử dụng thường quan trọng ngang hoặc hơn cả các đổi mới kỹ thuật sâu.</p>
</blockquote>
<p>Một số cải tiến về khả năng sử dụng khác cũng được bổ sung.<br />
FFS là một trong những hệ thống tệp đầu tiên cho phép <strong>tên file dài</strong>, cho phép đặt tên biểu đạt hơn thay vì cách tiếp cận truyền thống với kích thước cố định (ví dụ: 8 ký tự).<br />
Hơn nữa, một khái niệm mới được giới thiệu là <strong>symbolic link</strong>.<br />
Như đã thảo luận ở chương trước [AD14b], <strong>hard link</strong> bị giới hạn ở chỗ:</p>
<ul>
<li>Không thể trỏ tới thư mục (để tránh tạo vòng lặp trong cây hệ thống tệp)</li>
<li>Chỉ có thể trỏ tới file trong cùng một volume (tức <strong>inode number</strong> vẫn phải có ý nghĩa)</li>
</ul>
<p><strong>Symbolic link</strong> cho phép người dùng tạo một “bí danh” (<em>alias</em>) tới bất kỳ file hoặc thư mục nào trên hệ thống và do đó linh hoạt hơn nhiều.<br />
FFS cũng giới thiệu thao tác <code>rename()</code> nguyên tử để đổi tên file.<br />
Những cải tiến về khả năng sử dụng, vượt ra ngoài công nghệ cơ bản, cũng có thể đã giúp FFS có được một cộng đồng người dùng mạnh mẽ hơn.</p>
<h2 id="418-tóm-tắt-summary"><a class="header" href="#418-tóm-tắt-summary">41.8 Tóm tắt (Summary)</a></h2>
<p>Sự ra đời của <strong>FFS</strong> là một <strong>bước ngoặt</strong> trong lịch sử hệ thống tệp, vì nó cho thấy rằng vấn đề <strong>quản lý file</strong> là một trong những vấn đề thú vị nhất trong một hệ điều hành, và chỉ ra cách bắt đầu xử lý thiết bị quan trọng nhất – <strong>ổ đĩa cứng</strong>.<br />
Kể từ đó, hàng trăm hệ thống tệp mới đã được phát triển, nhưng cho đến nay, nhiều hệ thống tệp vẫn lấy cảm hứng từ FFS (ví dụ: <strong>Linux ext2</strong> và <strong>ext3</strong> rõ ràng là hậu duệ về mặt ý tưởng).<br />
Chắc chắn rằng tất cả các hệ thống hiện đại đều rút ra bài học chính từ FFS: <strong>hãy đối xử với đĩa như chính nó – một chiếc đĩa</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="42-tính-nhất-quán-khi-xảy-ra-sự-cố-crash-consistency-fsck-và-journaling"><a class="header" href="#42-tính-nhất-quán-khi-xảy-ra-sự-cố-crash-consistency-fsck-và-journaling">42. Tính nhất quán khi xảy ra sự cố (Crash Consistency): FSCK và Journaling</a></h1>
<p>Như chúng ta đã thấy cho đến thời điểm này, file system (hệ thống tệp) quản lý một tập hợp các cấu trúc dữ liệu (data structure) để hiện thực hóa các trừu tượng (abstraction) mà chúng ta mong đợi: file (tệp), directory (thư mục), và tất cả các metadata (siêu dữ liệu) khác cần thiết để hỗ trợ trừu tượng cơ bản này. Không giống như hầu hết các cấu trúc dữ liệu (ví dụ: những cấu trúc tồn tại trong bộ nhớ của một chương trình đang chạy), các cấu trúc dữ liệu của file system phải tồn tại lâu dài (persist), nghĩa là chúng phải được lưu trữ trên các thiết bị có khả năng giữ dữ liệu ngay cả khi mất điện (chẳng hạn như ổ cứng từ hoặc SSD dùng bộ nhớ flash).</p>
<p>Một thách thức lớn mà file system phải đối mặt là làm thế nào để cập nhật các cấu trúc dữ liệu persistent (lưu trữ lâu dài) ngay cả khi có khả năng xảy ra mất điện hoặc system crash (hệ thống bị sập). Cụ thể, điều gì sẽ xảy ra nếu ngay giữa quá trình cập nhật các cấu trúc trên đĩa (on-disk structures), ai đó vô tình rút dây nguồn và máy mất điện? Hoặc hệ điều hành gặp lỗi và bị crash? Do khả năng mất điện hoặc crash, việc cập nhật một cấu trúc dữ liệu persistent trở nên khá phức tạp, và dẫn đến một vấn đề mới, thú vị trong việc hiện thực file system, được gọi là <strong>crash-consistency problem</strong> (vấn đề đảm bảo tính nhất quán khi xảy ra sự cố).</p>
<p>Vấn đề này khá dễ hiểu. Hãy tưởng tượng bạn cần cập nhật hai cấu trúc trên đĩa, A và B, để hoàn tất một thao tác cụ thể. Vì đĩa chỉ xử lý một yêu cầu tại một thời điểm, một trong hai yêu cầu này sẽ được ghi xuống đĩa trước (hoặc A hoặc B). Nếu hệ thống bị crash hoặc mất điện sau khi một thao tác ghi hoàn tất, cấu trúc trên đĩa sẽ rơi vào trạng thái không nhất quán. Và như vậy, chúng ta có một vấn đề mà mọi file system đều phải giải quyết:</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ CẬP NHẬT ĐĨA NGAY CẢ KHI XẢY RA SỰ CỐ</strong>
Hệ thống có thể bị crash hoặc mất điện giữa hai thao tác ghi bất kỳ, và do đó trạng thái trên đĩa có thể chỉ được cập nhật một phần. Sau khi crash, hệ thống khởi động lại và muốn mount (gắn) file system một lần nữa (để truy cập các file, v.v.). Vì crash có thể xảy ra tại bất kỳ thời điểm nào, làm thế nào để đảm bảo file system giữ được hình ảnh (image) trên đĩa ở trạng thái hợp lý?</p>
</blockquote>
</blockquote>
<p>Trong chương này, chúng ta sẽ mô tả vấn đề này chi tiết hơn, và xem xét một số phương pháp mà các file system đã sử dụng để khắc phục. Chúng ta sẽ bắt đầu bằng cách xem xét phương pháp được sử dụng trong các file system cũ, được gọi là <strong>fsck</strong> hay <strong>file system checker</strong> (trình kiểm tra hệ thống tệp). Sau đó, chúng ta sẽ chuyển sang một phương pháp khác, được gọi là <strong>journaling</strong> (còn được biết đến với tên <strong>write-ahead logging</strong>), một kỹ thuật bổ sung một chút chi phí (overhead) cho mỗi thao tác ghi nhưng có khả năng phục hồi nhanh hơn sau khi crash hoặc mất điện. Chúng ta sẽ thảo luận về cơ chế cơ bản của journaling, bao gồm một số biến thể mà Linux ext3 [T98, PAA05] (một file system journaling tương đối hiện đại) triển khai.</p>
<h2 id="421-một-ví-dụ-chi-tiết"><a class="header" href="#421-một-ví-dụ-chi-tiết">42.1 Một ví dụ chi tiết</a></h2>
<p>Để bắt đầu việc tìm hiểu journaling, hãy xem một ví dụ. Chúng ta cần một workload (khối lượng công việc) có thao tác cập nhật các cấu trúc trên đĩa. Giả sử ở đây workload rất đơn giản: thao tác <strong>append</strong> (nối thêm) một data block (khối dữ liệu) vào cuối một file đã tồn tại. Việc append này được thực hiện bằng cách mở file, gọi <code>lseek()</code> để di chuyển file offset (vị trí con trỏ tệp) đến cuối file, sau đó thực hiện một thao tác ghi (write) 4KB vào file trước khi đóng nó.</p>
<p>Giả sử thêm rằng chúng ta đang sử dụng các cấu trúc file system đơn giản tiêu chuẩn trên đĩa, tương tự như các file system mà chúng ta đã thấy trước đây. Ví dụ nhỏ này bao gồm một <strong>inode bitmap</strong> (bản đồ bit của inode, với chỉ 8 bit, mỗi bit ứng với một inode), một <strong>data bitmap</strong> (bản đồ bit dữ liệu, cũng 8 bit, mỗi bit ứng với một data block), các inode (tổng cộng 8, đánh số từ 0 đến 7, phân bố trên bốn block), và các data block (tổng cộng 8, đánh số từ 0 đến 7). Dưới đây là sơ đồ của file system này:</p>
<p>...</p>
<p>Nếu bạn quan sát các cấu trúc trong hình, bạn sẽ thấy rằng chỉ có một inode được cấp phát (inode số 2), được đánh dấu trong inode bitmap, và một data block được cấp phát (data block số 4), cũng được đánh dấu trong data bitmap. Inode này được ký hiệu là I[v1], vì đây là phiên bản đầu tiên của inode này; nó sẽ sớm được cập nhật (do workload đã mô tả ở trên).</p>
<p>Hãy cùng xem bên trong inode đơn giản này. Bên trong I[v1], chúng ta thấy:</p>
<p>...</p>
<p>Trong inode (chỉ mục nút) đơn giản này, kích thước của file là 1 (nghĩa là nó có một block đã được cấp phát), con trỏ trực tiếp (direct pointer) đầu tiên trỏ tới block 4 (block dữ liệu đầu tiên của file, ký hiệu Da), và cả ba con trỏ trực tiếp còn lại đều được đặt là null (biểu thị rằng chúng không được sử dụng). Tất nhiên, inode thực tế có nhiều trường (field) hơn rất nhiều; hãy xem lại các chương trước để biết thêm thông tin.</p>
<p>Khi chúng ta thực hiện thao tác append (nối thêm) vào file, tức là đang thêm một data block (khối dữ liệu) mới vào nó, khi đó cần phải cập nhật ba cấu trúc trên đĩa (on-disk structures): inode (phải trỏ tới block mới và ghi nhận kích thước mới lớn hơn do thao tác append), data block mới Db, và một phiên bản mới của data bitmap (gọi là B[v2]) để biểu thị rằng data block mới đã được cấp phát.</p>
<p>Như vậy, trong bộ nhớ của hệ thống, chúng ta có ba block cần phải ghi xuống đĩa. Inode đã được cập nhật (inode phiên bản 2, viết tắt là I[v2]) hiện trông như sau:</p>
<p>...</p>
<p>Data bitmap đã được cập nhật (B[v2]) hiện có dạng: 00001100. Cuối cùng là data block (Db), chứa bất kỳ dữ liệu nào mà người dùng ghi vào file. Có thể là… nhạc vi phạm bản quyền chẳng hạn?</p>
<p>Điều chúng ta mong muốn là hình ảnh cuối cùng của file system trên đĩa sẽ trông như sau:</p>
<p>...</p>
<p>Để đạt được sự chuyển đổi này, file system phải thực hiện ba thao tác ghi riêng biệt xuống đĩa, mỗi thao tác cho một thành phần: inode (I[v2]), bitmap (B[v2]) và data block (Db). Lưu ý rằng các thao tác ghi này thường không diễn ra ngay lập tức khi người dùng gọi system call <code>write()</code>; thay vào đó, inode, bitmap và dữ liệu mới (ở trạng thái “bẩn” – dirty) sẽ nằm trong bộ nhớ chính (trong page cache hoặc buffer cache) một thời gian; sau đó, khi file system quyết định ghi chúng xuống đĩa (ví dụ sau 5 giây hoặc 30 giây), nó sẽ gửi các yêu cầu ghi tương ứng tới đĩa. Thật không may, một sự cố crash có thể xảy ra và làm gián đoạn quá trình cập nhật này. Đặc biệt, nếu crash xảy ra sau khi một hoặc hai thao tác ghi đã hoàn tất nhưng chưa phải cả ba, file system có thể rơi vào trạng thái “kỳ quặc” (không nhất quán).</p>
<h3 id="các-kịch-bản-crash-crash-scenarios"><a class="header" href="#các-kịch-bản-crash-crash-scenarios">Các kịch bản crash (Crash Scenarios)</a></h3>
<p>Để hiểu rõ hơn vấn đề, hãy xem một số ví dụ về kịch bản crash. Giả sử chỉ có một thao tác ghi thành công; khi đó sẽ có ba khả năng xảy ra như sau:</p>
<p>Trường hợp thứ nhất, chỉ có data block (Db) được ghi xuống đĩa. Trong tình huống này, dữ liệu đã nằm trên đĩa, nhưng không có inode nào trỏ tới nó và cũng không có bitmap nào cho biết block đó đã được cấp phát. Do đó, về bản chất, thao tác ghi này coi như chưa từng xảy ra. Trường hợp này hoàn toàn không gây vấn đề gì xét từ góc độ crash consistency (tính nhất quán khi xảy ra sự cố) của file system^[1].</p>
<p>Trường hợp thứ hai, chỉ có inode đã được cập nhật (I[v2]) được ghi xuống đĩa. Khi đó, inode trỏ tới địa chỉ đĩa (5) – nơi mà Db đáng lẽ sẽ được ghi vào – nhưng Db vẫn chưa được ghi ở đó. Vì vậy, nếu tin vào con trỏ này, chúng ta sẽ đọc phải dữ liệu rác (garbage data) từ đĩa (nội dung cũ của địa chỉ đĩa 5). Hơn nữa, xuất hiện một vấn đề mới gọi là file-system inconsistency (sự không nhất quán của hệ thống tệp). Bitmap trên đĩa cho biết data block 5 chưa được cấp phát, nhưng inode lại nói rằng nó đã được cấp phát. Sự mâu thuẫn giữa bitmap và inode này là một dạng không nhất quán trong cấu trúc dữ liệu của file system; để sử dụng file system, chúng ta phải tìm cách giải quyết vấn đề này (sẽ bàn thêm ở phần sau).</p>
<p>Trường hợp thứ ba, chỉ có bitmap đã được cập nhật (B[v2]) được ghi xuống đĩa. Khi đó, bitmap cho biết block 5 đã được cấp phát, nhưng không có inode nào trỏ tới nó. Do đó, file system lại rơi vào trạng thái không nhất quán; nếu không được xử lý, thao tác ghi này sẽ dẫn đến hiện tượng “rò rỉ không gian” (space leak), vì block 5 sẽ không bao giờ được sử dụng bởi file system.</p>
<p>Ngoài ra, còn có ba kịch bản crash khác trong quá trình cố gắng ghi ba block xuống đĩa. Trong các trường hợp này, hai thao tác ghi thành công và thao tác cuối cùng thất bại:</p>
<p>Trường hợp thứ nhất, inode (I[v2]) và bitmap (B[v2]) được ghi xuống đĩa, nhưng data (Db) thì không. Khi đó, metadata của file system hoàn toàn nhất quán: inode có con trỏ tới block 5, bitmap cho biết block 5 đang được sử dụng, và mọi thứ trông có vẻ ổn xét từ góc độ metadata. Nhưng vẫn có một vấn đề: block 5 lại chứa dữ liệu rác.</p>
<p>Trường hợp thứ hai, inode (I[v2]) và data block (Db) được ghi, nhưng bitmap (B[v2]) thì không. Khi đó, inode trỏ tới dữ liệu đúng trên đĩa, nhưng lại tồn tại sự không nhất quán giữa inode và phiên bản cũ của bitmap (B1). Do đó, một lần nữa, chúng ta cần giải quyết vấn đề này trước khi sử dụng file system.</p>
<p>Trường hợp thứ ba, bitmap (B[v2]) và data block (Db) được ghi, nhưng inode (I[v2]) thì không. Khi đó, lại xuất hiện sự không nhất quán giữa inode và data bitmap. Tuy block đã được ghi và bitmap cho biết nó đang được sử dụng, nhưng chúng ta không biết nó thuộc về file nào, vì không có inode nào trỏ tới file đó.</p>
<p>^[1]: Trong trường hợp này, dữ liệu tồn tại trên đĩa nhưng không thể truy cập được, và vì không có metadata nào tham chiếu đến nó, hệ thống coi như thao tác ghi chưa từng xảy ra.</p>
<h3 id="vấn-đề-crash-consistency-tính-nhất-quán-khi-xảy-ra-sự-cố"><a class="header" href="#vấn-đề-crash-consistency-tính-nhất-quán-khi-xảy-ra-sự-cố">Vấn đề Crash Consistency (Tính nhất quán khi xảy ra sự cố)</a></h3>
<p>Từ các kịch bản crash (sập hệ thống) đã phân tích ở trên, hy vọng bạn có thể thấy nhiều vấn đề có thể xảy ra đối với hình ảnh (image) của file system (hệ thống tệp) trên đĩa khi gặp sự cố: chúng ta có thể gặp tình trạng <strong>inconsistency</strong> (không nhất quán) trong các cấu trúc dữ liệu của file system; có thể xảy ra <strong>space leak</strong> (rò rỉ không gian lưu trữ); có thể trả về <strong>garbage data</strong> (dữ liệu rác) cho người dùng; và nhiều vấn đề khác.</p>
<p>Lý tưởng nhất, chúng ta muốn chuyển file system từ một trạng thái nhất quán này (ví dụ: trước khi file được append) sang một trạng thái nhất quán khác một cách <strong>atomic</strong> (nguyên tử, tức là toàn bộ thay đổi diễn ra trọn vẹn hoặc không diễn ra gì cả) — ví dụ: sau khi inode, bitmap và data block mới đã được ghi xuống đĩa.</p>
<p>Thật không may, chúng ta không thể dễ dàng làm điều này vì đĩa chỉ commit (ghi xác nhận) một thao tác ghi tại một thời điểm, và crash hoặc mất điện có thể xảy ra giữa các lần cập nhật này. Chúng ta gọi vấn đề tổng quát này là <strong>crash-consistency problem</strong> (vấn đề đảm bảo tính nhất quán khi xảy ra sự cố), hoặc cũng có thể gọi là <strong>consistent-update problem</strong> (vấn đề cập nhật nhất quán).</p>
<h2 id="422-giải-pháp-số-1-trình-kiểm-tra-hệ-thống-tệp-file-system-checker"><a class="header" href="#422-giải-pháp-số-1-trình-kiểm-tra-hệ-thống-tệp-file-system-checker">42.2 Giải pháp số 1: Trình kiểm tra hệ thống tệp (File System Checker)</a></h2>
<p>Các file system đời đầu áp dụng một cách tiếp cận đơn giản đối với crash consistency. Về cơ bản, chúng cho phép sự không nhất quán xảy ra, rồi sửa chữa sau đó (khi khởi động lại). Một ví dụ kinh điển của cách tiếp cận “lười biếng” này là công cụ <code>fsck</code><sup class="footnote-reference"><a href="#2">1</a></sup>.</p>
<p><code>fsck</code> là một công cụ trong UNIX dùng để tìm ra các sự không nhất quán như vậy và sửa chữa chúng [MK96]; các hệ thống khác cũng có những công cụ tương tự để kiểm tra và sửa chữa một phân vùng đĩa.</p>
<p>Lưu ý rằng cách tiếp cận này không thể sửa được mọi vấn đề; ví dụ, trong trường hợp ở trên, file system có vẻ nhất quán nhưng inode lại trỏ tới dữ liệu rác. Mục tiêu thực sự duy nhất của <code>fsck</code> là đảm bảo metadata (siêu dữ liệu) của file system nhất quán về mặt nội bộ.</p>
<p>Công cụ <code>fsck</code> hoạt động qua một số giai đoạn, được tóm tắt trong bài báo của McKusick và Kowalski [MK96]. Nó được chạy <strong>trước</strong> khi file system được mount (gắn) và đưa vào sử dụng (<code>fsck</code> giả định rằng không có hoạt động file system nào khác đang diễn ra khi nó chạy); khi hoàn tất, file system trên đĩa sẽ ở trạng thái nhất quán và có thể được truy cập bởi người dùng.</p>
<p>Dưới đây là tóm tắt cơ bản những gì <code>fsck</code> thực hiện:</p>
<p><strong>Superblock:</strong> <code>fsck</code> trước tiên kiểm tra xem superblock có hợp lý hay không, chủ yếu bằng các phép kiểm tra hợp lệ (sanity check) như đảm bảo kích thước file system lớn hơn số block đã được cấp phát. Mục tiêu của các kiểm tra này thường là phát hiện superblock nghi ngờ bị hỏng; trong trường hợp này, hệ thống (hoặc quản trị viên) có thể quyết định sử dụng một bản sao dự phòng của superblock.</p>
<p><strong>Free blocks:</strong> Tiếp theo, <code>fsck</code> quét qua các inode, indirect block, double indirect block, v.v., để xác định block nào hiện đang được cấp phát trong file system. Thông tin này được dùng để tạo ra phiên bản chính xác của allocation bitmap (bản đồ cấp phát); do đó, nếu có sự không nhất quán giữa bitmap và inode, <code>fsck</code> sẽ giải quyết bằng cách tin tưởng thông tin trong inode. Cùng loại kiểm tra này cũng được áp dụng cho tất cả inode, đảm bảo rằng mọi inode đang được sử dụng đều được đánh dấu như vậy trong inode bitmap.</p>
<p><strong>Inode state:</strong> Mỗi inode được kiểm tra xem có bị hỏng hoặc gặp vấn đề gì không. Ví dụ, <code>fsck</code> đảm bảo rằng mỗi inode đã cấp phát có trường type (loại) hợp lệ (ví dụ: regular file, directory, symbolic link, v.v.). Nếu có vấn đề với các trường của inode mà không thể dễ dàng sửa chữa, inode đó được coi là nghi ngờ và bị xóa (clear) bởi <code>fsck</code>; inode bitmap cũng được cập nhật tương ứng.</p>
<p><strong>Inode links:</strong> <code>fsck</code> cũng xác minh link count (số liên kết) của mỗi inode đã cấp phát. Như bạn đã biết, link count cho biết số lượng thư mục khác nhau chứa tham chiếu (link) tới file này. Để xác minh link count, <code>fsck</code> quét toàn bộ cây thư mục, bắt đầu từ root directory, và tự xây dựng số đếm liên kết cho mọi file và thư mục trong file system. Nếu có sự khác biệt giữa số đếm mới tính và số đếm trong inode, cần thực hiện hành động sửa chữa, thường là cập nhật số đếm trong inode. Nếu phát hiện một inode đã cấp phát nhưng không có thư mục nào tham chiếu tới nó, inode đó sẽ được di chuyển vào thư mục <code>lost+found</code>.</p>
<p><strong>Duplicates:</strong> <code>fsck</code> cũng kiểm tra các duplicate pointer (con trỏ trùng lặp), tức là trường hợp hai inode khác nhau cùng tham chiếu tới một block. Nếu một inode rõ ràng là hỏng, nó có thể bị xóa. Hoặc, block được tham chiếu có thể được sao chép, để mỗi inode có bản sao riêng như mong muốn.</p>
<p><strong>Bad blocks:</strong> Trong quá trình quét danh sách tất cả con trỏ, <code>fsck</code> cũng kiểm tra các bad block pointer (con trỏ tới block không hợp lệ). Một con trỏ được coi là “bad” nếu nó trỏ tới một vị trí ngoài phạm vi hợp lệ, ví dụ: địa chỉ trỏ tới block lớn hơn kích thước phân vùng. Trong trường hợp này, <code>fsck</code> không thể làm gì thông minh hơn ngoài việc xóa (clear) con trỏ đó khỏi inode hoặc indirect block.</p>
<p><strong>Directory checks:</strong> <code>fsck</code> không hiểu nội dung của file người dùng; tuy nhiên, thư mục chứa thông tin được định dạng đặc biệt do file system tạo ra. Do đó, <code>fsck</code> thực hiện các kiểm tra tính toàn vẹn bổ sung trên nội dung của mỗi thư mục, đảm bảo rằng “.” và “..” là hai mục đầu tiên, rằng mỗi inode được tham chiếu trong một mục thư mục đều đã được cấp phát, và đảm bảo rằng không có thư mục nào được liên kết nhiều hơn một lần trong toàn bộ hệ thống thư mục.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">1</sup>
<p><code>fsck</code> là viết tắt của <em>file system check</em>, một tiện ích trong UNIX dùng để kiểm tra và sửa chữa sự không nhất quán của hệ thống tệp.</p>
</div>
<p>Như bạn có thể thấy, việc xây dựng một <code>fsck</code> hoạt động hiệu quả đòi hỏi kiến thức sâu rộng và chi tiết về file system (hệ thống tệp); đảm bảo rằng đoạn code như vậy hoạt động đúng trong mọi trường hợp là một thách thức không nhỏ [G+08]. Tuy nhiên, <code>fsck</code> (và các phương pháp tương tự) còn gặp một vấn đề lớn hơn, và có lẽ mang tính nền tảng hơn: chúng quá chậm.</p>
<p>Với một ổ đĩa dung lượng rất lớn, việc quét toàn bộ đĩa để tìm tất cả các block đã được cấp phát và đọc toàn bộ cây thư mục có thể mất nhiều phút, thậm chí hàng giờ. Khi dung lượng đĩa tăng và RAID trở nên phổ biến, hiệu năng của <code>fsck</code> trở nên không thể chấp nhận được (mặc dù đã có những cải tiến gần đây [M+13]).</p>
<p>Ở một góc độ cao hơn, giả định cơ bản của <code>fsck</code> có vẻ hơi thiếu hợp lý. Hãy xem lại ví dụ ở trên, khi chỉ có ba block được ghi xuống đĩa; thật tốn kém khi phải quét toàn bộ đĩa chỉ để sửa lỗi xảy ra trong quá trình cập nhật ba block này. Tình huống này giống như việc bạn làm rơi chìa khóa trên sàn phòng ngủ, nhưng lại bắt đầu một thuật toán tìm kiếm toàn bộ ngôi nhà, bắt đầu từ tầng hầm và đi qua từng phòng một. Cách này có thể hiệu quả, nhưng lại rất lãng phí. Vì vậy, khi dung lượng đĩa (và RAID) tăng lên, các nhà nghiên cứu và kỹ sư bắt đầu tìm kiếm những giải pháp khác.</p>
<h2 id="423-giải-pháp-số-2-journaling-hay-write-ahead-logging"><a class="header" href="#423-giải-pháp-số-2-journaling-hay-write-ahead-logging">42.3 Giải pháp số 2: Journaling (hay Write-Ahead Logging)</a></h2>
<p>Có lẽ giải pháp phổ biến nhất cho vấn đề <strong>consistent update</strong> (cập nhật nhất quán) là vay mượn một ý tưởng từ lĩnh vực hệ quản trị cơ sở dữ liệu (database management systems). Ý tưởng đó, được gọi là <strong>write-ahead logging</strong> (ghi nhật ký trước), được phát minh để giải quyết chính xác loại vấn đề này. Trong file system, chúng ta thường gọi write-ahead logging là <strong>journaling</strong> vì lý do lịch sử.</p>
<p>File system đầu tiên áp dụng kỹ thuật này là Cedar [H87], mặc dù nhiều file system hiện đại cũng sử dụng ý tưởng này, bao gồm Linux ext3 và ext4, reiserfs, IBM’s JFS, SGI’s XFS, và Windows NTFS.</p>
<p>Ý tưởng cơ bản như sau: khi cập nhật đĩa, trước khi ghi đè (overwrite) các cấu trúc hiện có, trước tiên hãy ghi lại một “ghi chú” nhỏ (ở một vị trí khác trên đĩa, tại một vị trí đã biết) mô tả những gì bạn sắp làm. Việc ghi chú này chính là phần “write ahead” (ghi trước), và chúng ta ghi nó vào một cấu trúc được tổ chức dưới dạng một “log” (nhật ký); do đó có tên gọi write-ahead logging.</p>
<p>Bằng cách ghi chú này xuống đĩa, bạn đảm bảo rằng nếu xảy ra crash trong quá trình cập nhật (ghi đè) các cấu trúc, bạn có thể quay lại xem ghi chú đã tạo và thử lại; nhờ đó, bạn sẽ biết chính xác cần sửa cái gì (và sửa như thế nào) sau khi crash, thay vì phải quét toàn bộ đĩa. Theo thiết kế, journaling bổ sung một chút công việc trong quá trình cập nhật để giảm đáng kể khối lượng công việc cần thiết khi khôi phục.</p>
<p>Bây giờ, chúng ta sẽ mô tả cách Linux ext3 — một file system journaling phổ biến — tích hợp journaling vào file system. Hầu hết các cấu trúc trên đĩa của ext3 giống hệt với Linux ext2, ví dụ: đĩa được chia thành các block group, và mỗi block group chứa một inode bitmap, data bitmap, các inode, và các data block. Cấu trúc mới quan trọng là <strong>journal</strong> (nhật ký) — chiếm một phần nhỏ dung lượng trong phân vùng hoặc trên một thiết bị khác.</p>
<p>Do đó, một file system ext2 (không có journaling) sẽ trông như sau:</p>
<p>...</p>
<p>Giả sử journal (nhật ký) được đặt trong cùng một file system image (ảnh hệ thống tệp) — mặc dù đôi khi nó được đặt trên một thiết bị riêng biệt, hoặc như một file bên trong file system — thì một file system ext3 có journal sẽ trông như sau:</p>
<p>...</p>
<p>Sự khác biệt thực sự chỉ là sự xuất hiện của journal, và tất nhiên, cách nó được sử dụng.</p>
<h3 id="data-journaling-ghi-nhật-ký-dữ-liệu"><a class="header" href="#data-journaling-ghi-nhật-ký-dữ-liệu">Data Journaling (Ghi nhật ký dữ liệu)</a></h3>
<p>Hãy xem một ví dụ đơn giản để hiểu cách <strong>data journaling</strong> hoạt động. Data journaling là một chế độ (mode) có sẵn trong file system Linux ext3, và phần lớn nội dung thảo luận ở đây dựa trên chế độ này.</p>
<p>Giả sử chúng ta lại có tình huống cập nhật quen thuộc, trong đó cần ghi inode (I[v2]), bitmap (B[v2]) và data block (Db) xuống đĩa. Trước khi ghi chúng vào các vị trí cuối cùng trên đĩa, chúng ta sẽ ghi chúng vào log (hay còn gọi là journal) trước. Trong log, điều này sẽ trông như sau:</p>
<p>...</p>
<p>Bạn có thể thấy chúng ta đã ghi năm block ở đây. <strong>Transaction begin</strong> (TxB) cho biết thông tin về bản cập nhật này, bao gồm thông tin về các thay đổi đang chờ áp dụng lên file system (ví dụ: địa chỉ cuối cùng của các block I[v2], B[v2] và Db), và một loại <strong>transaction identifier</strong> (TID – định danh giao dịch). Ba block ở giữa chỉ chứa nội dung chính xác của các block đó; đây được gọi là <strong>physical logging</strong> (ghi nhật ký vật lý) vì chúng ta đặt nội dung vật lý chính xác của bản cập nhật vào journal. Một ý tưởng thay thế là <strong>logical logging</strong> (ghi nhật ký logic), trong đó lưu một biểu diễn logic gọn hơn của bản cập nhật vào journal, ví dụ: “bản cập nhật này muốn append data block Db vào file X” — cách này phức tạp hơn một chút nhưng có thể tiết kiệm dung lượng trong log và có thể cải thiện hiệu năng. Block cuối cùng (TxE) là dấu hiệu kết thúc của giao dịch này, và cũng sẽ chứa TID.</p>
<p>Khi giao dịch này đã được ghi an toàn xuống đĩa, chúng ta sẵn sàng ghi đè các cấu trúc cũ trong file system; quá trình này được gọi là <strong>checkpointing</strong>. Như vậy, để checkpoint file system (tức là đưa nó lên trạng thái mới nhất với bản cập nhật đang chờ trong journal), chúng ta thực hiện ghi I[v2], B[v2] và Db vào các vị trí trên đĩa như đã thấy ở trên; nếu các thao tác ghi này hoàn tất thành công, chúng ta đã checkpoint thành công file system và về cơ bản là xong.</p>
<p>Do đó, trình tự thao tác ban đầu của chúng ta là:</p>
<ol>
<li><strong>Journal write:</strong> Ghi giao dịch, bao gồm một block transaction-begin, tất cả các cập nhật dữ liệu và metadata đang chờ, và một block transaction-end, vào log; chờ cho các thao tác ghi này hoàn tất.</li>
<li><strong>Checkpoint:</strong> Ghi các cập nhật metadata và dữ liệu đang chờ vào vị trí cuối cùng trong file system.</li>
</ol>
<p>Trong ví dụ của chúng ta, trước tiên sẽ ghi TxB, I[v2], B[v2], Db và TxE vào journal. Khi các thao tác ghi này hoàn tất, chúng ta sẽ hoàn tất bản cập nhật bằng cách checkpoint I[v2], B[v2] và Db vào các vị trí cuối cùng trên đĩa.</p>
<p>Mọi thứ trở nên phức tạp hơn một chút khi xảy ra crash trong quá trình ghi vào journal. Ở đây, chúng ta đang cố gắng ghi tập hợp các block trong giao dịch (ví dụ: TxB, I[v2], B[v2], Db, TxE) xuống đĩa. Một cách đơn giản là ghi từng block một, chờ mỗi block hoàn tất rồi mới ghi block tiếp theo. Tuy nhiên, cách này chậm. Lý tưởng nhất, chúng ta muốn ghi cả năm block cùng lúc, vì điều này sẽ biến năm thao tác ghi thành một thao tác ghi tuần tự duy nhất và do đó nhanh hơn.</p>
<p>Tuy nhiên, điều này <strong>không an toàn</strong>, vì lý do sau: với một thao tác ghi lớn như vậy, bên trong đĩa có thể thực hiện <strong>scheduling</strong> (lập lịch) và hoàn tất các phần nhỏ của thao tác ghi lớn theo bất kỳ thứ tự nào. Do đó, đĩa có thể (1) ghi TxB, I[v2], B[v2] và TxE trước, rồi chỉ sau đó (2) mới ghi Db. Thật không may, nếu đĩa mất điện giữa (1) và (2), thì những gì còn lại trên đĩa sẽ là:</p>
<p>...</p>
<p>Tại sao đây lại là vấn đề? Bởi vì giao dịch này trông giống như một giao dịch hợp lệ (nó có phần bắt đầu và kết thúc với số thứ tự khớp nhau). Hơn nữa, file system không thể nhìn vào block thứ tư và biết nó sai; xét cho cùng, đó là dữ liệu tùy ý của người dùng. Do đó, nếu hệ thống khởi động lại và chạy quá trình khôi phục, nó sẽ <strong>replay</strong> (phát lại) giao dịch này, và một cách vô tình sao chép nội dung của block rác ‘??’ vào vị trí mà Db đáng lẽ phải nằm. Điều này là xấu đối với dữ liệu người dùng bất kỳ; và còn tệ hơn nhiều nếu nó xảy ra với một phần quan trọng của file system, chẳng hạn như <strong>superblock</strong>, vì điều đó có thể khiến file system không thể mount (gắn) được.</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: OPTIMIZING LOG WRITES</strong><br />
Bạn có thể đã nhận thấy một điểm kém hiệu quả khi ghi vào log. Cụ thể, file system trước tiên phải ghi block transaction-begin và nội dung của giao dịch; chỉ sau khi các thao tác ghi này hoàn tất, file system mới có thể gửi block transaction-end xuống đĩa. Ảnh hưởng đến hiệu năng là rõ ràng nếu bạn hiểu cách đĩa hoạt động: thường sẽ phải chịu thêm một vòng quay đĩa (hãy thử nghĩ tại sao).</p>
<p>Một nghiên cứu sinh cũ của chúng tôi, Vijayan Prabhakaran, đã có một ý tưởng đơn giản để khắc phục vấn đề này [P+05]. Khi ghi một giao dịch vào journal, hãy bao gồm một <strong>checksum</strong> (mã kiểm tra) của nội dung journal trong cả block bắt đầu và block kết thúc. Làm như vậy cho phép file system ghi toàn bộ giao dịch cùng lúc, mà không cần chờ đợi; nếu trong quá trình khôi phục, file system phát hiện sự không khớp giữa checksum tính toán được và checksum lưu trữ trong giao dịch, nó có thể kết luận rằng đã xảy ra crash trong khi ghi giao dịch và do đó bỏ qua bản cập nhật file system đó. Với một thay đổi nhỏ trong giao thức ghi và hệ thống khôi phục, file system có thể đạt hiệu năng tốt hơn trong trường hợp thông thường; hơn nữa, hệ thống còn đáng tin cậy hơn một chút, vì mọi lần đọc từ journal giờ đây đều được bảo vệ bởi checksum.</p>
<p>Sự cải tiến đơn giản này đủ hấp dẫn để thu hút sự chú ý của các nhà phát triển file system Linux, và sau đó được tích hợp vào thế hệ tiếp theo của file system Linux, gọi là (bạn đoán đúng rồi đấy!) Linux ext4. Hiện nay, nó được triển khai trên hàng triệu máy tính trên toàn thế giới, bao gồm cả nền tảng di động Android. Vì vậy, mỗi khi bạn ghi xuống đĩa trên nhiều hệ thống dựa trên Linux, một chút mã được phát triển tại Wisconsin đang giúp hệ thống của bạn nhanh hơn và đáng tin cậy hơn.</p>
</blockquote>
</blockquote>
<p>Để tránh vấn đề này, file system thực hiện ghi giao dịch theo hai bước. Đầu tiên, nó ghi tất cả các block <strong>ngoại trừ</strong> block TxE vào journal, và thực hiện các thao tác ghi này cùng lúc. Khi các thao tác ghi này hoàn tất, journal sẽ trông giống như sau (giả sử lại với workload append của chúng ta):</p>
<p>Khi các thao tác ghi này hoàn tất, file system (hệ thống tệp) sẽ thực hiện ghi block <strong>TxE</strong>, để lại journal (nhật ký) ở trạng thái cuối cùng và an toàn:</p>
<p>...</p>
<p>Một khía cạnh quan trọng của quá trình này là <strong>bảo đảm tính nguyên tử (atomicity)</strong> do đĩa cung cấp. Thực tế, đĩa đảm bảo rằng bất kỳ thao tác ghi 512 byte nào cũng sẽ hoặc được thực hiện hoàn toàn, hoặc không thực hiện gì cả (và không bao giờ ghi một phần). Do đó, để đảm bảo việc ghi TxE là nguyên tử, ta nên thiết kế nó thành một block 512 byte duy nhất.</p>
<p>Vì vậy, giao thức hiện tại để cập nhật file system, với ba giai đoạn được đánh nhãn như sau:</p>
<ol>
<li><strong>Journal write:</strong> Ghi nội dung của transaction (bao gồm TxB, metadata và data) vào log; chờ cho các thao tác ghi này hoàn tất.</li>
<li><strong>Journal commit:</strong> Ghi block commit của transaction (chứa TxE) vào log; chờ ghi hoàn tất; transaction được coi là đã commit.</li>
<li><strong>Checkpoint:</strong> Ghi nội dung của bản cập nhật (metadata và data) vào các vị trí cuối cùng trên đĩa.</li>
</ol>
<h3 id="recovery-khôi-phục"><a class="header" href="#recovery-khôi-phục">Recovery (Khôi phục)</a></h3>
<p>Bây giờ, hãy tìm hiểu cách một file system có thể sử dụng nội dung của journal để khôi phục sau khi crash (sập hệ thống). Crash có thể xảy ra ở bất kỳ thời điểm nào trong chuỗi cập nhật này.</p>
<p>Nếu crash xảy ra <strong>trước</strong> khi transaction được ghi an toàn vào log (tức là trước khi Bước 2 ở trên hoàn tất), thì công việc của chúng ta rất đơn giản: chỉ cần bỏ qua bản cập nhật đang chờ.</p>
<p>Nếu crash xảy ra <strong>sau</strong> khi transaction đã được commit vào log, nhưng <strong>trước</strong> khi checkpoint hoàn tất, file system có thể khôi phục bản cập nhật như sau: khi hệ thống khởi động, quá trình khôi phục của file system sẽ quét log và tìm các transaction đã commit xuống đĩa; các transaction này sẽ được <strong>replay</strong> (phát lại) theo thứ tự, với việc file system cố gắng ghi lại các block trong transaction vào vị trí cuối cùng trên đĩa.</p>
<p>Hình thức logging này là một trong những dạng đơn giản nhất, được gọi là <strong>redo logging</strong>. Bằng cách khôi phục các transaction đã commit trong journal, file system đảm bảo rằng các cấu trúc trên đĩa nhất quán, và do đó có thể tiếp tục mount (gắn) file system và sẵn sàng xử lý các yêu cầu mới.</p>
<p>Lưu ý rằng crash có thể xảy ra ở bất kỳ thời điểm nào trong quá trình checkpointing, ngay cả sau khi một số bản cập nhật tới vị trí cuối cùng của các block đã hoàn tất. Trong trường hợp xấu nhất, một số bản cập nhật này sẽ chỉ đơn giản được thực hiện lại trong quá trình khôi phục. Vì recovery là một hoạt động hiếm (chỉ diễn ra sau khi hệ thống bị crash bất ngờ), nên một vài thao tác ghi dư thừa không phải là vấn đề đáng lo ngại<sup class="footnote-reference"><a href="#3">2</a></sup>.</p>
<h3 id="batching-log-updates-gộp-các-cập-nhật-log"><a class="header" href="#batching-log-updates-gộp-các-cập-nhật-log">Batching Log Updates (Gộp các cập nhật log)</a></h3>
<p>Bạn có thể nhận thấy rằng giao thức cơ bản này có thể tạo ra rất nhiều lưu lượng ghi đĩa bổ sung. Ví dụ, hãy tưởng tượng chúng ta tạo hai file liên tiếp, gọi là <code>file1</code> và <code>file2</code>, trong cùng một thư mục.</p>
<p>Để tạo một file, cần cập nhật một số cấu trúc trên đĩa, tối thiểu bao gồm: <strong>inode bitmap</strong> (để cấp phát một inode mới), inode mới tạo của file, data block của thư mục cha chứa entry thư mục mới, và inode của thư mục cha (lúc này có thời gian sửa đổi mới).</p>
<p>Với journaling, về mặt logic, chúng ta commit tất cả thông tin này vào journal cho mỗi lần tạo file. Vì các file nằm trong cùng một thư mục, và giả sử chúng thậm chí có inode nằm trong cùng một inode block, điều này có nghĩa là nếu không cẩn thận, chúng ta sẽ ghi đi ghi lại cùng một block nhiều lần.</p>
<p>Để khắc phục vấn đề này, một số file system không commit từng bản cập nhật xuống đĩa một cách riêng lẻ (ví dụ: Linux ext3); thay vào đó, có thể <strong>buffer</strong> (đệm) tất cả các bản cập nhật vào một <strong>global transaction</strong> (giao dịch toàn cục).</p>
<p>Trong ví dụ trên, khi hai file được tạo, file system chỉ đánh dấu inode bitmap trong bộ nhớ, inode của các file, dữ liệu thư mục và inode của thư mục là <strong>dirty</strong> (bẩn – cần ghi lại), và thêm chúng vào danh sách các block tạo thành transaction hiện tại. Khi đến thời điểm ghi các block này xuống đĩa (ví dụ: sau một timeout 5 giây), transaction toàn cục này sẽ được commit, chứa tất cả các bản cập nhật đã mô tả ở trên.</p>
<p>Nhờ việc buffer các bản cập nhật, file system có thể tránh được tình trạng lưu lượng ghi đĩa quá mức trong nhiều trường hợp.</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">2</sup>
<p>Trong thực tế, việc ghi lặp lại một số block trong quá trình khôi phục không gây ảnh hưởng nghiêm trọng, vì đây là thao tác hiếm khi xảy ra và chỉ diễn ra sau sự cố hệ thống.</p>
</div>
<h3 id="giới-hạn-kích-thước-của-log-making-the-log-finite"><a class="header" href="#giới-hạn-kích-thước-của-log-making-the-log-finite">Giới hạn kích thước của Log (Making The Log Finite)</a></h3>
<p>Như vậy, chúng ta đã xây dựng được một giao thức cơ bản để cập nhật các cấu trúc của file system (hệ thống tệp) trên đĩa. File system sẽ <strong>buffer</strong> (đệm) các bản cập nhật trong bộ nhớ một thời gian; khi đến lúc cần ghi xuống đĩa, file system trước tiên sẽ cẩn thận ghi chi tiết của transaction (giao dịch) vào <strong>journal</strong> (hay còn gọi là <strong>write-ahead log</strong> – nhật ký ghi trước); sau khi transaction hoàn tất, file system sẽ <strong>checkpoint</strong> các block đó tới vị trí cuối cùng của chúng trên đĩa.</p>
<p>Tuy nhiên, log có kích thước hữu hạn. Nếu chúng ta tiếp tục thêm transaction vào đó (như trong hình minh họa), nó sẽ sớm đầy. Bạn nghĩ chuyện gì sẽ xảy ra khi đó?</p>
<p>...</p>
<p>Khi log đầy, sẽ phát sinh hai vấn đề. Vấn đề đầu tiên đơn giản hơn nhưng ít nghiêm trọng hơn: log càng lớn thì thời gian <strong>recovery</strong> (khôi phục) càng lâu, vì quá trình khôi phục phải <strong>replay</strong> (phát lại) tất cả các transaction trong log (theo thứ tự) để phục hồi. Vấn đề thứ hai nghiêm trọng hơn: khi log đầy (hoặc gần đầy), không thể commit thêm transaction mới xuống đĩa, khiến file system trở nên “kém hữu dụng” (thực chất là vô dụng).</p>
<p>Để giải quyết các vấn đề này, các file system dùng journaling sẽ coi log như một cấu trúc dữ liệu vòng tròn (<strong>circular data structure</strong>), tái sử dụng nó nhiều lần; đây là lý do journal đôi khi được gọi là <strong>circular log</strong> (nhật ký vòng tròn). Để làm được điều này, file system phải thực hiện một số hành động sau một thời gian kể từ khi checkpoint. Cụ thể, khi một transaction đã được checkpoint, file system nên giải phóng không gian mà nó chiếm trong journal, cho phép log được tái sử dụng. Có nhiều cách để đạt được điều này; ví dụ, bạn có thể đơn giản đánh dấu transaction cũ nhất và mới nhất chưa được checkpoint trong log, thông tin này được lưu trong <strong>journal superblock</strong>; tất cả không gian còn lại được coi là trống. Dưới đây là minh họa:</p>
<p>...</p>
<p>Trong <strong>journal superblock</strong> (không nên nhầm với <strong>main file system superblock</strong>), hệ thống journaling ghi lại đủ thông tin để biết transaction nào chưa được checkpoint, từ đó vừa rút ngắn thời gian recovery, vừa cho phép tái sử dụng log theo cách vòng tròn. Và như vậy, chúng ta bổ sung thêm một bước nữa vào giao thức cơ bản:</p>
<ol>
<li><strong>Journal write:</strong> Ghi nội dung của transaction (bao gồm TxB và nội dung bản cập nhật) vào log; chờ cho các thao tác ghi này hoàn tất.</li>
<li><strong>Journal commit:</strong> Ghi block commit của transaction (chứa TxE) vào log; chờ ghi hoàn tất; transaction được coi là đã commit.</li>
<li><strong>Checkpoint:</strong> Ghi nội dung của bản cập nhật vào vị trí cuối cùng trong file system.</li>
<li><strong>Free:</strong> Sau một thời gian, đánh dấu transaction là đã giải phóng trong journal bằng cách cập nhật journal superblock.</li>
</ol>
<p>Như vậy, chúng ta đã có giao thức <strong>data journaling</strong> cuối cùng. Nhưng vẫn còn một vấn đề: chúng ta đang ghi mỗi data block xuống đĩa <strong>hai lần</strong>, đây là một chi phí lớn, đặc biệt đối với một sự kiện hiếm như system crash (sập hệ thống). Bạn có thể nghĩ ra cách nào để vẫn đảm bảo tính nhất quán mà không cần ghi dữ liệu hai lần không?</p>
<h3 id="metadata-journaling-ghi-nhật-ký-siêu-dữ-liệu"><a class="header" href="#metadata-journaling-ghi-nhật-ký-siêu-dữ-liệu">Metadata Journaling (Ghi nhật ký siêu dữ liệu)</a></h3>
<p>Mặc dù quá trình recovery giờ đây nhanh (chỉ cần quét journal và phát lại một vài transaction thay vì quét toàn bộ đĩa), nhưng hoạt động bình thường của file system lại chậm hơn so với mong muốn. Cụ thể, với mỗi thao tác ghi xuống đĩa, chúng ta giờ đây cũng phải ghi vào journal trước, do đó <strong>gấp đôi</strong> lưu lượng ghi; sự tăng gấp đôi này đặc biệt gây ảnh hưởng trong các workload ghi tuần tự (sequential write), vốn giờ đây sẽ chỉ đạt một nửa băng thông ghi tối đa của ổ đĩa. Hơn nữa, giữa thao tác ghi vào journal và ghi vào file system chính, sẽ có một thao tác <strong>seek</strong> (di chuyển đầu đọc/ghi) tốn kém, làm tăng đáng kể overhead đối với một số workload.</p>
<p>Do chi phí cao của việc ghi mỗi data block xuống đĩa hai lần, người ta đã thử một số cách khác nhau để tăng tốc hiệu năng. Ví dụ, chế độ journaling mà chúng ta vừa mô tả ở trên thường được gọi là <strong>data journaling</strong> (như trong Linux ext3), vì nó ghi nhật ký toàn bộ dữ liệu người dùng (ngoài metadata của file system).</p>
<p>Một dạng journaling đơn giản hơn (và phổ biến hơn) đôi khi được gọi là <strong>ordered journaling</strong> (hoặc chỉ là <strong>metadata journaling</strong>), và nó gần giống như trên, ngoại trừ việc dữ liệu người dùng <strong>không</strong> được ghi vào journal. Do đó, khi thực hiện cùng một bản cập nhật như trên, thông tin sau sẽ được ghi vào journal:</p>
<p>...</p>
<p>Block dữ liệu <strong>Db</strong>, vốn trước đây được ghi vào log, giờ sẽ được ghi trực tiếp vào file system chính, tránh được thao tác ghi bổ sung; xét rằng phần lớn lưu lượng I/O tới đĩa là dữ liệu, việc không ghi dữ liệu hai lần sẽ giảm đáng kể tải I/O của journaling. Tuy nhiên, sự thay đổi này đặt ra một câu hỏi thú vị: <strong>khi nào</strong> chúng ta nên ghi các data block xuống đĩa?</p>
<p>Hãy cùng xem lại ví dụ append (nối thêm) vào một file để hiểu rõ hơn vấn đề. Bản cập nhật bao gồm ba block: <strong>I[v2]</strong>, <strong>B[v2]</strong>, và <strong>Db</strong>. Hai block đầu đều là metadata và sẽ được ghi vào log rồi checkpoint; block cuối cùng chỉ được ghi một lần vào file system. Vậy chúng ta nên ghi <strong>Db</strong> xuống đĩa khi nào? Điều này có quan trọng không?</p>
<p>Thực tế, thứ tự ghi dữ liệu <strong>có</strong> quan trọng đối với metadata-only journaling (ghi nhật ký chỉ siêu dữ liệu). Ví dụ, điều gì sẽ xảy ra nếu chúng ta ghi <strong>Db</strong> xuống đĩa <strong>sau</strong> khi transaction (chứa I[v2] và B[v2]) hoàn tất? Cách tiếp cận này gặp một vấn đề: file system vẫn nhất quán, nhưng I[v2] có thể trỏ tới dữ liệu rác. Cụ thể, hãy xét trường hợp I[v2] và B[v2] đã được ghi, nhưng Db chưa kịp ghi xuống đĩa. Khi đó, file system sẽ cố gắng khôi phục. Vì Db không có trong log, file system sẽ phát lại (replay) các thao tác ghi I[v2] và B[v2], và tạo ra một file system nhất quán (xét từ góc độ metadata). Tuy nhiên, I[v2] sẽ trỏ tới dữ liệu rác, tức là bất cứ thứ gì đang nằm ở vị trí mà Db đáng lẽ sẽ được ghi.</p>
<p>Để đảm bảo tình huống này không xảy ra, một số file system (ví dụ: Linux ext3) ghi các data block (của regular file) xuống đĩa <strong>trước</strong>, rồi mới ghi metadata liên quan. Cụ thể, giao thức như sau:</p>
<ol>
<li><strong>Data write:</strong> Ghi dữ liệu vào vị trí cuối cùng; chờ hoàn tất (việc chờ là tùy chọn; xem chi tiết bên dưới).</li>
<li><strong>Journal metadata write:</strong> Ghi block bắt đầu (begin block) và metadata vào log; chờ các thao tác ghi hoàn tất.</li>
<li><strong>Journal commit:</strong> Ghi block commit của transaction (chứa TxE) vào log; chờ ghi hoàn tất; transaction (bao gồm dữ liệu) được coi là đã commit.</li>
<li><strong>Checkpoint metadata:</strong> Ghi nội dung cập nhật metadata vào vị trí cuối cùng trong file system.</li>
<li><strong>Free:</strong> Sau đó, đánh dấu transaction là đã giải phóng trong journal superblock.</li>
</ol>
<p>Bằng cách buộc ghi dữ liệu trước, file system có thể đảm bảo rằng một con trỏ sẽ không bao giờ trỏ tới dữ liệu rác. Thực tế, quy tắc “ghi đối tượng được trỏ tới trước đối tượng trỏ tới nó” là cốt lõi của crash consistency (tính nhất quán khi xảy ra sự cố), và còn được khai thác nhiều hơn nữa trong các cơ chế crash consistency khác [GP94] (xem chi tiết bên dưới).</p>
<p>Trong hầu hết các hệ thống, metadata journaling (tương tự ordered journaling của ext3) phổ biến hơn full data journaling. Ví dụ, Windows NTFS và SGI’s XFS đều sử dụng một dạng metadata journaling. Linux ext3 cho phép bạn chọn giữa ba chế độ: data, ordered hoặc unordered (trong unordered mode, dữ liệu có thể được ghi bất kỳ lúc nào). Tất cả các chế độ này đều giữ metadata nhất quán; điểm khác biệt nằm ở ngữ nghĩa xử lý dữ liệu.</p>
<p>Cuối cùng, lưu ý rằng việc buộc ghi dữ liệu hoàn tất (Bước 1) trước khi ghi vào journal (Bước 2) <strong>không bắt buộc</strong> để đảm bảo tính đúng đắn, như giao thức trên đã chỉ ra. Cụ thể, hoàn toàn có thể đồng thời ghi dữ liệu, block bắt đầu của transaction, và metadata được ghi nhật ký; yêu cầu thực sự duy nhất là Bước 1 và Bước 2 phải hoàn tất <strong>trước</strong> khi thực hiện ghi block commit của journal (Bước 3).</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: FORCING WRITES TO DISK</strong><br />
Để đảm bảo thứ tự giữa hai thao tác ghi đĩa, các file system hiện đại phải thực hiện một số biện pháp bổ sung. Trước đây, việc buộc thứ tự giữa hai thao tác ghi A và B rất đơn giản: chỉ cần gửi lệnh ghi A xuống đĩa, chờ đĩa gửi ngắt (interrupt) báo cho hệ điều hành khi ghi xong, rồi mới gửi lệnh ghi B.</p>
<p>Mọi thứ trở nên phức tạp hơn do việc sử dụng ngày càng nhiều <strong>write cache</strong> (bộ đệm ghi) trong đĩa. Khi bật write buffering (đôi khi gọi là immediate reporting), đĩa sẽ thông báo cho hệ điều hành rằng thao tác ghi đã hoàn tất ngay khi dữ liệu được đưa vào bộ nhớ đệm của đĩa, chứ chưa thực sự được ghi xuống bề mặt đĩa. Nếu hệ điều hành sau đó gửi một thao tác ghi tiếp theo, không có gì đảm bảo rằng nó sẽ được ghi xuống đĩa <strong>sau</strong> các thao tác ghi trước; do đó, thứ tự giữa các thao tác ghi không được đảm bảo. Một giải pháp là tắt write buffering. Tuy nhiên, các hệ thống hiện đại thường áp dụng biện pháp bổ sung là gửi <strong>write barrier</strong> (rào chắn ghi) rõ ràng; khi một barrier hoàn tất, nó đảm bảo rằng tất cả các thao tác ghi được gửi trước barrier sẽ tới đĩa <strong>trước</strong> bất kỳ thao tác ghi nào được gửi sau barrier.</p>
<p>Tất cả cơ chế này đòi hỏi phải tin tưởng rất nhiều vào hoạt động chính xác của đĩa. Thật không may, các nghiên cứu gần đây cho thấy một số nhà sản xuất đĩa, nhằm cung cấp các sản phẩm “hiệu năng cao hơn”, đã cố tình bỏ qua yêu cầu write-barrier, khiến đĩa có vẻ chạy nhanh hơn nhưng tiềm ẩn nguy cơ hoạt động sai [C+13, R+11]. Như Kahan đã nói, “nhanh” gần như luôn thắng “chậm”, ngay cả khi “nhanh” là sai.</p>
</blockquote>
</blockquote>
<h3 id="trường-hợp-phức-tạp-tái-sử-dụng-block-tricky-case-block-reuse"><a class="header" href="#trường-hợp-phức-tạp-tái-sử-dụng-block-tricky-case-block-reuse">Trường hợp phức tạp: Tái sử dụng block (Tricky Case: Block Reuse)</a></h3>
<p>Có một số <strong>corner case</strong> (trường hợp biên) thú vị khiến cơ chế journaling trở nên phức tạp hơn, và do đó đáng để thảo luận. Nhiều trường hợp trong số này liên quan đến việc <strong>tái sử dụng block</strong>; như Stephen Tweedie (một trong những người đóng vai trò chính trong việc phát triển ext3) đã nói:</p>
<blockquote>
<p>“Phần kinh khủng nhất của toàn bộ hệ thống là gì? ... Chính là việc xóa file. Mọi thứ liên quan đến xóa đều rắc rối. Mọi thứ liên quan đến xóa... bạn sẽ gặp ác mộng về những gì xảy ra nếu các block bị xóa rồi được cấp phát lại.” [T00]</p>
</blockquote>
<p>Ví dụ cụ thể mà Tweedie đưa ra như sau: giả sử bạn đang sử dụng một dạng <strong>metadata journaling</strong> (ghi nhật ký chỉ siêu dữ liệu), và do đó các data block của file <strong>không</strong> được ghi vào journal. Giả sử bạn có một thư mục tên là <code>foo</code>. Người dùng thêm một entry vào <code>foo</code> (ví dụ bằng cách tạo một file), và do thư mục được coi là metadata, nội dung của <code>foo</code> sẽ được ghi vào log; giả sử vị trí dữ liệu thư mục <code>foo</code> là block 1000. Khi đó log sẽ chứa nội dung tương tự như sau:</p>
<p>...</p>
<p>Tại thời điểm này, người dùng xóa toàn bộ nội dung trong thư mục và cả thư mục đó, giải phóng block 1000 để tái sử dụng. Cuối cùng, người dùng tạo một file mới (ví dụ <code>bar</code>), và file này tình cờ tái sử dụng đúng block 1000 vốn thuộc về <code>foo</code>. <strong>Inode</strong> của <code>bar</code> được commit xuống đĩa, cũng như dữ liệu của nó; tuy nhiên, do đang sử dụng metadata journaling, chỉ inode của <code>bar</code> được commit vào journal; dữ liệu mới ghi trong block 1000 của file <code>bar</code> <strong>không</strong> được ghi vào journal.</p>
<p>...</p>
<p>Bây giờ giả sử xảy ra crash và tất cả thông tin này vẫn còn trong log. Trong quá trình replay (phát lại), quá trình khôi phục sẽ đơn giản phát lại mọi thứ trong log, bao gồm cả thao tác ghi dữ liệu thư mục vào block 1000; việc phát lại này sẽ <strong>ghi đè dữ liệu người dùng</strong> của file <code>bar</code> hiện tại bằng nội dung thư mục cũ! Rõ ràng đây không phải là một hành động khôi phục đúng, và chắc chắn sẽ khiến người dùng bất ngờ khi đọc file <code>bar</code>.</p>
<p>Có một số giải pháp cho vấn đề này. Ví dụ, có thể <strong>không bao giờ tái sử dụng block</strong> cho đến khi thao tác xóa các block đó đã được checkpoint ra khỏi journal. Cách mà Linux ext3 thực hiện là bổ sung một loại bản ghi mới vào journal, gọi là <strong>revoke record</strong> (bản ghi thu hồi). Trong trường hợp trên, việc xóa thư mục sẽ khiến một revoke record được ghi vào journal. Khi replay journal, hệ thống sẽ quét trước để tìm các revoke record; bất kỳ dữ liệu nào đã bị revoke sẽ không bao giờ được phát lại, nhờ đó tránh được vấn đề vừa nêu.</p>
<h3 id="tổng-kết-về-journaling-dòng-thời-gian-wrapping-up-journaling-a-timeline"><a class="header" href="#tổng-kết-về-journaling-dòng-thời-gian-wrapping-up-journaling-a-timeline">Tổng kết về Journaling: Dòng thời gian (Wrapping Up Journaling: A Timeline)</a></h3>
<p>Trước khi kết thúc phần thảo luận về journaling, chúng ta sẽ tóm tắt các giao thức đã bàn luận bằng các <strong>timeline</strong> (dòng thời gian) minh họa cho từng loại. <strong>Hình 42.1</strong> cho thấy giao thức khi ghi nhật ký cả dữ liệu và metadata, trong khi <strong>Hình 42.2</strong> cho thấy giao thức khi chỉ ghi nhật ký metadata.</p>
<p>Trong mỗi hình, thời gian tăng dần theo chiều từ trên xuống, và mỗi hàng trong hình thể hiện thời điểm logic mà một thao tác ghi có thể được phát lệnh hoặc có thể hoàn tất. Ví dụ, trong giao thức <strong>data journaling</strong> (Hình 42.1), thao tác ghi <strong>transaction begin block</strong> (TxB) và nội dung của transaction có thể được phát lệnh đồng thời, và do đó có thể hoàn tất theo bất kỳ thứ tự nào; tuy nhiên, thao tác ghi <strong>transaction end block</strong> (TxE) <strong>không</strong> được phát lệnh cho đến khi các thao tác ghi trước đó hoàn tất. Tương tự, các thao tác checkpoint ghi dữ liệu và metadata block <strong>không</strong> thể bắt đầu cho đến khi transaction end block đã được commit. Các đường gạch ngang nằm ngang thể hiện các điểm mà yêu cầu về thứ tự ghi phải được tuân thủ.</p>
<p><img src="42/img/fig42_1.PNG" alt="" /></p>
<p><strong>Hình 42.1: Data Journaling Timeline</strong></p>
<p>Một timeline tương tự được thể hiện cho giao thức <strong>metadata journaling</strong>. Lưu ý rằng thao tác ghi dữ liệu có thể được phát lệnh đồng thời với các thao tác ghi transaction begin và nội dung của journal; tuy nhiên, nó phải được phát lệnh và hoàn tất <strong>trước</strong> khi transaction end được phát lệnh.</p>
<p><img src="42/img/fig42_2.PNG" alt="" /></p>
<p><strong>Hình 42.2: Metadata Journaling Timeline</strong></p>
<p>Cuối cùng, lưu ý rằng thời điểm hoàn tất được đánh dấu cho mỗi thao tác ghi trong các timeline là <strong>tùy ý</strong>. Trong một hệ thống thực tế, thời gian hoàn tất được quyết định bởi <strong>I/O subsystem</strong> (hệ thống con I/O), vốn có thể sắp xếp lại thứ tự ghi để cải thiện hiệu năng. Các đảm bảo duy nhất về thứ tự mà chúng ta có là những yêu cầu bắt buộc để đảm bảo tính đúng đắn của giao thức (và được thể hiện qua các đường gạch ngang trong hình).</p>
<h2 id="424-giải-pháp-số-3-các-cách-tiếp-cận-khác-other-approaches"><a class="header" href="#424-giải-pháp-số-3-các-cách-tiếp-cận-khác-other-approaches">42.4 Giải pháp số 3: Các cách tiếp cận khác (Other Approaches)</a></h2>
<p>Cho đến nay, chúng ta đã mô tả hai lựa chọn để duy trì tính nhất quán của <strong>file system metadata</strong> (siêu dữ liệu của hệ thống tệp): một cách tiếp cận “lười biếng” dựa trên <code>fsck</code>, và một cách tiếp cận chủ động hơn được gọi là <strong>journaling</strong> (ghi nhật ký). Tuy nhiên, đây không phải là hai cách duy nhất.</p>
<p>Một cách tiếp cận khác, được gọi là <strong>Soft Updates</strong> [GP94], được giới thiệu bởi Ganger và Patt. Cách tiếp cận này sắp xếp cẩn thận thứ tự của tất cả các thao tác ghi xuống file system để đảm bảo rằng các cấu trúc trên đĩa <strong>không bao giờ</strong> rơi vào trạng thái không nhất quán. Ví dụ, bằng cách ghi <strong>data block</strong> (khối dữ liệu) được tham chiếu xuống đĩa <strong>trước</strong> inode (chỉ mục nút) trỏ tới nó, chúng ta có thể đảm bảo rằng inode sẽ không bao giờ trỏ tới dữ liệu rác; các quy tắc tương tự có thể được xây dựng cho tất cả các cấu trúc của file system. Tuy nhiên, việc triển khai Soft Updates là một thách thức; trong khi lớp journaling được mô tả ở trên có thể được triển khai với kiến thức tương đối ít về cấu trúc cụ thể của file system, thì Soft Updates đòi hỏi hiểu biết chi tiết về từng cấu trúc dữ liệu của file system, và do đó làm tăng đáng kể độ phức tạp của hệ thống.</p>
<p>Một cách tiếp cận khác được gọi là <strong>copy-on-write</strong> (COW), và được sử dụng trong một số file system phổ biến, bao gồm <strong>ZFS</strong> của Sun [B07]. Kỹ thuật này <strong>không bao giờ</strong> ghi đè trực tiếp lên các file hoặc thư mục hiện có; thay vào đó, nó đặt các bản cập nhật mới vào các vị trí chưa được sử dụng trên đĩa. Sau khi một số bản cập nhật được hoàn tất, file system COW sẽ “lật” (flip) cấu trúc gốc của file system để bao gồm các con trỏ tới các cấu trúc mới được cập nhật. Cách làm này giúp việc duy trì tính nhất quán của file system trở nên đơn giản. Chúng ta sẽ tìm hiểu kỹ hơn về kỹ thuật này khi thảo luận về <strong>log-structured file system</strong> (LFS) trong một chương sau; LFS là một ví dụ sớm của COW.</p>
<p>Một cách tiếp cận khác là kỹ thuật mà chúng tôi vừa phát triển tại Wisconsin. Trong kỹ thuật này, được gọi là <strong>backpointer-based consistency</strong> (BBC – tính nhất quán dựa trên con trỏ ngược), <strong>không</strong> áp đặt thứ tự giữa các thao tác ghi. Để đạt được tính nhất quán, một <strong>back pointer</strong> (con trỏ ngược) bổ sung được thêm vào mỗi block trong hệ thống; ví dụ, mỗi data block sẽ chứa tham chiếu tới inode mà nó thuộc về. Khi truy cập một file, file system có thể xác định file đó có nhất quán hay không bằng cách kiểm tra xem <strong>forward pointer</strong> (con trỏ xuôi – ví dụ: địa chỉ trong inode hoặc direct block) có trỏ tới một block mà block đó lại tham chiếu ngược về nó hay không. Nếu có, điều đó có nghĩa là mọi thứ đã được ghi an toàn xuống đĩa và file là nhất quán; nếu không, file là không nhất quán và một lỗi sẽ được trả về. Bằng cách thêm back pointer vào file system, có thể đạt được một dạng <strong>lazy crash consistency</strong> (tính nhất quán khi xảy ra sự cố theo kiểu lười biếng) mới [C+12].</p>
<p>Cuối cùng, chúng tôi cũng đã nghiên cứu các kỹ thuật nhằm giảm số lần giao thức journaling phải chờ thao tác ghi đĩa hoàn tất. Kỹ thuật này, được gọi là <strong>optimistic crash consistency</strong> [C+13], phát lệnh càng nhiều thao tác ghi xuống đĩa càng tốt bằng cách sử dụng một dạng tổng quát của <strong>transaction checksum</strong> [P+05], và bao gồm một số kỹ thuật khác để phát hiện sự không nhất quán nếu chúng xảy ra. Đối với một số workload, các kỹ thuật “lạc quan” này có thể cải thiện hiệu năng lên tới một bậc độ lớn (order of magnitude). Tuy nhiên, để hoạt động thực sự hiệu quả, cần một giao diện đĩa hơi khác so với hiện tại [C+13].</p>
<h2 id="425-tóm-tắt-summary"><a class="header" href="#425-tóm-tắt-summary">42.5 Tóm tắt (Summary)</a></h2>
<p>Chúng ta đã giới thiệu vấn đề <strong>crash consistency</strong> (tính nhất quán khi xảy ra sự cố), và thảo luận nhiều cách tiếp cận để giải quyết vấn đề này. Cách tiếp cận cũ hơn là xây dựng một <strong>file system checker</strong> (trình kiểm tra hệ thống tệp) hoạt động được, nhưng có khả năng quá chậm để khôi phục trên các hệ thống hiện đại. Do đó, nhiều file system hiện nay sử dụng <strong>journaling</strong>. Journaling giảm thời gian khôi phục từ <strong>O(kích-thước-ổ-đĩa)</strong> xuống <strong>O(kích-thước-log)</strong>, nhờ đó tăng tốc đáng kể quá trình khôi phục sau crash và khởi động lại. Vì lý do này, nhiều file system hiện đại sử dụng journaling.</p>
<p>Chúng ta cũng đã thấy rằng journaling có thể tồn tại ở nhiều dạng khác nhau; dạng phổ biến nhất là <strong>ordered metadata journaling</strong> (ghi nhật ký siêu dữ liệu có thứ tự), giúp giảm lượng lưu lượng ghi vào journal trong khi vẫn duy trì các đảm bảo hợp lý về tính nhất quán cho cả metadata của file system và dữ liệu người dùng. Cuối cùng, việc cung cấp các đảm bảo mạnh mẽ đối với dữ liệu người dùng có lẽ là một trong những điều quan trọng nhất; thật thú vị là, như các nghiên cứu gần đây đã chỉ ra, lĩnh vực này vẫn đang trong quá trình hoàn thiện [P+14].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="43-hệ-thống-tệp-cấu-trúc-nhật-ký-log-structured-file-systems"><a class="header" href="#43-hệ-thống-tệp-cấu-trúc-nhật-ký-log-structured-file-systems">43. Hệ thống tệp cấu trúc nhật ký (Log-structured File Systems)</a></h1>
<p>Vào đầu những năm 1990, một nhóm nghiên cứu tại Berkeley do Giáo sư John Ousterhout và nghiên cứu sinh Mendel Rosenblum dẫn dắt đã phát triển một hệ thống tệp mới được gọi là <strong>log-structured file system</strong> (LFS) [RO91]. Động lực để họ thực hiện điều này dựa trên các quan sát sau:</p>
<ul>
<li><strong>Bộ nhớ hệ thống ngày càng lớn:</strong> Khi dung lượng bộ nhớ tăng, nhiều dữ liệu hơn có thể được lưu trong bộ nhớ đệm (cache). Khi nhiều dữ liệu được cache hơn, lưu lượng truy cập đĩa ngày càng bao gồm nhiều thao tác ghi, vì các thao tác đọc được phục vụ trực tiếp từ cache. Do đó, hiệu năng của file system phần lớn được quyết định bởi hiệu năng ghi.</li>
<li><strong>Tồn tại khoảng cách lớn giữa hiệu năng I/O ngẫu nhiên và I/O tuần tự:</strong> Băng thông truyền dữ liệu của ổ cứng đã tăng đáng kể qua các năm [P98]; khi nhiều bit hơn được ghi trên bề mặt đĩa, băng thông khi truy cập các bit đó cũng tăng. Tuy nhiên, chi phí tìm kiếm (seek) và độ trễ quay (rotational delay) lại giảm chậm; việc chế tạo các động cơ nhỏ, giá rẻ để quay đĩa nhanh hơn hoặc di chuyển tay đọc nhanh hơn là một thách thức. Vì vậy, nếu có thể sử dụng đĩa theo cách tuần tự, bạn sẽ đạt được lợi thế hiệu năng đáng kể so với các phương pháp gây ra nhiều thao tác seek và quay.</li>
<li><strong>Các file system hiện tại hoạt động kém trên nhiều loại workload phổ biến:</strong> Ví dụ, <strong>FFS</strong> [MJLF84] sẽ thực hiện một số lượng lớn thao tác ghi chỉ để tạo một file mới có kích thước một block: một lần ghi cho inode mới, một lần để cập nhật inode bitmap, một lần cho data block của thư mục chứa file, một lần cho inode của thư mục để cập nhật nó, một lần cho data block mới của file, và một lần cho data bitmap để đánh dấu block dữ liệu đã được cấp phát. Mặc dù FFS đặt tất cả các block này trong cùng một block group, nó vẫn phải thực hiện nhiều thao tác seek ngắn và các lần trễ quay tiếp theo, khiến hiệu năng thấp hơn nhiều so với băng thông tuần tự tối đa.</li>
<li><strong>File system không nhận thức về RAID:</strong> Ví dụ, cả RAID-4 và RAID-5 đều gặp vấn đề <strong>small-write</strong> (ghi nhỏ), trong đó một thao tác ghi logic vào một block duy nhất sẽ gây ra 4 thao tác I/O vật lý. Các file system hiện tại không cố gắng tránh hành vi ghi tệ nhất này trên RAID.</li>
</ul>
<blockquote>
<blockquote>
<p><strong>TIP: CHI TIẾT LÀ QUAN TRỌNG</strong><br />
Tất cả các hệ thống thú vị đều bao gồm một vài ý tưởng tổng quát và nhiều chi tiết. Đôi khi, khi học về các hệ thống này, bạn có thể nghĩ: “Ồ, tôi hiểu ý tưởng chung rồi; phần còn lại chỉ là chi tiết,” và từ đó chỉ học một nửa cách hệ thống thực sự hoạt động. Đừng làm vậy! Nhiều khi, chính các chi tiết mới là yếu tố then chốt. Như chúng ta sẽ thấy với LFS, ý tưởng tổng thể rất dễ hiểu, nhưng để xây dựng một hệ thống hoạt động thực sự, bạn phải suy nghĩ kỹ về tất cả các trường hợp phức tạp.</p>
</blockquote>
</blockquote>
<p>Một file system lý tưởng sẽ tập trung vào hiệu năng ghi, và cố gắng tận dụng băng thông tuần tự của đĩa. Hơn nữa, nó sẽ hoạt động tốt với các workload phổ biến không chỉ ghi dữ liệu mà còn thường xuyên cập nhật các cấu trúc metadata trên đĩa. Cuối cùng, nó sẽ hoạt động tốt cả trên RAID lẫn ổ đĩa đơn.</p>
<p>Loại file system mới mà Rosenblum và Ousterhout giới thiệu được gọi là <strong>LFS</strong> (Log-structured File System). Khi ghi xuống đĩa, LFS trước tiên sẽ <strong>buffer</strong> (đệm) tất cả các bản cập nhật (bao gồm cả metadata!) trong một <strong>segment</strong> (phân đoạn) nằm trong bộ nhớ; khi segment đầy, nó sẽ được ghi xuống đĩa trong một lần truyền tuần tự dài tới một vùng chưa sử dụng của đĩa. LFS <strong>không bao giờ</strong> ghi đè dữ liệu hiện có, mà luôn ghi các segment vào các vị trí trống. Vì các segment có kích thước lớn, đĩa (hoặc RAID) được sử dụng hiệu quả, và hiệu năng của file system đạt gần mức tối đa.</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ BIẾN MỌI GHI THÀNH GHI TUẦN TỰ?</strong><br />
Làm thế nào một file system có thể biến tất cả các thao tác ghi thành ghi tuần tự? Đối với thao tác đọc, điều này là không thể, vì block cần đọc có thể nằm ở bất kỳ đâu trên đĩa. Tuy nhiên, đối với thao tác ghi, file system <strong>luôn có quyền lựa chọn</strong>, và chính lựa chọn này là điều chúng ta muốn khai thác.</p>
</blockquote>
</blockquote>
<h2 id="431-ghi-tuần-tự-xuống-đĩa-writing-to-disk-sequentially"><a class="header" href="#431-ghi-tuần-tự-xuống-đĩa-writing-to-disk-sequentially">43.1 Ghi tuần tự xuống đĩa (Writing To Disk Sequentially)</a></h2>
<p>Như vậy, chúng ta có thách thức đầu tiên: làm thế nào để biến tất cả các bản cập nhật trạng thái của file system (hệ thống tệp) thành một chuỗi các thao tác ghi tuần tự xuống đĩa? Để hiểu rõ hơn, hãy sử dụng một ví dụ đơn giản. Giả sử chúng ta đang ghi một <strong>data block</strong> (khối dữ liệu) D vào một file. Việc ghi data block này xuống đĩa có thể dẫn đến bố cục trên đĩa như sau, với D được ghi tại địa chỉ đĩa A0:</p>
<p>...</p>
<p>Tuy nhiên, khi người dùng ghi một data block, không chỉ dữ liệu được ghi xuống đĩa; còn có các <strong>metadata</strong> (siêu dữ liệu) khác cần được cập nhật. Trong trường hợp này, giả sử chúng ta cũng ghi <strong>inode</strong> (chỉ mục nút) I của file xuống đĩa, và inode này trỏ tới data block D. Khi được ghi xuống đĩa, data block và inode sẽ trông như sau (lưu ý rằng inode có vẻ lớn bằng data block, điều này thường không đúng; trong hầu hết các hệ thống, data block có kích thước 4 KB, trong khi inode nhỏ hơn nhiều, khoảng 128 byte):</p>
<p>...</p>
<p>Ý tưởng cơ bản này — đơn giản là ghi tất cả các bản cập nhật (như data block, inode, v.v.) xuống đĩa theo thứ tự tuần tự — chính là cốt lõi của LFS (Log-structured File System). Nếu bạn hiểu điều này, bạn đã nắm được ý tưởng chính. Nhưng như với mọi hệ thống phức tạp, “quỷ dữ nằm trong chi tiết” — các chi tiết mới là phần khó.</p>
<h2 id="432-ghi-tuần-tự-và-hiệu-quả-writing-sequentially-and-effectively"><a class="header" href="#432-ghi-tuần-tự-và-hiệu-quả-writing-sequentially-and-effectively">43.2 Ghi tuần tự và hiệu quả (Writing Sequentially And Effectively)</a></h2>
<p>Thật không may, chỉ ghi tuần tự xuống đĩa <strong>không</strong> đủ để đảm bảo hiệu năng ghi cao. Ví dụ, giả sử chúng ta ghi một block duy nhất vào địa chỉ A tại thời điểm T. Sau đó, chúng ta chờ một lúc, rồi ghi xuống đĩa tại địa chỉ A + 1 (địa chỉ block tiếp theo theo thứ tự tuần tự), nhưng ở thời điểm T + δ. Trong khoảng thời gian giữa lần ghi thứ nhất và thứ hai, đĩa đã quay; khi bạn phát lệnh ghi thứ hai, nó sẽ phải chờ gần như cả một vòng quay trước khi được ghi (cụ thể, nếu thời gian quay là $T_{rotation}$, thì đĩa sẽ phải chờ $T_{rotation} - δ$ trước khi có thể ghi block thứ hai xuống bề mặt đĩa).</p>
<p>Do đó, bạn có thể thấy rằng chỉ ghi xuống đĩa theo thứ tự tuần tự là chưa đủ để đạt hiệu năng tối đa; thay vào đó, bạn phải phát lệnh ghi một số lượng lớn các block liên tiếp (hoặc một thao tác ghi lớn duy nhất) để đạt hiệu năng ghi tốt.</p>
<p>Để đạt được điều này, LFS sử dụng một kỹ thuật lâu đời được gọi là <strong>write buffering</strong> (đệm ghi)^[1]. Trước khi ghi xuống đĩa, LFS lưu trữ các bản cập nhật trong bộ nhớ; khi đã nhận đủ số lượng bản cập nhật, nó sẽ ghi tất cả xuống đĩa cùng một lúc, đảm bảo sử dụng đĩa một cách hiệu quả.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Thực tế rất khó tìm một tài liệu tham khảo “chuẩn” cho ý tưởng này, vì nó có thể đã được phát minh bởi nhiều người từ rất sớm trong lịch sử ngành máy tính. Để tìm hiểu lợi ích của write buffering, xem Solworth và Orji [SO90]; để tìm hiểu các tác hại tiềm ẩn, xem Mogul [M94].</p>
</div>
<p>Phần dữ liệu lớn mà LFS ghi trong một lần được gọi là <strong>segment</strong> (phân đoạn). Mặc dù thuật ngữ này bị lạm dụng trong nhiều lĩnh vực của hệ thống máy tính, ở đây nó chỉ đơn giản là một khối dữ liệu lớn mà LFS dùng để gom nhóm các thao tác ghi. Do đó, khi ghi xuống đĩa, LFS sẽ buffer các bản cập nhật trong một segment nằm trong bộ nhớ, rồi ghi toàn bộ segment này xuống đĩa trong một lần. Miễn là segment đủ lớn, các thao tác ghi này sẽ đạt hiệu quả cao.</p>
<p>Dưới đây là một ví dụ, trong đó LFS buffer hai nhóm bản cập nhật vào một segment nhỏ; các segment thực tế thường lớn hơn (vài MB). Bản cập nhật đầu tiên gồm bốn thao tác ghi block cho file <strong>j</strong>; bản cập nhật thứ hai là thêm một block vào file <strong>k</strong>. LFS sau đó commit toàn bộ segment gồm bảy block này xuống đĩa trong một lần. Bố cục trên đĩa của các block này sau khi ghi như sau:</p>
<p>...</p>
<h2 id="433-buffer-bao-nhiêu-là-đủ-how-much-to-buffer"><a class="header" href="#433-buffer-bao-nhiêu-là-đủ-how-much-to-buffer">43.3 Buffer bao nhiêu là đủ? (How Much To Buffer?)</a></h2>
<p>Điều này dẫn đến câu hỏi: <strong>LFS</strong> (Log-structured File System) nên buffer (đệm) bao nhiêu bản cập nhật trước khi ghi xuống đĩa? Câu trả lời, tất nhiên, phụ thuộc vào chính ổ đĩa, cụ thể là mức <strong>positioning overhead</strong> (chi phí định vị – bao gồm thời gian quay và seek) so với <strong>transfer rate</strong> (tốc độ truyền dữ liệu); hãy xem lại chương về <strong>FFS</strong> để tham khảo một phân tích tương tự.</p>
<p>Ví dụ, giả sử thời gian định vị (tức là chi phí quay và seek) trước mỗi lần ghi mất khoảng ( T_{position} ) giây. Giả sử thêm rằng tốc độ truyền dữ liệu cực đại của đĩa là ( R_{peak} ) MB/s. Vậy LFS nên buffer bao nhiêu dữ liệu trước khi ghi khi chạy trên loại đĩa này?</p>
<p>Cách suy nghĩ ở đây là: mỗi lần ghi, bạn phải trả một chi phí cố định cho việc định vị. Vậy bạn cần ghi bao nhiêu dữ liệu để <strong>amortize</strong> (phân bổ) chi phí đó? Rõ ràng, càng ghi nhiều thì càng tốt, và bạn sẽ càng tiến gần đến việc đạt được băng thông cực đại.</p>
<p>Để có câu trả lời cụ thể, giả sử chúng ta ghi ra ( D ) MB dữ liệu. Thời gian để ghi khối dữ liệu này (( T_{write} )) sẽ bằng thời gian định vị ( T_{position} ) cộng với thời gian truyền ( D ) MB dữ liệu (( \frac{D}{R_{peak}} )), tức là:</p>
<p>[
T_{write} = T_{position} + \frac{D}{R_{peak}}
]</p>
<p>Do đó, <strong>tốc độ ghi hiệu dụng</strong> (( R_{effective} )) — chính là lượng dữ liệu ghi được chia cho tổng thời gian ghi — sẽ là:</p>
<p>[
R_{effective} = \frac{D}{T_{position} + \frac{D}{R_{peak}}}
]</p>
<p>Điều chúng ta quan tâm là làm cho ( R_{effective} ) tiến gần tới ( R_{peak} ). Cụ thể, chúng ta muốn tốc độ hiệu dụng bằng một phần ( F ) của tốc độ cực đại, với ( 0 &lt; F &lt; 1 ) (một giá trị F điển hình có thể là 0.9, tức 90% tốc độ cực đại). Về mặt toán học, điều này có nghĩa là:</p>
<p>[
R_{effective} = F \times R_{peak}
]</p>
<p>Tại đây, chúng ta có thể giải ra ( D ):</p>
<p>[
D = \frac{F}{1 - F} \times R_{peak} \times T_{position}
]</p>
<p>Hãy làm một ví dụ: với một ổ đĩa có thời gian định vị là 10 mili-giây và tốc độ truyền cực đại là 100 MB/s; giả sử chúng ta muốn băng thông hiệu dụng đạt 90% tốc độ cực đại (F = 0.9). Khi đó:</p>
<p>[
D = \frac{0.9}{0.1} \times 100 \ \text{MB/s} \times 0.01 \ \text{giây} = 9 \ \text{MB}
]</p>
<p>Hãy thử một vài giá trị khác để xem cần buffer bao nhiêu để tiến gần tới băng thông cực đại. Cần bao nhiêu để đạt 95% tốc độ cực đại? 99%?</p>
<h2 id="434-vấn-đề-tìm-inode-problem-finding-inodes"><a class="header" href="#434-vấn-đề-tìm-inode-problem-finding-inodes">43.4 Vấn đề: Tìm inode (Problem: Finding Inodes)</a></h2>
<p>Để hiểu cách tìm một <strong>inode</strong> trong LFS, trước hết hãy xem lại cách tìm inode trong một file system UNIX điển hình. Trong một file system thông thường như <strong>FFS</strong>, hoặc thậm chí là hệ thống tệp UNIX cũ, việc tìm inode rất dễ, vì chúng được tổ chức thành một mảng và đặt trên đĩa ở các vị trí cố định.</p>
<p>Ví dụ, hệ thống tệp UNIX cũ lưu tất cả inode ở một vùng cố định trên đĩa. Do đó, khi biết số inode (inode number) và địa chỉ bắt đầu, để tìm một inode cụ thể, bạn chỉ cần tính địa chỉ đĩa chính xác của nó bằng cách nhân số inode với kích thước của một inode, rồi cộng với địa chỉ bắt đầu của mảng inode trên đĩa; việc <strong>array-based indexing</strong> (đánh chỉ số dựa trên mảng) này, khi biết số inode, là nhanh và đơn giản.</p>
<p>Việc tìm inode khi biết số inode trong FFS chỉ phức tạp hơn một chút, vì FFS chia bảng inode thành các khối (chunk) và đặt một nhóm inode trong mỗi <strong>cylinder group</strong>. Do đó, bạn cần biết kích thước của mỗi khối inode và địa chỉ bắt đầu của từng khối. Sau đó, các phép tính tương tự và cũng dễ dàng.</p>
<p>Trong LFS, mọi thứ khó khăn hơn nhiều. Tại sao? Bởi vì chúng ta đã “rải” các inode khắp đĩa! Tệ hơn nữa, chúng ta <strong>không bao giờ ghi đè tại chỗ</strong> (overwrite in place), và do đó phiên bản mới nhất của một inode (tức là phiên bản mà chúng ta cần) liên tục thay đổi vị trí.</p>
<h2 id="435-giải-pháp-thông-qua-gián-tiếp-inode-map-bản-đồ-inode"><a class="header" href="#435-giải-pháp-thông-qua-gián-tiếp-inode-map-bản-đồ-inode">43.5 Giải pháp thông qua gián tiếp: Inode Map (Bản đồ inode)</a></h2>
<p>Để khắc phục vấn đề này, các nhà thiết kế của <strong>LFS</strong> (Log-structured File System) đã giới thiệu một lớp <strong>indirection</strong> (gián tiếp) giữa <strong>inode number</strong> (số inode) và chính inode, thông qua một cấu trúc dữ liệu gọi là <strong>inode map</strong> (imap – bản đồ inode). <strong>Imap</strong> là một cấu trúc nhận vào số inode và trả về <strong>địa chỉ đĩa</strong> (disk address) của phiên bản inode mới nhất.</p>
<blockquote>
<blockquote>
<p><strong>TIP: SỬ DỤNG MỘT LỚP GIÁN TIẾP</strong><br />
Người ta thường nói rằng giải pháp cho mọi vấn đề trong Khoa học Máy tính chỉ đơn giản là thêm một lớp gián tiếp. Điều này rõ ràng không hoàn toàn đúng; nó chỉ là giải pháp cho <strong>hầu hết</strong> các vấn đề (vâng, nhận xét này vẫn hơi quá, nhưng bạn hiểu ý rồi đấy). Bạn hoàn toàn có thể coi mọi cơ chế ảo hóa (virtualization) mà chúng ta đã học, ví dụ như <strong>virtual memory</strong> (bộ nhớ ảo) hay khái niệm file, như là một lớp gián tiếp. Và chắc chắn <strong>inode map</strong> trong LFS là một dạng ảo hóa của inode number. Hy vọng bạn có thể thấy sức mạnh to lớn của gián tiếp trong các ví dụ này, cho phép chúng ta tự do di chuyển các cấu trúc (như page trong ví dụ VM, hoặc inode trong LFS) mà không cần thay đổi mọi tham chiếu tới chúng. Tất nhiên, gián tiếp cũng có mặt trái: chi phí bổ sung (overhead). Vì vậy, lần tới khi bạn gặp một vấn đề, hãy thử giải quyết nó bằng gián tiếp, nhưng nhớ cân nhắc kỹ chi phí của việc này. Như Wheeler đã nổi tiếng nói: “Mọi vấn đề trong khoa học máy tính đều có thể được giải quyết bằng một lớp gián tiếp khác, ngoại trừ vấn đề có quá nhiều lớp gián tiếp.”</p>
</blockquote>
</blockquote>
<p>Vì vậy, bạn có thể hình dung imap thường được triển khai như một mảng đơn giản, với 4 byte (một con trỏ đĩa) cho mỗi phần tử. Mỗi khi một inode được ghi xuống đĩa, imap sẽ được cập nhật với vị trí mới của nó.</p>
<p>Tuy nhiên, imap cần được lưu trữ <strong>persistent</strong> (bền vững – tức là ghi xuống đĩa); làm như vậy cho phép LFS theo dõi vị trí của các inode ngay cả khi hệ thống bị crash, và do đó hoạt động như mong muốn. Vậy câu hỏi đặt ra: <strong>imap nên được đặt ở đâu trên đĩa?</strong></p>
<p>Tất nhiên, nó có thể nằm ở một vị trí cố định trên đĩa. Nhưng thật không may, vì nó được cập nhật thường xuyên, điều này sẽ yêu cầu mỗi lần cập nhật cấu trúc file phải kèm theo một lần ghi imap, và do đó hiệu năng sẽ giảm (tức là sẽ có nhiều thao tác <strong>disk seek</strong> hơn, giữa mỗi lần cập nhật và vị trí cố định của imap).</p>
<p>Thay vào đó, LFS đặt các <strong>chunk</strong> (mảnh) của inode map ngay bên cạnh nơi nó đang ghi tất cả thông tin mới khác. Do đó, khi append (nối thêm) một data block vào file <em>k</em>, LFS thực tế sẽ ghi <strong>data block mới</strong>, <strong>inode</strong> của nó, và <strong>một phần của inode map</strong> cùng nhau xuống đĩa, như sau:</p>
<p>...</p>
<p>Trong hình minh họa này, phần của mảng imap được lưu trong block được đánh dấu “imap” cho LFS biết rằng inode <em>k</em> nằm ở địa chỉ đĩa A1; inode này, đến lượt nó, cho LFS biết rằng data block D của nó nằm ở địa chỉ A0.</p>
<h2 id="436-hoàn-thiện-giải-pháp-checkpoint-region-vùng-điểm-kiểm"><a class="header" href="#436-hoàn-thiện-giải-pháp-checkpoint-region-vùng-điểm-kiểm">43.6 Hoàn thiện giải pháp: Checkpoint Region (Vùng điểm kiểm)</a></h2>
<p>Người đọc tinh ý (chính là bạn, đúng không?) có thể nhận ra một vấn đề ở đây: <strong>Làm thế nào để tìm inode map, khi các phần của nó cũng đã được rải khắp đĩa?</strong> Cuối cùng thì không có phép màu nào cả: file system phải có một vị trí cố định và đã biết trên đĩa để bắt đầu quá trình tìm kiếm file.</p>
<p>LFS có một vị trí cố định như vậy trên đĩa, được gọi là <strong>checkpoint region</strong> (CR – vùng điểm kiểm). Checkpoint region chứa các con trỏ (tức là địa chỉ) tới các phần mới nhất của inode map, và do đó có thể tìm thấy các phần của inode map bằng cách đọc CR trước. Lưu ý rằng checkpoint region chỉ được cập nhật định kỳ (ví dụ khoảng mỗi 30 giây), và do đó hiệu năng không bị ảnh hưởng đáng kể.</p>
<p>Như vậy, cấu trúc tổng thể của bố cục trên đĩa sẽ bao gồm:</p>
<ul>
<li><strong>Checkpoint region</strong> (trỏ tới các phần mới nhất của inode map)</li>
<li>Các phần của inode map (mỗi phần chứa địa chỉ của các inode)</li>
<li>Các inode (trỏ tới file và thư mục) giống như trong các file system UNIX điển hình.</li>
</ul>
<p>Dưới đây là một ví dụ về checkpoint region (lưu ý nó nằm ngay ở đầu đĩa, tại địa chỉ 0), cùng với một <strong>imap chunk</strong>, một inode, và một data block. Một file system thực tế tất nhiên sẽ có CR lớn hơn nhiều (thực tế là có <strong>hai</strong> CR, như chúng ta sẽ tìm hiểu sau), nhiều imap chunk, và tất nhiên là nhiều inode, data block, v.v.</p>
<p>...</p>
<h2 id="437-Đọc-một-file-từ-đĩa-tóm-tắt-reading-a-file-from-disk-a-recap"><a class="header" href="#437-Đọc-một-file-từ-đĩa-tóm-tắt-reading-a-file-from-disk-a-recap">43.7 Đọc một file từ đĩa: Tóm tắt (Reading A File From Disk: A Recap)</a></h2>
<p>Để đảm bảo bạn hiểu cách <strong>LFS</strong> (Log-structured File System) hoạt động, chúng ta hãy cùng đi qua các bước cần thực hiện để đọc một file từ đĩa. Giả sử ban đầu chúng ta <strong>không có gì trong bộ nhớ</strong>. Cấu trúc dữ liệu đầu tiên trên đĩa mà chúng ta phải đọc là <strong>checkpoint region</strong> (vùng điểm kiểm). Checkpoint region chứa các con trỏ (tức là địa chỉ đĩa) tới toàn bộ <strong>inode map</strong> (imap – bản đồ inode), và do đó LFS sẽ đọc toàn bộ inode map này vào bộ nhớ và lưu trong cache.</p>
<p>Từ thời điểm này, khi được cung cấp <strong>inode number</strong> (số inode) của một file, LFS chỉ cần tra cứu ánh xạ từ inode number sang <strong>inode disk address</strong> (địa chỉ inode trên đĩa) trong imap, và đọc phiên bản inode mới nhất. Để đọc một block từ file, LFS sẽ tiến hành giống hệt như một file system UNIX điển hình, bằng cách sử dụng <strong>direct pointer</strong> (con trỏ trực tiếp), <strong>indirect pointer</strong> (con trỏ gián tiếp) hoặc <strong>doubly-indirect pointer</strong> (con trỏ gián tiếp kép) khi cần.</p>
<p>Trong trường hợp thông thường, LFS sẽ thực hiện <strong>số lượng thao tác I/O</strong> tương đương với một file system điển hình khi đọc file từ đĩa; toàn bộ imap đã được cache, và công việc bổ sung duy nhất mà LFS thực hiện trong quá trình đọc là tra cứu địa chỉ inode trong imap.</p>
<h2 id="438-còn-thư-mục-thì-sao-what-about-directories"><a class="header" href="#438-còn-thư-mục-thì-sao-what-about-directories">43.8 Còn thư mục thì sao? (What About Directories?)</a></h2>
<p>Cho đến giờ, chúng ta đã đơn giản hóa phần thảo luận bằng cách chỉ xét đến inode và data block. Tuy nhiên, để truy cập một file trong file system (ví dụ <code>/home/remzi/foo</code> – một trong những tên file giả ưa thích của chúng tôi), một số <strong>directory</strong> (thư mục) cũng phải được truy cập. Vậy LFS lưu trữ dữ liệu thư mục như thế nào?</p>
<p>May mắn thay, cấu trúc thư mục về cơ bản <strong>giống hệt</strong> như trong các file system UNIX cổ điển, ở chỗ một thư mục chỉ là một tập hợp các ánh xạ <strong>(tên, inode number)</strong>. Ví dụ, khi tạo một file trên đĩa, LFS phải ghi một inode mới, một số dữ liệu, cũng như dữ liệu thư mục và inode của thư mục tham chiếu đến file này. Hãy nhớ rằng LFS sẽ thực hiện việc này <strong>tuần tự</strong> trên đĩa (sau khi buffer các bản cập nhật trong một thời gian).</p>
<p>Do đó, việc tạo một file <code>foo</code> trong một thư mục sẽ dẫn đến các cấu trúc mới trên đĩa như sau:</p>
<p>...</p>
<p>Phần của inode map sẽ chứa thông tin về vị trí của cả file thư mục <code>dir</code> và file mới tạo <code>f</code>. Do đó, khi truy cập file <code>foo</code> (có inode number <code>k</code>), bạn sẽ:</p>
<ol>
<li>Tra cứu trong inode map (thường được cache trong bộ nhớ) để tìm vị trí của inode của thư mục <code>dir</code> (A3).</li>
<li>Đọc inode của thư mục, từ đó lấy vị trí của dữ liệu thư mục (A2).</li>
<li>Đọc data block này để nhận được ánh xạ <strong>(tên, inode number)</strong> của (<code>foo</code>, <code>k</code>).</li>
<li>Tra cứu lại inode map để tìm vị trí của inode number <code>k</code> (A1).</li>
<li>Cuối cùng, đọc data block mong muốn tại địa chỉ A0.</li>
</ol>
<p>Có một vấn đề nghiêm trọng khác trong LFS mà inode map giải quyết, được gọi là <strong>recursive update problem</strong> (vấn đề cập nhật đệ quy) [Z+12]. Vấn đề này xuất hiện trong bất kỳ file system nào <strong>không bao giờ cập nhật tại chỗ</strong> (never updates in place) như LFS, mà thay vào đó di chuyển các bản cập nhật tới vị trí mới trên đĩa.</p>
<p>Cụ thể, bất cứ khi nào một inode được cập nhật, vị trí của nó trên đĩa sẽ thay đổi. Nếu không cẩn thận, điều này sẽ kéo theo việc phải cập nhật cả thư mục trỏ tới file đó, rồi lại phải thay đổi thư mục cha của thư mục đó, và cứ thế lan lên toàn bộ cây thư mục của file system.</p>
<p>LFS đã khéo léo tránh được vấn đề này nhờ inode map. Mặc dù vị trí của một inode có thể thay đổi, nhưng sự thay đổi này <strong>không bao giờ</strong> được phản ánh vào chính thư mục; thay vào đó, cấu trúc imap được cập nhật, trong khi thư mục vẫn giữ nguyên ánh xạ <strong>(tên, inode number)</strong>. Nhờ cơ chế gián tiếp này, LFS tránh được vấn đề cập nhật đệ quy.</p>
<h2 id="439-một-vấn-đề-mới-thu-gom-rác-garbage-collection"><a class="header" href="#439-một-vấn-đề-mới-thu-gom-rác-garbage-collection">43.9 Một vấn đề mới: Thu gom rác (Garbage Collection)</a></h2>
<p>Bạn có thể đã nhận thấy một vấn đề khác với <strong>LFS</strong> (Log-structured File System): nó liên tục ghi phiên bản mới nhất của một file (bao gồm cả inode và dữ liệu) vào các vị trí mới trên đĩa. Quá trình này, mặc dù giúp duy trì hiệu quả ghi, lại dẫn đến việc LFS để lại các phiên bản cũ của cấu trúc file rải rác khắp đĩa. Chúng ta (một cách không mấy trang trọng) gọi các phiên bản cũ này là <strong>garbage</strong> (rác).</p>
<p>Ví dụ, hãy tưởng tượng trường hợp chúng ta có một file hiện có được tham chiếu bởi <strong>inode number</strong> (số inode) <em>k</em>, trỏ tới một <strong>data block</strong> (khối dữ liệu) duy nhất D0. Giờ chúng ta cập nhật block đó, tạo ra cả một inode mới và một data block mới. Bố cục trên đĩa của LFS sau đó sẽ trông như sau (lưu ý chúng ta bỏ qua imap và các cấu trúc khác để đơn giản hóa; một <strong>chunk</strong> mới của imap cũng sẽ phải được ghi xuống đĩa để trỏ tới inode mới):</p>
<p>...</p>
<p>Trong sơ đồ, bạn có thể thấy cả inode và data block đều có hai phiên bản trên đĩa: một phiên bản cũ (bên trái) và một phiên bản hiện tại, tức là <strong>live</strong> (đang được sử dụng – bên phải). Chỉ với hành động (logic) cập nhật một data block, một số cấu trúc mới phải được LFS ghi bền vững xuống đĩa, để lại các phiên bản cũ của các block đó trên đĩa.</p>
<p>Một ví dụ khác: giả sử thay vì cập nhật, chúng ta <strong>append</strong> (nối thêm) một block vào file gốc <em>k</em>. Trong trường hợp này, một phiên bản inode mới được tạo ra, nhưng data block cũ vẫn được inode trỏ tới. Do đó, nó vẫn <strong>live</strong> và hoàn toàn là một phần của file system hiện tại:</p>
<p>...</p>
<p>Vậy chúng ta nên làm gì với các phiên bản cũ của inode, data block, và các cấu trúc khác? Một lựa chọn là giữ lại các phiên bản cũ này và cho phép người dùng khôi phục các phiên bản file trước đó (ví dụ, khi họ vô tình ghi đè hoặc xóa file, điều này có thể rất hữu ích); một file system như vậy được gọi là <strong>versioning file system</strong> vì nó lưu lại các phiên bản khác nhau của một file.</p>
<p>Tuy nhiên, LFS chỉ giữ lại phiên bản <strong>live</strong> mới nhất của một file; do đó (ở chế độ nền), LFS phải định kỳ tìm các phiên bản cũ không còn sử dụng của dữ liệu file, inode, và các cấu trúc khác, rồi <strong>clean</strong> (dọn dẹp) chúng; việc dọn dẹp này sẽ giải phóng các block trên đĩa để sử dụng cho các lần ghi tiếp theo. Lưu ý rằng quá trình cleaning là một dạng <strong>garbage collection</strong> (thu gom rác), một kỹ thuật xuất hiện trong các ngôn ngữ lập trình có khả năng tự động giải phóng bộ nhớ không còn được sử dụng.</p>
<p>Trước đây, chúng ta đã thảo luận về <strong>segment</strong> (phân đoạn) như một cơ chế quan trọng giúp LFS thực hiện các thao tác ghi lớn xuống đĩa. Hóa ra, segment cũng đóng vai trò then chốt trong việc cleaning hiệu quả. Hãy tưởng tượng điều gì sẽ xảy ra nếu <strong>LFS cleaner</strong> chỉ đơn giản đi qua và giải phóng từng data block, inode, v.v., riêng lẻ trong quá trình cleaning. Kết quả: một file system với một số lượng lỗ trống (free hole) xen kẽ giữa các vùng đã cấp phát trên đĩa. Hiệu năng ghi sẽ giảm đáng kể, vì LFS sẽ không thể tìm được một vùng liên tục đủ lớn để ghi tuần tự xuống đĩa với hiệu năng cao.</p>
<p>Thay vào đó, LFS cleaner hoạt động theo <strong>từng segment</strong>, nhờ đó giải phóng các vùng lớn cho các lần ghi tiếp theo. Quá trình cleaning cơ bản diễn ra như sau: định kỳ, LFS cleaner đọc một số segment cũ (đang được sử dụng một phần), xác định block nào <strong>live</strong> trong các segment này, sau đó ghi ra một tập hợp segment mới chỉ chứa các block live, giải phóng các segment cũ để ghi mới. Cụ thể, chúng ta kỳ vọng cleaner sẽ đọc vào <strong>M</strong> segment hiện có, nén (compact) nội dung của chúng thành <strong>N</strong> segment mới (với N &lt; M), rồi ghi N segment này xuống đĩa ở các vị trí mới. M segment cũ sau đó được giải phóng và có thể được file system sử dụng cho các lần ghi tiếp theo.</p>
<p>Tuy nhiên, bây giờ chúng ta còn lại hai vấn đề:</p>
<ol>
<li><strong>Cơ chế (mechanism):</strong> Làm thế nào để LFS biết block nào trong một segment là live, và block nào là dead?</li>
<li><strong>Chính sách (policy):</strong> Cleaner nên chạy thường xuyên như thế nào, và nên chọn segment nào để dọn?</li>
</ol>
<h2 id="4310-xác-định-trạng-thái-sống-của-block-determining-block-liveness"><a class="header" href="#4310-xác-định-trạng-thái-sống-của-block-determining-block-liveness">43.10 Xác định trạng thái sống của block (Determining Block Liveness)</a></h2>
<p>Chúng ta sẽ giải quyết vấn đề <strong>cơ chế</strong> trước. Với một <strong>data block</strong> D nằm trong một <strong>on-disk segment</strong> S, LFS phải có khả năng xác định liệu D có <strong>live</strong> hay không. Để làm điều này, LFS thêm một lượng nhỏ thông tin bổ sung vào mỗi segment để mô tả từng block. Cụ thể, LFS lưu kèm với mỗi data block D: <strong>inode number</strong> (số inode – cho biết block này thuộc file nào) và <strong>offset</strong> (chỉ số block trong file). Thông tin này được ghi trong một cấu trúc ở đầu segment, gọi là <strong>segment summary block</strong>.</p>
<p>Với thông tin này, việc xác định một block là live hay dead trở nên đơn giản. Với một block D nằm trên đĩa tại địa chỉ A, hãy tra trong segment summary block để tìm <strong>inode number</strong> N và <strong>offset</strong> T của nó. Tiếp theo, tra trong <strong>imap</strong> để tìm vị trí hiện tại của inode N và đọc inode này từ đĩa (nếu inode đã ở trong bộ nhớ thì càng tốt). Cuối cùng, sử dụng offset T, tra trong inode (hoặc một indirect block) để xem inode cho rằng block thứ T của file này nằm ở đâu trên đĩa. Nếu nó trỏ chính xác tới địa chỉ đĩa A, LFS có thể kết luận block D là <strong>live</strong>. Nếu nó trỏ tới một địa chỉ khác, LFS có thể kết luận D không còn được sử dụng (tức là <strong>dead</strong>) và biết rằng phiên bản này không còn cần thiết.</p>
<p>Dưới đây là phần tóm tắt dưới dạng <strong>pseudocode</strong>:</p>
<p>...</p>
<p>Hình dưới đây mô tả cơ chế, trong đó <strong>segment summary block</strong> (khối tóm tắt phân đoạn, ký hiệu SS) ghi lại rằng data block tại địa chỉ A0 thực chất là một phần của file <em>k</em> tại offset 0. Bằng cách kiểm tra <strong>imap</strong> của <em>k</em>, bạn có thể tìm thấy inode và thấy rằng nó thực sự trỏ tới vị trí đó.</p>
<p>...</p>
<p>Có một số cách rút gọn mà LFS sử dụng để làm cho quá trình xác định trạng thái sống (liveness) hiệu quả hơn. Ví dụ, khi một file bị <strong>truncate</strong> (cắt ngắn) hoặc bị xóa, LFS sẽ tăng <strong>version number</strong> (số phiên bản) của nó và ghi số phiên bản mới này vào imap. Bằng cách cũng ghi số phiên bản này vào segment trên đĩa, LFS có thể bỏ qua bước kiểm tra dài dòng đã mô tả ở trên chỉ bằng cách so sánh số phiên bản trên đĩa với số phiên bản trong imap, từ đó tránh được các thao tác đọc bổ sung.</p>
<h2 id="4311-câu-hỏi-về-chính-sách-block-nào-cần-clean-và-khi-nào-a-policy-question-which-blocks-to-clean-and-when"><a class="header" href="#4311-câu-hỏi-về-chính-sách-block-nào-cần-clean-và-khi-nào-a-policy-question-which-blocks-to-clean-and-when">43.11 Câu hỏi về chính sách: Block nào cần clean, và khi nào? (A Policy Question: Which Blocks To Clean, And When?)</a></h2>
<p>Bên cạnh cơ chế đã mô tả ở trên, LFS phải bao gồm một tập hợp các <strong>policy</strong> (chính sách) để xác định cả <strong>khi nào</strong> cần clean và <strong>block nào</strong> đáng để clean. Việc xác định khi nào cần clean thì dễ hơn; có thể là định kỳ, trong thời gian hệ thống nhàn rỗi, hoặc khi bắt buộc vì đĩa đã đầy.</p>
<p>Việc xác định block nào cần clean thì khó hơn, và đã là chủ đề của nhiều bài báo nghiên cứu. Trong bài báo LFS gốc [RO91], các tác giả mô tả một phương pháp cố gắng phân tách <strong>hot segment</strong> và <strong>cold segment</strong>. Một hot segment là segment có nội dung thường xuyên bị ghi đè; do đó, với segment như vậy, chính sách tốt nhất là chờ lâu trước khi clean, vì càng ngày càng có nhiều block bị ghi đè (trong các segment mới) và do đó được giải phóng để sử dụng. Ngược lại, một cold segment có thể chỉ có một vài block chết nhưng phần còn lại của nội dung tương đối ổn định. Vì vậy, các tác giả kết luận rằng nên clean các cold segment sớm hơn và hot segment muộn hơn, và phát triển một heuristic (thuật toán kinh nghiệm) để thực hiện chính xác điều đó. Tuy nhiên, như hầu hết các chính sách khác, chính sách này không hoàn hảo; các phương pháp sau này đã chỉ ra cách làm tốt hơn [MR+97].</p>
<h2 id="4312-khôi-phục-sau-crash-và-log-crash-recovery-and-the-log"><a class="header" href="#4312-khôi-phục-sau-crash-và-log-crash-recovery-and-the-log">43.12 Khôi phục sau crash và Log (Crash Recovery And The Log)</a></h2>
<p>Một vấn đề cuối cùng: điều gì xảy ra nếu hệ thống bị crash trong khi LFS đang ghi xuống đĩa? Như bạn có thể nhớ từ chương trước về journaling, crash trong quá trình cập nhật là một vấn đề khó đối với file system, và do đó LFS cũng phải xem xét.</p>
<p>Trong hoạt động bình thường, LFS buffer các thao tác ghi trong một segment, và sau đó (khi segment đầy hoặc khi một khoảng thời gian nhất định đã trôi qua) ghi segment đó xuống đĩa. LFS tổ chức các thao tác ghi này trong một <strong>log</strong>, tức là checkpoint region trỏ tới <strong>head</strong> và <strong>tail segment</strong>, và mỗi segment trỏ tới segment tiếp theo sẽ được ghi. LFS cũng định kỳ cập nhật checkpoint region. Crash rõ ràng có thể xảy ra trong một trong hai thao tác này (ghi một segment, ghi CR). Vậy LFS xử lý crash khi ghi các cấu trúc này như thế nào?</p>
<p>Hãy xét trường hợp thứ hai trước. Để đảm bảo việc cập nhật CR diễn ra <strong>atomically</strong> (nguyên tử), LFS thực tế giữ <strong>hai CR</strong>, một ở mỗi đầu của đĩa, và ghi luân phiên vào chúng. LFS cũng triển khai một giao thức cẩn thận khi cập nhật CR với các con trỏ mới nhất tới inode map và các thông tin khác; cụ thể, nó ghi ra một <strong>header</strong> (chứa timestamp), sau đó là phần thân của CR, và cuối cùng là một block cuối cùng (cũng chứa timestamp). Nếu hệ thống bị crash trong khi cập nhật CR, LFS có thể phát hiện điều này bằng cách thấy cặp timestamp không nhất quán. LFS sẽ luôn chọn sử dụng CR mới nhất có timestamp nhất quán, và do đó đảm bảo CR được cập nhật nhất quán.</p>
<p>Bây giờ xét trường hợp thứ nhất. Vì LFS ghi CR khoảng mỗi 30 giây, snapshot nhất quán cuối cùng của file system có thể đã khá cũ. Do đó, khi khởi động lại, LFS có thể dễ dàng khôi phục bằng cách chỉ cần đọc checkpoint region, các phần imap mà nó trỏ tới, và các file và thư mục tiếp theo; tuy nhiên, nhiều giây cập nhật cuối cùng sẽ bị mất.</p>
<p>Để cải thiện điều này, LFS cố gắng xây dựng lại nhiều segment đó thông qua một kỹ thuật được gọi là <strong>roll forward</strong> trong lĩnh vực cơ sở dữ liệu. Ý tưởng cơ bản là bắt đầu với checkpoint region cuối cùng, tìm điểm kết thúc của log (được bao gồm trong CR), và sau đó sử dụng nó để đọc qua các segment tiếp theo và xem có bản cập nhật hợp lệ nào trong đó không. Nếu có, LFS sẽ cập nhật file system tương ứng và do đó khôi phục được phần lớn dữ liệu và metadata đã ghi kể từ checkpoint cuối cùng. Xem luận án đoạt giải của Rosenblum để biết chi tiết [R92].</p>
<h2 id="4313-tóm-tắt-summary"><a class="header" href="#4313-tóm-tắt-summary">43.13 Tóm tắt (Summary)</a></h2>
<p>LFS giới thiệu một cách tiếp cận mới để cập nhật đĩa. Thay vì ghi đè file tại chỗ, LFS luôn ghi vào một phần chưa sử dụng của đĩa, và sau đó thu hồi lại không gian cũ thông qua quá trình cleaning. Cách tiếp cận này, trong hệ thống cơ sở dữ liệu được gọi là <strong>shadow paging</strong> [L77] và trong lĩnh vực file system đôi khi được gọi là <strong>copy-on-write</strong>, cho phép ghi với hiệu năng rất cao, vì LFS có thể gom tất cả các bản cập nhật vào một segment trong bộ nhớ và sau đó ghi chúng ra cùng nhau theo thứ tự tuần tự.</p>
<blockquote>
<blockquote>
<p><strong>TIP: BIẾN KHUYẾT ĐIỂM THÀNH ƯU ĐIỂM</strong><br />
Bất cứ khi nào hệ thống của bạn có một khiếm khuyết cơ bản, hãy xem liệu bạn có thể biến nó thành một tính năng hoặc điều gì đó hữu ích hay không. <strong>WAFL</strong> của NetApp đã làm điều này với nội dung file cũ; bằng cách cung cấp các phiên bản cũ, WAFL không còn phải lo lắng về việc cleaning quá thường xuyên (mặc dù nó vẫn xóa các phiên bản cũ, cuối cùng, ở chế độ nền), và do đó vừa cung cấp một tính năng thú vị vừa loại bỏ phần lớn vấn đề cleaning của LFS chỉ trong một bước ngoặt tuyệt vời. Liệu có ví dụ nào khác như vậy trong các hệ thống không? Chắc chắn là có, nhưng bạn sẽ phải tự nghĩ ra, vì chương này đã kết thúc với chữ “O” viết hoa. Over. Done. Kaput. Hết. Peace!</p>
</blockquote>
</blockquote>
<p>Các thao tác ghi lớn mà LFS tạo ra rất tốt cho hiệu năng trên nhiều loại thiết bị khác nhau. Trên ổ cứng, ghi lớn đảm bảo thời gian định vị được giảm thiểu; trên các RAID dựa trên parity như RAID-4 và RAID-5, chúng loại bỏ hoàn toàn vấn đề <strong>small-write</strong>. Các nghiên cứu gần đây thậm chí đã chỉ ra rằng các thao tác I/O lớn là cần thiết để đạt hiệu năng cao trên SSD dựa trên Flash [HK+17]; do đó, có thể khá bất ngờ, các file system kiểu LFS có thể là một lựa chọn tuyệt vời ngay cả cho các phương tiện lưu trữ mới này.</p>
<p>Nhược điểm của cách tiếp cận này là nó tạo ra <strong>garbage</strong>; các bản sao cũ của dữ liệu bị rải rác khắp đĩa, và nếu muốn thu hồi không gian này cho các lần sử dụng tiếp theo, ta phải định kỳ clean các segment cũ. Cleaning đã trở thành tâm điểm của nhiều tranh luận trong LFS, và lo ngại về chi phí cleaning [SS+95] có lẽ đã hạn chế tác động ban đầu của LFS trong lĩnh vực này. Tuy nhiên, một số file system thương mại hiện đại, bao gồm <strong>WAFL</strong> của NetApp [HLM94], <strong>ZFS</strong> của Sun [B07], và <strong>btrfs</strong> của Linux [R+13], và thậm chí cả các SSD hiện đại dựa trên Flash [AD14], áp dụng cách tiếp cận copy-on-write tương tự khi ghi xuống đĩa, và do đó di sản trí tuệ của LFS vẫn tiếp tục tồn tại trong các file system hiện đại này. Đặc biệt, WAFL đã vượt qua vấn đề cleaning bằng cách biến nó thành một tính năng; bằng cách cung cấp các phiên bản cũ của file system thông qua <strong>snapshot</strong>, người dùng có thể truy cập các file cũ khi họ lỡ tay xóa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="44-Ổ-ssd-dựa-trên-flash-flash-based-ssds"><a class="header" href="#44-Ổ-ssd-dựa-trên-flash-flash-based-ssds">44. Ổ SSD dựa trên Flash (Flash-based SSDs)</a></h1>
<p>Sau hàng thập kỷ ổ đĩa cứng (HDD) thống trị, một dạng thiết bị lưu trữ bền vững (persistent storage) mới đã nổi lên và ngày càng quan trọng trên thế giới. Được gọi chung là <strong>solid-state storage</strong> (lưu trữ thể rắn), các thiết bị này <strong>không</strong> có bộ phận cơ khí hay chuyển động như ổ cứng; thay vào đó, chúng được chế tạo hoàn toàn từ các <strong>transistor</strong>, tương tự như bộ nhớ và bộ xử lý. Tuy nhiên, khác với bộ nhớ truy cập ngẫu nhiên thông thường (ví dụ: <strong>DRAM</strong>), thiết bị lưu trữ thể rắn (hay còn gọi là <strong>SSD</strong>) vẫn giữ được thông tin ngay cả khi mất điện, và do đó là ứng viên lý tưởng để lưu trữ dữ liệu lâu dài.</p>
<p>Công nghệ mà chúng ta tập trung ở đây được gọi là <strong>flash</strong> (cụ thể hơn là <strong>NAND-based flash</strong>), được Fujio Masuoka phát minh vào những năm 1980 [M+14]. Flash, như chúng ta sẽ thấy, có một số đặc tính rất riêng. Ví dụ, để ghi vào một phần dữ liệu của nó (tức là một <strong>flash page</strong>), trước tiên bạn phải xóa một phần lớn hơn (tức là một <strong>flash block</strong>), và thao tác này khá tốn kém. Ngoài ra, việc ghi quá thường xuyên vào một page sẽ khiến nó bị <strong>mòn</strong> (wear out). Hai đặc tính này khiến việc xây dựng một SSD dựa trên flash trở thành một thách thức thú vị:</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ XÂY DỰNG MỘT SSD DỰA TRÊN FLASH?</strong><br />
Làm thế nào để chúng ta xây dựng một SSD dựa trên flash? Làm thế nào để xử lý chi phí cao của thao tác xóa? Làm thế nào để chế tạo một thiết bị có tuổi thọ dài, khi việc ghi đè lặp lại sẽ làm thiết bị bị mòn? Liệu tiến bộ công nghệ có bao giờ dừng lại? Hay sẽ luôn khiến chúng ta kinh ngạc?</p>
</blockquote>
</blockquote>
<h2 id="441-lưu-trữ-một-bit-storing-a-single-bit"><a class="header" href="#441-lưu-trữ-một-bit-storing-a-single-bit">44.1 Lưu trữ một bit (Storing a Single Bit)</a></h2>
<p>Chip flash được thiết kế để lưu trữ một hoặc nhiều bit trong một transistor; mức điện tích bị giữ trong transistor được ánh xạ thành giá trị nhị phân. Trong <strong>single-level cell (SLC) flash</strong>, chỉ một bit được lưu trong một transistor (tức là 1 hoặc 0); với <strong>multi-level cell (MLC) flash</strong>, hai bit được mã hóa thành các mức điện tích khác nhau, ví dụ: 00, 01, 10 và 11 được biểu diễn bằng mức điện tích thấp, hơi thấp, hơi cao và cao. Thậm chí còn có <strong>triple-level cell (TLC) flash</strong>, mã hóa 3 bit trên mỗi cell. Nhìn chung, chip SLC đạt hiệu năng cao hơn và giá thành đắt hơn.</p>
<blockquote>
<blockquote>
<p><strong>TIP: CẨN THẬN VỚI THUẬT NGỮ</strong><br />
Bạn có thể nhận thấy rằng một số thuật ngữ chúng ta đã sử dụng nhiều lần trước đây (<strong>block</strong>, <strong>page</strong>) đang được dùng trong ngữ cảnh của flash, nhưng theo cách hơi khác so với trước. Các thuật ngữ mới không được tạo ra để làm khó bạn (mặc dù đôi khi có thể gây nhầm lẫn), mà xuất hiện vì không có một cơ quan trung ương nào quyết định thống nhất thuật ngữ. Một <strong>block</strong> đối với bạn có thể là một <strong>page</strong> đối với người khác, và ngược lại, tùy thuộc vào ngữ cảnh. Nhiệm vụ của bạn rất đơn giản: nắm rõ các thuật ngữ phù hợp trong từng lĩnh vực, và sử dụng chúng sao cho những người am hiểu trong ngành có thể hiểu bạn đang nói gì. Đây là một trong những trường hợp mà giải pháp duy nhất vừa đơn giản vừa đôi khi gây khó chịu: hãy dùng trí nhớ của bạn.</p>
</blockquote>
</blockquote>
<p>Tất nhiên, có rất nhiều chi tiết về cách lưu trữ ở mức bit này hoạt động, ở cấp độ vật lý thiết bị. Mặc dù nằm ngoài phạm vi của cuốn sách này, bạn có thể tự tìm hiểu thêm [J10].</p>
<h2 id="442-từ-bit-đến-bankplane-from-bits-to-banksplanes"><a class="header" href="#442-từ-bit-đến-bankplane-from-bits-to-banksplanes">44.2 Từ bit đến bank/plane (From Bits to Banks/Planes)</a></h2>
<p>Như người Hy Lạp cổ đại từng nói, lưu trữ một bit (hoặc vài bit) thì chưa thể tạo thành một hệ thống lưu trữ. Do đó, chip flash được tổ chức thành các <strong>bank</strong> hoặc <strong>plane</strong>, mỗi cái bao gồm một số lượng lớn cell.</p>
<p>Một <strong>bank</strong> được truy cập theo hai đơn vị kích thước khác nhau: <strong>block</strong> (đôi khi gọi là <strong>erase block</strong>), thường có kích thước 128 KB hoặc 256 KB, và <strong>page</strong>, có kích thước vài KB (ví dụ: 4 KB). Bên trong mỗi bank có rất nhiều block; bên trong mỗi block lại có nhiều page. Khi nói về flash, bạn phải nhớ thuật ngữ mới này, vốn khác với <strong>block</strong> mà chúng ta đề cập trong ổ đĩa và RAID, và khác với <strong>page</strong> mà chúng ta nói đến trong <strong>virtual memory</strong> (bộ nhớ ảo).</p>
<p><strong>Hình 44.1</strong> cho thấy một ví dụ về <strong>flash plane</strong> với các block và page; trong ví dụ đơn giản này có ba block, mỗi block chứa bốn page. Chúng ta sẽ thấy bên dưới lý do tại sao cần phân biệt giữa block và page; hóa ra sự phân biệt này là rất quan trọng đối với các thao tác trên flash như đọc và ghi, và còn quan trọng hơn đối với hiệu năng tổng thể của thiết bị. Điều quan trọng (và kỳ lạ) nhất mà bạn sẽ học được là: để ghi vào một page trong một block, trước tiên bạn phải xóa toàn bộ block; chi tiết phức tạp này khiến việc xây dựng một SSD dựa trên flash trở thành một thách thức thú vị và đáng để nghiên cứu, và sẽ là nội dung của nửa sau chương này.</p>
<p><img src="44/img/fig44_1.PNG" alt="" /></p>
<p><strong>Hình 44.1: Một chip flash đơn giản: Các page bên trong block</strong></p>
<h2 id="443-các-thao-tác-cơ-bản-trên-flash-basic-flash-operations"><a class="header" href="#443-các-thao-tác-cơ-bản-trên-flash-basic-flash-operations">44.3 Các thao tác cơ bản trên Flash (Basic Flash Operations)</a></h2>
<p>Với cấu trúc tổ chức của flash như đã mô tả, có ba thao tác mức thấp (low-level operations) mà một chip flash hỗ trợ. Lệnh <strong>read</strong> được dùng để đọc một page từ flash; <strong>erase</strong> và <strong>program</strong> được sử dụng kết hợp để ghi dữ liệu. Chi tiết như sau:</p>
<ul>
<li>
<p><strong>Read (một page)</strong>: Một client (thiết bị hoặc phần mềm sử dụng chip flash) có thể đọc bất kỳ page nào (ví dụ: 2KB hoặc 4KB) chỉ bằng cách gửi lệnh đọc và số hiệu page tương ứng tới thiết bị. Thao tác này thường rất nhanh, chỉ mất vài chục microsecond, bất kể vị trí trên thiết bị, và (gần như) không phụ thuộc vào vị trí của yêu cầu trước đó (khác hẳn với ổ đĩa từ). Khả năng truy cập nhanh đồng đều tới mọi vị trí có nghĩa là thiết bị này là một <strong>random access device</strong> (thiết bị truy cập ngẫu nhiên).</p>
</li>
<li>
<p><strong>Erase (một block)</strong>: Trước khi ghi vào một page trong flash, bản chất của thiết bị yêu cầu bạn phải xóa toàn bộ block chứa page đó. Lệnh erase, quan trọng là, sẽ <strong>xóa toàn bộ nội dung của block</strong> (bằng cách đặt mỗi bit về giá trị 1); do đó, bạn phải đảm bảo rằng mọi dữ liệu quan trọng trong block đã được sao chép sang nơi khác (ví dụ: bộ nhớ, hoặc một block flash khác) trước khi thực hiện lệnh erase. Lệnh erase khá tốn kém, mất vài millisecond để hoàn tất. Sau khi xóa xong, toàn bộ block được đặt lại trạng thái ban đầu và mỗi page trong đó sẵn sàng để được lập trình (program).</p>
</li>
<li>
<p><strong>Program (một page)</strong>: Sau khi một block đã được erase, lệnh program có thể được dùng để thay đổi một số bit 1 trong page thành bit 0, và ghi nội dung mong muốn của page vào flash. Việc program một page ít tốn kém hơn erase một block, nhưng tốn hơn đọc một page, thường mất khoảng vài trăm microsecond trên các chip flash hiện đại.</p>
</li>
</ul>
<p>Một cách để hình dung về chip flash là: mỗi page có một <strong>trạng thái</strong> (state) gắn liền với nó. Các page bắt đầu ở trạng thái <strong>INVALID</strong> (không hợp lệ). Khi xóa block chứa page, bạn đặt trạng thái của page (và tất cả các page trong block đó) thành <strong>ERASED</strong> (đã xóa), điều này vừa đặt lại nội dung của mỗi page trong block, vừa (quan trọng) khiến chúng có thể được lập trình. Khi bạn program một page, trạng thái của nó chuyển sang <strong>VALID</strong> (hợp lệ), nghĩa là nội dung đã được thiết lập và có thể đọc. Các thao tác đọc không ảnh hưởng đến trạng thái này (mặc dù bạn chỉ nên đọc từ các page đã được program). Một khi một page đã được program, cách duy nhất để thay đổi nội dung của nó là xóa toàn bộ block chứa page đó.</p>
<p>Dưới đây là ví dụ về sự chuyển đổi trạng thái sau các thao tác erase và program khác nhau trong một block gồm 4 page:</p>
<p>...</p>
<h3 id="ví-dụ-chi-tiết-a-detailed-example"><a class="header" href="#ví-dụ-chi-tiết-a-detailed-example">Ví dụ chi tiết (A Detailed Example)</a></h3>
<p>Bởi vì quá trình ghi (tức là erase và program) khá đặc biệt, hãy cùng đi qua một ví dụ chi tiết để đảm bảo bạn hiểu rõ. Trong ví dụ này, giả sử chúng ta có bốn page 8-bit, nằm trong một block gồm 4 page (cả hai kích thước này đều nhỏ hơn thực tế, nhưng hữu ích cho minh họa); mỗi page đang ở trạng thái <strong>VALID</strong> vì đã được program trước đó.</p>
<p>...</p>
<p>Bây giờ giả sử chúng ta muốn ghi vào page 0, điền vào đó nội dung mới. Để ghi vào bất kỳ page nào, chúng ta <strong>phải</strong> xóa toàn bộ block trước. Giả sử chúng ta thực hiện điều đó, để lại block ở trạng thái:</p>
<p>...</p>
<p>Tin tốt là: giờ chúng ta có thể program page 0, ví dụ với nội dung <code>00000011</code>, ghi đè lên page 0 cũ (nội dung <code>00011000</code>) như mong muốn. Sau khi thực hiện, block của chúng ta trông như sau:</p>
<p>...</p>
<p>Và đây là tin xấu: nội dung trước đó của các page 1, 2 và 3 <strong>đều đã mất</strong>! Do đó, trước khi ghi đè bất kỳ page nào trong một block, chúng ta phải di chuyển mọi dữ liệu quan trọng sang vị trí khác (ví dụ: bộ nhớ, hoặc một nơi khác trên flash). Bản chất của thao tác erase sẽ có ảnh hưởng mạnh mẽ đến cách chúng ta thiết kế các SSD dựa trên flash, như chúng ta sẽ tìm hiểu ngay sau đây.</p>
<h3 id="tóm-tắt-summary-1"><a class="header" href="#tóm-tắt-summary-1">Tóm tắt (Summary)</a></h3>
<p>Tóm lại, việc đọc một <strong>page</strong> là đơn giản: chỉ cần đọc page đó. Các chip flash thực hiện thao tác này khá tốt và nhanh; xét về hiệu năng, chúng có tiềm năng vượt xa hiệu năng đọc ngẫu nhiên (random read) của các ổ đĩa từ hiện đại, vốn chậm do chi phí seek và quay cơ học.</p>
<p>Việc ghi một page thì phức tạp hơn; toàn bộ <strong>block</strong> phải được xóa trước (đảm bảo rằng mọi dữ liệu quan trọng đã được di chuyển sang vị trí khác), sau đó mới <strong>program</strong> (lập trình) page mong muốn. Điều này không chỉ tốn kém, mà việc lặp lại chu kỳ <strong>program/erase</strong> thường xuyên có thể dẫn đến vấn đề độ tin cậy lớn nhất của chip flash: <strong>wear out</strong> (hao mòn). Khi thiết kế một hệ thống lưu trữ sử dụng flash, hiệu năng và độ tin cậy của thao tác ghi là trọng tâm cần chú ý. Chúng ta sẽ sớm tìm hiểu cách các SSD hiện đại giải quyết những vấn đề này, mang lại hiệu năng và độ tin cậy cao bất chấp các giới hạn nói trên.</p>
<p><img src="44/img/fig44_2.PNG" alt="" /></p>
<p><strong>Hình 44.2: Đặc tính hiệu năng của flash thô (Raw Flash Performance Characteristics)</strong></p>
<h2 id="444-hiệu-năng-và-độ-tin-cậy-của-flash-flash-performance-and-reliability"><a class="header" href="#444-hiệu-năng-và-độ-tin-cậy-của-flash-flash-performance-and-reliability">44.4 Hiệu năng và độ tin cậy của Flash (Flash Performance And Reliability)</a></h2>
<p>Vì chúng ta quan tâm đến việc xây dựng một thiết bị lưu trữ từ các chip flash thô, nên việc hiểu các đặc tính hiệu năng cơ bản của chúng là cần thiết. <strong>Hình 44.2</strong> trình bày tóm tắt một số số liệu được tìm thấy trên các nguồn báo chí phổ biến [V12]. Trong đó, tác giả đưa ra độ trễ (latency) của các thao tác cơ bản <strong>read</strong>, <strong>program</strong>, và <strong>erase</strong> trên các loại flash SLC, MLC và TLC, lần lượt lưu trữ 1, 2 và 3 bit thông tin trên mỗi cell.</p>
<p>Như ta có thể thấy từ bảng, độ trễ đọc (read latency) khá tốt, chỉ mất vài chục microsecond để hoàn tất. Độ trễ program cao hơn và biến thiên nhiều hơn: thấp nhất khoảng 200 microsecond đối với SLC, nhưng cao hơn khi lưu nhiều bit hơn trên mỗi cell; để đạt hiệu năng ghi tốt, bạn sẽ phải sử dụng nhiều chip flash song song. Cuối cùng, thao tác erase khá tốn kém, thường mất vài millisecond. Việc xử lý chi phí này là yếu tố trung tâm trong thiết kế lưu trữ flash hiện đại.</p>
<p>Bây giờ hãy xét đến độ tin cậy của chip flash. Khác với ổ đĩa cơ khí, vốn có thể hỏng vì nhiều nguyên nhân (bao gồm cả sự cố nghiêm trọng <strong>head crash</strong>, khi đầu đọc của ổ đĩa tiếp xúc trực tiếp với bề mặt ghi), chip flash được làm hoàn toàn từ silicon và do đó ít gặp vấn đề về độ tin cậy hơn. Mối quan tâm chính là <strong>wear out</strong>; khi một block flash bị erase và program, nó dần tích tụ một lượng điện tích dư. Theo thời gian, khi điện tích dư này tăng lên, việc phân biệt giữa bit 0 và bit 1 trở nên khó khăn hơn. Khi không thể phân biệt được nữa, block đó trở nên không sử dụng được.</p>
<p>Tuổi thọ điển hình của một block hiện chưa được biết rõ. Các nhà sản xuất đánh giá block dựa trên MLC có tuổi thọ khoảng 10.000 chu kỳ <strong>P/E</strong> (Program/Erase); tức là mỗi block có thể bị xóa và lập trình 10.000 lần trước khi hỏng. Chip SLC, vì chỉ lưu một bit trên mỗi transistor, được đánh giá có tuổi thọ dài hơn, thường khoảng 100.000 chu kỳ P/E. Tuy nhiên, các nghiên cứu gần đây cho thấy tuổi thọ thực tế có thể dài hơn nhiều so với dự đoán [BD10].</p>
<p>Một vấn đề độ tin cậy khác trong chip flash được gọi là <strong>disturbance</strong> (nhiễu). Khi truy cập một page cụ thể trong flash, có khả năng một số bit trong các page lân cận bị lật (bit flip); các bit flip này được gọi là <strong>read disturb</strong> hoặc <strong>program disturb</strong>, tùy thuộc vào việc page đang được đọc hay được lập trình.</p>
<blockquote>
<blockquote>
<p><strong>TIP: TẦM QUAN TRỌNG CỦA KHẢ NĂNG TƯƠNG THÍCH NGƯỢC (BACKWARDS COMPATIBILITY)</strong><br />
Khả năng <strong>tương thích ngược</strong> luôn là một mối quan tâm trong các hệ thống phân lớp (layered systems). Bằng cách định nghĩa một <strong>giao diện ổn định</strong> giữa hai hệ thống, ta cho phép đổi mới ở mỗi phía của giao diện, đồng thời đảm bảo khả năng tương tác liên tục. Cách tiếp cận này đã rất thành công trong nhiều lĩnh vực: hệ điều hành (operating system) duy trì API tương đối ổn định cho ứng dụng, ổ đĩa cung cấp cùng một giao diện dựa trên block cho file system, và mỗi lớp trong ngăn xếp mạng IP (IP networking stack) cung cấp một giao diện cố định, không thay đổi cho lớp phía trên.<br />
Không ngạc nhiên khi sự cứng nhắc này cũng có mặt trái: các giao diện được định nghĩa ở một thế hệ có thể không còn phù hợp ở thế hệ tiếp theo. Trong một số trường hợp, có thể hữu ích khi xem xét <strong>thiết kế lại toàn bộ hệ thống</strong>. Một ví dụ điển hình là file system <strong>ZFS</strong> của Sun [B07]; bằng cách xem xét lại cách file system và RAID tương tác, các nhà thiết kế ZFS đã hình dung (và hiện thực hóa) một hệ thống tích hợp hiệu quả hơn.</p>
</blockquote>
</blockquote>
<h2 id="445-từ-flash-thô-đến-ssd-dựa-trên-flash-from-raw-flash-to-flash-based-ssds"><a class="header" href="#445-từ-flash-thô-đến-ssd-dựa-trên-flash-from-raw-flash-to-flash-based-ssds">44.5 Từ Flash thô đến SSD dựa trên Flash (From Raw Flash to Flash-Based SSDs)</a></h2>
<p>Với hiểu biết cơ bản về chip flash, chúng ta đối mặt với nhiệm vụ tiếp theo: <strong>làm thế nào để biến một tập hợp chip flash cơ bản thành một thiết bị lưu trữ giống như các thiết bị lưu trữ thông thường</strong>. Giao diện lưu trữ tiêu chuẩn là giao diện <strong>dựa trên block</strong> đơn giản, trong đó các block (sector) có kích thước 512 byte (hoặc lớn hơn) có thể được đọc hoặc ghi khi biết địa chỉ block. Nhiệm vụ của SSD dựa trên flash là cung cấp giao diện block tiêu chuẩn này trên nền các chip flash thô bên trong.</p>
<p>Bên trong, một SSD bao gồm một số chip flash (dùng cho lưu trữ bền vững – persistent storage). SSD cũng chứa một lượng bộ nhớ <strong>volatile</strong> (không bền vững, ví dụ: SRAM); loại bộ nhớ này hữu ích cho việc <strong>caching</strong> (lưu đệm) và <strong>buffering</strong> (đệm) dữ liệu, cũng như cho các bảng ánh xạ (mapping tables) mà chúng ta sẽ tìm hiểu bên dưới. Cuối cùng, SSD chứa <strong>control logic</strong> (mạch điều khiển) để điều phối hoạt động của thiết bị. Xem Agrawal và cộng sự [A+08] để biết chi tiết; <strong>Hình 44.3</strong> minh họa sơ đồ khối logic đơn giản của một SSD dựa trên flash.</p>
<p><img src="44/img/fig44_3.PNG" alt="" /></p>
<p><strong>Hình 44.3: SSD dựa trên Flash – Sơ đồ logic</strong></p>
<p>Một trong những chức năng thiết yếu của control logic là đáp ứng các yêu cầu đọc và ghi từ phía client, chuyển chúng thành các thao tác flash nội bộ khi cần. <strong>Flash Translation Layer</strong> (FTL – lớp dịch địa chỉ flash) cung cấp chính xác chức năng này. FTL nhận các yêu cầu đọc và ghi trên các <strong>logical block</strong> (khối logic – tạo thành giao diện thiết bị) và chuyển chúng thành các lệnh mức thấp <strong>read</strong>, <strong>erase</strong>, và <strong>program</strong> trên các <strong>physical block</strong> và <strong>physical page</strong> (tạo thành thiết bị flash vật lý thực tế). FTL phải thực hiện nhiệm vụ này với mục tiêu đạt <strong>hiệu năng cao</strong> và <strong>độ tin cậy cao</strong>.</p>
<p>Hiệu năng cao, như chúng ta sẽ thấy, có thể đạt được thông qua sự kết hợp của nhiều kỹ thuật. Một yếu tố then chốt là <strong>tận dụng nhiều chip flash song song</strong>; mặc dù chúng ta sẽ không bàn sâu về kỹ thuật này, nhưng có thể khẳng định rằng tất cả các SSD hiện đại đều sử dụng nhiều chip bên trong để đạt hiệu năng cao hơn. Một mục tiêu hiệu năng khác là <strong>giảm write amplification</strong> – được định nghĩa là tổng lưu lượng ghi (tính bằng byte) mà FTL gửi tới các chip flash chia cho tổng lưu lượng ghi (tính bằng byte) mà client gửi tới SSD. Như chúng ta sẽ thấy bên dưới, các cách tiếp cận FTL ngây thơ sẽ dẫn đến write amplification cao và hiệu năng thấp.</p>
<p>Độ tin cậy cao sẽ đạt được thông qua sự kết hợp của một số phương pháp khác nhau. Mối quan tâm chính, như đã thảo luận ở trên, là <strong>wear out</strong> (hao mòn). Nếu một block bị erase và program quá thường xuyên, nó sẽ trở nên không sử dụng được; do đó, FTL nên cố gắng <strong>phân tán các thao tác ghi</strong> đều trên các block của flash, đảm bảo rằng tất cả các block của thiết bị hao mòn gần như đồng thời; việc này được gọi là <strong>wear leveling</strong> và là một phần thiết yếu của bất kỳ FTL hiện đại nào.</p>
<p>Một mối quan tâm khác về độ tin cậy là <strong>program disturbance</strong> (nhiễu khi lập trình). Để giảm thiểu nhiễu này, FTL thường sẽ <strong>program các page trong một block đã erase theo thứ tự</strong>, từ page thấp đến page cao. Cách lập trình tuần tự này giúp giảm thiểu nhiễu và được sử dụng rộng rãi.</p>
<h2 id="446-tổ-chức-ftl-một-cách-tiếp-cận-tệ-ftl-organization-a-bad-approach"><a class="header" href="#446-tổ-chức-ftl-một-cách-tiếp-cận-tệ-ftl-organization-a-bad-approach">44.6 Tổ chức FTL: Một cách tiếp cận tệ (FTL Organization: A Bad Approach)</a></h2>
<p>Cách tổ chức đơn giản nhất của một <strong>FTL</strong> (Flash Translation Layer – lớp dịch địa chỉ flash) là phương pháp mà chúng ta gọi là <strong>direct mapped</strong> (ánh xạ trực tiếp). Trong cách tiếp cận này, một thao tác đọc tới <strong>logical page</strong> N (trang logic N) sẽ được ánh xạ trực tiếp thành thao tác đọc <strong>physical page</strong> N (trang vật lý N). Một thao tác ghi tới logical page N thì phức tạp hơn; FTL trước tiên phải đọc toàn bộ <strong>block</strong> chứa page N; sau đó phải <strong>erase</strong> (xóa) block đó; cuối cùng, FTL <strong>program</strong> (lập trình) lại các page cũ cũng như page mới.</p>
<p>Như bạn có thể đoán, FTL kiểu direct-mapped có nhiều vấn đề, cả về <strong>hiệu năng</strong> lẫn <strong>độ tin cậy</strong>. Vấn đề hiệu năng xuất hiện ở mỗi lần ghi: thiết bị phải đọc toàn bộ block (tốn kém), xóa block (rất tốn kém), rồi program lại (tốn kém). Kết quả cuối cùng là <strong>write amplification</strong> (khuếch đại ghi) nghiêm trọng (tỷ lệ thuận với số lượng page trong một block) và do đó hiệu năng ghi rất tệ, thậm chí còn chậm hơn cả ổ cứng thông thường với các thao tác seek và quay cơ học.</p>
<p>Tệ hơn nữa là độ tin cậy của cách tiếp cận này. Nếu <strong>metadata</strong> của file system hoặc dữ liệu file của người dùng bị ghi đè nhiều lần, cùng một block sẽ bị erase và program lặp đi lặp lại, nhanh chóng làm nó bị mòn (<strong>wear out</strong>) và có thể gây mất dữ liệu. Cách tiếp cận direct-mapped đơn giản là trao quá nhiều quyền kiểm soát việc hao mòn cho <strong>workload</strong> (tải công việc) của client; nếu workload không phân bổ đều tải ghi trên các logical block, các physical block chứa dữ liệu được truy cập thường xuyên sẽ nhanh chóng bị mòn. Vì cả lý do độ tin cậy lẫn hiệu năng, một FTL kiểu direct-mapped là một ý tưởng tồi.</p>
<h2 id="447-ftl-kiểu-log-structured-a-log-structured-ftl"><a class="header" href="#447-ftl-kiểu-log-structured-a-log-structured-ftl">44.7 FTL kiểu Log-Structured (A Log-Structured FTL)</a></h2>
<p>Vì những lý do trên, hầu hết các FTL ngày nay đều được thiết kế theo kiểu <strong>log-structured</strong> (cấu trúc nhật ký), một ý tưởng hữu ích cả trong thiết bị lưu trữ (như chúng ta sẽ thấy ngay sau đây) và trong các file system phía trên (ví dụ: <strong>log-structured file system</strong>). Khi ghi vào logical block N, thiết bị sẽ <strong>append</strong> (nối thêm) dữ liệu ghi vào vị trí trống tiếp theo trong block đang được ghi; chúng ta gọi kiểu ghi này là <strong>logging</strong>. Để cho phép đọc lại block N sau này, thiết bị duy trì một <strong>mapping table</strong> (bảng ánh xạ) trong bộ nhớ (và được lưu bền vững ở một dạng nào đó trên thiết bị); bảng này lưu địa chỉ vật lý của mỗi logical block trong hệ thống.</p>
<p>Hãy cùng đi qua một ví dụ để đảm bảo chúng ta hiểu cách tiếp cận log-based cơ bản hoạt động. Đối với client, thiết bị trông giống như một ổ đĩa thông thường, có thể đọc và ghi các sector 512 byte (hoặc nhóm sector). Để đơn giản, giả sử client đọc hoặc ghi các khối dữ liệu kích thước 4 KB. Giả sử thêm rằng SSD chứa một số lượng lớn các block kích thước 16 KB, mỗi block được chia thành bốn page 4 KB; các thông số này là không thực tế (block flash thường gồm nhiều page hơn) nhưng sẽ phục vụ tốt cho mục đích minh họa.</p>
<p>Giả sử client thực hiện chuỗi thao tác sau:</p>
<ul>
<li><code>Write(100)</code> với nội dung <strong>a1</strong></li>
<li><code>Write(101)</code> với nội dung <strong>a2</strong></li>
<li><code>Write(2000)</code> với nội dung <strong>b1</strong></li>
<li><code>Write(2001)</code> với nội dung <strong>b2</strong></li>
</ul>
<p>Các <strong>logical block address</strong> (địa chỉ block logic, ví dụ: 100) được client của SSD (ví dụ: một file system) sử dụng để ghi nhớ vị trí lưu trữ thông tin. Bên trong, thiết bị phải chuyển đổi các thao tác ghi block này thành các thao tác <strong>erase</strong> và <strong>program</strong> được phần cứng flash hỗ trợ, và bằng cách nào đó ghi nhận, cho mỗi logical block address, physical page nào của SSD đang lưu dữ liệu của nó. Giả sử tất cả các block của SSD hiện đều <strong>INVALID</strong> (không hợp lệ) và phải được erase trước khi bất kỳ page nào có thể được program. Dưới đây là trạng thái ban đầu của SSD, với tất cả các page được đánh dấu INVALID (i):</p>
<p>...</p>
<p>Khi thao tác ghi đầu tiên được gửi tới SSD (tới logical block 100), FTL quyết định ghi nó vào <strong>physical block</strong> 0, block này chứa bốn physical page: 0, 1, 2 và 3. Vì block chưa được erase, chúng ta chưa thể ghi vào; thiết bị trước tiên phải gửi lệnh erase tới block 0. Thao tác này dẫn đến trạng thái sau:</p>
<p>...</p>
<p>Block 0 giờ đã sẵn sàng để được program. Hầu hết các SSD sẽ ghi các page theo thứ tự (tức là từ page thấp đến page cao), giúp giảm các vấn đề về độ tin cậy liên quan đến <strong>program disturbance</strong> (nhiễu khi lập trình). SSD sau đó sẽ ghi logical block 100 vào physical page 0:</p>
<p>...</p>
<p>Bây giờ bạn có thể thấy điều gì xảy ra khi client ghi vào SSD. SSD tìm một vị trí cho thao tác ghi, thường là chọn page trống tiếp theo; sau đó nó program page đó với nội dung của block, và ghi nhận ánh xạ <strong>logical-to-physical</strong> (từ logic sang vật lý) trong bảng ánh xạ. Các thao tác đọc sau đó chỉ cần sử dụng bảng này để dịch logical block address mà client đưa ra thành số physical page cần đọc dữ liệu.</p>
<p>Hãy tiếp tục xem xét các thao tác ghi còn lại trong chuỗi ví dụ: 101, 2000 và 2001. Sau khi ghi các block này, trạng thái của thiết bị là:</p>
<p>...</p>
<p>Cách tiếp cận log-based, theo bản chất của nó, cải thiện hiệu năng (erase chỉ cần thực hiện thỉnh thoảng, và tránh hoàn toàn thao tác <strong>read-modify-write</strong> tốn kém của phương pháp direct-mapped), đồng thời nâng cao đáng kể độ tin cậy. FTL giờ đây có thể phân bổ các thao tác ghi trên tất cả các page, thực hiện cái gọi là <strong>wear leveling</strong> và kéo dài tuổi thọ của thiết bị; chúng ta sẽ thảo luận thêm về wear leveling ở phần sau.</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: TÍNH BỀN VỮNG CỦA THÔNG TIN ÁNH XẠ FTL (FTL MAPPING INFORMATION PERSISTENCE)</strong><br />
Bạn có thể tự hỏi: điều gì xảy ra nếu thiết bị bị mất điện? Liệu bảng ánh xạ trong bộ nhớ (in-memory mapping table) có biến mất không? Rõ ràng, thông tin này <strong>không thể</strong> bị mất hoàn toàn, vì nếu vậy thiết bị sẽ không thể hoạt động như một thiết bị lưu trữ bền vững (persistent storage device). Một SSD phải có cơ chế để khôi phục thông tin ánh xạ.</p>
<p>Cách đơn giản nhất là ghi kèm một số thông tin ánh xạ với mỗi page, trong vùng gọi là <strong>out-of-band (OOB) area</strong>. Khi thiết bị mất điện và được khởi động lại, nó phải tái tạo bảng ánh xạ bằng cách quét các vùng OOB và dựng lại bảng ánh xạ trong bộ nhớ. Cách tiếp cận cơ bản này có một số vấn đề; việc quét một SSD dung lượng lớn để tìm toàn bộ thông tin ánh xạ cần thiết là chậm. Để khắc phục hạn chế này, một số thiết bị cao cấp hơn sử dụng các kỹ thuật logging (ghi nhật ký) và checkpointing (tạo điểm kiểm) phức tạp hơn để tăng tốc quá trình khôi phục; bạn có thể tìm hiểu thêm về logging trong các chương nói về <strong>crash consistency</strong> và <strong>log-structured file system</strong> [AD14a].</p>
</blockquote>
</blockquote>
<p>Thật không may, cách tiếp cận log structuring cơ bản này có một số nhược điểm. Thứ nhất, việc ghi đè (overwrite) các logical block dẫn đến hiện tượng mà chúng ta gọi là <strong>garbage</strong> (rác), tức là các phiên bản dữ liệu cũ nằm rải rác trên ổ và chiếm dung lượng. Thiết bị phải định kỳ thực hiện <strong>garbage collection (GC)</strong> để tìm các block này và giải phóng không gian cho các lần ghi trong tương lai; việc garbage collection quá mức sẽ làm tăng <strong>write amplification</strong> và giảm hiệu năng. Thứ hai là chi phí cao của bảng ánh xạ trong bộ nhớ; thiết bị càng lớn thì bảng này càng cần nhiều bộ nhớ. Chúng ta sẽ lần lượt thảo luận từng vấn đề.</p>
<h2 id="448-garbage-collection"><a class="header" href="#448-garbage-collection">44.8 Garbage Collection</a></h2>
<p>Chi phí đầu tiên của bất kỳ cách tiếp cận log-structured nào như thế này là việc tạo ra <strong>garbage</strong>, và do đó phải thực hiện <strong>garbage collection</strong> (tức là thu hồi các block chết – dead-block reclamation). Hãy tiếp tục sử dụng ví dụ trước để hiểu rõ hơn. Nhớ lại rằng các logical block 100, 101, 2000 và 2001 đã được ghi vào thiết bị.</p>
<p>Bây giờ, giả sử các block 100 và 101 được ghi lại, với nội dung <strong>c1</strong> và <strong>c2</strong>. Các thao tác ghi này được ghi vào các page trống tiếp theo (trong trường hợp này là physical page 4 và 5), và bảng ánh xạ được cập nhật tương ứng. Lưu ý rằng thiết bị phải <strong>erase</strong> block 1 trước để có thể thực hiện thao tác program này:</p>
<p>...</p>
<p>Vấn đề bây giờ đã rõ: physical page 0 và 1, mặc dù được đánh dấu <strong>VALID</strong>, thực chất chứa <strong>garbage</strong>, tức là các phiên bản cũ của block 100 và 101. Do bản chất log-structured của thiết bị, các thao tác overwrite tạo ra các block rác, và thiết bị phải thu hồi chúng để cung cấp không gian trống cho các lần ghi mới.</p>
<p>Quá trình tìm các block rác (còn gọi là <strong>dead block</strong>) và thu hồi chúng để sử dụng trong tương lai được gọi là <strong>garbage collection</strong>, và đây là một thành phần quan trọng của bất kỳ SSD hiện đại nào. Quy trình cơ bản rất đơn giản: tìm một block chứa một hoặc nhiều page rác, đọc các page <strong>live</strong> (không phải rác) từ block đó, ghi các page live này vào log, và (cuối cùng) thu hồi toàn bộ block để sử dụng cho việc ghi.</p>
<p>Hãy minh họa bằng một ví dụ. Thiết bị quyết định thu hồi các page chết trong block 0 ở trên. Block 0 có hai page chết (page 0 và 1) và hai page live (page 2 và 3, lần lượt chứa block 2000 và 2001). Để làm điều này, thiết bị sẽ:</p>
<ul>
<li>Đọc dữ liệu live (page 2 và 3) từ block 0</li>
<li>Ghi dữ liệu live vào cuối log</li>
<li>Erase block 0 (giải phóng nó để sử dụng sau này)</li>
</ul>
<p>Để garbage collector hoạt động, trong mỗi block phải có đủ thông tin để SSD xác định được mỗi page là <strong>live</strong> hay <strong>dead</strong>. Một cách tự nhiên để đạt được điều này là lưu, tại một vị trí nào đó trong mỗi block, thông tin về logical block nào được lưu trong mỗi page. Thiết bị sau đó có thể sử dụng bảng ánh xạ để xác định liệu mỗi page trong block có chứa dữ liệu live hay không.</p>
<p>Từ ví dụ trên (trước khi garbage collection diễn ra), block 0 chứa các logical block 100, 101, 2000, 2001. Bằng cách kiểm tra bảng ánh xạ (trước khi garbage collection, bảng này chứa 100→4, 101→5, 2000→2, 2001→3), thiết bị có thể dễ dàng xác định page nào trong block SSD chứa thông tin live. Ví dụ, page 2 và 3 rõ ràng vẫn được trỏ tới trong bảng ánh xạ; page 0 và 1 thì không, và do đó là ứng viên cho garbage collection.</p>
<p>Khi quá trình garbage collection này hoàn tất trong ví dụ của chúng ta, trạng thái của thiết bị sẽ là:</p>
<p>...</p>
<p>Như bạn có thể thấy, <strong>garbage collection</strong> (GC) có thể rất tốn kém, vì yêu cầu phải đọc và ghi lại dữ liệu <strong>live</strong> (dữ liệu còn sử dụng). Ứng viên lý tưởng để thu hồi là một block chỉ chứa toàn <strong>dead page</strong> (trang chết); trong trường hợp này, block có thể được <strong>erase</strong> (xóa) ngay lập tức và dùng cho dữ liệu mới, mà không cần thực hiện di chuyển dữ liệu tốn kém.</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: MỘT API LƯU TRỮ MỚI GỌI LÀ TRIM</strong><br />
Khi nghĩ về ổ cứng (hard drive), chúng ta thường chỉ nghĩ đến giao diện cơ bản nhất để đọc và ghi: <strong>read</strong> và <strong>write</strong> (thường cũng có một lệnh <strong>cache flush</strong> để đảm bảo dữ liệu ghi đã thực sự được lưu bền vững, nhưng đôi khi chúng ta bỏ qua để đơn giản hóa). Với <strong>log-structured SSD</strong>, và thực tế là bất kỳ thiết bị nào duy trì ánh xạ <strong>logical-to-physical block</strong> (từ block logic sang block vật lý) một cách linh hoạt và thay đổi, một giao diện mới trở nên hữu ích, được gọi là thao tác <code>trim</code>.</p>
<p>Thao tác <code>trim</code> nhận vào một địa chỉ (và có thể là một độ dài), và đơn giản là thông báo cho thiết bị rằng block (hoặc các block) được chỉ định bởi địa chỉ (và độ dài) đã bị xóa; thiết bị do đó không còn phải theo dõi bất kỳ thông tin nào về vùng địa chỉ này nữa. Đối với ổ cứng thông thường, <code>trim</code> không đặc biệt hữu ích, vì ổ đĩa có ánh xạ tĩnh từ địa chỉ block tới platter, track và sector cụ thể. Tuy nhiên, đối với <strong>log-structured SSD</strong>, việc biết rằng một block không còn cần thiết là rất hữu ích, vì SSD có thể xóa thông tin này khỏi FTL và sau đó thu hồi không gian vật lý trong quá trình garbage collection.</p>
<p>Mặc dù đôi khi chúng ta nghĩ giao diện (interface) và hiện thực (implementation) là hai thực thể tách biệt, nhưng trong trường hợp này, chúng ta thấy rằng hiện thực đã định hình giao diện. Với các ánh xạ phức tạp, việc biết block nào không còn cần thiết sẽ giúp hiện thực hiệu quả hơn.</p>
</blockquote>
</blockquote>
<p>Để giảm chi phí GC, một số SSD <strong>overprovision</strong> (dự phòng dư) [A+08]; bằng cách thêm dung lượng flash bổ sung, việc dọn dẹp có thể được trì hoãn và thực hiện ở chế độ nền, có thể vào thời điểm thiết bị ít bận rộn hơn. Việc thêm dung lượng cũng làm tăng <strong>băng thông nội bộ</strong> (internal bandwidth), có thể được sử dụng cho việc dọn dẹp và do đó không làm giảm băng thông mà client cảm nhận. Nhiều ổ đĩa hiện đại overprovision theo cách này, đây là một yếu tố quan trọng để đạt hiệu năng tổng thể xuất sắc.</p>
<h2 id="449-kích-thước-bảng-ánh-xạ-mapping-table-size"><a class="header" href="#449-kích-thước-bảng-ánh-xạ-mapping-table-size">44.9 Kích thước bảng ánh xạ (Mapping Table Size)</a></h2>
<p>Chi phí thứ hai của log-structuring là khả năng bảng ánh xạ trở nên cực kỳ lớn, với một mục (entry) cho mỗi page 4 KB của thiết bị. Ví dụ, với một SSD 1 TB, chỉ cần một entry 4 byte cho mỗi page 4 KB đã dẫn đến <strong>1 GB bộ nhớ</strong> cần thiết chỉ để lưu các ánh xạ này! Do đó, sơ đồ FTL ở mức page (page-level FTL) là không khả thi.</p>
<h3 id="block-based-mapping-Ánh-xạ-theo-block"><a class="header" href="#block-based-mapping-Ánh-xạ-theo-block">Block-Based Mapping (Ánh xạ theo block)</a></h3>
<p>Một cách tiếp cận để giảm chi phí ánh xạ là chỉ giữ một con trỏ cho mỗi block của thiết bị, thay vì cho mỗi page, từ đó giảm lượng thông tin ánh xạ theo tỷ lệ:</p>
<p>[
\frac{\text{block size}}{\text{page size}}
]</p>
<p>FTL ở mức block này tương tự như việc sử dụng kích thước page lớn hơn trong hệ thống <strong>virtual memory</strong> (bộ nhớ ảo); khi đó, bạn dùng ít bit hơn cho <strong>VPN</strong> (Virtual Page Number – số trang ảo) và có phần offset lớn hơn trong mỗi địa chỉ ảo.</p>
<p>Tuy nhiên, việc sử dụng block-based mapping bên trong một log-based FTL lại không hoạt động tốt về mặt hiệu năng. Vấn đề lớn nhất xuất hiện khi có một <strong>small write</strong> (ghi nhỏ) – tức là một thao tác ghi nhỏ hơn kích thước của một block vật lý. Trong trường hợp này, FTL phải đọc một lượng lớn dữ liệu live từ block cũ và sao chép nó sang block mới (cùng với dữ liệu từ thao tác ghi nhỏ). Việc sao chép dữ liệu này làm tăng <strong>write amplification</strong> đáng kể và do đó làm giảm hiệu năng.</p>
<p>Để làm rõ vấn đề này, hãy xem một ví dụ. Giả sử client trước đó đã ghi các logical block 2000, 2001, 2002 và 2003 (với nội dung a, b, c, d), và chúng được lưu trong <strong>physical block</strong> 1 tại các <strong>physical page</strong> 4, 5, 6 và 7. Với ánh xạ theo page (per-page mapping), bảng dịch sẽ phải ghi nhận bốn ánh xạ cho các logical block này:<br />
2000 → 4, 2001 → 5, 2002 → 6, 2003 → 7.</p>
<p>Nếu thay vào đó, chúng ta sử dụng block-level mapping, FTL chỉ cần ghi nhận <strong>một</strong> ánh xạ địa chỉ cho toàn bộ dữ liệu này. Tuy nhiên, ánh xạ địa chỉ sẽ hơi khác so với các ví dụ trước. Cụ thể, chúng ta coi không gian địa chỉ logic của thiết bị được chia thành các <strong>chunk</strong> có kích thước bằng các block vật lý trong flash. Do đó, <strong>logical block address</strong> sẽ bao gồm hai phần: <strong>chunk number</strong> (số thứ tự chunk) và <strong>offset</strong> (độ lệch). Vì giả sử có bốn logical block nằm trong mỗi physical block, phần offset của địa chỉ logic cần 2 bit; các bit còn lại (bit có trọng số cao hơn) tạo thành chunk number.</p>
<p>Các logical block 2000, 2001, 2002 và 2003 đều có cùng chunk number (500), và có các offset khác nhau (0, 1, 2 và 3, tương ứng). Do đó, với block-level mapping, FTL ghi nhận rằng chunk 500 ánh xạ tới block 1 (bắt đầu tại physical page 4), như minh họa trong sơ đồ sau:</p>
<p>...</p>
<p>Trong một <strong>block-based FTL</strong> (FTL ánh xạ theo block), thao tác đọc là khá đơn giản. Trước tiên, FTL trích xuất <strong>chunk number</strong> (số thứ tự chunk) từ <strong>logical block address</strong> (địa chỉ block logic) mà client gửi đến, bằng cách lấy các bit cao nhất của địa chỉ. Sau đó, FTL tra cứu ánh xạ từ chunk number sang <strong>physical page</strong> (trang vật lý) trong bảng ánh xạ. Cuối cùng, FTL tính toán địa chỉ của flash page cần đọc bằng cách cộng <strong>offset</strong> (độ lệch) từ địa chỉ logic vào địa chỉ vật lý của block.</p>
<p>Ví dụ, nếu client gửi yêu cầu đọc tới địa chỉ logic 2002, thiết bị sẽ trích xuất chunk number logic (500), tra cứu bảng ánh xạ (tìm được giá trị 4), và cộng offset từ địa chỉ logic (2) vào giá trị ánh xạ (4). Kết quả là địa chỉ physical page (6) – nơi dữ liệu được lưu; FTL sau đó có thể phát lệnh đọc tới địa chỉ vật lý này và lấy về dữ liệu mong muốn (c).</p>
<p>Nhưng nếu client ghi vào logical block 2002 (với nội dung c’) thì sao? Trong trường hợp này, FTL phải đọc các block 2000, 2001 và 2003, sau đó ghi lại cả bốn logical block này vào một vị trí mới, đồng thời cập nhật bảng ánh xạ. Block 1 (nơi dữ liệu từng được lưu) sau đó có thể được erase và tái sử dụng, như minh họa dưới đây.</p>
<p>...</p>
<p>Như bạn có thể thấy từ ví dụ này, mặc dù ánh xạ ở mức block giúp giảm đáng kể lượng bộ nhớ cần cho việc dịch địa chỉ, nhưng nó lại gây ra các vấn đề hiệu năng nghiêm trọng khi các thao tác ghi nhỏ hơn kích thước block vật lý của thiết bị; vì các block vật lý thực tế có thể lớn tới 256KB hoặc hơn, nên các thao tác ghi nhỏ như vậy rất dễ xảy ra thường xuyên. Do đó, cần có một giải pháp tốt hơn. Bạn có cảm nhận được đây là đoạn trong chương mà chúng tôi sẽ tiết lộ giải pháp đó không? Hoặc tốt hơn, bạn có thể tự tìm ra trước khi đọc tiếp?</p>
<h3 id="hybrid-mapping-Ánh-xạ-lai"><a class="header" href="#hybrid-mapping-Ánh-xạ-lai">Hybrid Mapping (Ánh xạ lai)</a></h3>
<p>Để cho phép ghi linh hoạt nhưng vẫn giảm chi phí ánh xạ, nhiều FTL hiện đại áp dụng kỹ thuật <strong>hybrid mapping</strong> (ánh xạ lai). Với cách tiếp cận này, FTL giữ sẵn một vài block đã được erase và hướng tất cả các thao tác ghi vào đó; các block này được gọi là <strong>log block</strong>. Vì FTL muốn có khả năng ghi bất kỳ page nào vào bất kỳ vị trí nào trong log block mà không cần thực hiện toàn bộ thao tác sao chép dữ liệu như trong ánh xạ thuần block-based, nó sẽ duy trì ánh xạ ở mức page cho các log block này.</p>
<p>Do đó, về mặt logic, FTL có hai loại bảng ánh xạ trong bộ nhớ:</p>
<ul>
<li>Một tập nhỏ các ánh xạ theo page trong bảng gọi là <strong>log table</strong></li>
<li>Một tập lớn hơn các ánh xạ theo block trong bảng gọi là <strong>data table</strong></li>
</ul>
<p>Khi tìm kiếm một logical block cụ thể, FTL sẽ tra cứu log table trước; nếu không tìm thấy vị trí của logical block trong đó, FTL sẽ tra cứu data table để tìm vị trí và sau đó truy cập dữ liệu được yêu cầu.</p>
<p>Yếu tố then chốt của chiến lược hybrid mapping là giữ số lượng log block ở mức nhỏ. Để làm được điều này, FTL phải định kỳ kiểm tra các log block (vốn có con trỏ cho từng page) và chuyển chúng thành các block có thể được trỏ tới chỉ bằng một con trỏ block duy nhất. Việc chuyển đổi này được thực hiện bằng một trong ba kỹ thuật chính, dựa trên nội dung của block [KK+02].</p>
<p>Ví dụ, giả sử FTL trước đó đã ghi các logical page 1000, 1001, 1002 và 1003, và đặt chúng vào <strong>physical block</strong> 2 (các physical page 8, 9, 10, 11); giả sử nội dung ghi vào 1000, 1001, 1002 và 1003 lần lượt là a, b, c và d.</p>
<p>...</p>
<p>Bây giờ giả sử client ghi đè từng block này (với dữ liệu a’, b’, c’ và d’), theo đúng thứ tự như trước, vào một trong các log block hiện có, giả sử là physical block 0 (các physical page 0, 1, 2, 3). Trong trường hợp này, FTL sẽ có trạng thái như sau:</p>
<p>...</p>
<p>Vì các block này đã được ghi chính xác theo cùng một cách như trước, FTL có thể thực hiện kỹ thuật gọi là <strong>switch merge</strong>. Trong trường hợp này, log block (0) giờ trở thành nơi lưu trữ cho các block 0, 1, 2 và 3, và được trỏ tới bởi một con trỏ block duy nhất; block cũ (2) sẽ được erase và sử dụng làm log block. Trong kịch bản tốt nhất này, tất cả các con trỏ theo page cần thiết được thay thế bằng một con trỏ block duy nhất.</p>
<p>...</p>
<p>Trường hợp <strong>switch merge</strong> là tình huống tốt nhất đối với một <strong>hybrid FTL</strong> (FTL lai). Thật không may, đôi khi FTL không gặp may như vậy. Hãy tưởng tượng trường hợp chúng ta có cùng điều kiện ban đầu (các <strong>logical block</strong> 1000 … 1003 được lưu trong <strong>physical block</strong> 2) nhưng sau đó client ghi đè lên logical block 1000 và 1001. Bạn nghĩ điều gì sẽ xảy ra trong trường hợp này? Tại sao việc xử lý lại khó khăn hơn? (hãy suy nghĩ trước khi xem kết quả ở trang tiếp theo)</p>
<p>...</p>
<p>Để hợp nhất các page còn lại của physical block này, và do đó có thể tham chiếu đến chúng chỉ bằng một <strong>block pointer</strong> duy nhất, FTL thực hiện thao tác gọi là <strong>partial merge</strong> (hợp nhất một phần). Trong thao tác này, các logical block 1002 và 1003 được đọc từ physical block 2, sau đó được <strong>append</strong> (nối thêm) vào log. Trạng thái cuối cùng của SSD giống như trong trường hợp switch merge ở trên; tuy nhiên, trong trường hợp này, FTL phải thực hiện thêm các thao tác I/O để đạt được mục tiêu, do đó làm tăng <strong>write amplification</strong> (khuếch đại ghi).</p>
<p>Trường hợp cuối cùng mà FTL gặp phải được gọi là <strong>full merge</strong> (hợp nhất toàn phần), và yêu cầu nhiều công việc hơn nữa. Trong trường hợp này, FTL phải tập hợp các page từ nhiều block khác nhau để thực hiện <strong>cleaning</strong> (dọn dẹp). Ví dụ, hãy tưởng tượng rằng các logical block 0, 4, 8 và 12 được ghi vào log block A. Để chuyển log block này thành một block được ánh xạ theo block (block-mapped), FTL trước tiên phải tạo ra một <strong>data block</strong> chứa các logical block 0, 1, 2 và 3, do đó FTL phải đọc 1, 2 và 3 từ nơi khác rồi ghi lại 0, 1, 2 và 3 cùng nhau. Tiếp theo, quá trình merge phải thực hiện tương tự cho logical block 4, tìm 5, 6 và 7 và hợp nhất chúng thành một physical block duy nhất. Điều tương tự phải được thực hiện cho logical block 8 và 12, và sau đó (cuối cùng), log block A mới có thể được giải phóng. Việc full merge xảy ra thường xuyên, như không có gì ngạc nhiên, có thể gây hại nghiêm trọng cho hiệu năng và do đó nên tránh bất cứ khi nào có thể [GY+09].</p>
<h3 id="page-mapping-plus-caching-Ánh-xạ-theo-page-kết-hợp-bộ-nhớ-đệm"><a class="header" href="#page-mapping-plus-caching-Ánh-xạ-theo-page-kết-hợp-bộ-nhớ-đệm">Page Mapping Plus Caching (Ánh xạ theo page kết hợp bộ nhớ đệm)</a></h3>
<p>Với sự phức tạp của phương pháp hybrid ở trên, một số người đã đề xuất những cách đơn giản hơn để giảm tải bộ nhớ của các FTL ánh xạ theo page (<strong>page-mapped FTL</strong>). Có lẽ cách đơn giản nhất là chỉ lưu trong bộ nhớ các phần <strong>active</strong> (đang hoạt động) của FTL, từ đó giảm lượng bộ nhớ cần thiết [GY+09].</p>
<p>Cách tiếp cận này có thể hoạt động tốt. Ví dụ, nếu một workload nhất định chỉ truy cập một tập nhỏ các page, các ánh xạ của những page này sẽ được lưu trong FTL trong bộ nhớ, và hiệu năng sẽ rất tốt mà không tốn nhiều bộ nhớ. Tất nhiên, cách tiếp cận này cũng có thể hoạt động kém. Nếu bộ nhớ không thể chứa <strong>working set</strong> (tập làm việc) của các ánh xạ cần thiết, mỗi lần truy cập sẽ tối thiểu yêu cầu một lần đọc flash bổ sung để nạp ánh xạ bị thiếu trước khi có thể truy cập dữ liệu. Tệ hơn nữa, để tạo chỗ cho ánh xạ mới, FTL có thể phải <strong>evict</strong> (loại bỏ) một ánh xạ cũ, và nếu ánh xạ đó là <strong>dirty</strong> (tức là chưa được ghi bền vững xuống flash), sẽ phát sinh thêm một lần ghi. Tuy nhiên, trong nhiều trường hợp, workload sẽ thể hiện tính <strong>locality</strong> (tính cục bộ), và cách tiếp cận caching này vừa giảm chi phí bộ nhớ vừa duy trì hiệu năng cao.</p>
<h2 id="4410-wear-leveling-cân-bằng-hao-mòn"><a class="header" href="#4410-wear-leveling-cân-bằng-hao-mòn">44.10 Wear Leveling (Cân bằng hao mòn)</a></h2>
<p>Cuối cùng, một hoạt động nền liên quan mà các FTL hiện đại phải triển khai là <strong>wear leveling</strong> (cân bằng hao mòn), như đã giới thiệu ở trên. Ý tưởng cơ bản rất đơn giản: vì nhiều chu kỳ <strong>erase/program</strong> sẽ làm mòn một flash block, FTL nên cố gắng phân bổ đều công việc này trên tất cả các block của thiết bị. Bằng cách này, tất cả các block sẽ bị mòn gần như cùng lúc, thay vì chỉ một vài block “phổ biến” nhanh chóng trở nên không sử dụng được.</p>
<p>Cách tiếp cận log-structuring cơ bản thực hiện khá tốt việc phân bổ tải ghi ban đầu, và garbage collection cũng giúp ích. Tuy nhiên, đôi khi một block sẽ chứa dữ liệu sống lâu dài (long-lived data) mà không bị ghi đè; trong trường hợp này, garbage collection sẽ không bao giờ thu hồi block đó, và do đó nó không nhận được phần tải ghi công bằng.</p>
<p>Để khắc phục vấn đề này, FTL phải định kỳ đọc toàn bộ dữ liệu live từ các block như vậy và ghi lại chúng ở nơi khác, từ đó làm cho block sẵn sàng để ghi mới. Quá trình wear leveling này làm tăng <strong>write amplification</strong> của SSD, và do đó giảm hiệu năng vì cần thêm I/O để đảm bảo tất cả các block bị mòn ở tốc độ gần như nhau. Có nhiều thuật toán khác nhau đã được công bố trong tài liệu [A+08, M+14]; bạn có thể tìm hiểu thêm nếu quan tâm.</p>
<h2 id="4411-hiệu-năng-và-chi-phí-của-ssd-ssd-performance-and-cost"><a class="header" href="#4411-hiệu-năng-và-chi-phí-của-ssd-ssd-performance-and-cost">44.11 Hiệu năng và chi phí của SSD (SSD Performance And Cost)</a></h2>
<p>Trước khi kết thúc, hãy xem xét hiệu năng và chi phí của các SSD hiện đại, để hiểu rõ hơn cách chúng có thể được sử dụng trong các hệ thống lưu trữ bền vững (persistent storage systems). Trong cả hai khía cạnh này, chúng ta sẽ so sánh với ổ đĩa cứng truyền thống (<strong>HDD</strong> – Hard Disk Drive) và làm nổi bật những khác biệt lớn nhất giữa chúng.</p>
<h3 id="hiệu-năng-performance"><a class="header" href="#hiệu-năng-performance">Hiệu năng (Performance)</a></h3>
<p>Không giống như ổ đĩa cứng, <strong>SSD</strong> dựa trên flash không có thành phần cơ khí, và trên thực tế, ở nhiều khía cạnh chúng giống <strong>DRAM</strong> hơn, vì chúng là các thiết bị <strong>random access</strong> (truy cập ngẫu nhiên). Sự khác biệt lớn nhất về hiệu năng, so với ổ đĩa cứng, thể hiện rõ khi thực hiện các thao tác đọc và ghi ngẫu nhiên; trong khi một ổ đĩa cứng thông thường chỉ có thể thực hiện vài trăm I/O ngẫu nhiên mỗi giây, SSD có thể làm tốt hơn nhiều. Ở đây, chúng ta sử dụng một số dữ liệu từ các SSD hiện đại để thấy SSD thực sự nhanh hơn bao nhiêu; chúng ta đặc biệt quan tâm đến việc <strong>FTL</strong> (Flash Translation Layer – lớp dịch địa chỉ flash) che giấu các vấn đề hiệu năng của chip flash thô tốt đến mức nào.</p>
<p><strong>Bảng 44.4</strong> cho thấy một số dữ liệu hiệu năng của ba SSD khác nhau và một ổ đĩa cứng cao cấp; dữ liệu được lấy từ một số nguồn trực tuyến [S13, T15]. Hai cột bên trái thể hiện hiệu năng I/O ngẫu nhiên, và hai cột bên phải thể hiện hiệu năng tuần tự; ba hàng đầu tiên là dữ liệu của ba SSD khác nhau (từ Samsung, Seagate và Intel), và hàng cuối cùng là hiệu năng của một ổ đĩa cứng (HDD), trong trường hợp này là một ổ Seagate cao cấp.</p>
<p><img src="44/img/fig44_4.PNG" alt="" /></p>
<p><strong>Hình 44.4: So sánh hiệu năng giữa SSD và HDD (SSDs And Hard Drives: Performance Comparison)</strong></p>
<p>Từ bảng này, chúng ta có thể rút ra một số điểm thú vị.<br />
Thứ nhất, và rõ ràng nhất, là sự khác biệt về hiệu năng I/O ngẫu nhiên giữa SSD và ổ đĩa cứng duy nhất trong bảng. Trong khi SSD đạt hàng chục hoặc thậm chí hàng trăm MB/s trong các thao tác I/O ngẫu nhiên, thì ổ đĩa cứng “hiệu năng cao” này chỉ đạt tối đa khoảng vài MB/s (thực tế, chúng tôi đã làm tròn lên để được 2 MB/s).</p>
<p>Thứ hai, bạn có thể thấy rằng về hiệu năng tuần tự, sự khác biệt ít hơn nhiều; mặc dù SSD vẫn nhanh hơn, nhưng ổ đĩa cứng vẫn là lựa chọn tốt nếu tất cả những gì bạn cần là hiệu năng tuần tự.</p>
<p>Thứ ba, bạn có thể thấy rằng hiệu năng đọc ngẫu nhiên của SSD không tốt bằng hiệu năng ghi ngẫu nhiên. Lý do cho hiệu năng ghi ngẫu nhiên tốt một cách bất ngờ này là nhờ thiết kế <strong>log-structured</strong> (cấu trúc nhật ký) của nhiều SSD, biến các thao tác ghi ngẫu nhiên thành ghi tuần tự và cải thiện hiệu năng.</p>
<p>Cuối cùng, vì SSD vẫn thể hiện sự khác biệt nhất định giữa I/O tuần tự và I/O ngẫu nhiên, nhiều kỹ thuật trong các chương về cách xây dựng file system cho ổ đĩa cứng vẫn áp dụng được cho SSD [AD14b]; mặc dù mức độ chênh lệch giữa I/O tuần tự và I/O ngẫu nhiên nhỏ hơn, nhưng khoảng cách này vẫn đủ để cân nhắc kỹ lưỡng khi thiết kế file system nhằm giảm I/O ngẫu nhiên.</p>
<h3 id="chi-phí-cost"><a class="header" href="#chi-phí-cost">Chi phí (Cost)</a></h3>
<p>Như chúng ta đã thấy ở trên, hiệu năng của SSD vượt xa ổ đĩa cứng hiện đại, ngay cả khi thực hiện I/O tuần tự. Vậy tại sao SSD chưa hoàn toàn thay thế ổ đĩa cứng như là phương tiện lưu trữ phổ biến? Câu trả lời rất đơn giản: <strong>chi phí</strong>, hay cụ thể hơn là <strong>chi phí trên mỗi đơn vị dung lượng</strong>.</p>
<p>Hiện tại [A15], một SSD có giá khoảng 150 USD cho dung lượng 250 GB; tức là khoảng 0,60 USD cho mỗi GB. Một ổ đĩa cứng thông thường có giá khoảng 50 USD cho dung lượng 1 TB, tức là khoảng 0,05 USD cho mỗi GB. Như vậy, vẫn tồn tại sự chênh lệch hơn 10 lần về chi phí giữa hai loại phương tiện lưu trữ này.</p>
<p>Sự khác biệt về hiệu năng và chi phí này quyết định cách các hệ thống lưu trữ quy mô lớn được xây dựng. Nếu hiệu năng là mối quan tâm chính, SSD là lựa chọn tuyệt vời, đặc biệt nếu hiệu năng đọc ngẫu nhiên là quan trọng. Ngược lại, nếu bạn đang xây dựng một trung tâm dữ liệu lớn và muốn lưu trữ khối lượng thông tin khổng lồ, sự chênh lệch chi phí lớn sẽ khiến bạn nghiêng về ổ đĩa cứng.</p>
<p>Tất nhiên, một cách tiếp cận <strong>lai</strong> (hybrid) có thể hợp lý – một số hệ thống lưu trữ hiện nay được xây dựng với cả SSD và ổ đĩa cứng, sử dụng một số lượng nhỏ SSD cho dữ liệu “nóng” (hot data) được truy cập thường xuyên để đạt hiệu năng cao, trong khi lưu trữ phần dữ liệu “lạnh” (cold data) ít được sử dụng hơn trên ổ đĩa cứng để tiết kiệm chi phí. Chừng nào khoảng cách về giá vẫn tồn tại, ổ đĩa cứng vẫn sẽ tiếp tục được sử dụng.</p>
<h2 id="4412-tóm-tắt-summary"><a class="header" href="#4412-tóm-tắt-summary">44.12 Tóm tắt (Summary)</a></h2>
<p>Các <strong>SSD</strong> (Solid-State Drive – ổ lưu trữ thể rắn) dựa trên flash đang trở nên phổ biến trong laptop, desktop và cả các máy chủ bên trong các trung tâm dữ liệu (datacenter) – nơi vận hành nền kinh tế toàn cầu. Vì vậy, bạn nên biết đôi điều về chúng, đúng không?</p>
<p>Tin không vui là: chương này (giống như nhiều chương khác trong cuốn sách này) chỉ là bước khởi đầu để hiểu về công nghệ tiên tiến hiện nay. Một số nguồn để tìm hiểu thêm về công nghệ flash thô bao gồm các nghiên cứu về hiệu năng thực tế của thiết bị (ví dụ như của Chen et al. [CK+09] và Grupp et al. [GC+09]), các vấn đề trong thiết kế <strong>FTL</strong> (Flash Translation Layer – lớp dịch địa chỉ flash) (bao gồm các công trình của Agrawal et al. [A+08], Gupta et al. [GY+09], Huang et al. [H+14], Kim et al. [KK+02], Lee et al. [L+07], và Zhang et al. [Z+12]), và thậm chí cả các hệ thống phân tán sử dụng flash (bao gồm Gordon [CG+09] và CORFU [B+12]). Và, nếu được phép gợi ý, một cái nhìn tổng quan rất hay về tất cả những gì bạn cần làm để khai thác hiệu năng cao từ SSD có thể tìm thấy trong bài báo về “unwritten contract” [HK+17].</p>
<p>Đừng chỉ đọc các bài báo học thuật; hãy đọc cả những thông tin về các tiến bộ gần đây trên báo chí phổ thông (ví dụ: [V12]). Ở đó, bạn sẽ biết thêm những thông tin thực tiễn (nhưng vẫn hữu ích), chẳng hạn như việc Samsung sử dụng cả cell <strong>TLC</strong> và <strong>SLC</strong> trong cùng một SSD để tối đa hóa hiệu năng (SLC có thể buffer dữ liệu ghi nhanh) cũng như dung lượng (TLC có thể lưu nhiều bit hơn trên mỗi cell). Và như người ta thường nói, đây mới chỉ là “phần nổi của tảng băng”. Hãy tự mình tìm hiểu sâu hơn về “tảng băng” nghiên cứu này, có thể bắt đầu với bản khảo sát xuất sắc và gần đây của Ma et al. [M+14]. Nhưng hãy cẩn thận; ngay cả những con tàu vĩ đại nhất cũng có thể bị đánh chìm bởi tảng băng [W15].</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: CÁC THUẬT NGỮ CHÍNH VỀ SSD (KEY SSD TERMS)</strong></p>
<ul>
<li>Một <strong>flash chip</strong> (chip flash) bao gồm nhiều <strong>bank</strong>, mỗi bank được tổ chức thành các <strong>erase block</strong> (khối xóa, đôi khi chỉ gọi là block). Mỗi block lại được chia nhỏ thành một số lượng <strong>page</strong> nhất định.</li>
<li>Block có kích thước lớn (128KB–2MB) và chứa nhiều page, vốn có kích thước nhỏ hơn nhiều (1KB–8KB).</li>
<li>Để đọc từ flash, phát lệnh <strong>read</strong> kèm địa chỉ và độ dài; điều này cho phép client đọc một hoặc nhiều page.</li>
<li>Việc ghi vào flash phức tạp hơn. Trước tiên, client phải <strong>erase</strong> toàn bộ block (xóa toàn bộ thông tin trong block). Sau đó, client có thể <strong>program</strong> (lập trình) mỗi page đúng một lần, hoàn tất thao tác ghi.</li>
<li>Một thao tác mới là <code>trim</code> rất hữu ích để thông báo cho thiết bị biết khi một block (hoặc một dải block) không còn cần thiết nữa.</li>
<li>Độ tin cậy của flash chủ yếu được quyết định bởi <strong>wear out</strong> (hao mòn); nếu một block bị erase và program quá thường xuyên, nó sẽ trở nên không sử dụng được.</li>
<li>Một thiết bị lưu trữ thể rắn dựa trên flash (SSD) hoạt động như một ổ đĩa đọc/ghi dựa trên block thông thường; bằng cách sử dụng <strong>FTL</strong>, nó chuyển đổi các thao tác đọc và ghi từ client thành các thao tác đọc, erase và program trên các chip flash bên dưới.</li>
<li>Hầu hết các FTL đều có cấu trúc <strong>log-structured</strong>, giúp giảm chi phí ghi bằng cách tối thiểu hóa số chu kỳ erase/program. Một lớp dịch địa chỉ trong bộ nhớ sẽ theo dõi vị trí các ghi logic trên phương tiện vật lý.</li>
<li>Một vấn đề chính của FTL log-structured là chi phí <strong>garbage collection</strong> (thu gom rác), dẫn đến <strong>write amplification</strong> (khuếch đại ghi).</li>
<li>Một vấn đề khác là kích thước của <strong>mapping table</strong> (bảng ánh xạ), vốn có thể trở nên rất lớn. Sử dụng <strong>hybrid mapping</strong> (ánh xạ lai) hoặc chỉ cache các phần “nóng” của FTL là những cách khắc phục khả thi.</li>
<li>Vấn đề cuối cùng là <strong>wear leveling</strong> (cân bằng hao mòn); FTL đôi khi phải di chuyển dữ liệu từ các block chủ yếu được đọc để đảm bảo các block này cũng nhận được phần tải erase/program tương ứng.  </li>
</ul>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="45-tính-toàn-vẹn-và-bảo-vệ-dữ-liệu-data-integrity-and-protection"><a class="header" href="#45-tính-toàn-vẹn-và-bảo-vệ-dữ-liệu-data-integrity-and-protection">45. Tính toàn vẹn và bảo vệ dữ liệu (Data Integrity and Protection)</a></h1>
<p>Bên cạnh những cải tiến cơ bản đã được tìm thấy trong các <strong>file system</strong> (hệ thống tệp) mà chúng ta đã nghiên cứu cho đến nay, vẫn còn một số tính năng đáng để tìm hiểu. Trong chương này, chúng ta sẽ một lần nữa tập trung vào <strong>độ tin cậy</strong> (reliability) (trước đây đã nghiên cứu về độ tin cậy của hệ thống lưu trữ trong chương về <strong>RAID</strong>). Cụ thể, một file system hoặc hệ thống lưu trữ nên làm gì để đảm bảo dữ liệu được an toàn, xét đến bản chất không đáng tin cậy của các thiết bị lưu trữ hiện đại?</p>
<p>Lĩnh vực tổng quát này được gọi là <strong>data integrity</strong> (tính toàn vẹn dữ liệu) hoặc <strong>data protection</strong> (bảo vệ dữ liệu). Do đó, chúng ta sẽ tìm hiểu các kỹ thuật được sử dụng để đảm bảo rằng dữ liệu bạn đưa vào hệ thống lưu trữ sẽ vẫn giữ nguyên khi hệ thống lưu trữ trả lại cho bạn.</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ ĐẢM BẢO TÍNH TOÀN VẸN DỮ LIỆU</strong><br />
Hệ thống nên làm gì để đảm bảo dữ liệu được ghi xuống lưu trữ được bảo vệ? Cần những kỹ thuật nào? Làm thế nào để các kỹ thuật này hoạt động hiệu quả, với chi phí về không gian và thời gian thấp?</p>
</blockquote>
</blockquote>
<h2 id="451-các-dạng-lỗi-của-đĩa-disk-failure-modes"><a class="header" href="#451-các-dạng-lỗi-của-đĩa-disk-failure-modes">45.1 Các dạng lỗi của đĩa (Disk Failure Modes)</a></h2>
<p>Như bạn đã học trong chương về <strong>RAID</strong>, đĩa không hoàn hảo và đôi khi có thể bị hỏng. Trong các hệ thống RAID ban đầu, mô hình lỗi khá đơn giản: hoặc toàn bộ đĩa hoạt động, hoặc nó hỏng hoàn toàn, và việc phát hiện lỗi như vậy là khá đơn giản. Mô hình lỗi <strong>fail-stop</strong> (ngừng hoạt động hoàn toàn) này khiến việc xây dựng RAID trở nên tương đối dễ dàng [S90].</p>
<p>Điều mà bạn chưa được học là còn nhiều dạng lỗi khác mà các ổ đĩa hiện đại có thể gặp phải. Cụ thể, như Bairavasundaram và cộng sự đã nghiên cứu chi tiết [B+07, B+08], các ổ đĩa hiện đại đôi khi vẫn hoạt động gần như bình thường nhưng lại gặp khó khăn khi truy cập thành công một hoặc nhiều block. Đặc biệt, có hai loại lỗi <strong>single-block</strong> (trên một block đơn) phổ biến và đáng để xem xét: <strong>latent sector errors</strong> (LSE – lỗi sector tiềm ẩn) và <strong>block corruption</strong> (hỏng block). Chúng ta sẽ thảo luận chi tiết từng loại.</p>
<p>...</p>
<p><img src="45/img/fig45_1.PNG" alt="" /></p>
<p><strong>Hình 45.1: Tần suất xuất hiện của LSE và Block Corruption</strong></p>
<p><strong>LSE</strong> xảy ra khi một sector (hoặc nhóm sector) của đĩa bị hỏng theo một cách nào đó. Ví dụ, nếu <strong>đầu đọc/ghi</strong> của đĩa chạm vào bề mặt vì một lý do nào đó (<strong>head crash</strong> – sự cố đầu đọc, điều vốn không nên xảy ra trong vận hành bình thường), nó có thể làm hỏng bề mặt, khiến các bit không thể đọc được. <strong>Tia vũ trụ</strong> (cosmic rays) cũng có thể làm lật bit, dẫn đến nội dung sai. May mắn thay, <strong>in-disk error correcting codes</strong> (ECC – mã sửa lỗi tích hợp trong đĩa) được ổ đĩa sử dụng để xác định liệu các bit trên đĩa trong một block có đúng hay không, và trong một số trường hợp có thể sửa chúng; nếu dữ liệu không đúng và ổ đĩa không có đủ thông tin để sửa lỗi, ổ sẽ trả về lỗi khi có yêu cầu đọc.</p>
<p>Cũng có những trường hợp một block của đĩa bị hỏng theo cách mà chính ổ đĩa không thể phát hiện. Ví dụ, <strong>firmware</strong> của ổ đĩa bị lỗi có thể ghi một block vào sai vị trí; trong trường hợp này, ECC của ổ đĩa cho biết nội dung block là “tốt”, nhưng từ góc nhìn của client thì block sai sẽ được trả về khi truy cập. Tương tự, một block có thể bị hỏng khi nó được truyền từ host tới ổ đĩa qua một <strong>bus</strong> bị lỗi; dữ liệu bị hỏng này sẽ được ổ đĩa lưu lại, nhưng không phải là dữ liệu mà client mong muốn. Những loại lỗi này đặc biệt nguy hiểm vì chúng là <strong>silent faults</strong> (lỗi im lặng); ổ đĩa không đưa ra bất kỳ dấu hiệu nào về vấn đề khi trả về dữ liệu bị lỗi.</p>
<p>Prabhakaran và cộng sự mô tả quan điểm hiện đại hơn về lỗi đĩa này là <strong>mô hình lỗi fail-partial</strong> (fail-partial disk failure model) [P+05]. Trong mô hình này, đĩa vẫn có thể hỏng hoàn toàn (giống như trong mô hình <strong>fail-stop</strong> truyền thống); tuy nhiên, đĩa cũng có thể trông như vẫn hoạt động bình thường nhưng lại có một hoặc nhiều block trở nên không thể truy cập được (tức là <strong>LSE</strong> – <em>latent sector error</em>, lỗi sector tiềm ẩn) hoặc chứa nội dung sai (tức là <strong>corruption</strong> – hỏng dữ liệu). Do đó, khi truy cập một đĩa có vẻ đang hoạt động, đôi khi nó có thể trả về lỗi khi cố đọc hoặc ghi một block nhất định (<strong>non-silent partial fault</strong> – lỗi bộ phận không im lặng), và đôi khi nó có thể đơn giản trả về dữ liệu sai (<strong>silent partial fault</strong> – lỗi bộ phận im lặng).</p>
<p>Cả hai loại lỗi này đều tương đối hiếm, nhưng thực sự hiếm đến mức nào? <strong>Hình 45.1</strong> tóm tắt một số phát hiện từ hai nghiên cứu của Bairavasundaram [B+07, B+08].</p>
<p>Hình này cho thấy tỷ lệ phần trăm ổ đĩa xuất hiện ít nhất một LSE hoặc một lỗi hỏng block trong suốt thời gian nghiên cứu (khoảng 3 năm, trên hơn 1,5 triệu ổ đĩa). Hình cũng chia nhỏ kết quả thành hai loại: ổ “rẻ” (thường là ổ SATA) và ổ “đắt” (thường là ổ SCSI hoặc Fibre Channel). Như bạn có thể thấy, mặc dù mua ổ chất lượng cao hơn giúp giảm tần suất của cả hai loại vấn đề (khoảng một bậc độ lớn – <em>order of magnitude</em>), nhưng chúng vẫn xảy ra đủ thường xuyên để bạn cần cân nhắc kỹ cách xử lý trong hệ thống lưu trữ của mình.</p>
<p>Một số phát hiện bổ sung về <strong>LSE</strong>:</p>
<ul>
<li>Ổ đắt tiền có nhiều hơn một LSE có khả năng phát sinh thêm lỗi tương đương với ổ rẻ tiền.</li>
<li>Đối với hầu hết các ổ, tỷ lệ lỗi hàng năm tăng lên trong năm thứ hai.</li>
<li>Số lượng LSE tăng theo kích thước đĩa.</li>
<li>Hầu hết các ổ có LSE đều có ít hơn 50 lỗi.</li>
<li>Ổ có LSE có khả năng phát sinh thêm LSE cao hơn.</li>
<li>Tồn tại mức độ đáng kể của <strong>spatial locality</strong> (tính cục bộ không gian) và <strong>temporal locality</strong> (tính cục bộ thời gian).</li>
<li><strong>Disk scrubbing</strong> (quét đĩa định kỳ) là hữu ích (hầu hết LSE được phát hiện theo cách này).</li>
</ul>
<p>Một số phát hiện về <strong>corruption</strong> (hỏng dữ liệu):</p>
<ul>
<li>Xác suất hỏng dữ liệu thay đổi rất nhiều giữa các model ổ khác nhau trong cùng một loại ổ.</li>
<li>Ảnh hưởng của tuổi thọ khác nhau giữa các model.</li>
<li><strong>Workload</strong> (tải công việc) và kích thước đĩa có ít tác động đến corruption.</li>
<li>Hầu hết các ổ bị corruption chỉ có một vài lỗi hỏng.</li>
<li>Corruption không độc lập trong cùng một ổ hoặc giữa các ổ trong RAID.</li>
<li>Tồn tại <strong>spatial locality</strong> và một phần <strong>temporal locality</strong>.</li>
<li>Có mối tương quan yếu giữa corruption và LSE.</li>
</ul>
<p>Để tìm hiểu thêm về các lỗi này, bạn nên đọc các bài báo gốc [B+07, B+08]. Nhưng hy vọng rằng điểm chính đã rõ: nếu bạn thực sự muốn xây dựng một hệ thống lưu trữ đáng tin cậy, bạn phải tích hợp cơ chế để <strong>phát hiện</strong> và <strong>khôi phục</strong> cả LSE và block corruption.</p>
<h2 id="452-xử-lý-lỗi-sector-tiềm-ẩn-handling-latent-sector-errors"><a class="header" href="#452-xử-lý-lỗi-sector-tiềm-ẩn-handling-latent-sector-errors">45.2 Xử lý lỗi sector tiềm ẩn (Handling Latent Sector Errors)</a></h2>
<p>Với hai dạng lỗi bộ phận (partial disk failure) mới này, chúng ta cần xem có thể làm gì để xử lý chúng. Trước tiên, hãy giải quyết dạng dễ hơn, đó là <strong>latent sector errors</strong> (LSE – lỗi sector tiềm ẩn).</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: CÁCH XỬ LÝ LỖI SECTOR TIỀM ẨN</strong><br />
Hệ thống lưu trữ nên xử lý lỗi sector tiềm ẩn như thế nào? Cần thêm bao nhiêu cơ chế bổ sung để xử lý dạng lỗi bộ phận này?</p>
</blockquote>
</blockquote>
<p>Thực tế, lỗi LSE khá đơn giản để xử lý, vì chúng (theo định nghĩa) dễ dàng được phát hiện. Khi một hệ thống lưu trữ cố gắng truy cập một block và ổ đĩa trả về lỗi, hệ thống lưu trữ chỉ cần sử dụng bất kỳ cơ chế <strong>redundancy</strong> (dự phòng) nào mà nó có để trả lại dữ liệu đúng. Ví dụ, trong một hệ thống <strong>RAID</strong> dạng mirror, hệ thống sẽ truy cập bản sao thay thế; trong hệ thống RAID-4 hoặc RAID-5 dựa trên <strong>parity</strong> (chẵn lẻ), hệ thống sẽ tái tạo block từ các block khác trong nhóm parity. Do đó, các vấn đề dễ phát hiện như LSE có thể được khôi phục dễ dàng thông qua các cơ chế dự phòng tiêu chuẩn.</p>
<p>Sự gia tăng của LSE theo thời gian đã ảnh hưởng đến thiết kế RAID. Một vấn đề đặc biệt thú vị xuất hiện trong các hệ thống RAID-4/5 khi cả lỗi toàn bộ đĩa (<strong>full-disk fault</strong>) và LSE xảy ra đồng thời. Cụ thể, khi một ổ đĩa hỏng hoàn toàn, RAID sẽ cố gắng tái tạo ổ đĩa đó (ví dụ, sang một <strong>hot spare</strong>) bằng cách đọc toàn bộ các ổ còn lại trong nhóm parity và tính toán lại các giá trị bị thiếu. Nếu trong quá trình tái tạo, một LSE được phát hiện trên bất kỳ ổ nào khác, chúng ta sẽ gặp vấn đề: quá trình tái tạo không thể hoàn tất thành công.</p>
<p>Để giải quyết vấn đề này, một số hệ thống bổ sung thêm mức độ dự phòng. Ví dụ, <strong>RAID-DP</strong> của NetApp có tương đương với hai ổ parity thay vì một [C+04]. Khi một LSE được phát hiện trong quá trình tái tạo, parity bổ sung sẽ giúp tái tạo block bị thiếu. Tất nhiên, điều này có chi phí: duy trì hai block parity cho mỗi stripe tốn kém hơn; tuy nhiên, bản chất <strong>log-structured</strong> của file system <strong>NetApp WAFL</strong> giúp giảm chi phí này trong nhiều trường hợp [HLM94]. Chi phí còn lại là dung lượng lưu trữ, dưới dạng một ổ đĩa bổ sung cho block parity thứ hai.</p>
<h2 id="453-phát-hiện-lỗi-hỏng-dữ-liệu-checksum-detecting-corruption-the-checksum"><a class="header" href="#453-phát-hiện-lỗi-hỏng-dữ-liệu-checksum-detecting-corruption-the-checksum">45.3 Phát hiện lỗi hỏng dữ liệu: Checksum (Detecting Corruption: The Checksum)</a></h2>
<p>Bây giờ, hãy giải quyết vấn đề khó hơn: các lỗi im lặng (<strong>silent failures</strong>) do <strong>data corruption</strong> (hỏng dữ liệu). Làm thế nào để ngăn người dùng nhận dữ liệu sai khi corruption xảy ra và khiến ổ đĩa trả về dữ liệu không chính xác?</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: CÁCH BẢO TOÀN TÍNH TOÀN VẸN DỮ LIỆU KHI XẢY RA CORRUPTION</strong><br />
Với bản chất im lặng của các lỗi này, hệ thống lưu trữ có thể làm gì để phát hiện khi corruption xảy ra? Cần những kỹ thuật nào? Làm thế nào để triển khai chúng một cách hiệu quả?</p>
</blockquote>
</blockquote>
<p>Không giống như LSE, việc phát hiện corruption là một vấn đề then chốt. Làm thế nào để client biết rằng một block đã bị hỏng? Khi đã biết block cụ thể bị hỏng, quá trình khôi phục cũng giống như trước: bạn cần có một bản sao khác của block đó (và hy vọng là bản sao này không bị hỏng!). Do đó, ở đây chúng ta tập trung vào các kỹ thuật phát hiện.</p>
<p>Cơ chế chính mà các hệ thống lưu trữ hiện đại sử dụng để bảo toàn <strong>data integrity</strong> (tính toàn vẹn dữ liệu) được gọi là <strong>checksum</strong>. Checksum đơn giản là kết quả của một hàm nhận vào một khối dữ liệu (ví dụ: một block 4KB) và tính toán một giá trị dựa trên dữ liệu đó, tạo ra một bản tóm tắt nhỏ về nội dung dữ liệu (ví dụ: 4 hoặc 8 byte). Bản tóm tắt này được gọi là checksum. Mục tiêu của phép tính này là cho phép hệ thống phát hiện nếu dữ liệu bị hỏng hoặc bị thay đổi bằng cách lưu checksum cùng với dữ liệu và sau đó, khi truy cập lại, xác nhận rằng checksum hiện tại của dữ liệu khớp với giá trị checksum ban đầu đã lưu.</p>
<blockquote>
<blockquote>
<p><strong>TIP: KHÔNG CÓ BỮA TRƯA MIỄN PHÍ</strong><br />
“There’s No Such Thing As A Free Lunch” (TNSTAAFL) là một thành ngữ Mỹ cổ, ngụ ý rằng khi bạn tưởng như đang nhận được thứ gì đó miễn phí, thực tế bạn vẫn phải trả một cái giá nào đó. Thành ngữ này bắt nguồn từ thời các quán ăn quảng cáo bữa trưa miễn phí để thu hút khách; chỉ khi bước vào, bạn mới nhận ra rằng để có được “bữa trưa miễn phí” đó, bạn phải mua một hoặc nhiều đồ uống có cồn. Tất nhiên, điều này có thể không phải là vấn đề, đặc biệt nếu bạn là một người thích uống rượu (hoặc một sinh viên đại học điển hình).</p>
</blockquote>
</blockquote>
<h3 id="các-hàm-checksum-phổ-biến-common-checksum-functions"><a class="header" href="#các-hàm-checksum-phổ-biến-common-checksum-functions">Các hàm Checksum phổ biến (Common Checksum Functions)</a></h3>
<p>Có nhiều hàm khác nhau được sử dụng để tính <strong>checksum</strong>, và chúng khác nhau về <strong>độ mạnh</strong> (strength – tức là khả năng bảo vệ tính toàn vẹn dữ liệu tốt đến mức nào) và <strong>tốc độ</strong> (speed – tức là tốc độ tính toán). Một sự đánh đổi (trade-off) phổ biến trong các hệ thống xuất hiện ở đây: thường thì, càng bảo vệ tốt hơn thì chi phí càng cao. Không có cái gọi là “bữa trưa miễn phí”.</p>
<p>Một hàm checksum đơn giản mà một số hệ thống sử dụng dựa trên phép <strong>exclusive or (XOR)</strong>. Với checksum dựa trên XOR, giá trị checksum được tính bằng cách XOR từng phần (chunk) của block dữ liệu cần tính checksum, từ đó tạo ra một giá trị duy nhất đại diện cho XOR của toàn bộ block.</p>
<p>Để minh họa cụ thể hơn, giả sử chúng ta đang tính một checksum 4 byte cho một block 16 byte (block này tất nhiên là quá nhỏ để thực tế là một sector hoặc block đĩa, nhưng sẽ dùng cho ví dụ). 16 byte dữ liệu, ở dạng hex, như sau:</p>
<pre><code>365e c4cd ba14 8a92 ecef 2c3a 40be f666
</code></pre>
<p>Nếu biểu diễn ở dạng nhị phân, ta có:</p>
<pre><code>0011 0110    0101 1110    1100 0100    1100 1101
1011 1010    0001 0100    1000 1010    1001 0010
1110 1100    1110 1111    0010 1100    0011 1010
0100 0000    1011 1110    1111 0110    0110 0110
</code></pre>
<p>Vì chúng ta đã sắp xếp dữ liệu thành các nhóm 4 byte mỗi hàng, nên dễ dàng thấy giá trị checksum sẽ là gì: thực hiện phép XOR trên từng cột để có giá trị checksum cuối cùng:</p>
<pre><code>0010 0000 0001 1011    1001 0100 0000 0011
</code></pre>
<p>Kết quả, ở dạng hex, là <code>0x201b9403</code>.</p>
<p>XOR là một checksum hợp lý nhưng có hạn chế. Ví dụ, nếu hai bit ở cùng một vị trí trong mỗi đơn vị được tính checksum thay đổi, checksum sẽ không phát hiện ra lỗi. Vì lý do này, người ta đã nghiên cứu các hàm checksum khác.</p>
<p>Một hàm checksum cơ bản khác là <strong>cộng</strong> (addition). Cách tiếp cận này có ưu điểm là nhanh; việc tính toán chỉ yêu cầu thực hiện phép cộng bù 2 (<strong>2’s-complement addition</strong>) trên từng phần dữ liệu, bỏ qua tràn số (overflow). Nó có thể phát hiện nhiều thay đổi trong dữ liệu, nhưng không tốt nếu dữ liệu, chẳng hạn, bị dịch chuyển.</p>
<p>Một thuật toán phức tạp hơn một chút được gọi là <strong>Fletcher checksum</strong>, đặt theo tên của nhà phát minh John G. Fletcher [F82]. Nó khá đơn giản để tính toán và bao gồm việc tính hai byte kiểm tra, <code>s1</code> và <code>s2</code>. Cụ thể, giả sử một block D gồm các byte <code>d1 ... dn</code>; <code>s1</code> được định nghĩa như sau:<br />
<code>s1 = (s1 + di) mod 255</code> (tính trên tất cả <code>di</code>);<br />
<code>s2</code> lần lượt là:<br />
<code>s2 = (s2 + s1) mod 255</code> (cũng tính trên tất cả <code>di</code>) [F04].<br />
Fletcher checksum gần mạnh như <strong>CRC</strong> (xem bên dưới), phát hiện tất cả lỗi 1 bit, 2 bit, và nhiều lỗi dạng burst [F04].</p>
<p>Một checksum phổ biến khác là <strong>cyclic redundancy check (CRC)</strong>. Giả sử bạn muốn tính checksum cho một block dữ liệu D. Tất cả những gì bạn làm là coi D như một số nhị phân lớn (thực chất nó chỉ là một chuỗi bit) và chia nó cho một giá trị k đã được thống nhất. Phần dư của phép chia này chính là giá trị CRC. Thực tế, phép chia modulo nhị phân này có thể được triển khai khá hiệu quả, và đó là lý do CRC cũng rất phổ biến trong mạng máy tính. Xem thêm chi tiết ở [M13].</p>
<p>Dù sử dụng phương pháp nào, rõ ràng là không có checksum nào hoàn hảo: có thể tồn tại hai block dữ liệu với nội dung khác nhau nhưng có cùng checksum, hiện tượng này gọi là <strong>collision</strong> (xung đột). Điều này là trực quan: sau cùng, tính checksum là lấy một thứ lớn (ví dụ: 4KB) và tạo ra một bản tóm tắt nhỏ hơn nhiều (ví dụ: 4 hoặc 8 byte). Khi chọn một hàm checksum tốt, chúng ta cố gắng tìm một hàm giảm thiểu khả năng xảy ra collision trong khi vẫn dễ tính toán.</p>
<h3 id="bố-trí-checksum-checksum-layout"><a class="header" href="#bố-trí-checksum-checksum-layout">Bố trí Checksum (Checksum Layout)</a></h3>
<p>Bây giờ bạn đã hiểu phần nào cách tính checksum, hãy phân tích cách sử dụng checksum trong một hệ thống lưu trữ. Câu hỏi đầu tiên cần giải quyết là <strong>bố trí checksum</strong> – tức là checksum nên được lưu trên đĩa như thế nào?</p>
<p>Cách cơ bản nhất là lưu một checksum cùng với mỗi sector (hoặc block) của đĩa. Cho một block dữ liệu D, gọi checksum của dữ liệu đó là C(D). Như vậy, nếu không có checksum, bố cục đĩa sẽ như sau:</p>
<p>...</p>
<p>Với checksum, bố cục sẽ thêm một checksum cho mỗi block:</p>
<p>...</p>
<p>Vì checksum thường nhỏ (ví dụ: 8 byte), và đĩa chỉ có thể ghi theo đơn vị sector (512 byte) hoặc bội số của nó, một vấn đề phát sinh là làm thế nào để đạt được bố cục trên. Một giải pháp mà các nhà sản xuất ổ đĩa áp dụng là định dạng ổ với sector 520 byte; thêm 8 byte mỗi sector để lưu checksum.</p>
<p>Trong các ổ đĩa không có chức năng này, file system phải tìm cách lưu checksum được đóng gói vào các block 512 byte. Một khả năng như sau:</p>
<p>...</p>
<p>Trong sơ đồ này, n checksum được lưu cùng nhau trong một sector, tiếp theo là n block dữ liệu, tiếp theo là một sector checksum khác cho n block tiếp theo, và cứ thế tiếp diễn. Cách tiếp cận này có ưu điểm là hoạt động trên mọi loại đĩa, nhưng có thể kém hiệu quả hơn; nếu file system, chẳng hạn, muốn ghi đè block D1, nó phải đọc sector checksum chứa C(D1), cập nhật C(D1) trong đó, rồi ghi lại sector checksum và block dữ liệu mới D1 (tức là một lần đọc và hai lần ghi). Cách tiếp cận trước đó (một checksum cho mỗi sector) chỉ cần thực hiện một lần ghi.</p>
<h2 id="454-sử-dụng-checksum-using-checksums"><a class="header" href="#454-sử-dụng-checksum-using-checksums">45.4 Sử dụng Checksum (Using Checksums)</a></h2>
<p>Khi đã quyết định được <strong>bố trí checksum</strong> (checksum layout), chúng ta có thể tiến hành tìm hiểu cách sử dụng checksum trong thực tế. Khi đọc một block D, <strong>client</strong> (tức là file system hoặc bộ điều khiển lưu trữ – storage controller) cũng sẽ đọc checksum của block đó từ đĩa, ký hiệu là ( C_s(D) ), gọi là <strong>stored checksum</strong> (checksum đã lưu – do đó có chỉ số dưới ( C_s )).</p>
<p>Client sau đó tính toán checksum trên block D vừa đọc được, gọi là <strong>computed checksum</strong> ( C_c(D) ). Tại thời điểm này, client so sánh checksum đã lưu và checksum vừa tính:</p>
<ul>
<li>Nếu chúng bằng nhau (tức là ( C_s(D) == C_c(D) )), dữ liệu <strong>nhiều khả năng</strong> chưa bị hỏng và có thể an toàn trả về cho người dùng.</li>
<li>Nếu chúng <strong>không</strong> bằng nhau (tức là ( C_s(D) \neq C_c(D) )), điều này ngụ ý dữ liệu đã thay đổi kể từ thời điểm lưu trữ (vì checksum đã lưu phản ánh giá trị dữ liệu tại thời điểm đó). Trong trường hợp này, chúng ta đã phát hiện ra <strong>corruption</strong> (hỏng dữ liệu) nhờ checksum.</li>
</ul>
<p>Khi phát hiện corruption, câu hỏi tự nhiên là: <strong>chúng ta nên làm gì?</strong></p>
<ul>
<li>Nếu hệ thống lưu trữ có một bản sao dự phòng (<strong>redundant copy</strong>), câu trả lời rất đơn giản: hãy thử sử dụng bản sao đó.</li>
<li>Nếu hệ thống lưu trữ <strong>không</strong> có bản sao dự phòng, khả năng cao là phải trả về lỗi.</li>
</ul>
<p>Dù trong trường hợp nào, cần nhận thức rằng việc phát hiện corruption <strong>không</strong> phải là “viên đạn bạc” (magic bullet); nếu không có cách nào khác để lấy dữ liệu không bị hỏng, thì đơn giản là bạn đã <strong>hết cách</strong>.</p>
<h2 id="455-một-vấn-đề-mới-misdirected-writes-ghi-sai-hướng"><a class="header" href="#455-một-vấn-đề-mới-misdirected-writes-ghi-sai-hướng">45.5 Một vấn đề mới: Misdirected Writes (Ghi sai hướng)</a></h2>
<p>Cơ chế cơ bản được mô tả ở trên hoạt động tốt trong hầu hết các trường hợp block bị hỏng. Tuy nhiên, các ổ đĩa hiện đại có một số dạng lỗi bất thường cần giải pháp khác.</p>
<p>Dạng lỗi đầu tiên đáng chú ý được gọi là <strong>misdirected write</strong> (ghi sai hướng). Lỗi này xảy ra trong ổ đĩa hoặc bộ điều khiển RAID, khi dữ liệu được ghi xuống đĩa <strong>đúng</strong> về nội dung nhưng <strong>sai vị trí</strong>.</p>
<ul>
<li>Trong hệ thống <strong>một ổ đĩa</strong>, điều này có nghĩa là ổ đĩa ghi block ( D_x ) <strong>không</strong> vào địa chỉ x (như mong muốn) mà lại vào địa chỉ y (do đó “làm hỏng” ( D_y )).</li>
<li>Trong hệ thống <strong>nhiều ổ đĩa</strong>, bộ điều khiển có thể ghi ( D_{i,x} ) <strong>không</strong> vào địa chỉ x của ổ i mà lại vào một ổ khác j.</li>
</ul>
<p>Do đó, câu hỏi đặt ra là:</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: CÁCH XỬ LÝ MISDIRECTED WRITES</strong><br />
Hệ thống lưu trữ hoặc bộ điều khiển đĩa nên phát hiện misdirected writes như thế nào? Checksum cần bổ sung thêm tính năng gì?</p>
</blockquote>
</blockquote>
<p>Câu trả lời, không có gì ngạc nhiên, là khá đơn giản: <strong>thêm một chút thông tin</strong> vào mỗi checksum. Trong trường hợp này, việc thêm <strong>physical identifier</strong> (ID vật lý) là rất hữu ích.</p>
<p>Ví dụ: nếu thông tin được lưu trữ hiện tại bao gồm cả checksum ( C(D) ) <strong>và</strong> số hiệu ổ đĩa cùng số sector của block, thì client có thể dễ dàng xác định liệu dữ liệu đúng có đang nằm ở đúng vị trí hay không.</p>
<p>Cụ thể, nếu client đang đọc block 4 trên ổ 10 (( D_{10,4} )), thông tin đã lưu nên bao gồm số hiệu ổ đĩa và offset sector, như minh họa bên dưới. Nếu thông tin này không khớp, tức là đã xảy ra <strong>misdirected write</strong>, và corruption được phát hiện.</p>
<p>Dưới đây là ví dụ về thông tin bổ sung này trong một hệ thống hai ổ đĩa. Lưu ý rằng hình minh họa này, giống như các hình trước, <strong>không theo tỷ lệ</strong> (not to scale), vì checksum thường rất nhỏ (ví dụ: 8 byte) trong khi block dữ liệu lớn hơn nhiều (ví dụ: 4 KB hoặc hơn).</p>
<p>Từ <strong>định dạng trên đĩa</strong> (on-disk format), bạn có thể thấy hiện tại có một lượng đáng kể thông tin dư thừa (<strong>redundancy</strong>) trên đĩa:</p>
<ul>
<li>Với mỗi block, số hiệu ổ đĩa được lặp lại bên trong block đó.</li>
<li>Offset của block cũng được lưu ngay bên cạnh block.</li>
</ul>
<p>Sự hiện diện của thông tin dư thừa này không có gì bất ngờ; <strong>redundancy</strong> chính là chìa khóa để <strong>phát hiện lỗi</strong> (trong trường hợp này) và <strong>khôi phục</strong> (trong các trường hợp khác). Một chút thông tin bổ sung, dù không thực sự cần thiết với các ổ đĩa “hoàn hảo”, vẫn có thể giúp ích rất nhiều trong việc phát hiện các tình huống sự cố nếu chúng xảy ra.</p>
<h2 id="456-một-vấn-đề-cuối-cùng-lost-writes-ghi-bị-mất"><a class="header" href="#456-một-vấn-đề-cuối-cùng-lost-writes-ghi-bị-mất">45.6 Một vấn đề cuối cùng: Lost Writes (Ghi bị mất)</a></h2>
<p>Thật không may, <strong>misdirected writes</strong> (ghi sai hướng) không phải là vấn đề cuối cùng mà chúng ta cần đề cập. Cụ thể, một số thiết bị lưu trữ hiện đại còn gặp một vấn đề gọi là <strong>lost write</strong> (ghi bị mất), xảy ra khi thiết bị thông báo cho tầng trên rằng một thao tác ghi đã hoàn tất, nhưng trên thực tế dữ liệu đó <strong>không</strong> được lưu bền vững; do đó, những gì còn lại trên block là nội dung cũ thay vì nội dung mới đã được cập nhật.</p>
<p>Câu hỏi hiển nhiên ở đây là: liệu bất kỳ chiến lược <strong>checksumming</strong> (tính checksum) nào ở trên (ví dụ: checksum cơ bản, hoặc <strong>physical identity</strong> – định danh vật lý) có giúp phát hiện lost write hay không?<br />
Đáng tiếc, câu trả lời là <strong>không</strong>: block cũ nhiều khả năng vẫn có checksum khớp, và <strong>physical ID</strong> được sử dụng ở trên (số hiệu ổ đĩa và offset block) cũng sẽ đúng. Do đó, chúng ta có vấn đề cuối cùng:</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: CÁCH XỬ LÝ LOST WRITES</strong><br />
Hệ thống lưu trữ hoặc bộ điều khiển đĩa nên phát hiện lost write như thế nào? Checksum cần bổ sung thêm tính năng gì?</p>
</blockquote>
</blockquote>
<p>Có một số giải pháp khả thi có thể giúp [K+08]. Một cách tiếp cận kinh điển [BS04] là thực hiện <strong>write verify</strong> hoặc <strong>read-after-write</strong>; bằng cách đọc lại ngay dữ liệu sau khi ghi, hệ thống có thể đảm bảo rằng dữ liệu thực sự đã được ghi xuống bề mặt đĩa. Tuy nhiên, cách tiếp cận này khá chậm, vì làm tăng gấp đôi số lượng I/O cần thiết để hoàn tất một thao tác ghi.</p>
<p>Một số hệ thống thêm checksum ở một vị trí khác trong hệ thống để phát hiện lost write. Ví dụ, <strong>Zettabyte File System (ZFS)</strong> của Sun bao gồm một checksum trong mỗi <strong>inode</strong> của file system và trong các <strong>indirect block</strong> cho mọi block thuộc về một file. Do đó, ngay cả khi thao tác ghi vào một data block bị mất, checksum trong inode sẽ không khớp với dữ liệu cũ. Chỉ khi cả thao tác ghi vào inode và ghi vào dữ liệu đều bị mất đồng thời thì cơ chế này mới thất bại – một tình huống khó xảy ra (nhưng đáng tiếc là vẫn có thể!).</p>
<h2 id="457-scrubbing-quét-kiểm-tra-đĩa"><a class="header" href="#457-scrubbing-quét-kiểm-tra-đĩa">45.7 Scrubbing (Quét kiểm tra đĩa)</a></h2>
<p>Với tất cả những gì đã thảo luận, bạn có thể tự hỏi: <strong>khi nào</strong> các checksum này thực sự được kiểm tra? Tất nhiên, một phần việc kiểm tra diễn ra khi dữ liệu được ứng dụng truy cập, nhưng phần lớn dữ liệu hiếm khi được truy cập, và do đó sẽ <strong>không</strong> được kiểm tra. Dữ liệu không được kiểm tra là một vấn đề đối với hệ thống lưu trữ đáng tin cậy, vì <strong>bit rot</strong> (sự suy giảm bit theo thời gian) có thể cuối cùng ảnh hưởng đến tất cả các bản sao của một dữ liệu nhất định.</p>
<p>Để khắc phục vấn đề này, nhiều hệ thống sử dụng <strong>disk scrubbing</strong> (quét kiểm tra đĩa) dưới nhiều hình thức khác nhau [K+08]. Bằng cách định kỳ đọc qua <strong>từng block</strong> của hệ thống và kiểm tra xem checksum có còn hợp lệ hay không, hệ thống lưu trữ có thể giảm khả năng tất cả các bản sao của một dữ liệu nào đó bị hỏng. Các hệ thống điển hình thường lên lịch quét vào ban đêm hoặc hàng tuần.</p>
<h2 id="458-chi-phí-overheads-của-việc-sử-dụng-checksum"><a class="header" href="#458-chi-phí-overheads-của-việc-sử-dụng-checksum">45.8 Chi phí (Overheads) của việc sử dụng Checksum</a></h2>
<p>Trước khi kết thúc, chúng ta sẽ thảo luận về một số <strong>overhead</strong> (chi phí phụ trội) khi sử dụng <strong>checksum</strong> để bảo vệ dữ liệu. Giống như nhiều hệ thống máy tính khác, có hai loại overhead riêng biệt: <strong>overhead về không gian</strong> (space) và <strong>overhead về thời gian</strong> (time).</p>
<p><strong>Overhead về không gian</strong> có hai dạng:</p>
<ul>
<li>
<p><strong>Thứ nhất</strong> là trên đĩa (hoặc phương tiện lưu trữ khác) – mỗi checksum được lưu sẽ chiếm một phần dung lượng trên đĩa, phần này không thể dùng cho dữ liệu người dùng. Một tỷ lệ điển hình có thể là một checksum 8 byte cho mỗi block dữ liệu 4 KB, tương đương với khoảng <strong>0,19% overhead dung lượng trên đĩa</strong>.</p>
</li>
<li>
<p><strong>Thứ hai</strong> là trong bộ nhớ của hệ thống. Khi truy cập dữ liệu, bộ nhớ phải có chỗ chứa cả checksum và dữ liệu. Tuy nhiên, nếu hệ thống chỉ kiểm tra checksum rồi loại bỏ nó sau khi xong, overhead này chỉ tồn tại trong thời gian ngắn và không đáng lo ngại. Chỉ khi checksum được giữ lại trong bộ nhớ (để tăng mức bảo vệ chống lại <strong>memory corruption</strong> – lỗi hỏng dữ liệu trong bộ nhớ [Z+13]) thì overhead nhỏ này mới trở nên đáng chú ý.</p>
</li>
</ul>
<p>Mặc dù overhead về không gian là nhỏ, nhưng <strong>overhead về thời gian</strong> do việc tính toán checksum có thể khá đáng kể. Tối thiểu, <strong>CPU</strong> phải tính toán checksum cho mỗi block, cả khi dữ liệu được lưu (để xác định giá trị checksum sẽ lưu) và khi dữ liệu được truy cập (để tính lại checksum và so sánh với checksum đã lưu).</p>
<p>Một cách tiếp cận để giảm overhead CPU – được nhiều hệ thống sử dụng checksum áp dụng (bao gồm cả <strong>network stack</strong>) – là <strong>kết hợp việc sao chép dữ liệu và tính checksum thành một hoạt động duy nhất</strong>; vì việc sao chép là cần thiết (ví dụ: sao chép dữ liệu từ <strong>kernel page cache</strong> sang <strong>user buffer</strong>), nên việc kết hợp sao chép/tính checksum có thể rất hiệu quả.</p>
<p>Ngoài overhead CPU, một số cơ chế checksumming có thể gây thêm <strong>overhead I/O</strong>, đặc biệt khi checksum được lưu tách biệt khỏi dữ liệu (dẫn đến cần thêm I/O để truy cập chúng), và cho bất kỳ I/O bổ sung nào cần cho quá trình <strong>background scrubbing</strong> (quét kiểm tra nền).</p>
<ul>
<li>Trường hợp đầu tiên có thể giảm bằng thiết kế.</li>
<li>Trường hợp thứ hai có thể điều chỉnh để giới hạn tác động, ví dụ bằng cách kiểm soát thời điểm thực hiện scrubbing.</li>
</ul>
<p>Thời điểm giữa đêm, khi hầu hết (nhưng không phải tất cả!) những người làm việc năng suất đã đi ngủ, có thể là lúc thích hợp để thực hiện scrubbing và tăng độ bền vững của hệ thống lưu trữ.</p>
<h2 id="459-tóm-tắt-summary"><a class="header" href="#459-tóm-tắt-summary">45.9 Tóm tắt (Summary)</a></h2>
<p>Chúng ta đã thảo luận về <strong>bảo vệ dữ liệu</strong> trong các hệ thống lưu trữ hiện đại, tập trung vào việc triển khai và sử dụng <strong>checksum</strong>. Các loại checksum khác nhau bảo vệ chống lại các loại lỗi khác nhau; khi các thiết bị lưu trữ phát triển, chắc chắn sẽ xuất hiện các dạng lỗi mới.</p>
<p>Có thể những thay đổi này sẽ buộc cộng đồng nghiên cứu và ngành công nghiệp phải xem xét lại một số phương pháp cơ bản này, hoặc phát minh ra những phương pháp hoàn toàn mới. Thời gian sẽ trả lời. Hoặc cũng có thể không. Thời gian vốn dĩ thú vị theo cách đó.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="48-hệ-thống-phân-tán-distributed-systems"><a class="header" href="#48-hệ-thống-phân-tán-distributed-systems">48. Hệ thống phân tán (Distributed Systems)</a></h1>
<p><strong>Hệ thống phân tán</strong> đã thay đổi bộ mặt của thế giới. Khi trình duyệt web của bạn kết nối tới một web server ở đâu đó trên hành tinh, bạn đang tham gia vào một dạng đơn giản của <strong>hệ thống phân tán kiểu client/server</strong>. Tuy nhiên, khi bạn truy cập một dịch vụ web hiện đại như Google hoặc Facebook, bạn không chỉ tương tác với một máy duy nhất; phía sau hậu trường, các dịch vụ phức tạp này được xây dựng từ một tập hợp lớn (tức là hàng nghìn) máy, mỗi máy hợp tác để cung cấp dịch vụ cụ thể của trang. Do đó, có thể thấy rõ lý do tại sao việc nghiên cứu hệ thống phân tán lại thú vị. Thực tế, nó xứng đáng có hẳn một môn học riêng; ở đây, chúng ta chỉ giới thiệu một vài chủ đề chính.</p>
<p>Khi xây dựng một hệ thống phân tán, nhiều thách thức mới xuất hiện. Thách thức lớn nhất mà chúng ta tập trung ở đây là <strong>failure</strong> (lỗi/hỏng hóc); máy tính, ổ đĩa, mạng và phần mềm đều có thể hỏng theo thời gian, vì chúng ta không (và có lẽ sẽ không bao giờ) biết cách xây dựng các thành phần và hệ thống “hoàn hảo”. Tuy nhiên, khi xây dựng một dịch vụ web hiện đại, chúng ta muốn nó xuất hiện với khách hàng như thể nó <strong>không bao giờ hỏng</strong>; vậy làm thế nào để đạt được điều này?</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: CÁCH XÂY DỰNG HỆ THỐNG HOẠT ĐỘNG KHI THÀNH PHẦN BỊ LỖI</strong><br />
Làm thế nào để xây dựng một hệ thống hoạt động từ các thành phần không phải lúc nào cũng hoạt động đúng? Câu hỏi cơ bản này có thể khiến bạn nhớ lại một số chủ đề chúng ta đã thảo luận trong phần mảng lưu trữ RAID; tuy nhiên, các vấn đề ở đây thường phức tạp hơn, và giải pháp cũng vậy.</p>
</blockquote>
</blockquote>
<p>Điều thú vị là, mặc dù lỗi là thách thức trung tâm trong việc xây dựng hệ thống phân tán, nó cũng là một cơ hội. Đúng là máy móc sẽ hỏng; nhưng việc một máy hỏng không có nghĩa là toàn bộ hệ thống phải ngừng hoạt động. Bằng cách tập hợp nhiều máy lại, chúng ta có thể xây dựng một hệ thống <strong>có vẻ như hiếm khi hỏng</strong>, mặc dù các thành phần của nó hỏng thường xuyên. Đây chính là <strong>vẻ đẹp và giá trị cốt lõi</strong> của hệ thống phân tán, và là lý do tại sao chúng là nền tảng của hầu hết mọi dịch vụ web hiện đại mà bạn sử dụng, bao gồm Google, Facebook, v.v.</p>
<blockquote>
<blockquote>
<p><strong>TIP: GIAO TIẾP VỐN DĨ LÀ KHÔNG ĐÁNG TIN CẬY</strong><br />
Trong hầu hết mọi trường hợp, nên coi giao tiếp là một hoạt động vốn dĩ không đáng tin cậy. Lỗi bit (bit corruption), liên kết hoặc máy bị hỏng hoặc không hoạt động, và thiếu bộ đệm cho các gói tin đến đều dẫn đến cùng một kết quả: gói tin đôi khi không đến được đích. Để xây dựng các dịch vụ đáng tin cậy trên nền mạng không đáng tin cậy như vậy, chúng ta phải xem xét các kỹ thuật có thể đối phó với việc mất gói tin.</p>
</blockquote>
</blockquote>
<p>Ngoài ra còn có những vấn đề quan trọng khác. <strong>Hiệu năng hệ thống</strong> thường rất quan trọng; với một mạng kết nối các thành phần của hệ thống phân tán, các nhà thiết kế hệ thống phải cân nhắc kỹ cách thực hiện nhiệm vụ, cố gắng giảm số lượng thông điệp gửi đi và làm cho giao tiếp hiệu quả nhất có thể (độ trễ thấp, băng thông cao). Cuối cùng, <strong>bảo mật</strong> cũng là một yếu tố cần thiết. Khi kết nối tới một site từ xa, việc đảm bảo rằng bên kia thực sự là người họ tuyên bố trở thành một vấn đề trung tâm. Hơn nữa, đảm bảo rằng bên thứ ba không thể theo dõi hoặc thay đổi một phiên giao tiếp đang diễn ra giữa hai bên cũng là một thách thức.</p>
<p>Trong phần giới thiệu này, chúng ta sẽ đề cập đến khía cạnh cơ bản nhất và mới mẻ trong hệ thống phân tán: <strong>giao tiếp</strong>. Cụ thể, các máy trong một hệ thống phân tán nên giao tiếp với nhau như thế nào? Chúng ta sẽ bắt đầu với các <strong>primitive</strong> (nguyên thủy) cơ bản nhất là <strong>message</strong> (thông điệp), và xây dựng một số primitive cấp cao hơn trên nền tảng đó. Như đã nói ở trên, <strong>failure</strong> sẽ là trọng tâm: các tầng giao tiếp nên xử lý lỗi như thế nào?</p>
<h2 id="481-cơ-bản-về-giao-tiếp-communication-basics"><a class="header" href="#481-cơ-bản-về-giao-tiếp-communication-basics">48.1 Cơ bản về giao tiếp (Communication Basics)</a></h2>
<p>Nguyên tắc trung tâm của mạng máy tính hiện đại là: <strong>giao tiếp vốn dĩ không đáng tin cậy</strong>. Dù là trên mạng diện rộng (<strong>wide-area Internet</strong>) hay mạng cục bộ tốc độ cao (<strong>local-area high-speed network</strong>) như <strong>Infiniband</strong>, các gói tin thường xuyên bị mất, bị hỏng hoặc không đến được đích.</p>
<p>Có nhiều nguyên nhân dẫn đến mất hoặc hỏng gói tin. Đôi khi, trong quá trình truyền, một số bit bị lật do sự cố điện hoặc các vấn đề tương tự. Đôi khi, một thành phần trong hệ thống, chẳng hạn như liên kết mạng, bộ định tuyến gói tin (<strong>packet router</strong>) hoặc thậm chí máy chủ từ xa, bị hỏng hoặc không hoạt động đúng; cáp mạng đôi khi cũng bị đứt.</p>
<p>Tuy nhiên, nguyên nhân cơ bản hơn là mất gói tin do <strong>thiếu bộ đệm</strong> trong <strong>network switch</strong>, <strong>router</strong>, hoặc <strong>endpoint</strong>. Cụ thể, ngay cả khi chúng ta có thể đảm bảo rằng tất cả các liên kết hoạt động đúng và tất cả các thành phần trong hệ thống (switch, router, end host) đều đang chạy như mong đợi, việc mất gói tin vẫn có thể xảy ra vì lý do sau: Hãy tưởng tượng một gói tin đến một router; để gói tin được xử lý, nó phải được đặt vào bộ nhớ nào đó bên trong router. Nếu nhiều gói tin như vậy đến cùng lúc, có thể bộ nhớ trong router không đủ để chứa tất cả. Lúc này, lựa chọn duy nhất của router là <strong>loại bỏ</strong> một hoặc nhiều gói tin. Hành vi tương tự cũng xảy ra ở các <strong>end host</strong>; khi bạn gửi một số lượng lớn thông điệp tới một máy duy nhất, tài nguyên của máy đó có thể nhanh chóng bị quá tải, và do đó việc mất gói tin lại xảy ra.</p>
<p>Vì vậy, <strong>mất gói tin</strong> là một hiện tượng cơ bản trong mạng máy tính. Câu hỏi đặt ra là: <strong>chúng ta nên xử lý nó như thế nào?</strong></p>
<h2 id="482-các-tầng-giao-tiếp-không-đáng-tin-cậy-unreliable-communication-layers"><a class="header" href="#482-các-tầng-giao-tiếp-không-đáng-tin-cậy-unreliable-communication-layers">48.2 Các tầng giao tiếp không đáng tin cậy (Unreliable Communication Layers)</a></h2>
<p>Một cách đơn giản là: <strong>chúng ta không xử lý nó</strong>. Bởi vì một số ứng dụng biết cách tự xử lý việc mất gói tin (<strong>packet loss</strong>), đôi khi sẽ hữu ích nếu để chúng giao tiếp thông qua một tầng truyền thông cơ bản <strong>không đáng tin cậy</strong>. Đây là một ví dụ của <strong>end-to-end argument</strong> (lập luận đầu-cuối) mà bạn thường nghe nói đến (xem phần <em>Aside</em> ở cuối chương).</p>
<p>Một ví dụ điển hình của tầng không đáng tin cậy như vậy là <strong>UDP/IP networking stack</strong> (ngăn xếp mạng UDP/IP) hiện có trên hầu hết các hệ thống hiện đại. Để sử dụng <strong>UDP</strong>, một <strong>process</strong> (tiến trình) sử dụng <strong>sockets API</strong> để tạo một <strong>communication endpoint</strong> (điểm cuối giao tiếp); các tiến trình trên máy khác (hoặc trên cùng một máy) gửi <strong>UDP datagram</strong> (gói tin UDP – một thông điệp có kích thước cố định tới một giới hạn tối đa) tới tiến trình ban đầu.</p>
<p><strong>Hình 48.1</strong> và <strong>Hình 48.2</strong> minh họa một client và server đơn giản được xây dựng trên nền UDP/IP. Client có thể gửi một thông điệp tới server, và server sẽ phản hồi lại. Chỉ với một lượng mã nhỏ như vậy, bạn đã có tất cả những gì cần để bắt đầu xây dựng hệ thống phân tán!</p>
<p>...</p>
<p><img src="48/img/fig48_1.PNG" alt="" /></p>
<p><strong>Hình 48.1: Ví dụ mã UDP (client.c, server.c)</strong></p>
<p>...</p>
<p><img src="48/img/fig48_2.PNG" alt="" /></p>
<p><strong>Hình 48.2: Một thư viện UDP đơn giản (udp.c)</strong></p>
<p>UDP là một ví dụ tuyệt vời của tầng giao tiếp không đáng tin cậy. Nếu bạn sử dụng nó, bạn sẽ gặp những tình huống gói tin bị mất (<strong>dropped</strong>) và do đó không đến được đích; phía gửi sẽ <strong>không bao giờ</strong> được thông báo về việc mất gói tin này. Tuy nhiên, điều đó không có nghĩa là UDP không bảo vệ chống lại bất kỳ lỗi nào. Ví dụ, UDP bao gồm một <strong>checksum</strong> để phát hiện một số dạng lỗi hỏng gói tin (<strong>packet corruption</strong>).</p>
<blockquote>
<blockquote>
<p><strong>TIP: SỬ DỤNG CHECKSUM ĐỂ ĐẢM BẢO TÍNH TOÀN VẸN (INTEGRITY)</strong><br />
Checksum là một phương pháp thường được sử dụng để phát hiện lỗi hỏng dữ liệu nhanh chóng và hiệu quả trong các hệ thống hiện đại. Một checksum đơn giản là phép cộng: chỉ cần cộng tất cả các byte của một khối dữ liệu; tất nhiên, nhiều loại checksum tinh vi hơn đã được tạo ra, bao gồm <strong>cyclic redundancy codes (CRC)</strong> cơ bản, <strong>Fletcher checksum</strong>, và nhiều loại khác [MK09].<br />
Trong mạng máy tính, checksum được sử dụng như sau: Trước khi gửi một thông điệp từ máy này sang máy khác, tính toán checksum trên các byte của thông điệp. Sau đó gửi cả thông điệp và checksum tới đích. Ở phía nhận, máy nhận cũng tính toán checksum trên thông điệp nhận được; nếu checksum tính được khớp với checksum đã gửi, máy nhận có thể yên tâm rằng dữ liệu <strong>nhiều khả năng</strong> không bị hỏng trong quá trình truyền.<br />
Checksum có thể được đánh giá theo nhiều tiêu chí khác nhau. <strong>Hiệu quả</strong> là một yếu tố chính: liệu thay đổi trong dữ liệu có dẫn đến thay đổi trong checksum không? Checksum càng mạnh thì càng khó để thay đổi dữ liệu mà không bị phát hiện. <strong>Hiệu năng</strong> là tiêu chí quan trọng khác: tính toán checksum tốn bao nhiêu chi phí? Đáng tiếc, hiệu quả và hiệu năng thường mâu thuẫn nhau, nghĩa là checksum chất lượng cao thường tốn nhiều chi phí tính toán. Cuộc sống, một lần nữa, không hoàn hảo.</p>
</blockquote>
</blockquote>
<p>Tuy nhiên, vì nhiều ứng dụng chỉ đơn giản muốn gửi dữ liệu tới đích mà không phải lo lắng về việc mất gói tin, chúng ta cần nhiều hơn thế. Cụ thể, chúng ta cần <strong>giao tiếp đáng tin cậy</strong> trên nền một mạng không đáng tin cậy.</p>
<h2 id="483-các-tầng-giao-tiếp-đáng-tin-cậy-reliable-communication-layers"><a class="header" href="#483-các-tầng-giao-tiếp-đáng-tin-cậy-reliable-communication-layers">48.3 Các tầng giao tiếp đáng tin cậy (Reliable Communication Layers)</a></h2>
<p>Để xây dựng một tầng giao tiếp đáng tin cậy, chúng ta cần một số cơ chế và kỹ thuật mới để xử lý việc mất gói tin. Hãy xem xét một ví dụ đơn giản trong đó một client đang gửi một thông điệp tới server qua một kết nối không đáng tin cậy. Câu hỏi đầu tiên cần trả lời: <strong>làm thế nào để phía gửi biết rằng phía nhận thực sự đã nhận được thông điệp?</strong></p>
<p>Kỹ thuật mà chúng ta sẽ sử dụng được gọi là <strong>acknowledgment</strong> (xác nhận), hay viết tắt là <strong>ack</strong>. Ý tưởng rất đơn giản: phía gửi gửi một thông điệp tới phía nhận; phía nhận sau đó gửi lại một thông điệp ngắn để xác nhận đã nhận được. <strong>Hình 48.3</strong> minh họa quá trình này.</p>
<p><img src="48/img/fig48_3.PNG" alt="" /></p>
<p><strong>Hình 48.3: Thông điệp và xác nhận (Message Plus Acknowledgment)</strong></p>
<p>Khi phía gửi nhận được <strong>acknowledgment</strong> cho thông điệp, nó có thể yên tâm rằng phía nhận thực sự đã nhận được thông điệp gốc. Tuy nhiên, điều gì sẽ xảy ra nếu phía gửi <strong>không</strong> nhận được acknowledgment?</p>
<p>Để xử lý trường hợp này, chúng ta cần một cơ chế bổ sung, gọi là <strong>timeout</strong> (hết thời gian chờ). Khi phía gửi gửi một thông điệp, nó sẽ đặt một bộ đếm thời gian để kích hoạt sau một khoảng thời gian nhất định. Nếu trong khoảng thời gian đó không nhận được acknowledgment, phía gửi kết luận rằng thông điệp đã bị mất. Khi đó, phía gửi sẽ <strong>retry</strong> (thử gửi lại), gửi cùng một thông điệp một lần nữa với hy vọng lần này nó sẽ đến nơi.</p>
<p>Để cách tiếp cận này hoạt động, phía gửi phải giữ lại một bản sao của thông điệp, phòng khi cần gửi lại. Sự kết hợp giữa <strong>timeout</strong> và <strong>retry</strong> khiến một số người gọi phương pháp này là <strong>timeout/retry</strong>; khá thông minh, phải không? <strong>Hình 48.4</strong> minh họa một ví dụ.</p>
<p><img src="48/img/fig48_4.PNG" alt="" /></p>
<p><strong>Hình 48.4: Thông điệp và xác nhận – Yêu cầu bị rơi (Message Plus Acknowledgment: Dropped Request)</strong></p>
<p>Thật không may, cơ chế <strong>timeout/retry</strong> (hết thời gian chờ/thử lại) ở dạng này vẫn chưa đủ. <strong>Hình 48.5</strong> minh họa một ví dụ về mất gói tin (<strong>packet loss</strong>) có thể gây ra rắc rối. Trong ví dụ này, không phải thông điệp gốc bị mất, mà là <strong>acknowledgment</strong> (gói tin xác nhận).</p>
<p>Từ góc nhìn của phía gửi, tình huống có vẻ giống nhau: không nhận được ack, và do đó cần thực hiện timeout và retry. Nhưng từ góc nhìn của phía nhận, lại hoàn toàn khác: cùng một thông điệp đã được nhận <strong>hai lần</strong>! Mặc dù có thể có những trường hợp điều này không gây hại, nhưng nhìn chung thì không ổn; hãy tưởng tượng điều gì sẽ xảy ra khi bạn đang tải xuống một tệp và các gói tin thừa bị lặp lại trong quá trình tải. Do đó, khi chúng ta hướng tới một tầng thông điệp đáng tin cậy (<strong>reliable message layer</strong>), chúng ta thường muốn đảm bảo rằng <strong>mỗi thông điệp chỉ được nhận đúng một lần</strong> bởi phía nhận.</p>
<p><img src="48/img/fig48_5.PNG" alt="" /></p>
<p><strong>Hình 48.5: Thông điệp và xác nhận – Phản hồi bị rơi (Message Plus Acknowledgment: Dropped Reply)</strong></p>
<p>Để cho phép phía nhận phát hiện việc truyền trùng lặp thông điệp, phía gửi phải gán cho mỗi thông điệp một <strong>định danh duy nhất</strong> (unique ID), và phía nhận cần có cách để theo dõi xem nó đã thấy thông điệp đó trước đây hay chưa. Khi phía nhận phát hiện một thông điệp trùng lặp, nó chỉ cần gửi ack cho thông điệp đó, nhưng (quan trọng) <strong>không</strong> chuyển thông điệp này lên ứng dụng nhận dữ liệu. Như vậy, phía gửi nhận được ack nhưng thông điệp không bị nhận hai lần, đảm bảo <strong>ngữ nghĩa exactly-once</strong> (chỉ-một-lần) như đã đề cập.</p>
<p>Có nhiều cách để phát hiện thông điệp trùng lặp. Ví dụ, phía gửi có thể tạo một ID duy nhất cho mỗi thông điệp; phía nhận có thể lưu lại mọi ID mà nó từng thấy. Cách này có thể hoạt động, nhưng chi phí quá cao, đòi hỏi bộ nhớ không giới hạn để lưu tất cả ID.</p>
<p>Một cách đơn giản hơn, yêu cầu ít bộ nhớ, giải quyết được vấn đề này là sử dụng <strong>sequence counter</strong> (bộ đếm tuần tự). Với sequence counter, phía gửi và phía nhận thống nhất một giá trị bắt đầu (ví dụ: 1) cho một bộ đếm mà mỗi bên sẽ duy trì. Mỗi khi gửi một thông điệp, giá trị hiện tại của bộ đếm sẽ được gửi kèm theo thông điệp; giá trị này (N) đóng vai trò như ID của thông điệp. Sau khi gửi thông điệp, phía gửi tăng giá trị bộ đếm lên (N + 1).</p>
<blockquote>
<blockquote>
<p><strong>TIP: CẨN THẬN KHI ĐẶT GIÁ TRỊ TIMEOUT</strong><br />
Như bạn có thể đoán từ phần thảo luận, việc đặt giá trị timeout đúng là một yếu tố quan trọng khi sử dụng timeout để thử gửi lại thông điệp. Nếu timeout quá nhỏ, phía gửi sẽ gửi lại thông điệp một cách không cần thiết, lãng phí thời gian CPU và tài nguyên mạng. Nếu timeout quá lớn, phía gửi sẽ chờ quá lâu mới gửi lại, làm giảm hiệu năng cảm nhận được ở phía gửi. Giá trị “đúng” từ góc nhìn của một client và server đơn lẻ là chờ vừa đủ để phát hiện mất gói tin nhưng không lâu hơn.<br />
Tuy nhiên, trong hệ thống phân tán thường có nhiều hơn một client và server, như chúng ta sẽ thấy ở các chương sau. Trong kịch bản nhiều client gửi tới một server, mất gói tin ở server có thể là dấu hiệu server đang quá tải. Nếu đúng vậy, client có thể thử lại theo cách thích ứng khác; ví dụ, sau lần timeout đầu tiên, client có thể tăng giá trị timeout lên cao hơn, có thể gấp đôi giá trị ban đầu. Cơ chế <strong>exponential back-off</strong> (lùi thời gian theo cấp số nhân), được tiên phong trong mạng Aloha và áp dụng trong Ethernet thời kỳ đầu [A70], giúp tránh tình huống tài nguyên bị quá tải do quá nhiều lần gửi lại. Các hệ thống mạnh mẽ luôn cố gắng tránh loại quá tải này.</p>
</blockquote>
</blockquote>
<p>Phía nhận sử dụng giá trị bộ đếm của mình như giá trị mong đợi cho ID của thông điệp đến từ phía gửi đó. Nếu ID của thông điệp nhận được (N) khớp với bộ đếm của phía nhận (cũng là N), nó gửi ack và chuyển thông điệp lên ứng dụng; trong trường hợp này, phía nhận kết luận đây là lần đầu tiên thông điệp này được nhận. Sau đó, phía nhận tăng bộ đếm của mình lên (N + 1) và chờ thông điệp tiếp theo.</p>
<p>Nếu ack bị mất, phía gửi sẽ timeout và gửi lại thông điệp N. Lần này, bộ đếm của phía nhận đã cao hơn (N + 1), do đó phía nhận biết rằng nó đã nhận thông điệp này trước đó. Vì vậy, nó gửi ack nhưng không chuyển thông điệp lên ứng dụng. Theo cách đơn giản này, <strong>sequence counter</strong> có thể được sử dụng để tránh trùng lặp.</p>
<p>Tầng giao tiếp đáng tin cậy được sử dụng phổ biến nhất được gọi là <strong>TCP/IP</strong>, hay ngắn gọn là <strong>TCP</strong>. TCP có mức độ tinh vi cao hơn nhiều so với mô tả ở trên, bao gồm cơ chế xử lý <strong>congestion</strong> (tắc nghẽn) trong mạng [VJ88], hỗ trợ nhiều yêu cầu đồng thời (<strong>multiple outstanding requests</strong>), và hàng trăm tinh chỉnh và tối ưu hóa nhỏ khác. Hãy tìm hiểu thêm nếu bạn quan tâm; tốt hơn nữa, hãy tham gia một khóa học về mạng máy tính và học kỹ phần này.</p>
<h2 id="484-các-trừu-tượng-giao-tiếp-communication-abstractions"><a class="header" href="#484-các-trừu-tượng-giao-tiếp-communication-abstractions">48.4 Các trừu tượng giao tiếp (Communication Abstractions)</a></h2>
<p>Với một <strong>messaging layer</strong> (tầng nhắn tin) cơ bản, chúng ta tiếp cận câu hỏi tiếp theo trong chương này: <strong>khi xây dựng một hệ thống phân tán, chúng ta nên sử dụng trừu tượng giao tiếp nào?</strong></p>
<p>Cộng đồng nghiên cứu hệ thống đã phát triển nhiều cách tiếp cận trong nhiều năm qua. Một nhánh công trình đã lấy các <strong>OS abstractions</strong> (trừu tượng của hệ điều hành) và mở rộng chúng để hoạt động trong môi trường phân tán. Ví dụ, các hệ thống <strong>distributed shared memory (DSM)</strong> – bộ nhớ chia sẻ phân tán – cho phép các <strong>process</strong> (tiến trình) trên các máy khác nhau chia sẻ một không gian địa chỉ ảo (<strong>virtual address space</strong>) lớn [LH89]. Trừu tượng này biến một phép tính phân tán thành thứ trông giống như một ứng dụng đa luồng (<strong>multi-threaded application</strong>); điểm khác biệt duy nhất là các luồng này chạy trên các máy khác nhau thay vì trên các bộ xử lý khác nhau trong cùng một máy.</p>
<p>Cách hầu hết các hệ thống DSM hoạt động là thông qua hệ thống <strong>virtual memory</strong> (bộ nhớ ảo) của hệ điều hành. Khi một <strong>page</strong> (trang) được truy cập trên một máy, có thể xảy ra hai tình huống:</p>
<ul>
<li>Trường hợp thứ nhất (tốt nhất), page đã có sẵn trên máy, và dữ liệu được lấy nhanh chóng.</li>
<li>Trường hợp thứ hai, page hiện đang nằm trên một máy khác. Khi đó xảy ra <strong>page fault</strong> (lỗi trang), và <strong>page fault handler</strong> (trình xử lý lỗi trang) sẽ gửi một thông điệp tới máy khác để lấy page, cài đặt nó vào <strong>page table</strong> (bảng trang) của tiến trình yêu cầu, rồi tiếp tục thực thi.</li>
</ul>
<p>Cách tiếp cận này ngày nay không được sử dụng rộng rãi vì nhiều lý do. Vấn đề lớn nhất của DSM là cách nó xử lý <strong>failure</strong> (lỗi/hỏng hóc). Hãy tưởng tượng, nếu một máy bị hỏng; điều gì sẽ xảy ra với các page trên máy đó? Nếu các cấu trúc dữ liệu của phép tính phân tán được phân tán khắp toàn bộ không gian địa chỉ thì sao? Trong trường hợp này, một phần của các cấu trúc dữ liệu đó sẽ đột ngột trở nên không thể truy cập. Xử lý lỗi khi một phần không gian địa chỉ của bạn biến mất là rất khó; hãy tưởng tượng một <strong>linked list</strong> (danh sách liên kết) mà con trỏ “next” trỏ vào một phần của không gian địa chỉ đã mất. Thật khủng khiếp!</p>
<p>Một vấn đề khác là hiệu năng. Khi viết mã, người ta thường giả định rằng truy cập bộ nhớ là rẻ. Trong các hệ thống DSM, một số truy cập là rẻ, nhưng một số khác gây ra page fault và yêu cầu lấy dữ liệu tốn kém từ máy từ xa. Do đó, lập trình viên của các hệ thống DSM phải rất cẩn thận tổ chức tính toán sao cho hầu như không có giao tiếp nào xảy ra, điều này làm mất đi nhiều ý nghĩa của cách tiếp cận này. Mặc dù đã có nhiều nghiên cứu trong lĩnh vực này, tác động thực tiễn là rất ít; ngày nay không ai xây dựng hệ thống phân tán đáng tin cậy bằng DSM nữa.</p>
<h2 id="485-remote-procedure-call-rpc"><a class="header" href="#485-remote-procedure-call-rpc">48.5 Remote Procedure Call (RPC)</a></h2>
<p>Trong khi các <strong>OS abstractions</strong> tỏ ra là lựa chọn kém hiệu quả để xây dựng hệ thống phân tán, các <strong>programming language (PL) abstractions</strong> (trừu tượng của ngôn ngữ lập trình) lại hợp lý hơn nhiều. Trừu tượng chiếm ưu thế nhất dựa trên ý tưởng <strong>remote procedure call</strong> (gọi thủ tục từ xa), hay viết tắt là <strong>RPC</strong> [BN84]<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Các gói RPC đều có một mục tiêu đơn giản: làm cho quá trình thực thi mã trên một máy từ xa trở nên đơn giản và trực quan như việc gọi một hàm cục bộ. Do đó, từ góc nhìn của <strong>client</strong>, một call thủ tục được thực hiện, và một thời gian sau, kết quả được trả về. <strong>Server</strong> chỉ cần định nghĩa một số <strong>routine</strong> (thủ tục) mà nó muốn xuất ra. Phần “ma thuật” còn lại được xử lý bởi hệ thống RPC, vốn thường có hai thành phần chính:</p>
<ul>
<li><strong>Stub generator</strong> (trình tạo stub, đôi khi gọi là <strong>protocol compiler</strong> – trình biên dịch giao thức)</li>
<li><strong>Run-time library</strong> (thư viện thời gian chạy)</li>
</ul>
<p>Chúng ta sẽ xem xét chi tiết từng thành phần này ngay sau đây.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>BN84 – Tài liệu tham khảo gốc về RPC.</p>
</div>
<h3 id="trình-tạo-stub-stub-generator"><a class="header" href="#trình-tạo-stub-stub-generator">Trình tạo Stub (Stub Generator)</a></h3>
<p>Nhiệm vụ của <strong>stub generator</strong> khá đơn giản: loại bỏ phần khó khăn trong việc đóng gói (packing) các tham số và kết quả của hàm vào thông điệp bằng cách tự động hóa quá trình này. Cách tiếp cận này mang lại nhiều lợi ích: giúp tránh được những lỗi đơn giản thường gặp khi viết mã thủ công; hơn nữa, một <strong>stub compiler</strong> (trình biên dịch stub) có thể tối ưu mã này và cải thiện hiệu năng.</p>
<p><strong>Đầu vào</strong> của trình biên dịch này đơn giản là tập hợp các call hàm mà <strong>server</strong> muốn xuất ra cho <strong>client</strong>. Về mặt khái niệm, nó có thể đơn giản như sau:</p>
<pre><code class="language-c">interface {
    int func1(int arg1);
    int func2(int arg1, int arg2);
};
</code></pre>
<p><strong>Stub generator</strong> sẽ lấy một interface như trên và sinh ra một số thành phần mã khác nhau.</p>
<ul>
<li><strong>Phía client</strong>: sinh ra <strong>client stub</strong>, chứa mỗi hàm được định nghĩa trong interface; một chương trình client muốn sử dụng dịch vụ RPC này sẽ liên kết (link) với client stub và gọi vào đó để thực hiện các RPC.</li>
</ul>
<p>Bên trong, mỗi hàm trong client stub sẽ thực hiện toàn bộ công việc cần thiết để thực hiện <strong>remote procedure call</strong>.<br />
Từ góc nhìn của client, mã chỉ đơn giản là một call hàm (ví dụ: client gọi <code>func1(x)</code>); nhưng bên trong, mã trong client stub cho <code>func1()</code> sẽ thực hiện:</p>
<ul>
<li><strong>Tạo bộ đệm thông điệp (message buffer).</strong> Thông thường, đây chỉ là một mảng byte liên tiếp có kích thước nhất định.</li>
<li><strong>Đóng gói thông tin cần thiết vào message buffer.</strong> Thông tin này bao gồm một định danh (identifier) cho hàm cần gọi, cũng như tất cả các tham số mà hàm cần (ví dụ: trong trường hợp trên, một số nguyên cho <code>func1</code>). Quá trình đưa toàn bộ thông tin này vào một bộ đệm liên tiếp được gọi là <strong>marshaling</strong> (đóng gói tham số) hoặc <strong>serialization</strong> (tuần tự hóa thông điệp).</li>
<li><strong>Gửi thông điệp tới RPC server đích.</strong> Việc giao tiếp với RPC server và tất cả các chi tiết cần thiết để hoạt động đúng được xử lý bởi <strong>RPC run-time library</strong> (thư viện thời gian chạy RPC), sẽ được mô tả chi tiết hơn bên dưới.</li>
<li><strong>Chờ phản hồi.</strong> Vì call hàm thường là đồng bộ (<strong>synchronous</strong>), call sẽ chờ cho đến khi hoàn tất.</li>
<li><strong>Giải nén mã trả về và các tham số khác.</strong> Nếu hàm chỉ trả về một mã kết quả duy nhất, quá trình này khá đơn giản; tuy nhiên, các hàm phức tạp hơn có thể trả về kết quả phức tạp (ví dụ: một danh sách), và do đó stub có thể cần giải nén chúng. Bước này còn được gọi là <strong>unmarshaling</strong> hoặc <strong>deserialization</strong>.</li>
<li><strong>Trả kết quả về cho hàm gọi.</strong> Cuối cùng, trả kết quả từ client stub về mã client.</li>
</ul>
<p><strong>Phía server</strong> cũng được sinh mã. Các bước thực hiện trên server như sau:</p>
<ul>
<li><strong>Giải nén thông điệp.</strong> Bước này, gọi là <strong>unmarshaling</strong> hoặc <strong>deserialization</strong>, lấy thông tin ra khỏi thông điệp đến. Định danh hàm và các tham số được trích xuất.</li>
<li><strong>Gọi vào hàm thực tế.</strong> Cuối cùng! Đây là lúc hàm từ xa thực sự được thực thi. <strong>RPC runtime</strong> gọi vào hàm được chỉ định bởi ID và truyền vào các tham số cần thiết.</li>
<li><strong>Đóng gói kết quả.</strong> Các giá trị trả về được <strong>marshal</strong> trở lại thành một bộ đệm phản hồi duy nhất.</li>
<li><strong>Gửi phản hồi.</strong> Phản hồi được gửi lại cho phía gọi.</li>
</ul>
<p>Có một số vấn đề quan trọng khác cần xem xét trong <strong>stub compiler</strong>:</p>
<ul>
<li>
<p><strong>Tham số phức tạp</strong>: Làm thế nào để đóng gói và gửi một cấu trúc dữ liệu phức tạp?<br />
Ví dụ, khi gọi <strong>system call</strong> <code>write()</code>, ta truyền vào ba tham số: một số nguyên <strong>file descriptor</strong>, một con trỏ tới <strong>buffer</strong>, và một kích thước cho biết bao nhiêu byte (bắt đầu từ con trỏ) sẽ được ghi. Nếu một gói RPC nhận một con trỏ, nó cần biết cách diễn giải con trỏ đó và thực hiện hành động đúng. Thông thường, điều này được thực hiện thông qua:</p>
<ul>
<li>Các kiểu dữ liệu đã biết (ví dụ: <code>buffer_t</code> dùng để truyền các khối dữ liệu với kích thước xác định, mà RPC compiler hiểu được), hoặc</li>
<li>Gắn chú thích (annotation) vào cấu trúc dữ liệu với thông tin bổ sung, cho phép compiler biết byte nào cần được <strong>serialize</strong>.</li>
</ul>
</li>
<li>
<p><strong>Tổ chức server liên quan đến concurrency (tính đồng thời)</strong>:<br />
Một server đơn giản chỉ chờ yêu cầu trong một vòng lặp và xử lý từng yêu cầu một. Tuy nhiên, như bạn có thể đoán, điều này rất kém hiệu quả; nếu một call RPC bị chặn (ví dụ: do I/O), tài nguyên server sẽ bị lãng phí.<br />
Do đó, hầu hết server được xây dựng theo một dạng <strong>concurrent</strong> nào đó. Một mô hình phổ biến là <strong>thread pool</strong> (bể luồng). Trong mô hình này:</p>
<ul>
<li>Một tập hữu hạn các <strong>thread</strong> được tạo khi server khởi động.</li>
<li>Khi một thông điệp đến, nó được phân phối tới một trong các <strong>worker thread</strong>, luồng này sẽ thực hiện công việc của call RPC và cuối cùng phản hồi.</li>
<li>Trong thời gian đó, <strong>main thread</strong> tiếp tục nhận các yêu cầu khác và có thể phân phối chúng cho các worker khác.</li>
</ul>
</li>
</ul>
<p>Cách tổ chức này cho phép thực thi đồng thời trong server, tăng mức sử dụng tài nguyên; tuy nhiên, chi phí tiêu chuẩn cũng xuất hiện, chủ yếu là độ phức tạp lập trình, vì các call RPC giờ đây có thể cần sử dụng <strong>lock</strong> và các <strong>synchronization primitives</strong> (cơ chế đồng bộ hóa) khác để đảm bảo hoạt động đúng.</p>
<h3 id="thư-viện-thời-gian-chạy-run-time-library"><a class="header" href="#thư-viện-thời-gian-chạy-run-time-library">Thư viện thời gian chạy (Run-Time Library)</a></h3>
<p><strong>Run-time library</strong> đảm nhiệm phần lớn công việc nặng trong một hệ thống <strong>RPC</strong> (Remote Procedure Call – gọi thủ tục từ xa); hầu hết các vấn đề về hiệu năng và độ tin cậy đều được xử lý tại đây. Chúng ta sẽ cùng thảo luận một số thách thức chính khi xây dựng một tầng run-time như vậy.</p>
<p>Một trong những thách thức đầu tiên cần vượt qua là <strong>làm thế nào để định vị một dịch vụ từ xa</strong>. Vấn đề này, gọi là <strong>naming</strong> (đặt tên/định danh), là một vấn đề phổ biến trong các hệ thống phân tán, và ở một mức độ nào đó vượt ra ngoài phạm vi thảo luận hiện tại. Cách tiếp cận đơn giản nhất là xây dựng dựa trên các hệ thống đặt tên hiện có, ví dụ: <strong>hostname</strong> và <strong>port number</strong> do các giao thức Internet hiện tại cung cấp. Trong hệ thống như vậy, <strong>client</strong> phải biết hostname hoặc địa chỉ IP của máy đang chạy dịch vụ RPC mong muốn, cũng như số cổng mà nó đang sử dụng (port number chỉ đơn giản là một cách để định danh một hoạt động giao tiếp cụ thể đang diễn ra trên một máy, cho phép nhiều kênh giao tiếp đồng thời). Bộ giao thức (protocol suite) sau đó phải cung cấp cơ chế định tuyến các gói tin tới một địa chỉ cụ thể từ bất kỳ máy nào khác trong hệ thống. Để tìm hiểu sâu hơn về vấn đề naming, bạn có thể tham khảo các tài liệu về <strong>DNS</strong> và <strong>name resolution</strong> trên Internet, hoặc tốt hơn là đọc chương viết rất hay trong sách của Saltzer và Kaashoek [SK09].</p>
<p>Khi client đã biết server nào cần liên hệ cho một dịch vụ từ xa cụ thể, câu hỏi tiếp theo là <strong>RPC nên được xây dựng trên giao thức tầng vận chuyển (transport-level protocol) nào</strong>. Cụ thể, hệ thống RPC nên sử dụng một giao thức đáng tin cậy như <strong>TCP/IP</strong>, hay nên xây dựng trên một tầng giao tiếp không đáng tin cậy như <strong>UDP/IP</strong>?</p>
<p>Nếu suy nghĩ đơn giản, lựa chọn này có vẻ dễ dàng: rõ ràng chúng ta muốn yêu cầu được gửi <strong>đáng tin cậy</strong> tới server từ xa, và cũng muốn nhận phản hồi một cách đáng tin cậy. Vậy thì nên chọn giao thức vận chuyển đáng tin cậy như TCP, đúng không?</p>
<p>Đáng tiếc, xây dựng RPC trên một tầng giao tiếp đáng tin cậy có thể dẫn đến <strong>sự kém hiệu quả nghiêm trọng về hiệu năng</strong>. Hãy nhớ lại phần thảo luận ở trên về cách các tầng giao tiếp đáng tin cậy hoạt động: với <strong>acknowledgment</strong> (xác nhận) kết hợp với <strong>timeout/retry</strong> (hết thời gian chờ/thử lại). Do đó, khi client gửi một yêu cầu RPC tới server, server sẽ phản hồi bằng một ack để caller biết rằng yêu cầu đã được nhận. Tương tự, khi server gửi phản hồi tới client, client cũng gửi ack để server biết rằng phản hồi đã được nhận. Khi xây dựng một giao thức request/response (yêu cầu/đáp ứng) như RPC trên một tầng giao tiếp đáng tin cậy, sẽ có <strong>hai thông điệp “thừa”</strong> được gửi.</p>
<p>Vì lý do này, nhiều gói RPC được xây dựng trên các tầng giao tiếp không đáng tin cậy như UDP. Cách này cho phép một tầng RPC hiệu quả hơn, nhưng đồng thời bổ sung trách nhiệm đảm bảo độ tin cậy cho chính hệ thống RPC. Tầng RPC đạt được mức độ tin cậy mong muốn bằng cách sử dụng timeout/retry và acknowledgment tương tự như đã mô tả ở trên. Bằng cách sử dụng một dạng <strong>sequence numbering</strong> (đánh số thứ tự), tầng giao tiếp có thể đảm bảo rằng mỗi RPC diễn ra <strong>chính xác một lần</strong> (trong trường hợp không có lỗi), hoặc <strong>nhiều nhất một lần</strong> (trong trường hợp xảy ra lỗi).</p>
<h3 id="các-vấn-đề-khác-other-issues"><a class="header" href="#các-vấn-đề-khác-other-issues">Các vấn đề khác (Other Issues)</a></h3>
<p>Có một số vấn đề khác mà <strong>RPC run-time</strong> cũng phải xử lý. Ví dụ: điều gì xảy ra khi một call từ xa mất nhiều thời gian để hoàn tất? Với cơ chế timeout, một call từ xa chạy lâu có thể bị client coi là lỗi, dẫn đến việc retry, và do đó cần xử lý cẩn thận. Một giải pháp là sử dụng <strong>explicit acknowledgment</strong> (xác nhận rõ ràng từ phía nhận gửi tới phía gửi) khi phản hồi chưa được tạo ngay; điều này cho client biết rằng server đã nhận yêu cầu. Sau đó, sau một khoảng thời gian, client có thể định kỳ hỏi xem server vẫn đang xử lý yêu cầu hay không; nếu server liên tục trả lời “có”, client nên tiếp tục chờ (suy cho cùng, đôi khi một call thủ tục có thể mất nhiều thời gian để hoàn tất).</p>
<p>Run-time cũng phải xử lý các call thủ tục có tham số lớn, vượt quá kích thước có thể chứa trong một gói tin duy nhất. Một số giao thức mạng tầng thấp cung cấp chức năng <strong>fragmentation</strong> (phân mảnh phía gửi – chia gói lớn thành nhiều gói nhỏ) và <strong>reassembly</strong> (tái hợp phía nhận – ghép các phần nhỏ thành một khối logic lớn hơn); nếu không, RPC run-time có thể phải tự triển khai chức năng này. Xem chi tiết trong bài báo của Birrell và Nelson [BN84].</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: LẬP LUẬN END-TO-END (THE END-TO-END ARGUMENT)</strong><br />
Lập luận <strong>end-to-end</strong> cho rằng tầng cao nhất trong một hệ thống, thường là ứng dụng ở “đầu cuối”, mới là nơi duy nhất trong một hệ thống phân tầng có thể thực sự triển khai một số chức năng nhất định. Trong bài báo nổi tiếng [SRC84], Saltzer và cộng sự đã minh họa điều này qua một ví dụ xuất sắc: <strong>truyền tệp tin đáng tin cậy</strong> giữa hai máy. Nếu bạn muốn truyền một tệp từ máy A sang máy B, và đảm bảo rằng các byte trên B <strong>chính xác</strong> giống với các byte ban đầu trên A, bạn phải có một cơ chế kiểm tra “end-to-end” cho việc này; các cơ chế đáng tin cậy ở tầng thấp hơn, ví dụ trong mạng hoặc đĩa, không cung cấp được đảm bảo này.</p>
<p>Ngược lại là cách tiếp cận cố gắng giải quyết vấn đề truyền tệp tin đáng tin cậy bằng cách thêm độ tin cậy vào các tầng thấp hơn của hệ thống. Ví dụ, giả sử chúng ta xây dựng một giao thức truyền thông đáng tin cậy và sử dụng nó để xây dựng truyền tệp tin đáng tin cậy. Giao thức truyền thông này đảm bảo rằng mọi byte được gửi bởi phía gửi sẽ được nhận theo đúng thứ tự bởi phía nhận, sử dụng timeout/retry, acknowledgment và sequence number. Đáng tiếc, sử dụng một giao thức như vậy <strong>không</strong> đồng nghĩa với việc truyền tệp tin là đáng tin cậy; hãy tưởng tượng dữ liệu bị hỏng trong bộ nhớ của phía gửi trước khi truyền, hoặc xảy ra sự cố khi phía nhận ghi dữ liệu xuống đĩa. Trong những trường hợp đó, mặc dù dữ liệu đã được truyền đáng tin cậy qua mạng, việc truyền tệp tin của chúng ta cuối cùng vẫn <strong>không</strong> đáng tin cậy. Để xây dựng một truyền tệp tin đáng tin cậy, phải bao gồm các kiểm tra độ tin cậy end-to-end, ví dụ: sau khi truyền xong, đọc lại tệp trên đĩa của phía nhận, tính toán checksum và so sánh với checksum của tệp trên phía gửi.</p>
<p>Hệ quả của nguyên tắc này là đôi khi việc để các tầng thấp hơn cung cấp thêm chức năng có thể cải thiện hiệu năng hệ thống hoặc tối ưu hóa hệ thống. Do đó, bạn không nên loại trừ hoàn toàn việc có các cơ chế như vậy ở tầng thấp hơn; thay vào đó, hãy cân nhắc kỹ lưỡng tính hữu ích của chúng, xét đến cách chúng sẽ được sử dụng trong toàn bộ hệ thống hoặc ứng dụng.</p>
</blockquote>
</blockquote>
<p>Một vấn đề mà nhiều hệ thống phải xử lý là <strong>byte ordering</strong> (thứ tự byte). Như bạn có thể biết, một số máy lưu trữ giá trị theo thứ tự gọi là <strong>big endian</strong>, trong khi những máy khác sử dụng <strong>little endian</strong>.</p>
<ul>
<li><strong>Big endian</strong> lưu các byte (ví dụ, của một số nguyên) từ bit có trọng số cao nhất đến bit có trọng số thấp nhất, tương tự như cách viết số Ả Rập.</li>
<li><strong>Little endian</strong> thì ngược lại.</li>
</ul>
<p>Cả hai đều là những cách hợp lệ để lưu trữ thông tin số; câu hỏi đặt ra ở đây là <strong>làm thế nào để giao tiếp giữa các máy có endianness khác nhau</strong>.</p>
<p>Các gói RPC thường xử lý vấn đề này bằng cách cung cấp một <strong>endianness</strong> được xác định rõ ràng trong định dạng thông điệp của chúng. Trong gói RPC của Sun, lớp <strong>XDR (eXternal Data Representation)</strong> cung cấp chức năng này.</p>
<ul>
<li>Nếu máy gửi hoặc nhận thông điệp có cùng endianness với XDR, thông điệp sẽ được gửi và nhận như bình thường.</li>
<li>Nếu máy giao tiếp có endianness khác, mỗi phần thông tin trong thông điệp phải được chuyển đổi.</li>
</ul>
<p>Do đó, sự khác biệt về endianness có thể gây ra một chi phí hiệu năng nhỏ.</p>
<p>Một vấn đề cuối cùng là liệu có nên <strong>phơi bày bản chất bất đồng bộ (asynchronous)</strong> của giao tiếp cho client hay không, từ đó cho phép một số tối ưu hóa hiệu năng.<br />
Cụ thể, RPC thông thường được thực hiện <strong>đồng bộ</strong> (synchronous), tức là khi client thực hiện call thủ tục, nó phải chờ cho đến khi call trả về trước khi tiếp tục. Vì thời gian chờ này có thể dài, và vì client có thể có những công việc khác cần làm, một số gói RPC cho phép gọi RPC <strong>bất đồng bộ</strong> (asynchronous).</p>
<p>Khi một RPC bất đồng bộ được thực hiện, gói RPC sẽ gửi yêu cầu và trả về ngay lập tức; client sau đó có thể tự do làm việc khác, chẳng hạn gọi các RPC khác hoặc thực hiện các tính toán hữu ích khác.<br />
Tại một thời điểm nào đó, client sẽ muốn xem kết quả của RPC bất đồng bộ; khi đó nó sẽ gọi lại vào tầng RPC, yêu cầu chờ cho đến khi các RPC đang chờ hoàn tất, và lúc này các tham số trả về mới có thể được truy cập.</p>
<h2 id="486-tóm-tắt-summary"><a class="header" href="#486-tóm-tắt-summary">48.6 Tóm tắt (Summary)</a></h2>
<p>Chúng ta đã được giới thiệu một chủ đề mới: <strong>hệ thống phân tán</strong> (distributed systems), và vấn đề lớn nhất của nó: <strong>xử lý lỗi</strong> (failure) – điều giờ đây đã trở thành chuyện thường ngày. Như người ta vẫn nói ở Google: khi bạn chỉ có một máy tính để bàn, lỗi là hiếm; nhưng khi bạn ở trong một <strong>data center</strong> với hàng nghìn máy, lỗi xảy ra <strong>liên tục</strong>.<br />
<strong>Chìa khóa</strong> của bất kỳ hệ thống phân tán nào là cách bạn xử lý những lỗi đó.</p>
<p>Chúng ta cũng đã thấy rằng <strong>giao tiếp</strong> là trái tim của mọi hệ thống phân tán. Một trừu tượng phổ biến của giao tiếp này là <strong>remote procedure call (RPC)</strong>, cho phép client thực hiện các call từ xa tới server; gói RPC xử lý tất cả các chi tiết phức tạp, bao gồm <strong>timeout/retry</strong> và <strong>acknowledgment</strong>, để cung cấp một dịch vụ gần giống nhất với call thủ tục cục bộ.</p>
<p>Cách tốt nhất để thực sự hiểu một gói RPC tất nhiên là <strong>tự mình sử dụng nó</strong>. Hệ thống RPC của Sun, sử dụng trình biên dịch stub <code>rpcgen</code>, là một ví dụ cũ; <strong>gRPC</strong> của Google và <strong>Apache Thrift</strong> là những phiên bản hiện đại hơn của cùng ý tưởng. Hãy thử một trong số chúng và tự trải nghiệm để hiểu tại sao chúng lại được quan tâm đến vậy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="49-hệ-thống-tệp-mạng-của-sun-suns-network-file-system--nfs"><a class="header" href="#49-hệ-thống-tệp-mạng-của-sun-suns-network-file-system--nfs">49. Hệ thống Tệp Mạng của Sun (Sun’s Network File System – NFS)</a></h1>
<p>Một trong những ứng dụng đầu tiên của mô hình tính toán <strong>client/server</strong> phân tán là trong lĩnh vực <strong>distributed file system</strong> (hệ thống tệp phân tán). Trong môi trường như vậy, có một số máy client và một máy server (hoặc một vài máy); server lưu trữ dữ liệu trên các ổ đĩa của nó, và các client yêu cầu dữ liệu thông qua các thông điệp giao thức được định dạng chuẩn.</p>
<p><img src="49/img/fig49_1.PNG" alt="" /></p>
<p><strong>Hình 49.1: Một hệ thống Client/Server tổng quát</strong></p>
<p>Như bạn có thể thấy từ hình minh họa, server sở hữu các ổ đĩa, và các client gửi thông điệp qua mạng để truy cập thư mục và tệp trên các ổ đĩa đó.</p>
<p>Tại sao chúng ta lại sử dụng mô hình này? (tức là, tại sao không để client dùng ổ đĩa cục bộ của chính nó?)</p>
<ul>
<li>Lý do chính là mô hình này cho phép <strong>chia sẻ dữ liệu dễ dàng</strong> giữa các client. Ví dụ, nếu bạn truy cập một tệp trên một máy (Client 0) và sau đó sử dụng một máy khác (Client 2), bạn sẽ có cùng một cái nhìn về hệ thống tệp. Dữ liệu của bạn được chia sẻ một cách tự nhiên giữa các máy khác nhau.</li>
<li>Lợi ích thứ hai là <strong>quản trị tập trung</strong>; ví dụ, việc sao lưu tệp có thể được thực hiện từ một vài máy server thay vì từ hàng loạt máy client.</li>
<li>Một lợi ích khác có thể là <strong>bảo mật</strong>; việc đặt tất cả server trong một phòng máy được khóa sẽ ngăn chặn một số loại sự cố nhất định.</li>
</ul>
<blockquote>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ XÂY DỰNG MỘT DISTRIBUTED FILE SYSTEM</strong><br />
Làm thế nào để xây dựng một hệ thống tệp phân tán? Những khía cạnh chính cần xem xét là gì? Điều gì dễ mắc sai lầm? Chúng ta có thể học được gì từ các hệ thống hiện có?</p>
</blockquote>
</blockquote>
<h2 id="491-một-distributed-file-system-cơ-bản"><a class="header" href="#491-một-distributed-file-system-cơ-bản">49.1 Một Distributed File System cơ bản</a></h2>
<p>Bây giờ chúng ta sẽ nghiên cứu kiến trúc của một hệ thống tệp phân tán đơn giản. Một hệ thống tệp phân tán kiểu client/server đơn giản có nhiều thành phần hơn so với các hệ thống tệp mà chúng ta đã nghiên cứu trước đây.</p>
<ul>
<li>
<p><strong>Phía client</strong>: có các ứng dụng client truy cập tệp và thư mục thông qua <strong>client-side file system</strong> (hệ thống tệp phía client).<br />
Ứng dụng client gọi các <strong>system call</strong> tới client-side file system (chẳng hạn như <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>, <code>mkdir()</code>, v.v.) để truy cập các tệp được lưu trữ trên server.<br />
Do đó, đối với ứng dụng client, hệ thống tệp không khác gì so với hệ thống tệp cục bộ (dựa trên đĩa), ngoại trừ có thể về hiệu năng; theo cách này, distributed file system cung cấp khả năng truy cập tệp <strong>minh bạch</strong> (transparent access) – một mục tiêu hiển nhiên; rốt cuộc, ai lại muốn dùng một hệ thống tệp yêu cầu một bộ API khác hoặc gây khó khăn khi sử dụng?</p>
</li>
<li>
<p><strong>Vai trò của client-side file system</strong> là thực hiện các hành động cần thiết để xử lý các system call đó.<br />
Ví dụ, nếu client thực hiện một yêu cầu <code>read()</code>, client-side file system có thể gửi một thông điệp tới <strong>server-side file system</strong> (hay thường gọi là <strong>file server</strong>) để đọc một block cụ thể; file server sau đó sẽ đọc block từ đĩa (hoặc từ <strong>in-memory cache</strong> của nó), và gửi lại một thông điệp cho client chứa dữ liệu được yêu cầu.<br />
Client-side file system sau đó sẽ sao chép dữ liệu vào <strong>user buffer</strong> được truyền cho system call <code>read()</code>, và yêu cầu sẽ hoàn tất.<br />
Lưu ý rằng, một lần <code>read()</code> tiếp theo của cùng block đó trên client có thể được lấy từ bộ nhớ cache của client hoặc thậm chí từ đĩa cục bộ của client; trong trường hợp tốt nhất, sẽ <strong>không cần</strong> tạo ra lưu lượng mạng nào.</p>
</li>
</ul>
<p><img src="49/img/fig49_2.PNG" alt="" /></p>
<p><strong>Hình 49.2: Kiến trúc Distributed File System</strong></p>
<p>Từ cái nhìn tổng quan đơn giản này, bạn có thể thấy rằng có <strong>hai thành phần phần mềm quan trọng</strong> trong một distributed file system kiểu client/server:</p>
<ol>
<li><strong>Client-side file system</strong></li>
<li><strong>File server</strong></li>
</ol>
<p>Hành vi kết hợp của chúng quyết định hành vi của toàn bộ distributed file system. Bây giờ là lúc nghiên cứu một hệ thống cụ thể: <strong>Sun’s Network File System (NFS)</strong>.</p>
<h2 id="492-tìm-hiểu-về-nfs"><a class="header" href="#492-tìm-hiểu-về-nfs">49.2 Tìm hiểu về NFS</a></h2>
<p>Một trong những hệ thống phân tán đầu tiên và khá thành công được phát triển bởi <strong>Sun Microsystems</strong>, được gọi là <strong>Sun Network File System (NFS)</strong> [S86].</p>
<p>Khi định nghĩa NFS, Sun đã chọn một cách tiếp cận khác thường: thay vì xây dựng một hệ thống độc quyền và đóng, Sun đã phát triển một <strong>giao thức mở</strong> chỉ đơn giản là <strong>xác định chính xác định dạng thông điệp</strong> mà client và server sẽ sử dụng để giao tiếp.</p>
<p>Nhờ đó, các nhóm khác nhau có thể phát triển NFS server của riêng họ và cạnh tranh trong thị trường NFS, đồng thời vẫn đảm bảo khả năng tương tác (<strong>interoperability</strong>). Và điều này đã thành công: ngày nay có nhiều công ty bán NFS server (bao gồm Oracle/Sun, NetApp [HLM94], EMC, IBM và những hãng khác), và sự thành công rộng rãi của NFS có thể được cho là nhờ vào cách tiếp cận “<strong>thị trường mở</strong>” này.</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: TẠI SAO SERVER BỊ CRASH</strong><br />
Trước khi đi sâu vào chi tiết của giao thức NFSv2, bạn có thể tự hỏi: tại sao server lại bị crash? Như bạn có thể đoán, có rất nhiều lý do. Server có thể đơn giản bị mất điện (tạm thời); chỉ khi có điện trở lại thì máy mới có thể khởi động lại. Server thường bao gồm hàng trăm nghìn hoặc thậm chí hàng triệu dòng mã; do đó, chúng có lỗi (<strong>bug</strong>) (ngay cả phần mềm tốt cũng có một vài lỗi trên mỗi trăm hoặc nghìn dòng mã), và cuối cùng sẽ gặp phải một lỗi gây crash. Chúng cũng có thể bị <strong>memory leak</strong> (rò rỉ bộ nhớ); ngay cả một rò rỉ nhỏ cũng có thể khiến hệ thống hết bộ nhớ và crash. Và cuối cùng, trong các hệ thống phân tán, luôn tồn tại mạng giữa client và server; nếu mạng hoạt động bất thường (ví dụ: nếu bị phân vùng – <strong>network partition</strong> – và client và server vẫn hoạt động nhưng không thể giao tiếp), thì có thể <strong>trông như</strong> một máy từ xa đã bị crash, nhưng thực tế là nó chỉ tạm thời không thể truy cập qua mạng.</p>
</blockquote>
</blockquote>
<h2 id="493-trọng-tâm-khôi-phục-nhanh-và-đơn-giản-khi-server-bị-crash-simple-and-fast-server-crash-recovery"><a class="header" href="#493-trọng-tâm-khôi-phục-nhanh-và-đơn-giản-khi-server-bị-crash-simple-and-fast-server-crash-recovery">49.3 Trọng tâm: Khôi phục nhanh và đơn giản khi server bị crash (Simple And Fast Server Crash Recovery)</a></h2>
<p>Trong chương này, chúng ta sẽ thảo luận về <strong>giao thức NFS cổ điển</strong> (phiên bản 2, hay còn gọi là <strong>NFSv2</strong>), vốn đã là tiêu chuẩn trong nhiều năm; khi chuyển sang <strong>NFSv3</strong> chỉ có một số thay đổi nhỏ, còn khi chuyển sang <strong>NFSv4</strong> thì có những thay đổi lớn hơn về giao thức. Tuy nhiên, NFSv2 vừa tuyệt vời vừa gây nhiều bực bội, và do đó sẽ là trọng tâm nghiên cứu của chúng ta.</p>
<p>Trong NFSv2, mục tiêu chính khi thiết kế giao thức là <strong>khôi phục nhanh chóng và đơn giản khi server bị crash</strong>. Trong môi trường nhiều client – một server, mục tiêu này là hoàn toàn hợp lý; bất kỳ phút nào server ngừng hoạt động (hoặc không thể truy cập) đều khiến tất cả các máy client (và người dùng của chúng) không hài lòng và giảm năng suất. Nói cách khác, <strong>server ra sao thì cả hệ thống sẽ như vậy</strong>.</p>
<h2 id="494-chìa-khóa-để-khôi-phục-nhanh-khi-crash-statelessness"><a class="header" href="#494-chìa-khóa-để-khôi-phục-nhanh-khi-crash-statelessness">49.4 Chìa khóa để khôi phục nhanh khi crash: Statelessness</a></h2>
<p>Mục tiêu đơn giản này được hiện thực hóa trong NFSv2 bằng cách thiết kế một giao thức <strong>stateless</strong> (không lưu trạng thái). Theo thiết kế, server <strong>không</strong> theo dõi bất kỳ thông tin nào về những gì đang diễn ra ở mỗi client.<br />
Ví dụ: server không biết client nào đang cache block nào, hoặc file nào đang được mở ở mỗi client, hoặc vị trí con trỏ file hiện tại của một file, v.v. Nói ngắn gọn, server không theo dõi bất kỳ hoạt động nào của client; thay vào đó, giao thức được thiết kế sao cho <strong>mỗi yêu cầu giao thức đều chứa toàn bộ thông tin cần thiết để hoàn tất yêu cầu đó</strong>. Nếu điều này chưa rõ ràng, cách tiếp cận stateless sẽ trở nên dễ hiểu hơn khi chúng ta phân tích chi tiết giao thức ở phần sau.</p>
<p>Ví dụ về một giao thức <strong>stateful</strong> (có lưu trạng thái, tức là không stateless) là system call <code>open()</code>.<br />
Với một <strong>pathname</strong>, <code>open()</code> trả về một <strong>file descriptor</strong> (một số nguyên). Descriptor này được sử dụng trong các call <code>read()</code> hoặc <code>write()</code> tiếp theo để truy cập các block dữ liệu của file, như trong đoạn code ứng dụng sau (lưu ý: phần kiểm tra lỗi của system call được lược bỏ để tiết kiệm không gian):</p>
<pre><code class="language-c">char buffer[MAX];
int fd = open(&quot;foo&quot;, O_RDONLY); // lấy descriptor &quot;fd&quot;
read(fd, buffer, MAX);          // đọc MAX byte từ foo qua &quot;fd&quot;
read(fd, buffer, MAX);          // đọc MAX byte lần nữa
...
read(fd, buffer, MAX);          // đọc MAX byte lần nữa
close(fd);                      // đóng file
</code></pre>
<p><img src="49/img/fig49_3.PNG" alt="" /></p>
<p><strong>Hình 49.3: Mã phía client – Đọc từ một file</strong></p>
<p>Bây giờ hãy tưởng tượng <strong>client-side file system</strong> mở file bằng cách gửi một thông điệp giao thức tới server với nội dung: “mở file ‘foo’ và trả lại cho tôi một descriptor”. <strong>File server</strong> sau đó mở file cục bộ ở phía nó và gửi descriptor này về cho client.<br />
Trong các lần đọc tiếp theo, ứng dụng client sử dụng descriptor đó để gọi system call <code>read()</code>; client-side file system sẽ truyền descriptor này trong thông điệp gửi tới file server, với nội dung: “đọc một số byte từ file được tham chiếu bởi descriptor mà tôi đang gửi cho bạn”.</p>
<p>Trong ví dụ này, <strong>file descriptor</strong> là một phần của <strong>shared state</strong> (trạng thái chia sẻ) giữa client và server (Ousterhout gọi đây là <strong>distributed state</strong> [O91]). <strong>Shared state</strong>, như đã gợi ý ở trên, làm phức tạp quá trình khôi phục sau crash.<br />
Hãy tưởng tượng server bị crash sau khi hoàn tất lần đọc đầu tiên, nhưng trước khi client gửi yêu cầu đọc thứ hai. Sau khi server khởi động lại, client gửi yêu cầu đọc thứ hai. Đáng tiếc, server <strong>không hề biết</strong> <code>fd</code> đang tham chiếu tới file nào; thông tin đó chỉ tồn tại tạm thời trong bộ nhớ và đã bị mất khi server crash.<br />
Để xử lý tình huống này, client và server sẽ phải thực hiện một <strong>recovery protocol</strong> (giao thức khôi phục), trong đó client phải giữ đủ thông tin trong bộ nhớ của mình để có thể thông báo cho server những gì nó cần biết (trong trường hợp này là file descriptor <code>fd</code> tham chiếu tới file <code>foo</code>).</p>
<p>Tình huống còn tệ hơn khi xét đến việc <strong>stateful server</strong> phải xử lý <strong>client crash</strong>.<br />
Ví dụ: một client mở một file và sau đó bị crash. Lời gọi <code>open()</code> đã tiêu tốn một file descriptor trên server; làm sao server biết được khi nào thì an toàn để đóng file đó?<br />
Trong hoạt động bình thường, client cuối cùng sẽ gọi <code>close()</code> và thông báo cho server rằng file nên được đóng. Tuy nhiên, khi client bị crash, server sẽ không bao giờ nhận được <code>close()</code>, và do đó phải tự phát hiện client đã crash để đóng file.</p>
<p>Vì những lý do này, các nhà thiết kế NFS đã quyết định theo đuổi cách tiếp cận <strong>stateless</strong>: <strong>mỗi thao tác của client đều chứa toàn bộ thông tin cần thiết để hoàn tất yêu cầu</strong>.<br />
Không cần cơ chế khôi phục phức tạp; server chỉ cần khởi động lại, và client, trong trường hợp xấu nhất, chỉ cần gửi lại yêu cầu.</p>
<h2 id="495-giao-thức-nfsv2-the-nfsv2-protocol"><a class="header" href="#495-giao-thức-nfsv2-the-nfsv2-protocol">49.5 Giao thức NFSv2 (The NFSv2 Protocol)</a></h2>
<p>Chúng ta đến với phần định nghĩa giao thức NFSv2. Bài toán đặt ra rất đơn giản:</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ ĐỊNH NGHĨA MỘT FILE PROTOCOL THEO KIỂU STATELESS</strong><br />
Làm thế nào để định nghĩa giao thức mạng cho phép hoạt động ở chế độ <strong>stateless</strong> (không lưu trạng thái)? Rõ ràng, các call <strong>stateful</strong> như <code>open()</code> không thể nằm trong phạm vi thảo luận (vì nó yêu cầu server phải theo dõi các file đang mở); tuy nhiên, ứng dụng phía client vẫn muốn gọi <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code> và các call API chuẩn khác để truy cập file và thư mục. Do đó, câu hỏi chi tiết hơn là: làm thế nào để định nghĩa giao thức vừa <strong>stateless</strong> vừa hỗ trợ API hệ thống tệp <strong>POSIX</strong>?</p>
</blockquote>
</blockquote>
<p>Một yếu tố then chốt để hiểu thiết kế của giao thức NFS là <strong>file handle</strong>. <strong>File handle</strong> được dùng để mô tả duy nhất file hoặc thư mục mà một thao tác cụ thể sẽ thực hiện; do đó, nhiều yêu cầu giao thức sẽ bao gồm một file handle.</p>
<p>Bạn có thể hình dung một file handle gồm ba thành phần quan trọng:</p>
<ol>
<li><strong>Volume identifier</strong> (định danh volume)</li>
<li><strong>Inode number</strong> (số inode)</li>
<li><strong>Generation number</strong> (số thế hệ)</li>
</ol>
<p>Kết hợp lại, ba thành phần này tạo thành một định danh duy nhất cho một file hoặc thư mục mà client muốn truy cập.</p>
<ul>
<li><strong>Volume identifier</strong> cho server biết yêu cầu đang tham chiếu tới hệ thống tệp nào (một NFS server có thể export nhiều hệ thống tệp).</li>
<li><strong>Inode number</strong> cho server biết file nào trong phân vùng đó đang được truy cập.</li>
<li><strong>Generation number</strong> cần thiết khi tái sử dụng một inode number; bằng cách tăng giá trị này mỗi khi inode number được tái sử dụng, server đảm bảo rằng một client với file handle cũ sẽ không thể vô tình truy cập vào file mới được cấp phát.</li>
</ul>
<p>Dưới đây là tóm tắt một số thành phần quan trọng của giao thức; toàn bộ giao thức có thể tìm thấy ở nơi khác (xem sách của Callaghan để có cái nhìn chi tiết và xuất sắc về NFS [C00]).</p>
<p><img src="49/img/fig49_4.PNG" alt="" /></p>
<p><strong>Hình 49.4: Giao thức NFS – Ví dụ</strong></p>
<p>Một số thành phần quan trọng của giao thức:</p>
<ul>
<li>
<p><strong>LOOKUP</strong>: được dùng để lấy file handle, sau đó sẽ được sử dụng để truy cập dữ liệu file. Client gửi <strong>directory file handle</strong> và tên file cần tra cứu; server trả về file handle (hoặc directory handle) của file đó kèm theo <strong>attributes</strong> (thuộc tính).<br />
Ví dụ: giả sử client đã có file handle của thư mục gốc <code>/</code> (thực tế, điều này có được thông qua <strong>NFS mount protocol</strong>, là cách client và server kết nối ban đầu; chúng ta sẽ không bàn chi tiết về mount protocol ở đây). Nếu một ứng dụng trên client mở file <code>/foo.txt</code>, client-side file system sẽ gửi yêu cầu LOOKUP tới server, truyền vào file handle của <code>/</code> và tên <code>foo.txt</code>; nếu thành công, file handle (và attributes) của <code>foo.txt</code> sẽ được trả về.</p>
</li>
<li>
<p><strong>Attributes</strong>: là metadata mà hệ thống tệp lưu cho mỗi file, bao gồm thời gian tạo file, thời gian sửa đổi cuối cùng, kích thước, thông tin quyền sở hữu và phân quyền, v.v. – tức là cùng loại thông tin mà bạn nhận được khi gọi <code>stat()</code> trên một file.</p>
</li>
<li>
<p><strong>READ</strong> và <strong>WRITE</strong>:</p>
<ul>
<li><strong>READ</strong> yêu cầu client gửi file handle, offset trong file và số byte cần đọc. Server sẽ đọc dữ liệu (file handle cho biết volume và inode, offset và count cho biết byte nào cần đọc) và trả về dữ liệu cùng attributes mới nhất (hoặc lỗi nếu thất bại).</li>
<li><strong>WRITE</strong> tương tự, nhưng dữ liệu được gửi từ client tới server, và server trả về mã thành công cùng attributes mới nhất.</li>
</ul>
</li>
<li>
<p><strong>GETATTR</strong>: cho một file handle, yêu cầu này trả về attributes của file, bao gồm thời gian sửa đổi cuối cùng. Chúng ta sẽ thấy tại sao yêu cầu này quan trọng trong NFSv2 khi bàn về caching (bạn có đoán được lý do không?).</p>
</li>
</ul>
<h2 id="496-từ-giao-thức-đến-distributed-file-system-from-protocol-to-distributed-file-system"><a class="header" href="#496-từ-giao-thức-đến-distributed-file-system-from-protocol-to-distributed-file-system">49.6 Từ giao thức đến Distributed File System (From Protocol To Distributed File System)</a></h2>
<p>Hy vọng đến đây bạn đã hình dung được cách giao thức này được triển khai thành một hệ thống tệp phân tán thông qua <strong>client-side file system</strong> và <strong>file server</strong>.</p>
<ul>
<li><strong>Client-side file system</strong> theo dõi các file đang mở và thường dịch các yêu cầu của ứng dụng thành tập hợp các thông điệp giao thức tương ứng.</li>
<li><strong>Server</strong> chỉ đơn giản phản hồi các thông điệp giao thức, mỗi thông điệp chứa toàn bộ thông tin cần thiết để hoàn tất yêu cầu.</li>
</ul>
<p>Ví dụ, hãy xét một ứng dụng đơn giản đọc một file. Trong sơ đồ (<strong>Hình 49.5</strong>), chúng ta thấy các system call mà ứng dụng thực hiện, và cách client-side file system cùng file server xử lý các call này.</p>
<p><img src="49/img/fig49_5.PNG" alt="" /></p>
<p><strong>Hình 49.5: Đọc một file – Hoạt động của Client-side và File Server</strong></p>
<p>Một vài nhận xét về hình minh họa:</p>
<ol>
<li>
<p><strong>Client</strong> theo dõi toàn bộ trạng thái liên quan đến truy cập file, bao gồm ánh xạ từ <strong>file descriptor</strong> (số nguyên) sang <strong>NFS file handle</strong> và vị trí con trỏ file hiện tại. Điều này cho phép client biến mỗi yêu cầu đọc (vốn không chỉ rõ offset cần đọc) thành một thông điệp READ được định dạng đúng, chỉ rõ cho server byte nào của file cần đọc. Sau khi đọc thành công, client cập nhật vị trí con trỏ file; các lần đọc tiếp theo sẽ dùng cùng file handle nhưng offset khác.</p>
</li>
<li>
<p><strong>Tương tác với server</strong>: Khi file được mở lần đầu, client-side file system gửi thông điệp LOOKUP. Nếu đường dẫn dài (ví dụ <code>/home/remzi/foo.txt</code>), client sẽ gửi ba LOOKUP:</p>
<ul>
<li>Một để tra <code>home</code> trong thư mục <code>/</code></li>
<li>Một để tra <code>remzi</code> trong <code>home</code></li>
<li>Và một để tra <code>foo.txt</code> trong <code>remzi</code>.</li>
</ul>
</li>
<li>
<p><strong>Mỗi yêu cầu tới server</strong> đều chứa toàn bộ thông tin cần thiết để hoàn tất yêu cầu. Đây là điểm thiết kế quan trọng để có thể khôi phục trơn tru sau khi server bị lỗi, vì nó đảm bảo server không cần trạng thái để phản hồi yêu cầu.</p>
</li>
</ol>
<h2 id="497-xử-lý-lỗi-server-với-các-thao-tác-idempotent-handling-server-failure-with-idempotent-operations"><a class="header" href="#497-xử-lý-lỗi-server-với-các-thao-tác-idempotent-handling-server-failure-with-idempotent-operations">49.7 Xử lý lỗi server với các thao tác idempotent (Handling Server Failure With Idempotent Operations)</a></h2>
<p>Khi một <strong>client</strong> gửi thông điệp tới <strong>server</strong>, đôi khi nó không nhận được phản hồi. Có nhiều nguyên nhân có thể dẫn đến việc này.</p>
<ul>
<li>Trong một số trường hợp, thông điệp có thể bị <strong>network</strong> (mạng) làm rơi; mạng có thể làm mất gói tin, và do đó hoặc yêu cầu hoặc phản hồi có thể bị mất, khiến client không bao giờ nhận được câu trả lời.</li>
<li>Cũng có thể server đã bị <strong>crash</strong> và do đó hiện tại không phản hồi các thông điệp. Sau một thời gian, server sẽ được khởi động lại và chạy bình thường, nhưng trong thời gian đó tất cả các yêu cầu đã bị mất.</li>
</ul>
<p>Trong tất cả các trường hợp này, client sẽ phải đối mặt với câu hỏi: <strong>nên làm gì khi server không phản hồi kịp thời?</strong></p>
<p>Trong <strong>NFSv2</strong>, client xử lý tất cả các lỗi này theo một cách <strong>duy nhất, thống nhất và gọn gàng</strong>: nó đơn giản là <strong>gửi lại yêu cầu</strong>.<br />
Cụ thể, sau khi gửi yêu cầu, client đặt một bộ đếm thời gian (<strong>timer</strong>) để kích hoạt sau một khoảng thời gian nhất định.</p>
<ul>
<li>Nếu phản hồi được nhận trước khi timer kích hoạt, timer bị hủy và mọi thứ đều ổn.</li>
<li>Nếu timer kích hoạt trước khi nhận được phản hồi, client giả định rằng yêu cầu chưa được xử lý và gửi lại.<br />
Nếu server phản hồi, mọi thứ lại ổn và client đã xử lý gọn gàng vấn đề.</li>
</ul>
<p>Khả năng của client trong việc đơn giản gửi lại yêu cầu (bất kể nguyên nhân lỗi là gì) là nhờ một thuộc tính quan trọng của hầu hết các yêu cầu NFS: chúng là <strong>idempotent</strong>.</p>
<p><strong>Idempotent</strong> nghĩa là: hiệu ứng của việc thực hiện thao tác nhiều lần <strong>tương đương</strong> với hiệu ứng của việc thực hiện thao tác đó một lần duy nhất.</p>
<ul>
<li>Ví dụ: nếu bạn ghi một giá trị vào một vị trí bộ nhớ ba lần, kết quả giống như chỉ ghi một lần ⇒ “store value to memory” là một thao tác idempotent.</li>
<li>Ngược lại, nếu bạn tăng một bộ đếm ba lần, kết quả sẽ khác so với chỉ tăng một lần ⇒ “increment counter” <strong>không</strong> phải là idempotent.</li>
</ul>
<p>Nói chung, mọi thao tác chỉ đọc dữ liệu thì hiển nhiên là idempotent; còn thao tác cập nhật dữ liệu thì cần xem xét kỹ để xác định xem nó có thuộc tính này hay không.</p>
<p>Trọng tâm của thiết kế <strong>crash recovery</strong> (khôi phục sau crash) trong NFS là tính idempotent của hầu hết các thao tác phổ biến:</p>
<ul>
<li><strong>LOOKUP</strong> và <strong>READ</strong> là idempotent một cách hiển nhiên, vì chúng chỉ đọc thông tin từ file server và không cập nhật gì.</li>
<li>Thú vị hơn, <strong>WRITE</strong> cũng là idempotent. Nếu một WRITE thất bại, client có thể đơn giản gửi lại. Thông điệp WRITE chứa dữ liệu, số byte (count), và <strong>offset chính xác</strong> để ghi dữ liệu. Do đó, nó có thể được lặp lại với đảm bảo rằng kết quả của nhiều lần ghi giống hệt kết quả của một lần ghi.</li>
</ul>
<p><img src="49/img/fig49_6.PNG" alt="" /></p>
<p><strong>Hình 49.6: Ba loại mất mát (The Three Types Of Loss)</strong></p>
<p>Theo cách này, client có thể xử lý tất cả các timeout theo một cách thống nhất:</p>
<ul>
<li><strong>Case 1</strong>: Nếu một yêu cầu WRITE bị mất, client sẽ gửi lại, server thực hiện ghi, và mọi thứ ổn.</li>
<li><strong>Case 2</strong>: Nếu server bị down khi yêu cầu được gửi, nhưng đã up trở lại khi yêu cầu thứ hai được gửi, mọi thứ vẫn hoạt động như mong muốn.</li>
<li><strong>Case 3</strong>: Nếu server nhận yêu cầu WRITE, ghi dữ liệu xuống đĩa và gửi phản hồi, nhưng phản hồi bị mất, client sẽ gửi lại yêu cầu. Khi nhận lại, server sẽ thực hiện đúng thao tác như trước: ghi dữ liệu xuống đĩa và phản hồi. Nếu lần này client nhận được phản hồi, mọi thứ lại ổn.</li>
</ul>
<p>Như vậy, client đã xử lý cả <strong>message loss</strong> (mất thông điệp) và <strong>server failure</strong> (lỗi server) theo một cách thống nhất. Gọn gàng!</p>
<p>Một lưu ý nhỏ: một số thao tác khó để làm idempotent.<br />
Ví dụ: khi bạn tạo một thư mục đã tồn tại, bạn sẽ nhận thông báo rằng yêu cầu <code>mkdir</code> thất bại. Trong NFS, nếu file server nhận thông điệp giao thức MKDIR và thực hiện thành công nhưng phản hồi bị mất, client có thể gửi lại và gặp lỗi “thư mục đã tồn tại” – mặc dù thao tác ban đầu đã thành công và chỉ thất bại ở lần gửi lại. Cuộc sống không hoàn hảo.</p>
<blockquote>
<blockquote>
<p><strong>TIP: “PERFECT IS THE ENEMY OF THE GOOD” – LUẬT CỦA VOLTAIRE <sup class="footnote-reference"><a href="#2">1</a></sup></strong><br />
Ngay cả khi bạn thiết kế một hệ thống tuyệt vời, đôi khi các trường hợp đặc biệt (corner cases) sẽ không hoạt động hoàn hảo như mong muốn. Lấy ví dụ <code>mkdir</code> ở trên; bạn có thể thiết kế lại <code>mkdir</code> với ngữ nghĩa khác để nó trở thành idempotent (hãy thử nghĩ cách làm), nhưng liệu có đáng không? Triết lý thiết kế của NFS bao quát hầu hết các trường hợp quan trọng, và nhìn chung làm cho thiết kế hệ thống trở nên gọn gàng và đơn giản khi xử lý lỗi. Do đó, chấp nhận rằng cuộc sống không hoàn hảo nhưng vẫn xây dựng hệ thống là dấu hiệu của một kỹ sư giỏi. Câu nói này được cho là của Voltaire: “... một người Ý khôn ngoan nói rằng cái tốt nhất là kẻ thù của cái tốt” [V72], và vì thế chúng ta gọi đây là <strong>Luật của Voltaire</strong>.</p>
</blockquote>
</blockquote>
<h2 id="498-cải-thiện-hiệu-năng-client-side-caching-bộ-nhớ-đệm-phía-client"><a class="header" href="#498-cải-thiện-hiệu-năng-client-side-caching-bộ-nhớ-đệm-phía-client">49.8 Cải thiện hiệu năng: Client-side Caching (Bộ nhớ đệm phía client)</a></h2>
<p><strong>Distributed file system</strong> (hệ thống tệp phân tán) có nhiều ưu điểm, nhưng việc gửi tất cả các yêu cầu đọc và ghi qua mạng có thể dẫn đến một vấn đề lớn về hiệu năng: mạng thường không nhanh, đặc biệt khi so với bộ nhớ hoặc đĩa cục bộ. Do đó, một câu hỏi khác được đặt ra: <strong>làm thế nào để cải thiện hiệu năng của một distributed file system?</strong></p>
<p>Câu trả lời, như bạn có thể đoán từ tiêu đề, là <strong>client-side caching</strong> (bộ nhớ đệm phía client). <strong>NFS client-side file system</strong> lưu trữ dữ liệu file (và metadata) mà nó đã đọc từ server trong bộ nhớ của client. Nhờ vậy, trong khi lần truy cập đầu tiên tốn kém (vì cần giao tiếp qua mạng), các lần truy cập sau được phục vụ rất nhanh từ bộ nhớ của client.</p>
<p>Bộ nhớ đệm này cũng đóng vai trò như một bộ đệm tạm thời cho các thao tác ghi. Khi một ứng dụng client ghi vào file, dữ liệu sẽ được lưu tạm trong bộ nhớ của client (trong cùng bộ nhớ đệm với dữ liệu đọc từ file server) trước khi được ghi ra server. Cơ chế <strong>write buffering</strong> này hữu ích vì nó tách độ trễ của call <code>write()</code> trong ứng dụng khỏi hiệu năng ghi thực tế, tức là call <code>write()</code> của ứng dụng sẽ trả về ngay lập tức (chỉ đưa dữ liệu vào cache của client-side file system); dữ liệu chỉ được ghi ra file server sau đó.</p>
<p>Vậy là NFS client cache dữ liệu và hiệu năng thường rất tốt, xong rồi phải không? Đáng tiếc là chưa hẳn. Việc thêm cơ chế cache vào bất kỳ hệ thống nào có nhiều client cache sẽ dẫn đến một thách thức lớn và thú vị, gọi là <strong>cache consistency problem</strong> (vấn đề nhất quán bộ nhớ đệm).</p>
<h2 id="499-vấn-đề-nhất-quán-bộ-nhớ-đệm-the-cache-consistency-problem"><a class="header" href="#499-vấn-đề-nhất-quán-bộ-nhớ-đệm-the-cache-consistency-problem">49.9 Vấn đề nhất quán bộ nhớ đệm (The Cache Consistency Problem)</a></h2>
<p>Vấn đề này được minh họa rõ nhất với ba client và một server.</p>
<ul>
<li>Giả sử client <strong>C1</strong> đọc file <strong>F</strong> và giữ một bản sao trong cache cục bộ.</li>
<li>Tiếp theo, một client khác, <strong>C2</strong>, ghi đè file <strong>F</strong>, thay đổi nội dung của nó; gọi phiên bản mới là <strong>F[v2]</strong> và phiên bản cũ là <strong>F[v1]</strong> (file vẫn cùng tên, chỉ khác nội dung).</li>
<li>Cuối cùng, có một client thứ ba, <strong>C3</strong>, chưa từng truy cập file <strong>F</strong>.</li>
</ul>
<p><img src="49/img/fig49_7.PNG" alt="" /></p>
<p><strong>Hình 49.7: Vấn đề nhất quán bộ nhớ đệm</strong></p>
<p>Có thể bạn đã thấy vấn đề (Hình 49.7). Thực tế, có <strong>hai tiểu vấn đề</strong>:</p>
<ol>
<li>
<p><strong>Update visibility</strong> (tính hiển thị của bản cập nhật):<br />
Client <strong>C2</strong> có thể giữ dữ liệu ghi trong cache một thời gian trước khi gửi lên server; trong thời gian đó, khi <strong>F[v2]</strong> chỉ nằm trong bộ nhớ của C2, bất kỳ client nào khác (ví dụ C3) truy cập F sẽ nhận bản cũ <strong>F[v1]</strong>. Điều này khiến các client khác nhận dữ liệu lỗi thời, có thể gây khó chịu (ví dụ: bạn đăng nhập vào C2, cập nhật F, rồi đăng nhập vào C3 và đọc file nhưng lại nhận bản cũ).</p>
</li>
<li>
<p><strong>Stale cache</strong> (cache lỗi thời):<br />
Trong trường hợp này, C2 đã gửi dữ liệu ghi lên server, và server có phiên bản mới nhất <strong>F[v2]</strong>. Tuy nhiên, C1 vẫn giữ <strong>F[v1]</strong> trong cache; nếu một chương trình trên C1 đọc F, nó sẽ nhận bản cũ thay vì bản mới nhất.</p>
</li>
</ol>
<p><strong>Cách NFSv2 giải quyết:</strong></p>
<ul>
<li>
<p><strong>Giải quyết update visibility</strong>:<br />
Client triển khai cơ chế <strong>flush-on-close</strong> (hay <strong>close-to-open</strong> consistency semantics); cụ thể, khi một file được ghi và sau đó đóng bởi ứng dụng client, client sẽ gửi tất cả các cập nhật (các trang dirty trong cache) lên server. Nhờ đó, một lần mở file sau đó từ node khác sẽ thấy phiên bản mới nhất.</p>
</li>
<li>
<p><strong>Giải quyết stale cache</strong>:<br />
Trước khi dùng dữ liệu trong cache, client-side file system sẽ gửi yêu cầu <strong>GETATTR</strong> tới server để lấy <strong>attributes</strong> (thuộc tính) của file. Thuộc tính này bao gồm thời điểm file được sửa đổi lần cuối trên server; nếu thời điểm này mới hơn thời điểm file được đưa vào cache của client, client sẽ <strong>invalidate</strong> (hủy) file trong cache, đảm bảo các lần đọc tiếp theo sẽ lấy bản mới nhất từ server. Nếu client thấy mình đã có bản mới nhất, nó sẽ dùng dữ liệu trong cache để tăng hiệu năng.</p>
</li>
</ul>
<p><strong>Vấn đề mới phát sinh:</strong><br />
Khi nhóm phát triển ban đầu tại Sun triển khai giải pháp stale cache này, họ nhận ra một vấn đề mới: server NFS bị <strong>ngập lụt</strong> bởi các yêu cầu GETATTR.<br />
Nguyên tắc thiết kế tốt là tối ưu cho <strong>trường hợp phổ biến</strong>; ở đây, trường hợp phổ biến là file chỉ được truy cập từ một client (có thể nhiều lần), nhưng client vẫn phải gửi GETATTR mỗi lần để chắc chắn không ai thay đổi file. Điều này khiến server liên tục bị hỏi “có ai thay đổi file này không?”, trong khi hầu hết thời gian câu trả lời là “không”.</p>
<p><strong>Giải pháp:</strong><br />
Thêm <strong>attribute cache</strong> vào mỗi client. Client vẫn xác thực file trước khi truy cập, nhưng thường chỉ cần tra trong attribute cache. Thuộc tính của file được đưa vào cache khi file được truy cập lần đầu, và sẽ <strong>timeout</strong> sau một khoảng thời gian (ví dụ 3 giây). Trong thời gian này, mọi truy cập file sẽ dùng bản cache mà không cần giao tiếp mạng với server.</p>
<h2 id="4910-Đánh-giá-tính-nhất-quán-cache-của-nfs-assessing-nfs-cache-consistency"><a class="header" href="#4910-Đánh-giá-tính-nhất-quán-cache-của-nfs-assessing-nfs-cache-consistency">49.10 Đánh giá tính nhất quán cache của NFS (Assessing NFS Cache Consistency)</a></h2>
<p>Một vài nhận xét cuối cùng về tính nhất quán cache của NFS:</p>
<ul>
<li>
<p><strong>Flush-on-close</strong> được thêm vào để “hợp lý” hơn, nhưng lại gây ra vấn đề hiệu năng: nếu một file tạm hoặc file sống ngắn được tạo trên client và sớm bị xóa, nó vẫn bị gửi lên server. Một cách tối ưu hơn là giữ các file ngắn hạn này trong bộ nhớ cho đến khi bị xóa, loại bỏ hoàn toàn tương tác với server.</p>
</li>
<li>
<p>Việc thêm <strong>attribute cache</strong> khiến khó xác định chính xác phiên bản file mà bạn nhận được: đôi khi là bản mới nhất, đôi khi là bản cũ chỉ vì attribute cache chưa hết hạn. Dù hầu hết thời gian điều này không gây vấn đề, nhưng đôi khi vẫn dẫn đến hành vi khó hiểu.</p>
</li>
</ul>
<p>Như vậy, chúng ta đã mô tả sự “đặc biệt” của <strong>NFS client caching</strong>. Đây là một ví dụ thú vị cho thấy chi tiết triển khai có thể quyết định <strong>ngữ nghĩa quan sát được bởi người dùng</strong>, thay vì ngược lại.</p>
<h2 id="4911-Ảnh-hưởng-của-write-buffering-phía-server-implications-on-server-side-write-buffering"><a class="header" href="#4911-Ảnh-hưởng-của-write-buffering-phía-server-implications-on-server-side-write-buffering">49.11 Ảnh hưởng của Write Buffering phía Server (Implications On Server-Side Write Buffering)</a></h2>
<p>Cho đến giờ, chúng ta tập trung vào <strong>client caching</strong> (bộ nhớ đệm phía client), nơi phát sinh hầu hết các vấn đề thú vị. Tuy nhiên, các <strong>NFS server</strong> thường là những máy được trang bị tốt với nhiều bộ nhớ, và vì vậy chúng cũng có các vấn đề liên quan đến caching. Khi dữ liệu (và metadata) được đọc từ đĩa, NFS server sẽ giữ nó trong bộ nhớ, và các lần đọc tiếp theo của dữ liệu (và metadata) đó sẽ không cần truy cập đĩa, mang lại một cải thiện (nhỏ) về hiệu năng.</p>
<p>Điều thú vị hơn là trường hợp <strong>write buffering</strong> (đệm ghi). Một NFS server <strong>tuyệt đối không được</strong> trả về trạng thái thành công cho một yêu cầu <strong>WRITE</strong> trong giao thức cho đến khi thao tác ghi đã được ghi xuống <strong>stable storage</strong> (bộ nhớ lưu trữ bền vững, ví dụ: đĩa hoặc thiết bị lưu trữ lâu dài khác). Mặc dù server có thể lưu một bản sao dữ liệu trong bộ nhớ, việc trả về thành công cho client khi yêu cầu WRITE chưa được ghi xuống bộ nhớ bền vững có thể dẫn đến hành vi sai; bạn có đoán được tại sao không?</p>
<p>Câu trả lời nằm ở giả định của chúng ta về cách client xử lý lỗi server. Hãy tưởng tượng chuỗi thao tác ghi sau được thực hiện bởi một client:</p>
<pre><code class="language-c">write(fd, a_buffer, size); // ghi block 1 toàn ký tự 'a'
write(fd, b_buffer, size); // ghi block 2 toàn ký tự 'b'
write(fd, c_buffer, size); // ghi block 3 toàn ký tự 'c'
</code></pre>
<p>Các thao tác này ghi đè ba block của một file: block đầu bằng ‘a’, block thứ hai bằng ‘b’, và block thứ ba bằng ‘c’. Giả sử file ban đầu trông như sau:</p>
<pre><code>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
</code></pre>
<p>Chúng ta kỳ vọng kết quả cuối cùng sau các thao tác ghi sẽ là:</p>
<pre><code>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
cccccccccccccccccccccccccccccccccccccccccccc
</code></pre>
<p>Bây giờ, giả sử ba thao tác ghi này được gửi tới server dưới dạng ba thông điệp WRITE riêng biệt.</p>
<ul>
<li>Thông điệp WRITE đầu tiên được server nhận và ghi xuống đĩa, sau đó thông báo thành công cho client.</li>
<li>Thông điệp WRITE thứ hai chỉ được lưu trong bộ nhớ, và server <strong>cũng</strong> báo thành công cho client trước khi ghi xuống đĩa; không may, server bị crash trước khi ghi nó xuống đĩa.</li>
<li>Server nhanh chóng khởi động lại và nhận yêu cầu WRITE thứ ba, thao tác này thành công.</li>
</ul>
<p>Kết quả là, từ góc nhìn của client, tất cả yêu cầu đều thành công, nhưng nội dung file lại như sau:</p>
<pre><code>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy &lt;--- lỗi
cccccccccccccccccccccccccccccccccccccccccccc
</code></pre>
<p>Thật tệ! Vì server đã báo thành công cho client ở thao tác ghi thứ hai trước khi commit xuống đĩa, một phần dữ liệu cũ vẫn tồn tại trong file, điều này – tùy ứng dụng – có thể gây hậu quả nghiêm trọng.</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: SỰ ĐỔI MỚI KÉO THEO SỰ ĐỔI MỚI (INNOVATION BREEDS INNOVATION) <sup class="footnote-reference"><a href="#3">2</a></sup></strong><br />
Giống như nhiều công nghệ tiên phong khác, việc đưa NFS ra đời cũng đòi hỏi những đổi mới nền tảng khác để đảm bảo thành công. Có lẽ bền vững nhất là <strong>Virtual File System (VFS)</strong> / <strong>Virtual Node (vnode)</strong> interface, được Sun giới thiệu để cho phép các hệ thống tệp khác nhau dễ dàng tích hợp vào hệ điều hành [K86].<br />
Lớp <strong>VFS</strong> bao gồm các thao tác áp dụng cho toàn bộ hệ thống tệp, như mount/unmount, lấy thống kê toàn hệ thống tệp, và ép ghi tất cả các trang dirty (chưa ghi) xuống đĩa. Lớp <strong>vnode</strong> bao gồm tất cả các thao tác có thể thực hiện trên một file, như open, close, read, write, v.v.<br />
Để xây dựng một hệ thống tệp mới, chỉ cần định nghĩa các “method” này; framework sẽ xử lý phần còn lại, kết nối system call tới triển khai hệ thống tệp cụ thể, thực hiện các chức năng chung (ví dụ: caching) một cách tập trung, và cho phép nhiều hệ thống tệp cùng hoạt động trong một hệ điều hành.<br />
Mặc dù một số chi tiết đã thay đổi, nhiều hệ thống hiện đại vẫn có một dạng lớp VFS/vnode, bao gồm Linux, các biến thể BSD, macOS, và thậm chí Windows (dưới dạng Installable File System). Ngay cả khi NFS trở nên ít quan trọng hơn, những nền tảng cần thiết bên dưới nó vẫn sẽ tồn tại.</p>
</blockquote>
</blockquote>
<p>Để tránh vấn đề này, NFS server <strong>phải</strong> commit mỗi thao tác ghi xuống <strong>persistent storage</strong> trước khi thông báo thành công cho client; làm vậy cho phép client phát hiện lỗi server trong khi ghi và retry cho đến khi thành công. Điều này đảm bảo chúng ta sẽ không bao giờ gặp tình trạng nội dung file bị trộn lẫn như ví dụ trên.</p>
<p>Vấn đề mà yêu cầu này gây ra trong triển khai NFS server là hiệu năng ghi, nếu không được xử lý tốt, có thể trở thành <strong>nút thắt cổ chai</strong>. Thực tế, một số công ty (ví dụ: Network Appliance) ra đời với mục tiêu đơn giản là xây dựng NFS server có khả năng ghi nhanh; một thủ thuật họ sử dụng là ghi dữ liệu vào <strong>bộ nhớ có pin dự phòng</strong> (battery-backed memory) trước, cho phép phản hồi nhanh các yêu cầu WRITE mà không sợ mất dữ liệu và không phải chịu chi phí ghi xuống đĩa ngay lập tức; thủ thuật thứ hai là sử dụng thiết kế hệ thống tệp được tối ưu hóa đặc biệt để ghi xuống đĩa nhanh chóng khi cần [HLM94, RO91].</p>
<h2 id="4912-tóm-tắt-summary"><a class="header" href="#4912-tóm-tắt-summary">49.12 Tóm tắt (Summary)</a></h2>
<p>Chúng ta đã tìm hiểu về <strong>NFS distributed file system</strong>. NFS tập trung vào ý tưởng <strong>khôi phục nhanh và đơn giản khi server bị lỗi</strong>, đạt được điều này thông qua thiết kế giao thức cẩn thận. <strong>Idempotency</strong> (tính idempotent) của các thao tác là yếu tố then chốt; vì client có thể an toàn thực hiện lại một thao tác thất bại, nên việc này là chấp nhận được dù server đã hay chưa thực hiện yêu cầu.</p>
<p>Chúng ta cũng đã thấy việc đưa caching vào một hệ thống nhiều client – một server có thể làm mọi thứ phức tạp hơn. Đặc biệt, hệ thống phải giải quyết <strong>cache consistency problem</strong> (vấn đề nhất quán bộ nhớ đệm) để hoạt động hợp lý; tuy nhiên, NFS giải quyết theo cách hơi “ad hoc”, đôi khi dẫn đến hành vi kỳ lạ có thể quan sát được. Cuối cùng, chúng ta thấy caching phía server cũng phức tạp: các thao tác ghi phải được commit xuống <strong>stable storage</strong> trước khi trả về thành công (nếu không dữ liệu có thể bị mất).</p>
<p>Chúng ta chưa bàn đến các vấn đề khác cũng rất quan trọng, đặc biệt là <strong>bảo mật</strong>. Bảo mật trong các phiên bản NFS đầu tiên cực kỳ lỏng lẻo; rất dễ để bất kỳ người dùng nào trên client giả mạo thành người dùng khác và truy cập hầu như bất kỳ file nào. Việc tích hợp sau này với các dịch vụ xác thực nghiêm ngặt hơn (ví dụ: <strong>Kerberos</strong> [NT94]) đã khắc phục những thiếu sót rõ ràng này.</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: CÁC THUẬT NGỮ CHÍNH TRONG NFS</strong></p>
<ul>
<li>Chìa khóa để đạt được mục tiêu khôi phục nhanh và đơn giản khi crash trong NFS nằm ở thiết kế giao thức <strong>stateless</strong>. Sau khi crash, server có thể nhanh chóng khởi động lại và phục vụ yêu cầu; client chỉ cần retry cho đến khi thành công.</li>
<li>Làm cho các yêu cầu <strong>idempotent</strong> là một khía cạnh trung tâm của giao thức NFS. Một thao tác là idempotent khi việc thực hiện nó nhiều lần cho kết quả giống như thực hiện một lần. Trong NFS, idempotency cho phép client retry mà không lo lắng, và hợp nhất cơ chế gửi lại thông điệp bị mất với cách client xử lý crash của server.</li>
<li>Các yêu cầu về hiệu năng đòi hỏi phải có <strong>client-side caching</strong> và <strong>write buffering</strong>, nhưng điều này lại dẫn đến vấn đề nhất quán bộ nhớ đệm.</li>
<li>NFS triển khai giải pháp kỹ thuật cho vấn đề nhất quán bộ nhớ đệm thông qua nhiều cách: cơ chế <strong>flush-on-close</strong> (close-to-open) đảm bảo khi</li>
</ul>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="50-hệ-thống-tệp-andrew-andrew-file-system--afs"><a class="header" href="#50-hệ-thống-tệp-andrew-andrew-file-system--afs">50. Hệ thống Tệp Andrew (Andrew File System – AFS)</a></h1>
<p><strong>Andrew File System</strong> được giới thiệu tại <strong>Carnegie-Mellon University (CMU)</strong><sup class="footnote-reference"><a href="#1">1</a></sup> vào những năm 1980 [H+88]. Dưới sự dẫn dắt của Giáo sư nổi tiếng <strong>M. Satyanarayanan</strong> của CMU (thường được gọi tắt là “Satya”), mục tiêu chính của dự án này rất đơn giản: <strong>khả năng mở rộng</strong> (scale). Cụ thể, làm thế nào để thiết kế một <strong>distributed file system</strong> (hệ thống tệp phân tán) sao cho một server có thể hỗ trợ nhiều client nhất có thể?</p>
<p>Điều thú vị là có rất nhiều khía cạnh trong thiết kế và triển khai ảnh hưởng đến khả năng mở rộng. Quan trọng nhất là thiết kế <strong>giao thức</strong> giữa client và server.<br />
Ví dụ, trong <strong>NFS</strong>, giao thức buộc client phải định kỳ kiểm tra với server để xác định xem nội dung trong cache có thay đổi hay không; vì mỗi lần kiểm tra đều tiêu tốn tài nguyên server (bao gồm CPU và băng thông mạng), các lần kiểm tra thường xuyên như vậy sẽ giới hạn số lượng client mà server có thể phục vụ, và do đó giới hạn khả năng mở rộng.</p>
<p>AFS cũng khác với NFS ở chỗ ngay từ đầu, <strong>hành vi hợp lý ở góc nhìn người dùng</strong> đã là một ưu tiên hàng đầu. Trong NFS, <strong>cache consistency</strong> (tính nhất quán của bộ nhớ đệm) rất khó mô tả vì nó phụ thuộc trực tiếp vào các chi tiết triển khai mức thấp, bao gồm cả thời gian timeout của cache phía client. Trong AFS, cache consistency đơn giản và dễ hiểu: khi file được mở, client sẽ nhận được bản sao mới nhất và nhất quán từ server.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Mặc dù ban đầu được gọi là “Carnegie-Mellon University”, sau này CMU bỏ dấu gạch nối, và từ đó có tên hiện đại “Carnegie Mellon University”. Vì AFS bắt nguồn từ công trình vào đầu những năm 80, chúng tôi sử dụng tên CMU ở dạng gốc có gạch nối đầy đủ. Xem thêm tại: https://www.quora.com/When-did-Carnegie-Mellon-University-remove-the-hyphen-in-the-university-name nếu bạn quan tâm đến chi tiết nhỏ này.</p>
</div>
<h2 id="501-phiên-bản-afs-1-afs-version-1"><a class="header" href="#501-phiên-bản-afs-1-afs-version-1">50.1 Phiên bản AFS 1 (AFS Version 1)</a></h2>
<p>Chúng ta sẽ thảo luận về hai phiên bản của AFS [H+88, S+85]. Phiên bản đầu tiên (mà chúng ta sẽ gọi là <strong>AFSv1</strong>, nhưng thực tế hệ thống gốc được gọi là <strong>ITC distributed file system</strong> [S+85]) đã có một số thiết kế cơ bản, nhưng không mở rộng được như mong muốn, dẫn đến việc thiết kế lại và hình thành giao thức cuối cùng (mà chúng ta sẽ gọi là <strong>AFSv2</strong>, hoặc đơn giản là <strong>AFS</strong>) [H+88]. Sau đây là phần mô tả phiên bản đầu tiên.</p>
<p><img src="50/img/fig50_1.PNG" alt="" /></p>
<p><strong>Hình 50.1: Các điểm nổi bật của giao thức AFSv1</strong></p>
<p>Một trong những nguyên tắc cơ bản của tất cả các phiên bản AFS là <strong>whole-file caching</strong> (bộ nhớ đệm toàn bộ file) trên <strong>local disk</strong> (đĩa cục bộ) của máy client đang truy cập file. Khi bạn gọi <code>open()</code> một file, toàn bộ file (nếu tồn tại) sẽ được lấy từ server và lưu thành một file trên đĩa cục bộ của bạn. Các thao tác <code>read()</code> và <code>write()</code> tiếp theo của ứng dụng sẽ được chuyển hướng tới <strong>local file system</strong> (hệ thống tệp cục bộ) nơi file được lưu; do đó, các thao tác này <strong>không cần giao tiếp mạng</strong> và rất nhanh. Cuối cùng, khi <code>close()</code>, file (nếu đã bị sửa đổi) sẽ được ghi trả lại server.<br />
Lưu ý sự khác biệt rõ rệt với NFS, vốn cache theo <strong>block</strong> (không phải toàn bộ file, mặc dù NFS có thể cache tất cả các block của một file) và lưu trong bộ nhớ của client (không phải trên đĩa cục bộ).</p>
<p>Đi sâu hơn một chút:</p>
<ul>
<li>Khi một ứng dụng client lần đầu gọi <code>open()</code>, mã phía client của AFS (mà các nhà thiết kế AFS gọi là <strong>Venus</strong>) sẽ gửi một thông điệp giao thức <strong><code>Fetch</code></strong> tới server.</li>
<li>Thông điệp <code>Fetch</code> sẽ truyền toàn bộ <strong>pathname</strong> của file mong muốn (ví dụ: <code>/home/remzi/notes.txt</code>) tới <strong>file server</strong> (nhóm server này được gọi là <strong>Vice</strong>), server sẽ duyệt qua pathname, tìm file mong muốn và gửi toàn bộ file về cho client.</li>
<li>Mã phía client sau đó sẽ cache file này trên đĩa cục bộ của client (bằng cách ghi nó xuống local disk).</li>
</ul>
<p>Như đã nói ở trên, các call <code>read()</code> và <code>write()</code> tiếp theo trong AFS hoàn toàn là <strong>local</strong> (không có giao tiếp với server); chúng chỉ được chuyển hướng tới bản sao cục bộ của file. Vì các call <code>read()</code> và <code>write()</code> hoạt động giống như trên một local file system, khi một block được truy cập, nó cũng có thể được cache trong bộ nhớ của client. Do đó, AFS cũng sử dụng bộ nhớ của client để cache các block mà nó đã lưu trên đĩa cục bộ.</p>
<p>Cuối cùng, khi hoàn tất, AFS client sẽ kiểm tra xem file có bị sửa đổi hay không (tức là nó đã được mở để ghi); nếu có, nó sẽ ghi phiên bản mới trở lại server bằng thông điệp giao thức <strong><code>Store</code></strong>, gửi toàn bộ file và pathname tới server để lưu trữ lâu dài.</p>
<p>Lần tiếp theo file được truy cập, <strong>AFSv1</strong> thực hiện hiệu quả hơn nhiều:</p>
<ul>
<li>Mã phía client trước tiên liên hệ với server (sử dụng thông điệp giao thức <strong><code>TestAuth</code></strong>) để xác định xem file có thay đổi hay không.</li>
<li>Nếu không, client sẽ sử dụng bản sao đã cache cục bộ, nhờ đó cải thiện hiệu năng bằng cách tránh truyền dữ liệu qua mạng.</li>
</ul>
<p>Hình minh họa ở trên cho thấy một số thông điệp giao thức trong AFSv1. Lưu ý rằng phiên bản đầu tiên này chỉ cache <strong>nội dung file</strong>; ví dụ, các thư mục chỉ được lưu trên server.</p>
<blockquote>
<blockquote>
<p><strong>TIP: ĐO LƯỜNG RỒI MỚI XÂY DỰNG (PATTERSON’S LAW)</strong><br />
Một trong những người cố vấn của chúng tôi, <strong>David Patterson</strong> (nổi tiếng với RISC và RAID), luôn khuyến khích chúng tôi <strong>đo lường hệ thống và chứng minh vấn đề</strong> trước khi xây dựng một hệ thống mới để khắc phục vấn đề đó.<br />
Bằng cách sử dụng <strong>bằng chứng thực nghiệm</strong> thay vì chỉ dựa vào cảm tính, bạn có thể biến quá trình xây dựng hệ thống thành một nỗ lực khoa học hơn. Điều này còn có lợi ích phụ là buộc bạn phải suy nghĩ về <strong>cách đo lường hệ thống</strong> trước khi phiên bản cải tiến được phát triển.<br />
Khi bạn bắt tay vào xây dựng hệ thống mới, sẽ có hai điều tốt hơn:</p>
<ol>
<li>Bạn có bằng chứng cho thấy mình đang giải quyết một vấn đề thực sự.</li>
<li>Bạn đã có sẵn phương pháp đo lường để chứng minh rằng hệ thống mới thực sự cải thiện so với hiện trạng.<br />
Và đó là lý do chúng tôi gọi đây là <strong>Patterson’s Law</strong>.</li>
</ol>
</blockquote>
</blockquote>
<h2 id="502-các-vấn-đề-với-phiên-bản-1"><a class="header" href="#502-các-vấn-đề-với-phiên-bản-1">50.2 Các vấn đề với Phiên bản 1</a></h2>
<p>Một vài vấn đề then chốt trong phiên bản đầu tiên của <strong>AFS</strong> đã thúc đẩy các nhà thiết kế phải suy nghĩ lại về hệ thống tệp của mình. Để nghiên cứu chi tiết các vấn đề này, nhóm thiết kế AFS đã dành rất nhiều thời gian đo đạc nguyên mẫu hiện có để tìm ra nguyên nhân. Việc thử nghiệm như vậy là một điều tốt, bởi vì <strong>đo lường</strong> là chìa khóa để hiểu cách hệ thống hoạt động và cách cải thiện chúng; thu thập dữ liệu cụ thể, chính xác là một phần cần thiết trong quá trình xây dựng hệ thống. Trong nghiên cứu của mình, các tác giả đã tìm ra hai vấn đề chính với <strong>AFSv1</strong>:</p>
<ul>
<li>
<p><strong>Chi phí duyệt đường dẫn (path-traversal) quá cao:</strong> Khi thực hiện một yêu cầu giao thức <code>Fetch</code> hoặc <code>Store</code>, client gửi toàn bộ <strong>pathname</strong> (ví dụ: <code>/home/remzi/notes.txt</code>) tới server. Để truy cập file, server phải thực hiện một quá trình duyệt toàn bộ đường dẫn, đầu tiên tìm <code>home</code> trong thư mục gốc, sau đó tìm <code>remzi</code> trong <code>home</code>, và cứ thế cho đến khi tìm thấy file mong muốn. Khi có nhiều client truy cập server cùng lúc, các nhà thiết kế AFS nhận thấy server tiêu tốn phần lớn thời gian CPU chỉ để duyệt cây thư mục.</p>
</li>
<li>
<p><strong>Client gửi quá nhiều thông điệp giao thức <code>TestAuth</code>:</strong> Tương tự như NFS với số lượng lớn thông điệp <code>GETATTR</code>, AFSv1 tạo ra một lượng lớn lưu lượng mạng để kiểm tra xem một file cục bộ (hoặc thông tin <code>stat</code> của nó) có hợp lệ hay không thông qua thông điệp giao thức <code>TestAuth</code>. Do đó, server phải dành nhiều thời gian để trả lời client rằng chúng có thể sử dụng bản sao cache của file hay không. Phần lớn thời gian, câu trả lời là file không thay đổi.</p>
</li>
</ul>
<p>Thực tế còn có hai vấn đề khác với AFSv1: tải (load) không được cân bằng giữa các server, và server sử dụng một <strong>process</strong> (tiến trình) riêng biệt cho mỗi client, dẫn đến <strong>context switching</strong> và các overhead khác. Vấn đề mất cân bằng tải được giải quyết bằng cách giới thiệu <strong>volume</strong>, cho phép quản trị viên di chuyển chúng giữa các server để cân bằng tải; vấn đề context-switch được giải quyết trong AFSv2 bằng cách xây dựng server sử dụng <strong>thread</strong> (luồng) thay vì process. Tuy nhiên, để tiết kiệm dung lượng, ở đây chúng ta tập trung vào hai vấn đề giao thức chính ở trên – những vấn đề đã giới hạn khả năng mở rộng của hệ thống.</p>
<h2 id="503-cải-tiến-giao-thức-improving-the-protocol"><a class="header" href="#503-cải-tiến-giao-thức-improving-the-protocol">50.3 Cải tiến giao thức (Improving the Protocol)</a></h2>
<p>Hai vấn đề trên đã giới hạn khả năng mở rộng của AFS; CPU của server trở thành <strong>nút thắt cổ chai</strong> của hệ thống, và mỗi server chỉ có thể phục vụ khoảng 20 client trước khi bị quá tải. Server nhận quá nhiều thông điệp <code>TestAuth</code>, và khi nhận thông điệp <code>Fetch</code> hoặc <code>Store</code>, chúng tiêu tốn quá nhiều thời gian để duyệt cây thư mục. Do đó, các nhà thiết kế AFS phải đối mặt với một câu hỏi:</p>
<blockquote>
<blockquote>
<p><strong>THE CRUX: LÀM THẾ NÀO ĐỂ THIẾT KẾ MỘT FILE PROTOCOL CÓ KHẢ NĂNG MỞ RỘNG</strong><br />
Làm thế nào để thiết kế lại giao thức nhằm giảm thiểu số lần tương tác với server, tức là làm sao để giảm số lượng thông điệp <code>TestAuth</code>? Hơn nữa, làm thế nào để thiết kế giao thức sao cho các tương tác với server trở nên hiệu quả? Bằng cách giải quyết cả hai vấn đề này, một giao thức mới sẽ tạo ra một phiên bản AFS có khả năng mở rộng tốt hơn nhiều.</p>
</blockquote>
</blockquote>
<h2 id="504-phiên-bản-afs-2-afs-version-2"><a class="header" href="#504-phiên-bản-afs-2-afs-version-2">50.4 Phiên bản AFS 2 (AFS Version 2)</a></h2>
<p><strong>AFSv2</strong> giới thiệu khái niệm <strong>callback</strong> nhằm giảm số lượng tương tác giữa client và server. <strong>Callback</strong> đơn giản là một cam kết từ server tới client rằng server sẽ thông báo cho client khi một file mà client đang cache bị sửa đổi. Bằng cách thêm trạng thái này vào hệ thống, client không còn cần phải liên hệ với server để kiểm tra xem file trong cache có còn hợp lệ hay không. Thay vào đó, client giả định file vẫn hợp lệ cho đến khi server thông báo ngược lại; hãy chú ý sự tương đồng với mô hình <strong>polling</strong> (thăm dò) so với <strong>interrupts</strong> (ngắt).</p>
<p>AFSv2 cũng giới thiệu khái niệm <strong>file identifier (FID)</strong> (tương tự như <strong>NFS file handle</strong>) thay vì sử dụng <strong>pathname</strong> để chỉ định file mà client quan tâm. Một FID trong AFS bao gồm:</p>
<ul>
<li><strong>Volume identifier</strong> (định danh volume)</li>
<li><strong>File identifier</strong> (định danh file)</li>
<li><strong>Uniquifier</strong> (giá trị duy nhất, cho phép tái sử dụng volume ID và file ID khi một file bị xóa)</li>
</ul>
<p>Nhờ đó, thay vì gửi toàn bộ pathname tới server và để server duyệt đường dẫn để tìm file mong muốn, client sẽ tự duyệt pathname, từng thành phần một, cache kết quả và hy vọng giảm tải cho server.</p>
<p><strong>Ví dụ:</strong><br />
Nếu một client truy cập file <code>/home/remzi/notes.txt</code>, và <code>home</code> là thư mục AFS được mount vào <code>/</code> (tức là <code>/</code> là thư mục gốc cục bộ, nhưng <code>home</code> và các thư mục con của nó nằm trong AFS), thì:</p>
<ol>
<li>Client sẽ <code>Fetch</code> nội dung thư mục <code>home</code>, lưu chúng vào <strong>local-disk cache</strong> (cache trên đĩa cục bộ), và thiết lập một <strong>callback</strong> trên <code>home</code>.</li>
<li>Sau đó, client sẽ <code>Fetch</code> thư mục <code>remzi</code>, lưu vào local-disk cache, và thiết lập callback trên <code>remzi</code>.</li>
<li>Cuối cùng, client sẽ <code>Fetch</code> file <code>notes.txt</code>, cache file thường này trên đĩa cục bộ, thiết lập callback, và trả về <strong>file descriptor</strong> cho ứng dụng gọi.</li>
</ol>
<p>Xem <strong>Hình 50.2</strong> để biết tóm tắt.</p>
<p><img src="50/img/fig50_2.PNG" alt="" /></p>
<p><strong>Hình 50.2: Đọc một file – Hoạt động của Client-side và File Server</strong></p>
<p>Điểm khác biệt then chốt so với NFS là: với mỗi lần fetch một thư mục hoặc file, AFS client sẽ thiết lập một <strong>callback</strong> với server, đảm bảo rằng server sẽ thông báo cho client khi trạng thái cache của nó thay đổi.</p>
<p>Lợi ích là rõ ràng: mặc dù lần truy cập đầu tiên tới <code>/home/remzi/notes.txt</code> tạo ra nhiều thông điệp client–server (như mô tả ở trên), nó cũng thiết lập callback cho tất cả các thư mục cũng như file <code>notes.txt</code>. Do đó, các lần truy cập sau hoàn toàn là <strong>local</strong> và không cần tương tác với server.</p>
<p>Trong trường hợp phổ biến khi file đã được cache ở client, AFS hoạt động gần như giống hệt một <strong>local disk-based file system</strong> (hệ thống tệp dựa trên đĩa cục bộ). Nếu một file được truy cập nhiều hơn một lần, lần truy cập thứ hai sẽ nhanh như truy cập file cục bộ.</p>
<blockquote>
<blockquote>
<p><strong>ASIDE: CACHE CONSISTENCY KHÔNG PHẢI LÀ “THUỐC CHỮA BÁCH BỆNH”</strong><br />
Khi thảo luận về <strong>distributed file system</strong>, người ta thường nói nhiều về <strong>cache consistency</strong> (tính nhất quán của bộ nhớ đệm) mà hệ thống tệp cung cấp. Tuy nhiên, mức độ nhất quán cơ bản này <strong>không</strong> giải quyết được mọi vấn đề liên quan đến truy cập file từ nhiều client.<br />
Ví dụ: nếu bạn xây dựng một <strong>code repository</strong> (kho mã nguồn), với nhiều client thực hiện <strong>check-in</strong> và <strong>check-out</strong> mã, bạn không thể chỉ dựa vào hệ thống tệp bên dưới để xử lý tất cả; thay vào đó, bạn phải sử dụng <strong>file-level locking</strong> (khóa ở mức file) rõ ràng để đảm bảo “điều đúng đắn” xảy ra khi có truy cập đồng thời.<br />
Thực tế, bất kỳ ứng dụng nào thực sự quan tâm đến cập nhật đồng thời sẽ bổ sung cơ chế xử lý xung đột riêng. Mức độ nhất quán cơ bản được mô tả trong chương này và chương trước chủ yếu hữu ích cho các tình huống sử dụng thông thường, ví dụ: khi người dùng đăng nhập vào một client khác, họ mong đợi một phiên bản hợp lý của file của mình xuất hiện ở đó. Mong đợi nhiều hơn từ các giao thức này sẽ chỉ dẫn đến thất bại, thất vọng và… bực bội tràn trề.</p>
</blockquote>
</blockquote>
<h2 id="505-tính-nhất-quán-của-bộ-nhớ-đệm-cache-consistency"><a class="header" href="#505-tính-nhất-quán-của-bộ-nhớ-đệm-cache-consistency">50.5 Tính nhất quán của bộ nhớ đệm (Cache Consistency)</a></h2>
<p>Khi chúng ta thảo luận về <strong>NFS</strong>, có hai khía cạnh của <strong>cache consistency</strong> (tính nhất quán của bộ nhớ đệm) cần xem xét: <strong>update visibility</strong> (tính hiển thị của bản cập nhật) và <strong>cache staleness</strong> (tính lỗi thời của bộ nhớ đệm).</p>
<ul>
<li>Với <strong>update visibility</strong>, câu hỏi đặt ra là: <em>Khi nào server sẽ được cập nhật với phiên bản mới của một file?</em></li>
<li>Với <strong>cache staleness</strong>, câu hỏi là: <em>Khi server đã có phiên bản mới, mất bao lâu để các client nhìn thấy phiên bản mới thay vì bản cũ trong cache?</em></li>
</ul>
<p>Nhờ cơ chế <strong>callback</strong> và <strong>whole-file caching</strong> (cache toàn bộ file), tính nhất quán bộ nhớ đệm mà <strong>AFS</strong> cung cấp rất dễ mô tả và hiểu. Có hai trường hợp quan trọng cần xem xét:</p>
<ol>
<li><strong>Tính nhất quán giữa các process trên các máy khác nhau</strong></li>
<li><strong>Tính nhất quán giữa các process trên cùng một máy</strong></li>
</ol>
<p><strong>Giữa các máy khác nhau</strong>, AFS làm cho bản cập nhật trở nên hiển thị trên server và <strong>vô hiệu hóa</strong> (invalidate) các bản sao cache <strong>cùng một lúc</strong>, đó là khi file được đóng.</p>
<ul>
<li>Một client mở file, sau đó ghi vào nó (có thể nhiều lần).</li>
<li>Khi file được đóng, phiên bản mới được ghi (flush) lên server (và do đó trở nên hiển thị).</li>
<li>Tại thời điểm này, server sẽ “phá vỡ” (break) các callback của mọi client đang giữ bản sao cache; việc phá vỡ này được thực hiện bằng cách liên hệ với từng client và thông báo rằng callback của file đó không còn hợp lệ.</li>
</ul>
<p>Bước này đảm bảo rằng các client sẽ không đọc bản sao lỗi thời của file; các lần mở file tiếp theo trên các client đó sẽ yêu cầu <strong>fetch</strong> lại phiên bản mới từ server (và đồng thời thiết lập lại callback trên phiên bản mới).</p>
<p><strong>AFS có một ngoại lệ</strong> cho mô hình đơn giản này khi xét giữa các process trên <strong>cùng một máy</strong>. Trong trường hợp này, các thao tác ghi vào file sẽ <strong>ngay lập tức</strong> hiển thị cho các process cục bộ khác (tức là một process không cần đợi đến khi file được đóng mới thấy các cập nhật mới nhất). Điều này làm cho việc sử dụng trên một máy duy nhất hoạt động đúng như mong đợi, vì hành vi này dựa trên <strong>UNIX semantics</strong> thông thường. Chỉ khi chuyển sang một máy khác, bạn mới nhận thấy cơ chế nhất quán tổng quát hơn của AFS.</p>
<p>Có một trường hợp <strong>cross-machine</strong> (giữa các máy) thú vị đáng bàn thêm:</p>
<ul>
<li>Trong trường hợp hiếm hoi khi các process trên các máy khác nhau <strong>đồng thời</strong> sửa đổi một file, AFS áp dụng cơ chế <strong>last writer wins</strong> (chính xác hơn là <strong>last closer wins</strong>).</li>
<li>Cụ thể, client nào gọi <code>close()</code> <strong>sau cùng</strong> sẽ cập nhật toàn bộ file trên server sau cùng và do đó trở thành “phiên bản thắng” – tức là file còn lại trên server để các client khác thấy.</li>
<li>Kết quả là file được tạo ra hoàn chỉnh bởi <strong>một</strong> trong hai client.</li>
</ul>
<p>Lưu ý sự khác biệt so với giao thức dựa trên block như NFS:</p>
<ul>
<li>Trong NFS, các block riêng lẻ có thể được flush ra server khi mỗi client đang cập nhật file, và do đó file cuối cùng trên server có thể là <strong>sự pha trộn</strong> các cập nhật từ cả hai client.</li>
<li>Trong nhiều trường hợp, một file bị trộn như vậy sẽ không hợp lý, ví dụ: một ảnh JPEG bị hai client chỉnh sửa từng phần; kết quả trộn các ghi này có thể không tạo thành một JPEG hợp lệ.</li>
</ul>
<p><img src="50/img/fig50_3.PNG" alt="" /></p>
<p><strong>Hình 50.3: Dòng thời gian tính nhất quán bộ nhớ đệm (Cache Consistency Timeline)</strong></p>
<p>Hình này minh họa một số kịch bản khác nhau. Các cột thể hiện hành vi của hai process (P1 và P2) trên Client1 và trạng thái cache của nó, một process (P3) trên Client2 và trạng thái cache của nó, và server (Server), tất cả cùng thao tác trên một file duy nhất tên là F.<br />
Đối với server, hình chỉ hiển thị nội dung file sau khi thao tác ở cột bên trái hoàn tất. Hãy đọc và thử hiểu tại sao mỗi lần đọc lại trả về kết quả như vậy. Cột chú thích bên phải sẽ giúp bạn nếu gặp khó khăn.</p>
<h2 id="506-khôi-phục-sau-crash-crash-recovery"><a class="header" href="#506-khôi-phục-sau-crash-crash-recovery">50.6 Khôi phục sau crash (Crash Recovery)</a></h2>
<p>Từ mô tả ở trên, bạn có thể nhận thấy rằng <strong>crash recovery</strong> (khôi phục sau crash) trong AFS phức tạp hơn NFS. Và điều đó là đúng.</p>
<p>Ví dụ:</p>
<ul>
<li>Giả sử có một khoảng thời gian ngắn khi server (S) không thể liên hệ với client (C1), chẳng hạn khi C1 đang khởi động lại.</li>
<li>Trong lúc C1 không khả dụng, S có thể đã cố gửi cho nó một hoặc nhiều thông điệp <strong>callback recall</strong>; ví dụ: C1 có file F được cache trên đĩa cục bộ, và sau đó C2 (một client khác) cập nhật F, khiến S gửi thông điệp tới tất cả các client đang cache file này để xóa nó khỏi cache cục bộ.</li>
<li>Vì C1 có thể bỏ lỡ các thông điệp quan trọng này khi đang khởi động lại, khi tham gia lại hệ thống, C1 nên coi toàn bộ nội dung cache của mình là <strong>không đáng tin cậy</strong>.</li>
</ul>
<p>Do đó, khi truy cập file F lần tiếp theo, C1 nên:</p>
<ol>
<li>Gửi thông điệp <code>TestAuth</code> tới server để hỏi xem bản cache của file F có còn hợp lệ không.</li>
<li>Nếu hợp lệ, C1 có thể sử dụng nó.</li>
<li>Nếu không, C1 phải fetch phiên bản mới hơn từ server.</li>
</ol>
<p><strong>Khôi phục server sau crash</strong> cũng phức tạp hơn:</p>
<ul>
<li>Vấn đề là các callback được lưu trong bộ nhớ; do đó, khi server khởi động lại, nó <strong>không biết</strong> máy client nào đang giữ file nào.</li>
<li>Vì vậy, khi server khởi động lại, mỗi client phải nhận ra rằng server đã crash và coi toàn bộ nội dung cache của mình là <strong>không đáng tin cậy</strong>, và (như trên) phải xác minh lại tính hợp lệ của file trước khi sử dụng.</li>
</ul>
<p>Một <strong>server crash</strong> là một sự kiện lớn, vì cần đảm bảo rằng <strong>mọi client</strong> đều biết về crash kịp thời, nếu không sẽ có nguy cơ client truy cập file lỗi thời. Có nhiều cách để triển khai cơ chế khôi phục này, ví dụ:</p>
<ul>
<li>Server gửi thông điệp (“đừng tin nội dung cache của bạn!”) tới từng client khi nó hoạt động trở lại.</li>
<li>Hoặc client định kỳ kiểm tra xem server có đang hoạt động không (bằng <strong>heartbeat message</strong>).</li>
</ul>
<p>Như bạn thấy, việc xây dựng một mô hình cache hợp lý và có khả năng mở rộng hơn phải trả giá; với NFS, client hầu như không nhận thấy khi server crash.</p>
<p><img src="50/img/fig50_4.PNG" alt="" /></p>
<p><strong>Hình 50.4: So sánh AFS và NFS (Comparison: AFS vs. NFS)</strong></p>
<h2 id="507-khả-năng-mở-rộng-và-hiệu-năng-của-afsv2-scale-and-performance-of-afsv2"><a class="header" href="#507-khả-năng-mở-rộng-và-hiệu-năng-của-afsv2-scale-and-performance-of-afsv2">50.7 Khả năng mở rộng và hiệu năng của AFSv2 (Scale And Performance Of AFSv2)</a></h2>
<p>Với giao thức mới được áp dụng, <strong>AFSv2</strong> đã được đo đạc và cho thấy khả năng mở rộng cao hơn nhiều so với phiên bản ban đầu. Thực tế, mỗi server có thể hỗ trợ khoảng <strong>50 client</strong> (thay vì chỉ 20). Một lợi ích khác là hiệu năng phía client thường gần tương đương với hiệu năng cục bộ, vì trong trường hợp phổ biến, tất cả các truy cập file đều là <strong>local</strong>; các thao tác đọc file thường được lấy từ <strong>local disk cache</strong> (và có thể là từ bộ nhớ cục bộ). Chỉ khi client tạo một file mới hoặc ghi vào một file hiện có thì mới cần gửi thông điệp <code>Store</code> tới server để cập nhật nội dung mới của file.</p>
<p>Chúng ta cũng sẽ xem xét hiệu năng của AFS bằng cách so sánh các kịch bản truy cập hệ thống tệp phổ biến với <strong>NFS</strong>. <strong>Hình 50.4</strong> (trang 9) cho thấy kết quả so sánh định tính này.</p>
<p>Trong hình, chúng ta phân tích các mẫu đọc và ghi điển hình cho các file có kích thước khác nhau:</p>
<ul>
<li><strong>Small file</strong>: chứa <strong>Ns block</strong></li>
<li><strong>Medium file</strong>: chứa <strong>Nm block</strong></li>
<li><strong>Large file</strong>: chứa <strong>NL block</strong></li>
</ul>
<p>Giả định rằng <strong>small</strong> và <strong>medium file</strong> vừa với bộ nhớ của client; <strong>large file</strong> vừa với đĩa cục bộ nhưng không vừa với bộ nhớ client.</p>
<p>Chúng ta cũng giả định, để phân tích, rằng:</p>
<ul>
<li>Truy cập qua mạng tới server từ xa cho một block file mất <strong>Lnet</strong> đơn vị thời gian.</li>
<li>Truy cập bộ nhớ cục bộ mất <strong>Lmem</strong>.</li>
<li>Truy cập đĩa cục bộ mất <strong>Ldisk</strong>.</li>
</ul>
<p>Giả định chung:<br />
$$ L_{net} &gt; L_{disk} &gt; L_{mem} $$</p>
<p>Cuối cùng, giả định rằng lần truy cập đầu tiên tới một file <strong>không</strong> trúng cache nào. Các lần truy cập tiếp theo (“re-read”) sẽ trúng cache nếu cache liên quan đủ dung lượng để chứa file.</p>
<p>Các cột trong hình cho thấy thời gian một thao tác cụ thể (ví dụ: đọc tuần tự một small file) mất bao lâu trên NFS hoặc AFS. Cột ngoài cùng bên phải hiển thị <strong>tỉ lệ thời gian AFS/NFS</strong>.</p>
<h3 id="các-quan-sát-chính"><a class="header" href="#các-quan-sát-chính">Các quan sát chính:</a></h3>
<ol>
<li>
<p><strong>Hiệu năng tương đương trong nhiều trường hợp</strong><br />
Ví dụ: khi đọc file lần đầu (Workload 1, 3, 5), thời gian lấy file từ server từ xa chiếm ưu thế và tương tự trên cả hai hệ thống.</p>
<ul>
<li>Có thể bạn nghĩ AFS sẽ chậm hơn vì phải ghi file xuống đĩa cục bộ; tuy nhiên, các ghi này được <strong>buffer</strong> bởi cache của hệ thống tệp cục bộ phía client, nên chi phí này thường bị ẩn.</li>
<li>Tương tự, bạn có thể nghĩ rằng đọc từ bản sao cache trên đĩa của AFS sẽ chậm hơn; nhưng AFS được hưởng lợi từ cache bộ nhớ của hệ thống tệp cục bộ, nên nhiều lần đọc sẽ trúng cache bộ nhớ và hiệu năng tương tự NFS.</li>
</ul>
</li>
<li>
<p><strong>Khác biệt khi re-read large file tuần tự (Workload 6)</strong></p>
<ul>
<li>AFS có <strong>local disk cache</strong> lớn, nên khi file được truy cập lại, nó sẽ đọc từ đó.</li>
<li>NFS chỉ cache block trong bộ nhớ client; nếu file lớn hơn bộ nhớ cục bộ, NFS phải tải lại toàn bộ file từ server.</li>
<li>Do đó, AFS nhanh hơn NFS trong trường hợp này với hệ số $$ L_{net} / L_{disk} $$ (giả sử truy cập từ xa chậm hơn đĩa cục bộ).</li>
<li>Ngoài ra, NFS còn làm tăng tải server, ảnh hưởng đến khả năng mở rộng.</li>
</ul>
</li>
<li>
<p><strong>Ghi tuần tự file mới (Workload 8, 9)</strong></p>
<ul>
<li>AFS ghi file vào bản sao cache cục bộ; khi đóng file, client AFS sẽ gửi toàn bộ dữ liệu lên server.</li>
<li>NFS buffer ghi trong bộ nhớ client, có thể gửi một số block lên server do áp lực bộ nhớ, nhưng chắc chắn sẽ ghi khi đóng file để đảm bảo <strong>flush-on-close consistency</strong>.</li>
<li>Có thể nghĩ AFS chậm hơn vì ghi xuống đĩa cục bộ, nhưng thực tế ghi này được commit vào <strong>page cache</strong> trước, rồi mới ghi xuống đĩa nền, nên AFS vẫn hưởng lợi từ cơ chế cache bộ nhớ của hệ điều hành.</li>
</ul>
</li>
<li>
<p><strong>Ghi đè tuần tự file hiện có (Workload 10)</strong></p>
<ul>
<li>Đây là trường hợp AFS kém hơn: client phải fetch toàn bộ file cũ trước, rồi mới ghi đè.</li>
<li>NFS chỉ ghi đè block, tránh được việc đọc ban đầu không cần thiết<sup class="footnote-reference"><a href="#2">2</a></sup>.</li>
</ul>
</li>
<li>
<p><strong>Truy cập một phần nhỏ dữ liệu trong large file (Workload 7, 11)</strong></p>
<ul>
<li>NFS tốt hơn nhiều: AFS fetch toàn bộ file khi mở, dù chỉ đọc/ghi một phần nhỏ.</li>
<li>Nếu file bị sửa đổi, AFS sẽ ghi lại toàn bộ file lên server, nhân đôi tác động hiệu năng.</li>
<li>NFS, với giao thức dựa trên block, thực hiện I/O tỷ lệ thuận với kích thước thao tác.</li>
</ul>
</li>
</ol>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Ở đây giả định NFS ghi theo kích thước block và căn chỉnh block; nếu không, NFS client cũng phải đọc block trước. Cũng giả định file không được mở với cờ <strong>O_TRUNC</strong>; nếu có, lần mở ban đầu trong AFS sẽ không fetch nội dung file sắp bị cắt.</p>
</div>
<blockquote>
<blockquote>
<p><strong>ASIDE: TẦM QUAN TRỌNG CỦA WORKLOAD</strong><br />
Một thách thức khi đánh giá bất kỳ hệ thống nào là lựa chọn <strong>workload</strong> (tải công việc). Vì hệ thống máy tính được sử dụng theo nhiều cách khác nhau, có rất nhiều loại workload để lựa chọn. Nhà thiết kế hệ thống lưu trữ nên quyết định workload nào là quan trọng để đưa ra các quyết định thiết kế hợp lý.<br />
Các nhà thiết kế AFS, dựa trên kinh nghiệm đo lường cách hệ thống tệp được sử dụng, đã đưa ra một số giả định: hầu hết file không được chia sẻ thường xuyên và được truy cập tuần tự toàn bộ. Với giả định này, thiết kế AFS là hoàn toàn hợp lý.<br />
Tuy nhiên, giả định này không phải lúc nào cũng đúng. Ví dụ: một ứng dụng ghi nối thêm dữ liệu định kỳ vào log – các ghi nhỏ này vào một large file hiện có là vấn đề lớn với AFS. Nhiều workload khó khác cũng tồn tại, ví dụ: cập nhật ngẫu nhiên trong cơ sở dữ liệu giao dịch.<br />
Một nguồn thông tin về các loại workload phổ biến là các nghiên cứu đã được thực hiện. Xem các nghiên cứu như [B+91, H+11, R+00, V99], bao gồm cả bản tổng kết AFS [H+88], để có ví dụ phân tích workload.</p>
</blockquote>
</blockquote>
<p><strong>Tổng kết:</strong> NFS và AFS đưa ra các giả định khác nhau và do đó đạt được các kết quả hiệu năng khác nhau. Việc những khác biệt này có quan trọng hay không, như thường lệ, phụ thuộc vào <strong>workload</strong>.</p>
<h2 id="508-afs-các-cải-tiến-khác-other-improvements"><a class="header" href="#508-afs-các-cải-tiến-khác-other-improvements">50.8 AFS: Các cải tiến khác (Other Improvements)</a></h2>
<p>Tương tự như khi <strong>Berkeley FFS</strong> được giới thiệu (bổ sung <strong>symbolic link</strong> và nhiều tính năng khác), các nhà thiết kế <strong>AFS</strong> đã tận dụng cơ hội khi xây dựng hệ thống để bổ sung một số tính năng giúp hệ thống dễ sử dụng và quản lý hơn.</p>
<p>Ví dụ: <strong>AFS</strong> cung cấp cho client một <strong>global namespace</strong> (không gian tên toàn cục) thực sự, đảm bảo rằng tất cả các file đều được đặt tên giống nhau trên mọi máy client.<br />
Ngược lại, <strong>NFS</strong> cho phép mỗi client mount các NFS server theo bất kỳ cách nào họ muốn, và do đó chỉ bằng quy ước (và nỗ lực quản trị lớn) thì tên file mới có thể đồng nhất giữa các client.</p>
<p>AFS cũng coi trọng vấn đề <strong>bảo mật</strong> và tích hợp các cơ chế để <strong>xác thực người dùng</strong> (authenticate users) và đảm bảo rằng một tập hợp file có thể được giữ riêng tư nếu người dùng mong muốn.<br />
Ngược lại, NFS trong nhiều năm chỉ hỗ trợ bảo mật ở mức rất sơ khai.</p>
<p>AFS còn bao gồm các công cụ cho phép <strong>user-managed access control</strong> (kiểm soát truy cập do người dùng quản lý) một cách linh hoạt. Khi sử dụng AFS, người dùng có quyền kiểm soát lớn đối với việc ai có thể truy cập file nào.<br />
NFS, giống như hầu hết các hệ thống tệp UNIX, hỗ trợ rất hạn chế cho kiểu chia sẻ này.</p>
<p>Cuối cùng, như đã đề cập trước đó, AFS bổ sung các công cụ giúp <strong>quản trị viên hệ thống</strong> quản lý server dễ dàng hơn. Về tư duy quản trị hệ thống, AFS đã đi trước phần còn lại của lĩnh vực này rất xa.</p>
<h2 id="509-tóm-tắt-summary"><a class="header" href="#509-tóm-tắt-summary">50.9 Tóm tắt (Summary)</a></h2>
<p>AFS cho chúng ta thấy rằng <strong>distributed file system</strong> (hệ thống tệp phân tán) có thể được xây dựng theo cách rất khác so với những gì ta thấy ở NFS.<br />
Thiết kế giao thức của AFS đặc biệt quan trọng; bằng cách giảm thiểu tương tác với server (thông qua <strong>whole-file caching</strong> và <strong>callback</strong>), mỗi server có thể hỗ trợ nhiều client hơn và do đó giảm số lượng server cần thiết để quản lý một site nhất định.</p>
<p>Nhiều tính năng khác, bao gồm <strong>single namespace</strong>, bảo mật, và <strong>access-control list</strong> (danh sách kiểm soát truy cập), khiến AFS trở nên thân thiện khi sử dụng.<br />
Mô hình nhất quán (consistency model) mà AFS cung cấp đơn giản, dễ hiểu và suy luận, đồng thời không dẫn đến những hành vi kỳ lạ thỉnh thoảng thấy ở NFS.</p>
<p>Có lẽ đáng tiếc là AFS đang trên đà suy giảm.<br />
Vì NFS trở thành một <strong>open standard</strong> (tiêu chuẩn mở), nhiều nhà cung cấp đã hỗ trợ nó, và cùng với <strong>CIFS</strong> (giao thức hệ thống tệp phân tán dựa trên Windows), NFS thống trị thị trường.</p>
<p>Mặc dù đôi khi vẫn thấy các hệ thống AFS được triển khai (ví dụ tại một số tổ chức giáo dục, bao gồm Wisconsin), ảnh hưởng lâu dài có lẽ sẽ đến từ <strong>các ý tưởng</strong> của AFS hơn là chính hệ thống này.<br />
Thực tế, <strong>NFSv4</strong> hiện đã bổ sung <strong>server state</strong> (ví dụ: thông điệp giao thức “open”), và do đó ngày càng giống với giao thức cơ bản của AFS.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
