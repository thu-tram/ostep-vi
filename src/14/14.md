# 14 Phần xen kẽ: Memory API (Giao diện lập trình ứng dụng bộ nhớ)

Trong phần xen kẽ này, chúng ta sẽ thảo luận về các giao diện cấp phát bộ nhớ trong hệ thống UNIX. Các giao diện được cung cấp khá đơn giản, vì vậy chương này ngắn gọn và đi thẳng vào vấn đề^[1]. Vấn đề chính mà chúng ta đề cập là:

> **CRUX: CÁCH CẤP PHÁT VÀ QUẢN LÝ BỘ NHỚ**
>
> Trong các chương trình UNIX/C, việc hiểu cách cấp phát và quản lý bộ nhớ là rất quan trọng để xây dựng phần mềm mạnh mẽ và đáng tin cậy. Những giao diện nào thường được sử dụng? Những sai lầm nào cần tránh?

## 14.1 Các loại bộ nhớ

Khi chạy một chương trình C, có hai loại bộ nhớ được cấp phát. Loại đầu tiên được gọi là **stack memory** (bộ nhớ ngăn xếp), và việc cấp phát cũng như giải phóng bộ nhớ này được **compiler** (trình biên dịch) quản lý ngầm cho bạn — lập trình viên; vì lý do này, nó đôi khi được gọi là **automatic memory** (bộ nhớ tự động).

Khai báo bộ nhớ trên stack trong C rất dễ dàng. Ví dụ, giả sử bạn cần một vùng nhớ trong hàm `func()` để lưu một số nguyên `x`. Để khai báo vùng nhớ như vậy, bạn chỉ cần viết:

```c
void func() {
  int x; // khai báo một số nguyên trên stack
  ...
}
```

Compiler sẽ lo phần còn lại, đảm bảo tạo đủ không gian trên stack khi bạn gọi vào `func()`. Khi bạn thoát khỏi hàm, compiler sẽ tự động giải phóng vùng nhớ này; do đó, nếu bạn muốn một thông tin tồn tại lâu hơn thời gian thực thi hàm, bạn **không nên** để thông tin đó trên stack.

^[1]: Thực tế, chúng tôi hy vọng tất cả các chương đều như vậy! Nhưng chương này ngắn gọn và tập trung hơn.

Chính nhu cầu về bộ nhớ tồn tại lâu hơn này dẫn chúng ta đến loại bộ nhớ thứ hai, gọi là **heap memory** (bộ nhớ heap), nơi mọi thao tác cấp phát và giải phóng đều do **bạn** — lập trình viên — xử lý một cách tường minh. Đây là một trách nhiệm lớn, và chắc chắn là nguyên nhân của nhiều lỗi lập trình. Tuy nhiên, nếu bạn cẩn thận và chú ý, bạn có thể sử dụng các giao diện này đúng cách mà không gặp quá nhiều rắc rối. Ví dụ dưới đây minh họa cách cấp phát một số nguyên trên heap:

```c
void func() {
  int *x = (int *) malloc(sizeof(int));
  ...
}
```

Một vài lưu ý về đoạn code nhỏ này: Trước hết, bạn có thể nhận thấy rằng cả cấp phát trên stack và heap đều xảy ra trên cùng một dòng. Đầu tiên, compiler sẽ tạo không gian trên stack cho một con trỏ tới số nguyên khi thấy khai báo `(int *x)`; sau đó, khi chương trình gọi `malloc()`, nó yêu cầu cấp phát không gian cho một số nguyên trên heap; hàm này trả về địa chỉ của vùng nhớ đó (nếu thành công, hoặc `NULL` nếu thất bại), và địa chỉ này được lưu trên stack để chương trình sử dụng.

Do tính chất tường minh và cách sử dụng đa dạng hơn, heap memory mang lại nhiều thách thức hơn cho cả người dùng và hệ thống. Vì vậy, phần còn lại của chương này sẽ tập trung vào nó.

## 14.2 Lời gọi `malloc()` (The `malloc()` Call)

Lời gọi `malloc()` khá đơn giản: bạn truyền vào một kích thước (size) để yêu cầu một vùng nhớ trên heap, và nó sẽ hoặc thành công — trả về một con trỏ tới vùng nhớ vừa được cấp phát — hoặc thất bại và trả về `NULL`^[2]. Trang **manual** (hướng dẫn) cho thấy cách sử dụng `malloc`; gõ `man malloc` trên dòng lệnh, bạn sẽ thấy:

```
#include <stdlib.h>
...
void *malloc(size_t size);
```

Từ thông tin này, bạn có thể thấy rằng tất cả những gì cần làm là include tệp header `stdlib.h` để sử dụng `malloc`. Thực tế, bạn thậm chí không nhất thiết phải làm vậy, vì thư viện C (C library) — mà mọi chương trình C đều liên kết mặc định — đã chứa mã nguồn của `malloc()`; việc include header chỉ giúp compiler kiểm tra xem bạn có gọi `malloc()` đúng cách hay không (ví dụ: truyền đúng số lượng và kiểu tham số).

Tham số duy nhất mà `malloc()` nhận là kiểu `size_t`, mô tả số byte bạn cần. Tuy nhiên, hầu hết lập trình viên không nhập trực tiếp một con số (ví dụ: 10); thực tế, làm vậy bị coi là không tốt. Thay vào đó, người ta thường sử dụng các hàm hoặc macro. Ví dụ, để cấp phát không gian cho một số thực dấu chấm động chính xác kép (**double-precision floating point**), bạn chỉ cần viết:

^[2]: Lưu ý rằng `NULL` trong C thực ra không có gì đặc biệt, thường chỉ là một macro cho giá trị 0, ví dụ: `#define NULL 0` hoặc đôi khi `#define NULL (void*)0`.

> **TIP: KHI KHÔNG CHẮC, HÃY THỬ NGAY**
>
> Nếu bạn không chắc một hàm hay toán tử nào đó hoạt động thế nào, không gì tốt hơn là thử trực tiếp để đảm bảo nó hoạt động như mong đợi. Đọc manual hoặc tài liệu khác là hữu ích, nhưng cách nó vận hành thực tế mới là điều quan trọng. Hãy viết một đoạn code và kiểm tra! Đây chắc chắn là cách tốt nhất để đảm bảo code của bạn hoạt động như mong muốn. Thực tế, chúng tôi cũng đã làm vậy để kiểm chứng những gì mình nói về `sizeof()` là chính xác.

```c
double *d = (double *) malloc(sizeof(double));
```

Có vẻ hơi nhiều chữ “double” ở đây! Lời gọi `malloc()` này sử dụng toán tử `sizeof()` để yêu cầu đúng lượng bộ nhớ cần thiết; trong C, `sizeof()` thường được coi là một toán tử **compile-time** (thời gian biên dịch), nghĩa là kích thước thực tế được biết tại thời điểm biên dịch và một con số (trong trường hợp này là 8, cho kiểu double) sẽ được thay thế làm tham số cho `malloc()`. Vì lý do này, `sizeof()` được coi là toán tử chứ không phải lời gọi hàm (lời gọi hàm sẽ diễn ra tại **run time** — thời gian chạy).

Bạn cũng có thể truyền tên biến (không chỉ kiểu dữ liệu) vào `sizeof()`, nhưng trong một số trường hợp, kết quả có thể không như mong muốn, nên hãy cẩn thận. Ví dụ:

```c
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x));
```

Ở dòng đầu tiên, chúng ta đã cấp phát không gian cho một mảng 10 số nguyên — điều này hoàn toàn ổn. Tuy nhiên, khi dùng `sizeof()` ở dòng tiếp theo, nó trả về một giá trị nhỏ, chẳng hạn 4 (trên máy 32-bit) hoặc 8 (trên máy 64-bit). Nguyên nhân là vì trong trường hợp này, `sizeof()` chỉ đang cho biết kích thước của **con trỏ tới số nguyên**, chứ không phải lượng bộ nhớ đã được cấp phát động. Tuy nhiên, đôi khi `sizeof()` hoạt động đúng như mong đợi:

```c
int x[10];
printf("%d\n", sizeof(x));
```

Trong trường hợp này, compiler có đủ thông tin tĩnh để biết rằng 40 byte đã được cấp phát.

Một điểm cần chú ý khác là với **string** (chuỗi ký tự). Khi cấp phát bộ nhớ cho một chuỗi, hãy sử dụng mẫu sau:  
`malloc(strlen(s) + 1)` — hàm `strlen()` trả về độ dài chuỗi, và cộng thêm 1 để dành chỗ cho ký tự kết thúc chuỗi (`'\0'`). Sử dụng `sizeof()` ở đây có thể gây lỗi.

Bạn cũng có thể nhận thấy rằng `malloc()` trả về một con trỏ kiểu `void`. Đây là cách trong C để trả về một địa chỉ và để lập trình viên quyết định cách sử dụng nó. Lập trình viên thường dùng **cast** (ép kiểu) để chuyển kiểu trả về của `malloc()` sang kiểu mong muốn, ví dụ: con trỏ tới double. Việc cast này không thực sự thay đổi giá trị, mà chỉ báo cho compiler và những người đọc code rằng: “Tôi biết mình đang làm gì.” Việc cast không bắt buộc để code chạy đúng, nhưng có thể giúp tăng tính rõ ràng.


## 14.3 Lời gọi `free()`

Hóa ra, việc **cấp phát bộ nhớ** (allocating memory) là phần dễ của bài toán; biết **khi nào**, **cách nào**, và thậm chí **có nên** giải phóng bộ nhớ hay không mới là phần khó.  
Để giải phóng vùng bộ nhớ **heap** (heap memory) không còn sử dụng, lập trình viên chỉ cần gọi hàm `free()`:

```c
int *x = malloc(10 * sizeof(int));
...
free(x);
```

Hàm này nhận một đối số duy nhất: **con trỏ** (pointer) được trả về bởi `malloc()`. Do đó, bạn có thể nhận thấy rằng **kích thước** của vùng bộ nhớ đã cấp phát **không** được truyền vào bởi người dùng, và phải được **thư viện cấp phát bộ nhớ** tự theo dõi.


## 14.4 Các lỗi thường gặp

Có một số lỗi phổ biến khi sử dụng `malloc()` và `free()`. Dưới đây là những lỗi mà chúng tôi thường xuyên thấy khi giảng dạy môn Hệ điều hành cho sinh viên đại học. Tất cả các ví dụ này đều **biên dịch** và **chạy** mà không hề có cảnh báo từ trình biên dịch; tuy nhiên, như bạn sẽ học được (thường là theo cách khó khăn), việc biên dịch thành công một chương trình C là **cần thiết** nhưng **chưa đủ** để đảm bảo chương trình đúng.

Quản lý bộ nhớ đúng cách là một vấn đề lớn đến mức nhiều ngôn ngữ lập trình mới đã hỗ trợ **quản lý bộ nhớ tự động** (automatic memory management). Trong các ngôn ngữ này, mặc dù bạn vẫn gọi một hàm tương tự `malloc()` để cấp phát bộ nhớ (thường là `new` hoặc tương tự để cấp phát một đối tượng mới), bạn **không bao giờ** phải gọi hàm để giải phóng bộ nhớ; thay vào đó, một **garbage collector** sẽ chạy và xác định vùng bộ nhớ nào bạn không còn tham chiếu tới, rồi tự động giải phóng.


### Quên cấp phát bộ nhớ

Nhiều hàm yêu cầu bộ nhớ phải được cấp phát trước khi bạn gọi chúng. Ví dụ, hàm `strcpy(dst, src)` sao chép một chuỗi từ con trỏ nguồn sang con trỏ đích. Tuy nhiên, nếu bạn không cẩn thận, bạn có thể viết như sau:

```c
char *src = "hello";
char *dst; // oops! chưa được cấp phát
strcpy(dst, src); // segfault và chết
```

>> **TIP: IT COMPILED OR IT RAN ≠ IT IS CORRECT**  
>> Chỉ vì một chương trình **biên dịch thành công** (!) hoặc thậm chí **chạy đúng** một hoặc nhiều lần không có nghĩa là chương trình đó đúng. Nhiều yếu tố có thể tình cờ khiến bạn tin rằng nó hoạt động, nhưng rồi một thay đổi nhỏ xảy ra và nó hỏng. Một phản ứng phổ biến của sinh viên là nói (hoặc hét) “Nhưng nó chạy được trước đây mà!” rồi đổ lỗi cho trình biên dịch, hệ điều hành, phần cứng, hoặc thậm chí (xin mạn phép) là giảng viên. Nhưng vấn đề thường nằm đúng chỗ bạn nghĩ: **trong mã của bạn**. Hãy bắt tay vào gỡ lỗi trước khi đổ lỗi cho các thành phần khác.

Khi chạy đoạn code trên, bạn sẽ gặp **segmentation fault**[^3] — một thuật ngữ hoa mỹ để nói rằng **BẠN ĐÃ LÀM SAI GÌ ĐÓ VỚI BỘ NHỚ, LẬP TRÌNH VIÊN NGU NGỐC, VÀ TÔI (HỆ THỐNG) ĐANG RẤT GIẬN**.  

Trong trường hợp này, code đúng sẽ như sau:

```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src); // chạy đúng
```

Ngoài ra, bạn có thể dùng `strdup()` để đơn giản hóa hơn nữa. Xem **man page** của `strdup` để biết thêm chi tiết.


### Không cấp phát đủ bộ nhớ

Một lỗi liên quan là **không cấp phát đủ bộ nhớ**, đôi khi gọi là **buffer overflow** (tràn bộ đệm). Trong ví dụ trên, một lỗi phổ biến là cấp phát **gần đủ** dung lượng cho bộ đệm đích:

```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src)); // quá nhỏ!
strcpy(dst, src); // lỗi tiềm ẩn
```

Điều kỳ lạ là, tùy vào cách `malloc` được triển khai và nhiều yếu tố khác, chương trình này **thường** vẫn chạy “có vẻ” đúng.  
- Trong một số trường hợp, khi sao chép chuỗi, nó ghi **thêm 1 byte** ra ngoài vùng cấp phát, nhưng có thể điều này vô hại, ví dụ ghi đè lên một biến không còn dùng.  
- Trong một số trường hợp khác, tràn bộ đệm có thể **rất nguy hiểm**, và thực tế là nguồn gốc của nhiều lỗ hổng bảo mật [W06].  
- Cũng có khi thư viện `malloc` cấp phát dư một chút, nên chương trình không ghi đè dữ liệu quan trọng và vẫn chạy bình thường.  
- Và cũng có khi chương trình sẽ **lỗi và crash** ngay lập tức.

Bài học rút ra: **Chỉ vì nó chạy đúng một lần, không có nghĩa là nó đúng**.

[^3]: Nghe có vẻ bí ẩn, nhưng bạn sẽ sớm hiểu tại sao truy cập bộ nhớ bất hợp pháp lại được gọi là **segmentation fault**; nếu điều đó chưa đủ để bạn đọc tiếp, thì còn gì đủ nữa?


### Quên khởi tạo bộ nhớ đã cấp phát

Với lỗi này, bạn gọi `malloc()` đúng cách, nhưng quên gán giá trị cho các trường dữ liệu trong vùng bộ nhớ mới cấp phát. Đừng làm vậy! Nếu quên, chương trình sẽ gặp **uninitialized read** — đọc dữ liệu từ heap với giá trị không xác định.  
- Nếu may mắn, giá trị đó vô hại (ví dụ: bằng 0) và chương trình vẫn chạy.  
- Nếu xui, giá trị ngẫu nhiên có thể gây lỗi nghiêm trọng.


### Quên giải phóng bộ nhớ

Một lỗi phổ biến khác là **memory leak** (rò rỉ bộ nhớ), xảy ra khi bạn quên gọi `free()` để giải phóng bộ nhớ. Trong các ứng dụng hoặc hệ thống chạy lâu (như chính OS), đây là vấn đề nghiêm trọng: rò rỉ bộ nhớ dần dần sẽ khiến hệ thống **hết bộ nhớ**, buộc phải khởi động lại.  

Do đó, nguyên tắc chung là: khi bạn **không còn dùng** một vùng bộ nhớ, hãy chắc chắn giải phóng nó. Lưu ý: dùng ngôn ngữ có garbage collector **không giúp** nếu bạn vẫn giữ tham chiếu tới vùng nhớ đó — khi đó, GC sẽ **không bao giờ** giải phóng nó, và memory leak vẫn tồn tại ngay cả trong ngôn ngữ hiện đại.

Trong một số trường hợp, có thể bạn nghĩ không gọi `free()` là hợp lý. Ví dụ: chương trình của bạn chạy ngắn hạn và sẽ sớm kết thúc; khi process kết thúc, OS sẽ thu hồi tất cả các **page** đã cấp phát, nên về lý thuyết sẽ không có memory leak.  
Mặc dù điều này “hoạt động” (xem phần aside bên dưới), nhưng đây là **thói quen xấu**. Về lâu dài, một trong những mục tiêu của lập trình viên là hình thành **thói quen tốt**; một trong số đó là **hiểu rõ cách bạn quản lý bộ nhớ** và (trong các ngôn ngữ như C) **giải phóng các block** bạn đã cấp phát. Ngay cả khi bạn có thể “lách” mà không làm vậy, hãy tập thói quen giải phóng **mọi byte** bạn đã cấp phát một cách tường minh.

### Giải phóng bộ nhớ trước khi sử dụng xong

Đôi khi một chương trình sẽ giải phóng bộ nhớ trước khi nó sử dụng xong; lỗi như vậy được gọi là **dangling pointer** (con trỏ treo), và như bạn có thể đoán, đây cũng là một điều tồi tệ. Việc sử dụng tiếp theo có thể khiến chương trình bị crash, hoặc ghi đè lên vùng bộ nhớ hợp lệ (ví dụ: bạn gọi `free()`, nhưng sau đó lại gọi `malloc()` để cấp phát một thứ khác, và vùng bộ nhớ vừa bị giải phóng sai sẽ bị tái sử dụng).

>> **ASIDE: TẠI SAO KHÔNG CÓ BỘ NHỚ BỊ RÒ RỈ KHI PROCESS CỦA BẠN KẾT THÚC**  
>> Khi bạn viết một chương trình chạy ngắn hạn, bạn có thể cấp phát một số vùng nhớ bằng `malloc()`. Chương trình chạy và sắp kết thúc: liệu có cần gọi `free()` nhiều lần ngay trước khi thoát không? Mặc dù có vẻ sai nếu không làm vậy, nhưng thực tế sẽ không có bộ nhớ nào bị “mất” theo nghĩa thực sự.  
>> Lý do rất đơn giản: trong hệ thống thực sự tồn tại **hai cấp độ quản lý bộ nhớ**.  
>> - **Cấp độ thứ nhất**: do **OS** (hệ điều hành) thực hiện, cấp phát bộ nhớ cho các **process** (tiến trình) khi chúng chạy, và thu hồi lại khi process kết thúc (hoặc bị dừng).  
>> - **Cấp độ thứ hai**: bên trong mỗi process, ví dụ trong **heap** khi bạn gọi `malloc()` và `free()`.  
>> Ngay cả khi bạn không gọi `free()` (và do đó rò rỉ bộ nhớ trong heap), hệ điều hành sẽ thu hồi toàn bộ bộ nhớ của process (bao gồm các **page** cho code, stack, và heap) khi chương trình kết thúc. Dù trạng thái heap trong không gian địa chỉ của bạn ra sao, OS sẽ lấy lại tất cả các page đó khi process chết, đảm bảo rằng không có bộ nhớ nào bị mất, ngay cả khi bạn không giải phóng nó.  
>> Do đó, với các chương trình ngắn hạn, rò rỉ bộ nhớ thường không gây ra vấn đề vận hành (dù có thể bị coi là thói quen xấu).  
>> Khi bạn viết một **server** chạy lâu dài (như web server hoặc hệ quản trị cơ sở dữ liệu, vốn không bao giờ thoát), rò rỉ bộ nhớ là vấn đề nghiêm trọng hơn nhiều, và cuối cùng sẽ dẫn đến crash khi ứng dụng hết bộ nhớ.  
>> Và tất nhiên, rò rỉ bộ nhớ còn là vấn đề lớn hơn nhiều bên trong một chương trình đặc biệt: **hệ điều hành**. Điều này một lần nữa cho thấy: những người viết mã cho **kernel** (nhân hệ điều hành) có công việc khó khăn nhất...


### Giải phóng bộ nhớ nhiều lần

Đôi khi chương trình cũng giải phóng cùng một vùng bộ nhớ nhiều hơn một lần; điều này được gọi là **double free**. Kết quả của việc này là **không xác định** (undefined). Như bạn có thể tưởng tượng, thư viện cấp phát bộ nhớ có thể bị nhầm lẫn và làm ra nhiều hành vi kỳ lạ; crash là kết quả phổ biến.


### Gọi `free()` không đúng cách

Một vấn đề cuối cùng chúng ta thảo luận là gọi `free()` sai cách. `free()` chỉ mong bạn truyền vào một trong các con trỏ mà bạn đã nhận từ `malloc()` trước đó. Khi bạn truyền vào một giá trị khác, những điều tồi tệ có thể (và sẽ) xảy ra. Do đó, các **invalid free** (giải phóng không hợp lệ) là nguy hiểm và tất nhiên cần tránh.


**Tóm tắt**

Như bạn thấy, có rất nhiều cách để **lạm dụng bộ nhớ**. Vì các lỗi liên quan đến bộ nhớ xảy ra thường xuyên, một hệ sinh thái công cụ đã phát triển để giúp tìm ra các vấn đề này trong code của bạn. Hãy thử **purify** [HJ92] và **valgrind** [SN05]; cả hai đều rất xuất sắc trong việc giúp bạn xác định nguồn gốc của các vấn đề liên quan đến bộ nhớ. Khi đã quen với việc sử dụng các công cụ mạnh mẽ này, bạn sẽ tự hỏi làm sao mình từng sống thiếu chúng.


## 14.5 Hỗ trợ từ hệ điều hành (Underlying OS Support)

Bạn có thể nhận thấy rằng chúng ta chưa hề nói về **system call** khi thảo luận về `malloc()` và `free()`. Lý do rất đơn giản: chúng **không** phải là system call, mà là **library call** (call thư viện). Do đó, thư viện `malloc` quản lý không gian trong **virtual address space** (không gian địa chỉ ảo) của bạn, nhưng bản thân nó được xây dựng dựa trên một số system call để yêu cầu OS cấp thêm bộ nhớ hoặc trả lại một phần bộ nhớ cho hệ thống.

Một system call như vậy là `brk`, được dùng để thay đổi vị trí **program’s break** — vị trí cuối của heap. Nó nhận một đối số (địa chỉ của break mới), và do đó hoặc tăng hoặc giảm kích thước heap tùy thuộc vào việc break mới lớn hơn hay nhỏ hơn break hiện tại. Một call khác là `sbrk`, nhận vào một giá trị tăng (increment) nhưng về cơ bản phục vụ mục đích tương tự.

Lưu ý rằng bạn **không bao giờ** nên gọi trực tiếp `brk` hoặc `sbrk`. Chúng được sử dụng bởi thư viện cấp phát bộ nhớ; nếu bạn cố dùng chúng, bạn rất có thể sẽ khiến mọi thứ trở nên (cực kỳ) tồi tệ. Hãy chỉ dùng `malloc()` và `free()`.

Cuối cùng, bạn cũng có thể lấy bộ nhớ từ hệ điều hành thông qua call `mmap()`. Bằng cách truyền vào các đối số phù hợp, `mmap()` có thể tạo ra một **anonymous memory region** (vùng bộ nhớ ẩn danh) trong chương trình của bạn — một vùng không liên kết với bất kỳ file nào, mà liên kết với **swap space** (không gian hoán đổi), thứ mà chúng ta sẽ thảo luận chi tiết hơn ở phần **virtual memory** sau này. Vùng nhớ này cũng có thể được xử lý như một heap và quản lý tương tự. Xem **man page** của `mmap()` để biết thêm chi tiết.


## 14.6 Các call khác

Có một số call khác mà thư viện cấp phát bộ nhớ hỗ trợ. Ví dụ: `calloc()` vừa cấp phát bộ nhớ vừa **zero hóa** (đặt toàn bộ về 0) trước khi trả về; điều này ngăn chặn một số lỗi khi bạn giả định rằng bộ nhớ đã được zero hóa và quên khởi tạo nó (xem phần “uninitialized reads” ở trên).  

Hàm `realloc()` cũng hữu ích khi bạn đã cấp phát bộ nhớ cho một thứ gì đó (ví dụ: một mảng), và sau đó cần thêm dữ liệu vào: `realloc()` sẽ tạo một vùng bộ nhớ mới lớn hơn, sao chép dữ liệu từ vùng cũ sang, và trả về con trỏ tới vùng mới.


## 14.7 Tóm tắt

Chúng ta đã giới thiệu một số **API** liên quan đến cấp phát bộ nhớ. Như thường lệ, chúng ta mới chỉ đề cập đến những điều cơ bản; nhiều chi tiết hơn có thể tìm thấy ở các tài liệu khác. Hãy đọc sách C của [KR88] và Stevens [SR05] (Chương 7) để biết thêm thông tin. Để tham khảo một bài báo hiện đại thú vị về cách phát hiện và sửa nhiều vấn đề này một cách tự động, xem Novark và cộng sự [N+07]; bài báo này cũng chứa một bản tóm tắt hay về các vấn đề phổ biến và một số ý tưởng thú vị về cách tìm và khắc phục chúng.


## Tham khảo

[HJ92] Purify: Fast Detection of Memory Leaks and Access Errors  
R. Hastings and B. Joyce  
USENIX Winter ’92  
The paper behind the cool Purify tool, now a commercial product.  

[KR88] “The C Programming Language”  
Brian Kernighan and Dennis Ritchie  
Prentice-Hall 1988  
The C book, by the developers of C. Read it once, do some programming, then read it again, and then keep it near your desk or wherever you program.

[N+07] “Exterminator: Automatically Correcting Memory Errors with High Probability”  
Gene Novark, Emery D. Berger, and Benjamin G. Zorn  
PLDI 2007  
A cool paper on finding and correcting memory errors automatically, and a great overview of many common errors in C and C++ programs.

[SN05] “Using Valgrind to Detect Undefined Value Errors with Bit-precision”  
J. Seward and N. Nethercote  
USENIX ’05  
How to use valgrind to find certain types of errors.

[SR05] “Advanced Programming in the UNIX Environment”  
W. Richard Stevens and Stephen A. Rago  
Addison-Wesley, 2005  
We’ve said it before, we’ll say it again: read this book many times and use it as a reference whenever you are in doubt. The authors are always surprised at how each time they read something in this book, they learn something new, even after many years of C programming.

[W06] “Survey on Buffer Overflow Attacks and Countermeasures”  
Tim Werthman  
Available: www.nds.rub.de/lehre/seminar/SS06/Werthmann BufferOverflow.pdf  
A nice survey of buffer overflows and some of the security problems they cause. Refers to many of the famous exploits.