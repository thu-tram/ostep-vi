# 14 Interlude: Memory API
この章で、UNIXシステムでのメモリ割り当てインタフェースについて説明します。提供されるインターフェイスは非常にシンプルです。

>> CRUX: HOW TO ALLOCATE AND MANAGE MEMORY  
>> UNIX/Cプログラムでは、堅牢で信頼性の高いソフトウェアを構築する上で、メモリの割り当てと管理の方法を理解することが重要です。よく使われるインターフェースは何ですか？どのような間違いを避けるべきですか？

## 14.1 Types of Memory
Cプログラムの実行には、2種類のメモリが割り当てられています。最初のものはスタックメモリと呼ばれ、その割り当てと割り当て解除はコンパイラによって暗黙的に管理されます。このため、自動メモリと呼ばれることもあります。

Cでスタック上のメモリを宣言するのは簡単です。たとえば、xと呼ばれる整数の場合、関数`func()`にあるスペースが必要であるとします。そのような記憶を宣言するには、次のようなことをしてください。
```c
void func() {
    int x; // declares an integer on the stack
    ...
}
```
コンパイラは残りを行い、`func()`を呼び出すときにスタックにスペースを確保します。関数から戻ると、コンパイラはメモリを解放します。したがって、呼び出しの呼び出しを超えて生きる情報が必要な場合は、その情報をスタックに残さないほうがよいでしょう。

ヒープメモリと呼ばれる2種類目のメモリが長持ちするメモリが必要性です。すべての割り当てと割り当て解除は、プログラマによって明示的に処理されます。これを使うことは間違いなく重い責任です！そして確かに多くのバグの原因にもなっています。しかし、注意を払うと、このようなインターフェースを問題なく使用できます。ヒープに整数を割り当てる方法の例を次に示します。

```c
void func() {
int *x = (int *) malloc(sizeof(int));
...
}
```
この小さなコードスニペットに関するいくつかの注意をこれから述べます。最初に、スタックとヒープの両方の割り当てがこの行で行われることに気付くかもしれません。まず、コンパイラは、ポインタ(int * x)の宣言を見たときに整数へのポインタのためのスペースを確保することを知っています。その後、プログラムが`malloc()`を呼び出すと、ヒープ上の整数のためのスペースを要求します。ルーチンはそのような整数のアドレスを返します(成功した場合はアドレス、失敗した場合はNULLを返します)。その後、プログラムで使用するためにスタックに格納されます。

明示的な性質のために、そしてヒープメモリは、より多様な使用法のために、ユーザーとシステムの両方にとってより多くの課題が存在します。

## 14.2 The `malloc()` Call
`malloc()`呼び出しは非常に単純です。ヒープ上の空き容量を求めるサイズを渡し、それが成功し、新たに割り当てられた領域へのポインタを返すか、失敗しNULLを返します。マニュアルページには、mallocを使用するために必要なことが示されています。コマンドラインでman mallocと入力すると、次のように表示されます。
```c
#include <stdlib.h>
...
void *malloc(size_t size);
```
この情報から、mallocを使用するためのヘッダファイルstdlib.hをインクルードするだけで済みます。実際には、これを行う必要はありません。すべてのCプログラムがデフォルトでリンクするCライブラリには、その内部に`malloc()`のコードがあります。ヘッダを追加するだけで、コンパイラは`malloc()`を正しく呼び出すかどうかを確認できます(たとえば、適切な数の引数を適切な型に渡すなど)

単一のパラメータ`malloc()`は、必要なバイト数を単純に記述するタイプtの型です。しかし、ほとんどのプログラマーはここに数字を直接入力しません(10など)。代わりに、様々なルーチンおよびマクロが利用されます。たとえば、倍精度浮動小数点値にスペースを割り当てるには、次のようにします。
```c
double *d = (double *) malloc(sizeof(double));
```
うわー、二重にたくさんあります！この`malloc()`の呼び出しは、`sizeof()`演算子を使用して適切な量のスペースを要求します。これは一般にコンパイル時の演算子とみなされます。つまり、コンパイル時に実際のサイズが分かり、したがってmallocの引数として数値(この場合は8、倍精度の場合は8)が代入されます。このため、`sizeof()`は関数呼び出しではなく演算子として正しく考えられます(関数呼び出しは実行時に行われます)。

>> TIP: WHEN IN DOUBT, TRY IT OUT  
>> 使用しているルーチンや演算子がどのように動作しているかわからない場合は、単純に試してみて、期待どおりに動作するかどうかを確認することに代わるものはありません。マニュアルページやその他のドキュメントを読むのは便利ですが、実際にどのように動作するかは重要です。いくつかのコードを書いてテストしてください。それは間違いなくあなたのコードがあなたの望むように動作することを確認する最善の方法です。

また、変数の名前(型だけでなく)を`sizeof()`に渡すこともできますが、場合によっては結果が得られない場合もありますので注意してください。たとえば、次のコードスニペットを見てみましょう。
```c
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x));
```
最初の行では、10個の整数の配列のためのスペースを宣言しました。これはきれいで素敵です。しかし、次の行で`sizeof()`を使用すると、4(32ビットマシンの場合)や8(64ビットマシンの場合)などの小さな値が返されます。その理由は、`sizeof()`は、動的に割り当てられたメモリ量ではなく、整数へのポインタの大きさを単に求めていると考えているからです。しかし、`sizeof()`が期待通りに動作することもあります。
```c
int x[10];
printf("%d\n", sizeof(x));
```
この場合、40バイトが割り当てられていることをコンパイラが知るための十分な静的情報があります。注意すべき別の場所は文字列です。文字列のスペースを宣言するときは、関数`strlen()`を使用して文字列の長さを取得し、その末尾のスペースを確保するために1を追加する次のイディオムを使用します。malloc(strlen(s)+ 1)`sizeof()`を使用すると、ここで問題が発生する可能性があります。  
`malloc()`はvoid型へのポインタを返します。こうしている理由は、C言語でアドレスを渡して、プログラマがそれをどうするかを決定させるためです。プログラマーは、キャストと呼ばれるものを使用することによってさらに助けます。上記の例では、プログラマーは`malloc()`の戻り値の型をdoubleへのポインタにキャストします。`malloc()`の結果をキャストすることは、コンパイラやあなたのコードを読んでいる他のプログラマーには、「ええ、私がやっていることは分かっています」と言っている以外に、キャストは本当に何もやってくれません。正確に使うため以外にキャストは必要ありません。


## 14.3 The `free()` Call
結論として、メモリの割り当ては簡単な方程式の一部です。いつ、どのように、そしてメモリを解放するかを知ることは難しい部分です。使用されていないヒープメモリを解放するために、プログラマは単に`free()`を呼び出します。
```c
int *x = malloc(10 * sizeof(int));
...
free(x);
```
このルーチンは`malloc()`によって返された1つの引数をとります。したがって、割り当てられた領域のサイズはユーザーによって渡されず、メモリ割り当てライブラリ自体によって追跡される必要があります。

## 14.4 Common Errors
`malloc()`と`free()`の使用には多くの一般的なエラーがあります。ここでは、学部のオペレーティングシステムコースを教える上で何度も見てきたことがあります。これらの例はすべて、コンパイラからの指令でコンパイルして実行します。正しいCプログラムを構築するにはCプログラムをコンパイルする必要がありますが、(難しい方法で)よく学びたいのであれば十分に知る必要があります。

正確なメモリ管理は、多くの新しい言語が自動メモリ管理をサポートしているという問題がありました。そのような言語では、メモリを割り当てるために`malloc()`に似たもの(通常は新しいものや新しいオブジェクトを割り当てるのに似たもの)を呼び出している間に、空き領域に何かを呼び出す必要はありません。例えば、ガベージコレクタでは、参照していないメモリを見つけ出し、解放します。

### Forgetting To Allocate Memory
多くのルーチンは、呼び出す前にメモリを割り当てることを期待しています。たとえば、ルーチンstrcpy(dst、src)は、ソースポインタからデスティネーションポインタに文字列をコピーします。しかし、あなたが慎重でない場合、あなたはこれを行うかもしれません。
```c
char *src = "hello";
char *dst; // oops! unallocated
strcpy(dst, src); // segfault and die
```
このコードを実行すると、セグメンテーションフォルトにつながる可能性があります。つまり、「メモリに関して何か間違っているよ！もしかしてアホなプログラマ？？やめたら、プログラマ」というコードです。

>> TIP: IT COMPILED OR IT RAN ！= IT IS CORRECT  
>> プログラムがコンパイルされたか、正しく1回または複数回実行されただけであっても、プログラムが正しいとは限りません。多くのイベントは、あなたはそれがうまくいくと思うかもしれませんが、何かの拍子で止まります。一般的な生徒の反応は、「ちょっと待って！プログラムは以前は動いた！」と言い、コンパイラ、オペレーティングシステム、ハードウェア、または教授の責任を(たとえそれを言い表しても)責めます。しかし、問題は通常あなたのコード内にあると思うのが正しいです。あなたがそれらの他のコンポーネントを責める前に、デバッグしてください。

この場合、適切なコードは次のようになります。
```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src); // work properly
```
代わりに、`strdup()`を使用して、あなたの人生をさらに楽にすることができます。詳細はstrdupのmanページを参照してください。

### Not Allocating Enough Memory
関連するエラーで十分なメモリが割り当てられていない場合があります。バッファオーバーフローと呼ばれることもあります。上記の例では、一般的なエラーは、宛先バッファに十分な余裕を持たせることです。
```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src)); // too small!
strcpy(dst, src); // work properly
```
面白いことに、mallocの実装方法やその他の詳細によっては、このプログラムはよく正しく動作します。場合によっては、文字列のコピーが実行されるときに、割り当てられたスペースの最後を過ぎて1バイト分先に書き込まれますが、これは無害で、おそらくは使用されない変数を上書きするだけかもしれません。しかし、場合によっては、これらのオーバーフローは非常に有害であり、実際にはシステム[W06]の多くのセキュリティ脆弱性の原因です。他のケースでは、mallocライブラリは少し余分なスペースを割り当てていますので、あなたのプログラムは実際には他の変数の値を書き換えず、うまく動作します。他の場合では、プログラムは本当に故障しクラッシュするかもしれません。たとえそれが正しく実行されたとしても、正しいことを意味するわけではありません。

### Forgetting to Initialize Allocated Memory
このエラーでは、`malloc()`を適切に呼び出しますが、新しく割り当てられたデータ型にいくつかの値を入力するのを忘れてしまいます。絶対にこれはしないでください！あなたが忘れてしまった場合、プログラムは最終的に、未知の値のデータをヒープから読み出す初期化されていない読み込みに遭遇します。そこに何があるのか誰が知っていますか？あなたが運が良ければ、プログラムがまだ機能するような価値があります(たとえば、ゼロ)。不幸であれば、ランダムなデータや害があるデータに遭遇するでしょう。

### Forgetting To Free Memory
別の一般的なエラーはメモリリークと呼ばれ、メモリを解放するのを忘れたときに発生します。長時間実行するアプリケーションやシステム(OS自体など)では、これは大きな問題です。したがって、一般的に、あなたがメモリのチャンクで完了したら、あなたはそれを解放することを確認する必要があります。注意してほしいことはガベージコレクションを使っている言語では、ここの話は役に立たないことに注意してください。しかし、ガベージコレクションでも、まだメモリの一部を参照している場合、ガベージコレクタはそれを解放しないため、現代の言語でもメモリリークが問題になります。

場合によっては、`free()`を呼び出すのが合理的であるように見えるかもしれません。たとえば、あなたのプログラムは短命であり、すぐに終了します。この場合、プロセスが終了すると、OSは割り当てられたすべてのページをクリーンアップし、したがってメモリリーク自体は発生しません。これは確かに機能しますが、開発するときはおそらく戦略が悪いので、そのような戦略を選ぶことには注意してください。長期的には、プログラマーとしてのあなたの目標の1つは良い戦略を開発することです。そのような戦略の1つは、あなたがどのようにメモリを管理しているのか(Cのような言語で)、あなたが割り当てたブロックを解放することです。あなたがそうしないで逃げることができたとしても、あなたが明示的に割り当てる各バイトを解放する習慣を得るのは良いでしょう。

### Freeing Memory Before You Are Done With It
場合によっては、プログラムの使用が終了する前にメモリが解放されることもあります。そのような間違いは、ぶら下がりポインタと呼ばれ、あなたが推測できるように、それはまた悪いことです。後で使用すると、プログラムがクラッシュしたり、有効なメモリを上書きすることができます(たとえば、`free()`を呼び出した後、`malloc()`をもう一度呼び出すと、余分に解放されたメモリがリサイクルされます)。

### Freeing Memory Repeatedly
プログラムでは、メモリを複数回解放することもあります。これはダブルフリーとして知られています。その結果は未定義です。あなたが想像しているように、メモリ割り当てライブラリは混乱し、あらゆる種類の奇妙なことをするかもしれません。クラッシュは共通の結果です。

### Calling `free()` Incorrectly
私たちが議論している最後の問題は、`free()`の呼び出しが間違っていることです。結局、`free()`はあなたが以前に`malloc()`から受け取ったポインタの1つだけを渡すことを期待しています。あなたが他の価値を渡すと、悪いことが起きる可能性があります。したがって、このような無効な自由は危険であり、もちろん避けなければなりません。

>> ASIDE: WHY NO MEMORY IS LEAKED ONCE YOUR PROCESS EXITS  
>>短命のプログラムを書くときには、`malloc()`を使っていくらかの領域を割り当てるかもしれません。プログラムは実行され、完了しようとしています。終了する直前に`free()`を呼び出す必要がありますか？それが間違っているように見えますが、実際の意味では記憶が失われません。理由は簡単です。実際には、システムには2つのレベルのメモリ管理があります。第1レベルのメモリ管理は、実行時にプロセスにメモリを引き渡すOSによって実行され、プロセスが終了する(または終了する)ときにメモリを取り戻します。第2レベルの管理は、`malloc()`と`free()`を呼び出すときにヒープ内など、各プロセス内にあります。`free()`を呼び出すことに失敗してヒープ内のメモリがリークしても、オペレーティングシステムは、プログラムのすべてのメモリ(コード、スタック、ここではヒープに関連するページを含む)を実行が終了したら再利用します。アドレス空間内のヒープの状態が何であっても、OSはプロセスが終了したときにそれらのページをすべて取り戻すので、解放していないにもかかわらずメモリが失われます。  
>> したがって、短命のプログラムでは、メモリが漏れても操作上の問題が発生しないことがよくあります(ただし、悪い形であると考えられます)。長時間実行しているサーバー(Webサーバーやデータベース管理システムなど、決して終了しないサーバーなど)を作成すると、漏れたメモリははるかに大きな問題になり、メモリが不足するとクラッシュする可能性があります。もちろん、メモリのリークは、オペレーティングシステムそのものの1つの特定のプログラム内でのさらに大きな問題です。カーネルコードを書く人は、すべての中で最も厳しい仕事をしています...

### Summary
ご覧のように、メモリを乱用する方法はたくさんあります。メモリのエラーが頻繁に発生するため、コード内でこのような問題を見つけるのに役立つエコスペースのツールが開発されました。 [HJ92]とvalgrind [SN05]の両方を調べてください。どちらもメモリ関連の問題の原因を突き止めるのに役立ちます。これらの強力なツールの使用に慣れたら、そのツールを使わずに生き残った方法が不思議に思うでしょう。

## 14.5 Underlying OS Support
`malloc()`と`free()`について議論するときにシステムコールについて話していないことに気づいたかもしれません。その理由はシンプルです。システムコールではなく、ライブラリ呼び出しです。したがって、mallocライブラリは仮想アドレス空間内の空間を管理しますが、それ自体はOSに呼び出されるいくつかのシステムコールの上に構築され、より多くのメモリを要求したり、システムに戻っていくことがあります。

そのようなシステムコールの1つはbrkと呼ばれ、プログラムのブレークの位置を変更するために使用されます。ヒープの終わりの位置です。1つの引数(新しいブレークのアドレス)が必要なので、新しいブレークが現在のブレークより大きいか小さいかに基づいてヒープのサイズを増減します。追加の呼び出しsbrkはインクリメントされますが、そうでなければ同様の目的を果たします。

brkまたはsbrkのいずれかを直接呼び出すことはできません。それらはメモリ割り当てライブラリによって使用されます。あなたがそれらを使用しようとすると、おそらく何かが(ひどく)間違ってしまうことになります。代わりに`malloc()`と`free()`を使用してください。

最後に、`mmap()`呼び出しによってオペレーティングシステムからメモリを取得することもできます。正しい引数を渡すことで、`mmap()`はプログラム内で匿名のメモリ領域を作成することができます。この領域は特定のファイルに関連付けられず、スワップ空間に関連付けられます。このメモリは、ヒープのように扱うことができ、ヒープのように管理することもできます。詳細は、`mmap()`のマニュアルページを参照してください。

## 14.6 Other Calls
メモリ割り当てライブラリがサポートするその他の呼び出しがいくつかあります。たとえば、`calloc()`はメモリを割り当て、返す前にメモリをゼロにします。これは、メモリがゼロになっていると仮定して、それを自分で初期化することを忘れるところで、いくつかのエラーを防ぎます(上記の「初期化されていない読み取り」の段落を参照してください)。ルーチン`realloc()`は、何か(配列など)にスペースを割り当ててから、何かを追加する必要があるときにも便利です。`realloc()`は新しいメモリ領域を作り、古い領域をポインタを新しい領域に返します。

## 14.7 Summary
メモリ割り当てを扱うAPIのいくつかを紹介しました。いつものように、私たちは基本的な話をしました。詳細は他の場所でも入手可能です。詳細は、Cブック[KR88]とスティーブンス[SR05](第7章)を参照してください。これらの問題の多くを自動的に検出して修正する方法に関する現代的な最新の論文については、Novark et al。 [N+07]というものがあります。このペーパーには、一般的な問題の素敵な要約と、それらを見つけて修正するためのいくつかのすばらしいアイデアも含まれています。

# 参考文献

[HJ92] Purify: Fast Detection of Memory Leaks and Access Errors  
R. Hastings and B. Joyce  
USENIX Winter ’92  
The paper behind the cool Purify tool, now a commercial product.  

[KR88] “The C Programming Language”  
Brian Kernighan and Dennis Ritchie  
Prentice-Hall 1988  
The C book, by the developers of C. Read it once, do some programming, then read it again, and then keep it near your desk or wherever you program.

[N+07] “Exterminator: Automatically Correcting Memory Errors with High Probability”  
Gene Novark, Emery D. Berger, and Benjamin G. Zorn  
PLDI 2007  
A cool paper on finding and correcting memory errors automatically, and a great overview of many common errors in C and C++ programs.

[SN05] “Using Valgrind to Detect Undefined Value Errors with Bit-precision”  
J. Seward and N. Nethercote  
USENIX ’05  
How to use valgrind to find certain types of errors.

[SR05] “Advanced Programming in the UNIX Environment”  
W. Richard Stevens and Stephen A. Rago  
Addison-Wesley, 2005  
We’ve said it before, we’ll say it again: read this book many times and use it as a reference whenever you are in doubt. The authors are always surprised at how each time they read something in this book, they learn something new, even after many years of C programming.

[W06] “Survey on Buffer Overflow Attacks and Countermeasures”  
Tim Werthman  
Available: www.nds.rub.de/lehre/seminar/SS06/Werthmann BufferOverflow.pdf  
A nice survey of buffer overflows and some of the security problems they cause. Refers to many of the famous exploits.

[prev](../13/13.md)|[next](../15/15.md)